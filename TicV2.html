<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 10 (filtered)">
<title>Thinking in C++ 2nd ed Volume 2</title>

<style>
<!--
 <font color=#7F7F7F>/* Font Definitions */</font>
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:2 2 6 3 4 5 5 2 3 4;}
@font-face
	{font-family:Helv;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:"New York";
	panose-1:2 4 5 3 6 5 6 2 3 4;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 1 6 1 0 1 1 1 1 1;}
@font-face
	{font-family:"MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimHei;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:MingLiU;
	panose-1:2 1 6 9 0 1 1 1 1 1;}
@font-face
	{font-family:Mincho;
	panose-1:2 2 6 9 4 3 5 8 3 5;}
@font-face
	{font-family:Gulim;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:Century;
	panose-1:2 4 6 3 5 7 5 2 3 3;}
@font-face
	{font-family:"Angsana New";
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"Cordia New";
	panose-1:2 11 3 4 2 2 2 2 2 4;}
@font-face
	{font-family:Mangal;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Latha;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sylfaen;
	panose-1:1 10 5 2 5 3 6 3 3 3;}
@font-face
	{font-family:Vrinda;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Raavi;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Shruti;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sendnya;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Gautami;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tunga;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Estrangella Edessa";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 4 5 2 5 4 5 2 3 3;}
@font-face
	{font-family:"American Typewriter";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Courier New";
	panose-1:2 11 5 9 0 0 0 0 0 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"Serifa 55";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
 <font color=#7F7F7F>/* Style Definitions */</font>
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
h1
	{margin-top:12.0pt;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:-85.7pt;
	text-indent:85.7pt;
	page-break-after:avoid;
	font-size:24.0pt;
	font-family:Verdana;
	font-weight:bold;}
h2
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-.1in;
	page-break-after:avoid;
	font-size:18.0pt;
	font-family:Verdana;
	font-weight:bold;}
h3
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:Verdana;
	font-weight:bold;}
h4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13pt;
	page-break-after:avoid;
	font-size:10pt;
	font-family:Verdana;
	font-weight:bold;}
h5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:13pt;
	page-break-after:avoid;
	font-size:10pt;
	font-family:Verdana;
	font-weight:normal;}
h6
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:11.0pt;
	font-family:Verdana;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Arial;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Arial;
	font-style:italic;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
p.MsoIndex1, li.MsoIndex1, div.MsoIndex1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:10.5pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex2, li.MsoIndex2, div.MsoIndex2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:21.0pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex3, li.MsoIndex3, div.MsoIndex3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:31.5pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex4, li.MsoIndex4, div.MsoIndex4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:42.0pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex5, li.MsoIndex5, div.MsoIndex5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:52.5pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex6, li.MsoIndex6, div.MsoIndex6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:63.0pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex7, li.MsoIndex7, div.MsoIndex7
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:73.5pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex8, li.MsoIndex8, div.MsoIndex8
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:84.0pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoIndex9, li.MsoIndex9, div.MsoIndex9
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:94.5pt;
	margin-bottom:.0001pt;
	text-indent:-10.5pt;
	line-height:13pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:18.0pt;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.7in;
	margin-bottom:.0001pt;
	line-height:13pt;
	font-size:8.0pt;
	font-family:Verdana;}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:30.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:40.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:50.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:60.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:70.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToc9, li.MsoToc9, div.MsoToc9
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:80.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoNormalIndent, li.MsoNormalIndent, div.MsoNormalIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:13.0pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Verdana;}
p.MsoIndexHeading, li.MsoIndexHeading, div.MsoIndexHeading
	{margin-top:.25in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	border:none;
	padding:0in;
	font-size:13.0pt;
	font-family:Verdana;
	font-weight:bold;
	font-style:italic;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;
	font-weight:bold;}
p.MsoTof, li.MsoTof, div.MsoTof
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:20.0pt;
	text-indent:-20.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoEnvelopeAddress, li.MsoEnvelopeAddress, div.MsoEnvelopeAddress
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:2.0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Arial;}
p.MsoEnvelopeReturn, li.MsoEnvelopeReturn, div.MsoEnvelopeReturn
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Arial;}
span.MsoFootnoteReference
	{font-family:Verdana;
	position:relative;
	top:-4.0pt;
	font-size:7.0pt;}
p.MsoEndnoteText, li.MsoEndnoteText, div.MsoEndnoteText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoToa, li.MsoToa, div.MsoToa
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:10.0pt;
	text-indent:-10.0pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoMacroText, li.MsoMacroText, div.MsoMacroText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:normal;
	font-size:10.0pt;
	font-family:"Courier New";}
p.MsoToaHeading, li.MsoToaHeading, div.MsoToaHeading
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoList, li.MsoList, div.MsoList
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListBullet, li.MsoListBullet, div.MsoListBullet
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.5in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListNumber, li.MsoListNumber, div.MsoListNumber
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoList2, li.MsoList2, div.MsoList2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoList3, li.MsoList3, div.MsoList3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoList4, li.MsoList4, div.MsoList4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoList5, li.MsoList5, div.MsoList5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListBullet2, li.MsoListBullet2, div.MsoListBullet2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListBullet3, li.MsoListBullet3, div.MsoListBullet3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListBullet4, li.MsoListBullet4, div.MsoListBullet4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListBullet5, li.MsoListBullet5, div.MsoListBullet5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListNumber2, li.MsoListNumber2, div.MsoListNumber2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListNumber3, li.MsoListNumber3, div.MsoListNumber3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListNumber4, li.MsoListNumber4, div.MsoListNumber4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListNumber5, li.MsoListNumber5, div.MsoListNumber5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	text-indent:-.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	text-align:center;
	font-size:16.0pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoClosing, li.MsoClosing, div.MsoClosing
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:3.0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoSignature, li.MsoSignature, div.MsoSignature
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:3.0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	text-align:center;
	font-size:16.0pt;
	font-family:"Verdana";}
p.MsoListContinue, li.MsoListContinue, div.MsoListContinue
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListContinue2, li.MsoListContinue2, div.MsoListContinue2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListContinue3, li.MsoListContinue3, div.MsoListContinue3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.75in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListContinue4, li.MsoListContinue4, div.MsoListContinue4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoListContinue5, li.MsoListContinue5, div.MsoListContinue5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:1.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoMessageHeader, li.MsoMessageHeader, div.MsoMessageHeader
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.75in;
	text-indent:-.75in;
	line-height:12.0pt;
	background:#CCCCCC;
	border:none;
	padding:0in;
	font-size:10pt;
	font-family:Verdana;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	text-align:center;
	line-height:13pt;
	font-size:10pt;
	font-family:Arial;}
p.MsoSalutation, li.MsoSalutation, div.MsoSalutation
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoDate, li.MsoDate, div.MsoDate
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoBodyTextFirstIndent, li.MsoBodyTextFirstIndent, div.MsoBodyTextFirstIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:10.5pt;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;
	font-weight:bold;}
p.MsoBodyTextFirstIndent2, li.MsoBodyTextFirstIndent2, div.MsoBodyTextFirstIndent2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	text-indent:10.5pt;
	line-height:13pt;
	font-size:12.0pt;
	font-family:Verdana;}
p.MsoNoteHeading, li.MsoNoteHeading, div.MsoNoteHeading
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.MsoBodyText3, li.MsoBodyText3, div.MsoBodyText3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:8.0pt;
	font-family:Verdana;}
p.MsoBodyTextIndent2, li.MsoBodyTextIndent2, div.MsoBodyTextIndent2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:200%;
	font-size:10pt;
	font-family:Verdana;}
p.MsoBodyTextIndent3, li.MsoBodyTextIndent3, div.MsoBodyTextIndent3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:8.0pt;
	font-family:Verdana;}
p.MsoBlockText, li.MsoBlockText, div.MsoBlockText
	{margin-top:0in;
	margin-right:1.0in;
	margin-bottom:12.0pt;
	margin-left:1.0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:none;}
a:visited, span.MsoHyperlinkFollowed
	{color:blue;
	text-decoration:none;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	background:navy;
	font-size:10pt;
	font-family:Tahoma;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13pt;
	font-size:10pt;
	font-family:"Courier New";}
p.MsoAutoSig, li.MsoAutoSig, div.MsoAutoSig
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:"Verdana";}
address
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;
	font-style:italic;}
code
	{font-family:"Courier New";}
pre
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10.0pt;
	font-family:"Courier New";}
tt
	{font-family:"Courier New";}
p.Intro, li.Intro, div.Intro
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:0in;
	line-height:17.0pt;
	font-size:13.0pt;
	font-family:Verdana;}
p.Preformatted, li.Preformatted, div.Preformatted
	{margin-top:5.0pt;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:"Courier New";}
p.Numbered, li.Numbered, div.Numbered
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.7in;
	text-indent:-.45in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.contents, li.contents, div.contents
	{margin-top:12.0pt;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:-85.7pt;
	text-indent:85.7pt;
	page-break-after:avoid;
	font-size:24.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.CC1, li.CC1, div.CC1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
span.CC1Char
	{font-family:"Courier New";}
p.CodeInlineCharCharChar1CharCharCharCharCharChar, li.CodeInlineCharCharChar1CharCharCharCharCharChar, div.CodeInlineCharCharChar1CharCharCharCharCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.CodeInlineTrailerCharChar, li.CodeInlineTrailerCharChar, div.CodeInlineTrailerCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:normal;
	font-size:3.0pt;
	font-family:"Courier New";}
span.CodeInlineCharCharChar1CharCharCharCharCharCharChar
	{font-family:"Courier New";}
p.NumberList, li.NumberList, div.NumberList
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.25in;
	margin-bottom:.0001pt;
	text-indent:-.3in;
	line-height:normal;
	font-size:9.5pt;
	font-family:Verdana;
	color:black;}
p.TableHead, li.TableHead, div.TableHead
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:14.0pt;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.Table, li.Table, div.Table
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.Figure, li.Figure, div.Figure
	{margin-top:3.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.AfterTable, li.AfterTable, div.AfterTable
	{margin-top:9.0pt;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.5in;
	line-height:12.0pt;
	font-size:10pt;
	font-family:Verdana;}
p.BulletTIJ, li.BulletTIJ, div.BulletTIJ
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.75in;
	line-height:12.0pt;
	font-size:10pt;
	font-family:Verdana;}
p.drawingtext, li.drawingtext, div.drawingtext
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:.25in;
	font-size:10pt;
	font-family:Verdana;
	font-weight:bold;}
p.ExercisesCharCharCharCharChar, li.ExercisesCharCharCharCharChar, div.ExercisesCharCharCharCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.7in;
	margin-bottom:.0001pt;
	text-indent:-.45in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
span.Typewriter
	{font-family:"Courier New";}
span.CODE
	{font-family:"Courier New";}
p.AfterPicture, li.AfterPicture, div.AfterPicture
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
span.Illustration
	{font-family:"Serifa 55";
	font-style:italic;}
span.pro
	{color:fuchsia;}
span.r
	{color:red;}
p.Guidelines, li.Guidelines, div.Guidelines
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:-.1in;
	page-break-after:avoid;
	font-size:18.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.BulletSeminar, li.BulletSeminar, div.BulletSeminar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	font-size:14.0pt;
	font-family:"Verdana";}
p.TOCspace, li.TOCspace, div.TOCspace
	{margin:0in;
	margin-bottom:.0001pt;
	line-height:25%;
	font-size:10pt;
	font-family:Verdana;}
p.STLAlgorithmCharChar, li.STLAlgorithmCharChar, div.STLAlgorithmCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.25in;
	line-height:13pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
span.STLAlgorithmCharCharChar
	{font-family:"Courier New";}
span.CodeCharChar
	{font-family:"Courier New";}
span.CodeInlineCharCharChar
	{font-family:"Courier New";}
span.CodeInlineTrailerCharCharChar
	{font-family:"Courier New";}
p.Exercises, li.Exercises, div.Exercises
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.75in;
	text-indent:-.25in;
	line-height:14.0pt;
	font-size:11.0pt;
	font-family:Verdana;}
span.CodeCharCharChar
	{font-family:"Courier New";}
p.ChapterTitle, li.ChapterTitle, div.ChapterTitle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:.5in;
	background:white;
	font-size:32.0pt;
	font-family:Verdana;}
p.CodeInlineCharCharChar1CharCharChar, li.CodeInlineCharCharChar1CharCharChar, div.CodeInlineCharCharChar1CharCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.CodeInlineTrailerChar, li.CodeInlineTrailerChar, div.CodeInlineTrailerChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:1.0pt;
	margin-left:.85in;
	line-height:normal;
	font-size:3.0pt;
	font-family:Verdana;}
span.CodeInlineCharCharChar1CharCharCharChar
	{font-family:"Courier New";}
p.Bullet, li.Bullet, div.Bullet
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.2in;
	margin-bottom:.0001pt;
	line-height:normal;
	font-size:12.0pt;
	font-family:"Tms Rmn";
	color:black;}
p.EmphasisP, li.EmphasisP, div.EmphasisP
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:-.1in;
	margin-bottom:.0001pt;
	line-height:13pt;
	page-break-after:avoid;
	font-size:10pt;
	font-family:Verdana;
	font-weight:bold;
	font-style:italic;}
p.makeapoint, li.makeapoint, div.makeapoint
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.8in;
	font-size:14.0pt;
	font-family:Verdana;
	font-style:italic;}
p.DrawingObject, li.DrawingObject, div.DrawingObject
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:0in;
	text-align:center;
	line-height:11.0pt;
	font-size:10pt;
	font-family:Arial;
	color:black;
	letter-spacing:-.2pt;}
p.Comments, li.Comments, div.Comments
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:22.0pt;
	page-break-after:avoid;
	font-size:18.0pt;
	font-family:Verdana;}
p.TitleNoTOC, li.TitleNoTOC, div.TitleNoTOC
	{margin-top:0in;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:49.7pt;
	text-indent:-.75in;
	page-break-after:avoid;
	background:white;
	font-size:38.0pt;
	font-family:Verdana;
	color:black;}
p.TitlePage1, li.TitlePage1, div.TitlePage1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.25in;
	text-align:center;
	font-size:79.0pt;
	font-family:Verdana;
	letter-spacing:-1.0pt;}
p.TitlePage2, li.TitlePage2, div.TitlePage2
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	background:white;
	font-size:32.0pt;
	font-family:Verdana;}
p.TitlePage3, li.TitlePage3, div.TitlePage3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.25in;
	margin-left:0in;
	text-align:center;
	line-height:72.0pt;
	background:white;
	font-size:80.0pt;
	font-family:Verdana;
	color:black;
	letter-spacing:-1.0pt;}
p.TitlePage4, li.TitlePage4, div.TitlePage4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.25in;
	margin-left:0in;
	text-align:center;
	background:white;
	font-size:20.0pt;
	font-family:Verdana;}
p.TitlePage5, li.TitlePage5, div.TitlePage5
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	background:white;
	font-size:32.0pt;
	font-family:Verdana;}
p.TitlePage6, li.TitlePage6, div.TitlePage6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:0in;
	text-align:center;
	background:white;
	font-size:20.0pt;
	font-family:Verdana;}
p.TabularText, li.TabularText, div.TabularText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.5in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.TableFollower, li.TableFollower, div.TableFollower
	{margin-top:9.0pt;
	margin-right:0in;
	margin-bottom:9.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.Quote, li.Quote, div.Quote
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.25in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.LicenseAgreement, li.LicenseAgreement, div.LicenseAgreement
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13.0pt;
	font-size:9.0pt;
	font-family:Verdana;}
p.DefinitionList, li.DefinitionList, div.DefinitionList
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:13pt;
	font-size:10pt;
	font-family:"Verdana";}
p.tocspace0, li.tocspace0, div.tocspace0
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:3.0pt;
	font-size:10pt;
	font-family:Verdana;}
p.TOCPart, li.TOCPart, div.TOCPart
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	line-height:18.0pt;
	page-break-after:avoid;
	background:#E0E0E0;
	font-size:14.0pt;
	font-family:Verdana;}
p.parttitle, li.parttitle, div.parttitle
	{margin-top:12.0pt;
	margin-right:-76.3pt;
	margin-bottom:12.0pt;
	margin-left:-85.7pt;
	text-indent:85.7pt;
	page-break-after:avoid;
	font-size:48.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.Partbleed, li.Partbleed, div.Partbleed
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:normal;
	page-break-after:avoid;
	background:#E0E0E0;
	font-size:24.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.tabletext, li.tabletext, div.tabletext
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13pt;
	font-size:10pt;
	font-family:Verdana;}
p.tablehead0, li.tablehead0, div.tablehead0
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:13pt;
	font-size:12.0pt;
	font-family:Verdana;
	font-weight:bold;}
p.Code0, li.Code0, div.Code0
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:14.0pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Courier New";
	color:black;}
p.CodeInlineChar, li.CodeInlineChar, div.CodeInlineChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:.25in;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
span.ExercisesCharCharCharCharCharChar
	{font-family:Verdana;}
p.CodeCharChar1CharCharCharCharChar, li.CodeCharChar1CharCharCharCharChar, div.CodeCharChar1CharCharCharCharChar
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	border:none;
	padding:0in;
	font-size:10pt;
	font-family:"Courier New";}
span.CodeInlineCharChar
	{font-family:"Courier New";}
span.CodeInlineTrailerCharChar1
	{font-family:Verdana;}
ins
	{text-decoration:none;}
span.msoIns
	{text-decoration:underline;}
span.msoDel
	{text-decoration:line-through;
	color:red;}
 <font color=#7F7F7F>/* Page Definitions */</font>
 @page Section1
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section1
	{page:Section1;}
@page Section2
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section2
	{page:Section2;}
@page Section3
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section3
	{page:Section3;}
@page Section4
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section4
	{page:Section4;}
@page Section5
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section5
	{page:Section5;}
@page Section6
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 135.35pt 1.75in;}
div.Section6
	{page:Section6;}
@page Section7
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section7
	{page:Section7;}
@page Section8
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section8
	{page:Section8;}
@page Section9
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section9
	{page:Section9;}
@page Section10
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section10
	{page:Section10;}
@page Section11
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section11
	{page:Section11;}
@page Section12
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section12
	{page:Section12;}
@page Section13
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section13
	{page:Section13;}
@page Section14
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section14
	{page:Section14;}
@page Section15
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section15
	{page:Section15;}
@page Section16
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section16
	{page:Section16;}
@page Section17
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section17
	{page:Section17;}
@page Section18
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section18
	{page:Section18;}
@page Section19
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section19
	{page:Section19;}
@page Section20
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section20
	{page:Section20;}
@page Section21
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section21
	{page:Section21;}
@page Section22
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section22
	{page:Section22;}
@page Section23
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section23
	{page:Section23;}
@page Section24
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section24
	{page:Section24;}
@page Section25
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section25
	{page:Section25;}
@page Section26
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section26
	{page:Section26;}
@page Section27
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section27
	{page:Section27;}
@page Section28
	{size:8.5in 11.0in;
	margin:135.35pt 1.5in 1.6in 1.75in;}
div.Section28
	{page:Section28;}
 <font color=#7F7F7F>/* List Definitions */</font>
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=red vlink=purple>

<center>
<b>
<span style='font-size:24pt;font-family:Verdana'>Thinking In C++</span><br>
<br>
<span style='font-size:14pt;font-family:Verdana'>Volume 2: Practical Programming</span><br>
<br>
<span style='font-size:10pt;font-family:Verdana'>Bruce Eckel, President, MindView, Inc.</span><br>
<span style='font-size:10pt;font-family:Verdana'>Chuck Allison, Utah Valley State College</span><br>
<br><br>
<span style='font-size:14pt;font-family:Verdana'>
<a href="http://mindview.net/Books/TICPP/ThinkingInCPP2e.html">Book Home Page</a></span><br>
<span style='font-size:14pt;font-family:Verdana'>
<a href="http://mindview.net/Books/TICPPV2/Solutions">Annotated Solution Guide</a></span><br>
<span style='font-size:14pt;font-family:Verdana'>
<a href="http://mindview.net:8080/TICPPV2/">Report Errors Here</a></span><br>

</b>
</center>
<br><br>
<h3 style='margin-left:.1in'><a href="#cover">Cover</a></h3>
<h4><a href="#_TocRef53985602">Introduction</a></h4>
<h3 style='margin-left:.1in'><a href="#_TocRef53985614">Part 1: Building Stable Systems</a></h3>
<h4><a href="#_TocRef53985615">1: Exception handling</a></h4>
<h4><a href="#_TocRef53985643">2: Defensive programming</a></h4>
<h3 style='margin-left:.1in'><a href="#_TocRef53985656">Part 2: The Standard C++ Library</a></h3>
<h4><a href="#_TocRef53985657">3: Strings in depth</a></h4>
<h4><a href="#_TocRef53985673">4: Iostreams</a></h4>
<h4><a href="#_TocRef53985706">5: Templates in depth</a></h4>
<h4><a href="#_TocRef53985741">6: Generic algorithms</a></h4>
<h4><a href="#_TocRef53985769">7: Generic containers</a></h4>
<h3 style='margin-left:.1in'><a href="#_TocRef53985807">Part 3: Special Topics</a></h3>
<h4><a href="#_TocRef53985808">8: Runtime type identification</a></h4>
<h4><a href="#_TocRef53985820">9: Multiple inheritance</a></h4>
<h4><a href="#_TocRef53985831">10: Design patterns</a></h4>
<h4><a href="#_TocRef53985862">11: Concurrency</a></h4>
<h3 style='margin-left:.1in'><a href="#_TocRef53985892">Appendix</a></h3>
<h4><a href="#_TocRef53985892">A: Recommended reading</a></h4>
<h4><a href="#_TocRef53985898">B: Etc</a></h4>
<h4><a href="#_TocRef53985899">Index</a></h4>
<br><br>

<div class=Section1>

<p class=MsoNormal>“</a><span style='font-size:9.5pt'>I’d
like to congratulate the both of you for a very impressive work! Not only did I
find your book to be an enjoyable and rewarding read … I was astounded by the
accuracy both in terms of technical correctness and use of the language … I
believe that you have attained a level of craftsmanship that is simply
outstanding.”</span></p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:12.0pt'>Bjorn Karlsson<br>
Editorial Board, C/C++ Users Journal</span></b></p>

<p class=MsoNormal><span style='font-size:9.5pt'>“This book is a tremendous
achievement. You owe it to yourself to have a copy on your shelf.”</span></p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:12.0pt'>Al Stevens<br>
Contributing Editor, Doctor Dobbs Journal</span></b></p>

<p class=MsoNormal><span style='font-size:9.5pt'>“Eckel’s book is the only one
to so clearly explain how to rethink program construction for object
orientation. That the book is also an excellent tutorial on the ins and outs of
C++ is an added bonus.”</span></p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:12.0pt'>Andrew Binstock<br>
Editor, Unix Review</span></b></p>

<p class=MsoNormal><span style='font-size:9.5pt'>“Bruce continues to amaze me
with his insight into C++, and <i>Thinking in C++</i> is his best collection of
ideas yet. If you want clear answers to difficult questions about C++, buy this
outstanding book.”</span></p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:12.0pt'>Gary Entsminger<br>
Author, <i>The Tao of Objects</i></span></b></p>

<p class=MsoNormal><span style='font-size:9.5pt'>“<i>Thinking in C++</i> patiently
and methodically explores the issues of when and how to use inlines,
references, operator overloading, inheritance and dynamic objects, as well as
advanced topics such as the proper use of templates, exceptions and multiple
inheritance. The entire effort is woven in a fabric that includes Eckel’s own
philosophy of object and program design. A must for every C++ developer’s
bookshelf, <i>Thinking in C++</i> is the one C++ book you must have if you’re
doing serious development with C++.”</span></p>

<p class=MsoNormal align=right style='text-align:right'><b><span
style='font-size:12.0pt'>Richard Hale Shaw<br>
Contributing Editor, PC Magazine</span></b></p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section2></div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:auto'>
</span>

<div class=Section3>

<center><a name="cover"></a><br><img width=350 height=442 src="CPPV2cover.jpg"></center><br><br>
<center><img src="TicV2_files/image004.jpg">
<img src="TicV2_files/image005.jpg"></center>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'>&nbsp;</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'>CIP DATA AVAILABLE</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'>&nbsp;</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Vice President and Editorial Director,
ECS: <i>Marcia J. Horton</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Publisher: <i>Alan R. Apt</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Associate Editor: <i>Toni Dianne Holm</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Editorial Assistant: <i>Patrick Lindner</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Vice President and Director of Production
and Manufacturing, ESM: <i>David W. Riccardi</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Executive Managing Editor: <i>Vince O’Brien</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Managing Editor: <i>Camille Trentacoste</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Production Editor: <i>Irwin Zucker</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Director of Creative Services: <i>Paul
Belfanti</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Creative Director: <i>Carole Anson</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Cover and Interior Designer: <i>Daniel
Will-Harris</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Cover Illustrations: <i>Tina Jensen</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Manufacturing Manager: <i>Trudy Pisciotti</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Manufacturing Buyer: <i>Lisa McDowell</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:9.0pt'>Marketing Manager: <i>Pamela Shaffer</i></span></p>

<p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;
margin-left:16.55pt'><img width=95 height=71 src="TicV2_files/image003.gif"
align=left hspace=12><span style='font-size:12.0pt'>©2004 MindView, Inc.</span><span
style='font-size:13.0pt'><br>
</span><span style='font-size:11.0pt'>Published by Pearson Prentice Hall<br>
Pearson Education, Inc.<br>
Upper Saddle River, NJ 07458</span></p>

<p class=MsoNormal style='margin-bottom:4.0pt;line-height:normal'><span
style='font-size:9.0pt'>All rights reserved. No part of this book may be
reproduced in any form or by any means, without permission in writing from the
publisher.</span></p>

<p class=MsoNormal style='margin-bottom:4.0pt;line-height:normal'><span
style='font-size:9.0pt'>Pearson Prentice Hall® is a trademark of Pearson
Education, Inc.</span></p>

<p class=MsoNormal style='margin-bottom:4.0pt;line-height:normal'><span
style='font-size:9.0pt'>The authors and publisher of this book have used their
best efforts in preparing this book. These efforts include the development,
research, and testing of the theories and programs to determine their
effectiveness. The authors and publisher make no warranty of any kind,
expressed or implied, with regard to these programs or the documentation
contained in this book. The authors and publisher shall not be liable in any
event for incidental or consequential damages in connection with, or arising
out of, the furnishing, performance, or use of these programs.</span></p>

<p class=MsoNormal style='margin-bottom:4.0pt;line-height:normal'><span
style='font-size:9.0pt'>Printed in the United States of America</span></p>

<p class=MsoNormal style='margin-bottom:6.0pt'><span style='font-size:9.0pt'>10 
9  8  7  6  5  4  3  2  1</span></p>

<p class=MsoNormal style='margin-bottom:6.0pt'><span style='font-family:"Courier New"'>ISBN 
0-13-035313-2</span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education Ltd., <i>London</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education Australia Pty. Ltd., <i>Sydney</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education Singapore, Pte. Ltd.</span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education North Asia Ltd., <i>Hong
Kong</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education Canada, Inc., <i>Toronto</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Educación de Mexico, S.A. de C.V.</span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education-Japan, <i>Tokyo</i></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education Malaysia, Pte. Ltd.</span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'><span style='font-size:8.0pt'>Pearson Education, Inc., <i>Upper Saddle
River, New Jersey</i></span></p>

</div>

<span style='font-size:8.0pt;font-family:Verdana'><br clear=all
style='page-break-before:auto'>
</span>

<div class=Section4>

<p class=MsoNormal style='margin:0in;margin-bottom:.0001pt;line-height:normal'><span
style='font-size:8.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:24.0pt'><br clear=all style='page-break-before:
always'>
Dedication</span></p>

<p class=MsoNormal align=right style='text-align:right'>To all those who have
worked tirelessly<br>
to develop the C++ language</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:always'>
</span>

<div class=Section5></div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section6>

<p class=contents style='margin-left:-1in'>What’s inside…</p>

<p class=MsoToc1><a href="#_Toc53985602" name="_TocRef53985602">Introduction                                                 1</a></p>

<p class=MsoToc2><a href="#_Toc312373771" name="_TocRef312373771">Goals.......................................... 1</a></p>

<p class=MsoToc2><a href="#_Toc312373772" name="_TocRef312373772">Chapters..................................... 2</a></p>

<p class=MsoToc2><a href="#_Toc312373773" name="_TocRef312373773">Exercises..................................... 5</a></p>

<p class=MsoToc3><a href="#_Toc53985606" name="_TocRef53985606">Exercise solutions............... 5</a></p>

<p class=MsoToc2><a href="#_Toc310733137" name="_TocRef310733137">Source code................................. 5</a></p>

<p class=MsoToc2><a href="#_Toc53985608" name="_TocRef53985608">Compilers.................................... 7</a></p>

<p class=MsoToc2><a href="#_Toc53985609" name="_TocRef53985609">Language standards..................... 9</a></p>

<p class=MsoToc2><a href="#_Toc312373778" name="_TocRef312373778">Seminars, CD–ROMs<br>
&amp; consulting................................. 9</a></p>

<p class=MsoToc2><a href="#_Toc312373779" name="_TocRef312373779">Errors....................................... 10</a></p>

<p class=MsoToc2><a href="#_Toc53985612" name="_TocRef53985612">About the cover......................... 10</a></p>

<p class=MsoToc2><a href="#_Toc53985613" name="_TocRef53985613">Acknowledgements..................... 10</a></p>

<p class=MsoToc1><a href="#_Toc53985614" name="_TocRef53985614">I: Building Stable Systems                         13</a></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'>&nbsp;</p>

<p class=MsoToc1><a href="#_Toc53985615" name="_TocRef53985615">1: Exception Handling                                15</a></p>

<p class=MsoToc2><a href="#_Toc305593296" name="_TocRef305593296">Traditional error handling............. 16</a></p>

<p class=MsoToc2><a href="#_Toc305593297" name="_TocRef305593297">Throwing an exception................ 18</a></p>

<p class=MsoToc2><a href="#_Toc305593298" name="_TocRef305593298">Catching an exception................. 20</a></p>

<p class=MsoToc3><a href="#_Toc312374114" name="_TocRef312374114">The try block.................... 20</a></p>

<p class=MsoToc3><a href="#_Toc312374115" name="_TocRef312374115">Exception handlers........... 20</a></p>

<p class=MsoToc3><a href="#_Toc53985621" name="_TocRef53985621">Termination<br>
and resumption................ 22</a></p>

<p class=MsoToc2><a href="#_Toc305593301" name="_TocRef305593301">Exception matching..................... 23</a></p>

<p class=MsoToc3><a href="#_Toc53985623" name="_TocRef53985623">Catching any exception..... 25</a></p>

<p class=MsoToc3><a href="#_Toc312374119" name="_TocRef312374119">Rethrowing an exception... 26</a></p>

<p class=MsoToc3><a href="#_Toc312374120" name="_TocRef312374120">Uncaught exceptions......... 26</a></p>

<p class=MsoToc2><a href="#_Toc305593299" name="_TocRef305593299">Cleaning up................................ 28</a></p>

<p class=MsoToc3><a href="#_Toc53985627" name="_TocRef53985627">Resource management..... 30</a></p>

<p class=MsoToc3><a href="#_Toc312374123" name="_TocRef312374123">Making everything<br>
an object......................... 32</a></p>

<p class=MsoToc3><a href="#_Toc53985629" name="_TocRef53985629">auto_ptr.......................... 35</a></p>

<p class=MsoToc3><a href="#_Toc53985630" name="_TocRef53985630">Function–level try blocks... 36</a></p>

<p class=MsoToc2><a href="#_Toc53985631" name="_TocRef53985631">Standard exceptions................... 38</a></p>

<p class=MsoToc2><a href="#_Toc312374116" name="_TocRef312374116">Exception specifications............... 40</a></p>

<p class=MsoToc3><a href="#_Toc53985633" name="_TocRef53985633">Better exception<br>
specifications?.................. 45</a></p>

<p class=MsoToc3><a href="#_Toc53985634" name="_TocRef53985634">Exception specifications<br>
and inheritance................ 46</a></p>

<p class=MsoToc3><a href="#_Toc53985635" name="_TocRef53985635">When not to use<br>
exception specifications..... 47</a></p>

<p class=MsoToc2><a href="#_Toc53985636" name="_TocRef53985636">Exception safety......................... 48</a></p>

<p class=MsoToc2><a href="#_Toc53985637" name="_TocRef53985637">Programming with exceptions....... 52</a></p>

<p class=MsoToc3><a href="#_Toc312374127" name="_TocRef312374127">When to avoid exceptions.. 52</a></p>

<p class=MsoToc3><a href="#_Toc312374128" name="_TocRef312374128">Typical uses of exceptions. 54</a></p>

<p class=MsoToc2><a href="#_Toc305593304" name="_TocRef305593304">Overhead................................... 58</a></p>

<p class=MsoToc2><a href="#_Toc305593305" name="_TocRef305593305">Summary................................... 60</a></p>

<p class=MsoToc2><a href="#_Toc312374131" name="_TocRef312374131">Exercises................................... 61</a></p>

<p class=MsoToc1><a href="#_Toc53985643" name="_TocRef53985643">2: Defensive Programming                         63</a></p>

<p class=MsoToc2><a href="#_Toc53985644" name="_TocRef53985644">Assertions................................. 66</a></p>

<p class=MsoToc2><a href="#_Toc53985645" name="_TocRef53985645">A simple unit test framework........ 70</a></p>

<p class=MsoToc3><a href="#_Toc53985646" name="_TocRef53985646">Automated testing............ 71</a></p>

<p class=MsoToc3><a href="#_Toc53985647" name="_TocRef53985647">The TestSuite Framework.. 75</a></p>

<p class=MsoToc3><a href="#_Toc53985648" name="_TocRef53985648">Test suites....................... 79</a></p>

<p class=MsoToc3><a href="#_Toc53985649" name="_TocRef53985649">The test framework code... 81</a></p>

<p class=MsoToc2><a href="#_Toc53985650" name="_TocRef53985650">Debugging techniques................. 87</a></p>

<p class=MsoToc3><a href="#_Toc53985651" name="_TocRef53985651">Trace macros................... 87</a></p>

<p class=MsoToc3><a href="#_Toc53985652" name="_TocRef53985652">Trace file......................... 88</a></p>

<p class=MsoToc3><a href="#_Toc53985653" name="_TocRef53985653">Finding memory leaks....... 90</a></p>

<p class=MsoToc2><a href="#_Toc53985654" name="_TocRef53985654">Summary................................... 96</a></p>

<p class=MsoToc2><a href="#_Toc53985655" name="_TocRef53985655">Exercises................................... 97</a></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoToc1><a href="#_Toc53985656" name="_TocRef53985656">II: The Standard C++ Library                   101</a></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'>&nbsp;</p>

<p class=MsoToc1><a href="#_Toc53985657" name="_TocRef53985657">3: Strings in Depth                                   103</a></p>

<p class=MsoToc2><a href="#_Toc15743851" name="_TocRef15743851">What’s in a string?.................... 104</a></p>

<p class=MsoToc2><a href="#_Toc424692472" name="_TocRef424692472">Creating and initializing<br>
C++ strings............................. 106</a></p>

<p class=MsoToc2><a href="#_Toc15743853" name="_TocRef15743853">Operating on strings................. 109</a></p>

<p class=MsoToc3><a href="#_Toc15743854" name="_TocRef15743854">Appending, inserting, and<br>
concatenating strings...... 110</a></p>

<p class=MsoToc3><a href="#_Toc15743855" name="_TocRef15743855">Replacing string<br>
characters...................... 112</a></p>

<p class=MsoToc3><a href="#_Toc15743856" name="_TocRef15743856">Concatenation using  nonmember<br>
overloaded operators...... 117</a></p>

<p class=MsoToc2><a href="#_Toc15743857" name="_TocRef15743857">Searching in strings.................. 117</a></p>

<p class=MsoToc3><a href="#_Toc15743858" name="_TocRef15743858">Finding in reverse........... 123</a></p>

<p class=MsoToc3><a href="#_Toc15743859" name="_TocRef15743859">Finding first/last of<br>
a set of characters.......... 124</a></p>

<p class=MsoToc3><a href="#_Toc15743860" name="_TocRef15743860">Removing characters<br>
from strings................... 126</a></p>

<p class=MsoToc3><a href="#_Toc15743861" name="_TocRef15743861">Comparing strings.......... 129</a></p>

<p class=MsoToc3><a href="#_Toc15743862" name="_TocRef15743862">Strings and<br>
character traits............... 134</a></p>

<p class=MsoToc2><a href="#_Toc15743863" name="_TocRef15743863">A string application................... 140</a></p>

<p class=MsoToc2><a href="#_Toc53985671" name="_TocRef53985671">Summary................................. 145</a></p>

<p class=MsoToc2><a href="#_Toc15743865" name="_TocRef15743865">Exercises................................. 146</a></p>

<p class=MsoToc1><a href="#_Toc53985673" name="_TocRef53985673">4: Iostreams                                             151</a></p>

<p class=MsoToc2><a href="#_Toc305628663" name="_TocRef305628663">Why iostreams?........................ 151</a></p>

<p class=MsoToc2><a href="#_Toc305628664" name="_TocRef305628664">Iostreams to the rescue............ 156</a></p>

<p class=MsoToc3><a href="#_Toc312373878" name="_TocRef312373878">Inserters and extractors.. 156</a></p>

<p class=MsoToc3><a href="#_Toc312373879" name="_TocRef312373879">Common usage.............. 161</a></p>

<p class=MsoToc3><a href="#_Toc53985678" name="_TocRef53985678">Line–oriented input......... 164</a></p>

<p class=MsoToc2><a href="#_Toc53985679" name="_TocRef53985679">Handling stream errors.............. 165</a></p>

<p class=MsoToc2><a href="#_Toc305628665" name="_TocRef305628665">File iostreams........................... 168</a></p>

<p class=MsoToc3><a href="#_Toc53985681" name="_TocRef53985681">A File–Processing<br>
Example........................ 169</a></p>

<p class=MsoToc3><a href="#_Toc312373882" name="_TocRef312373882">Open modes................... 171</a></p>

<p class=MsoToc2><a href="#_Toc305628666" name="_TocRef305628666">Iostream buffering.................... 173</a></p>

<p class=MsoToc2><a href="#_Toc305628667" name="_TocRef305628667">Seeking in iostreams................. 175</a></p>

<p class=MsoToc2><a href="#_Toc53985685" name="_TocRef53985685">String iostreams....................... 179</a></p>

<p class=MsoToc3><a href="#_Toc53985686" name="_TocRef53985686">Input string streams........ 180</a></p>

<p class=MsoToc3><a href="#_Toc53985687" name="_TocRef53985687">Output string streams...... 182</a></p>

<p class=MsoToc2><a href="#_Toc53985688" name="_TocRef53985688">Output stream formatting.......... 186</a></p>

<p class=MsoToc3><a href="#_Toc53985689" name="_TocRef53985689">Format flags................... 186</a></p>

<p class=MsoToc3><a href="#_Toc53985690" name="_TocRef53985690">Format fields.................. 188</a></p>

<p class=MsoToc3><a href="#_Toc53985691" name="_TocRef53985691">Width, fill, and precision.. 190</a></p>

<p class=MsoToc3><a href="#_Toc312373892" name="_TocRef312373892">An exhaustive example... 191</a></p>

<p class=MsoToc2><a href="#_Toc53985693" name="_TocRef53985693">Manipulators............................. 194</a></p>

<p class=MsoToc3><a href="#_Toc312373894" name="_TocRef312373894">Manipulators with<br>
arguments..................... 196</a></p>

<p class=MsoToc3><a href="#_Toc53985695" name="_TocRef53985695">Creating manipulators..... 199</a></p>

<p class=MsoToc3><a href="#_Toc312373896" name="_TocRef312373896">Effectors........................ 201</a></p>

<p class=MsoToc2><a href="#_Toc312373897" name="_TocRef312373897">Iostream examples.................... 203</a></p>

<p class=MsoToc3><a href="#_Toc53985698" name="_TocRef53985698">Maintaining class library</br>
source code................... 204</a></p>

<p class=MsoToc3><a href="#_Toc53985699" name="_TocRef53985699">Detecting compiler errors 208</a></p>

<p class=MsoToc3><a href="#_Toc312373899" name="_TocRef312373899">A simple data logger....... 211</a></p>

<p class=MsoToc2><a href="#_Toc53985701" name="_TocRef53985701">Internationalization................... 216</a></p>

<p class=MsoToc3><a href="#_Toc53985702" name="_TocRef53985702">Wide Streams................. 216</a></p>

<p class=MsoToc3><a href="#_Toc53985703" name="_TocRef53985703">Locales.......................... 218</a></p>

<p class=MsoToc2><a href="#_Toc53985704" name="_TocRef53985704">Summary................................. 221</a></p>

<p class=MsoToc2><a href="#_Toc312373901" name="_TocRef312373901">Exercises................................. 222</a></p>

<p class=MsoToc1><a href="#_Toc53985706" name="_TocRef53985706">5: Templates in Depth                              227</a></p>

<p class=MsoToc2><a href="#_Toc53985707" name="_TocRef53985707">Template parameters................. 227</a></p>

<p class=MsoToc3><a href="#_Toc53985708" name="_TocRef53985708">Non–type<br>
template parameters....... 228</a></p>

<p class=MsoToc3><a href="#_Toc53985709" name="_TocRef53985709">Default template<br>
arguments..................... 230</a></p>

<p class=MsoToc3><a href="#_Toc53985710" name="_TocRef53985710">Template template<br>
parameters.................... 232</a></p>

<p class=MsoToc3><a href="#_Toc53985711" name="_TocRef53985711">The typename keyword... 238</a></p>

<p class=MsoToc3><a href="#_Toc53985712" name="_TocRef53985712">Using the template<br>
keyword as a hint........... 240</a></p>

<p class=MsoToc3><a href="#_Toc53985713" name="_TocRef53985713">Member Templates......... 242</a></p>

<p class=MsoToc2><a href="#_Toc53985714" name="_TocRef53985714">Function template issues........... 245</a></p>

<p class=MsoToc3><a href="#_Toc53985715" name="_TocRef53985715">Type deduction of function<br>
template arguments........ 245</a></p>

<p class=MsoToc3><a href="#_Toc53985716" name="_TocRef53985716">Function template<br>
overloading.................... 249</a></p>

<p class=MsoToc3><a href="#_Toc53985717" name="_TocRef53985717">Taking the address</br>
of a generated<br>
function template............ 251</a></p>

<p class=MsoToc3><a href="#_Toc312374091" name="_TocRef312374091">Applying a function</br>
to an STL sequence......... 255</a></p>

<p class=MsoToc3><a href="#_Toc53985719" name="_TocRef53985719">Partial ordering of<br>
function templates.......... 259</a></p>

<p class=MsoToc2><a href="#_Toc53985720" name="_TocRef53985720">Template specialization............... 260</a></p>

<p class=MsoToc3><a href="#_Toc53985721" name="_TocRef53985721">Explicit specialization....... 261</a></p>

<p class=MsoToc3><a href="#_Toc53985722" name="_TocRef53985722">Partial Specialization....... 263</a></p>

<p class=MsoToc3><a href="#_Toc53985723" name="_TocRef53985723">A practical example........ 265</a></p>

<p class=MsoToc3><a href="#_Toc312374086" name="_TocRef312374086">Preventing template<br>
code bloat...................... 268</a></p>

<p class=MsoToc2><a href="#_Toc53985725" name="_TocRef53985725">Name lookup issues.................. 273</a></p>

<p class=MsoToc3><a href="#_Toc53985726" name="_TocRef53985726">Names in templates........ 273</a></p>

<p class=MsoToc3><a href="#_Toc53985727" name="_TocRef53985727">Templates and friends..... 279</a></p>

<p class=MsoToc2><a href="#_Toc53985728" name="_TocRef53985728">Template programming idioms.... 285</a></p>

<p class=MsoToc3><a href="#_Toc53985729" name="_TocRef53985729">Traits............................. 285</a></p>

<p class=MsoToc3><a href="#_Toc53985730" name="_TocRef53985730">Policies.......................... 291</a></p>

<p class=MsoToc3><a href="#_Toc53985731" name="_TocRef53985731">The curiously recurring<br>
template pattern............. 294</a></p>

<p class=MsoToc2><a href="#_Toc53985732" name="_TocRef53985732">Template metaprogramming....... 297</a></p>

<p class=MsoToc3><a href="#_Toc53985733" name="_TocRef53985733">Compile–time<br>
programming................. 298</a></p>

<p class=MsoToc3><a href="#_Toc53985734" name="_TocRef53985734">Expression templates...... 308</a></p>

<p class=MsoToc2><a href="#_Toc53985735" name="_TocRef53985735">Template compilation models...... 315</a></p>

<p class=MsoToc3><a href="#_Toc53985736" name="_TocRef53985736">The inclusion model........ 315</a></p>

<p class=MsoToc3><a href="#_Toc312374093" name="_TocRef312374093">Explicit instantiation........ 316</a></p>

<p class=MsoToc3><a href="#_Toc53985738" name="_TocRef53985738">The separation model...... 319</a></p>

<p class=MsoToc2><a href="#_Toc53985739" name="_TocRef53985739">Summary................................. 320</a></p>

<p class=MsoToc2><a href="#_Toc53985740" name="_TocRef53985740">Exercises................................. 321</a></p>

<p class=MsoToc1><a href="#_Toc53985741" name="_TocRef53985741">6: Generic Algorithms                               325</a></p>

<p class=MsoToc2><a href="#_Toc22433867" name="_TocRef22433867">A first look............................... 325</a></p>

<p class=MsoToc3><a href="#_Toc22433868" name="_TocRef22433868">Predicates...................... 329</a></p>

<p class=MsoToc3><a href="#_Toc22433869" name="_TocRef22433869">Stream iterators............. 331</a></p>

<p class=MsoToc3><a href="#_Toc22433870" name="_TocRef22433870">Algorithm complexity...... 333</a></p>

<p class=MsoToc2><a href="#_Toc22433871" name="_TocRef22433871">Function objects....................... 335</a></p>

<p class=MsoToc3><a href="#_Toc22433872" name="_TocRef22433872">Classification of<br>
function objects.............. 336</a></p>

<p class=MsoToc3><a href="#_Toc22433873" name="_TocRef22433873">Automatic creation of<br>
function objects.............. 338</a></p>

<p class=MsoToc3><a href="#_Toc22433874" name="_TocRef22433874">Adaptable function objects 341</a></p>

<p class=MsoToc3><a href="#_Toc22433875" name="_TocRef22433875">More function<br>
object examples............. 343</a></p>

<p class=MsoToc3><a href="#_Toc22433876" name="_TocRef22433876">Function pointer adaptors 351</a></p>

<p class=MsoToc3><a href="#_Toc22433877" name="_TocRef22433877">Writing your own<br>
function object adaptors.. 358</a></p>

<p class=MsoToc2><a href="#_Toc22433878" name="_TocRef22433878">A catalog of STL algorithms....... 362</a></p>

<p class=MsoToc3><a href="#_Toc22433879" name="_TocRef22433879">Support tools for<br>
example creation............ 365</a></p>

<p class=MsoToc3><a href="#_Toc22433880" name="_TocRef22433880">Filling and generating...... 368</a></p>

<p class=MsoToc3><a href="#_Toc22433881" name="_TocRef22433881">Counting........................ 370</a></p>

<p class=MsoToc3><a href="#_Toc22433882" name="_TocRef22433882">Manipulating sequences... 372</a></p>

<p class=MsoToc3><a href="#_Toc22433883" name="_TocRef22433883">Searching and replacing.. 377</a></p>

<p class=MsoToc3><a href="#_Toc22433884" name="_TocRef22433884">Comparing ranges.......... 385</a></p>

<p class=MsoToc3><a href="#_Toc22433885" name="_TocRef22433885">Removing elements........ 389</a></p>

<p class=MsoToc3><a href="#_Toc22433886" name="_TocRef22433886">Sorting and operations<br>
on sorted ranges............ 393</a></p>

<p class=MsoToc3><a href="#_Toc22433887" name="_TocRef22433887">Heap operations............. 403</a></p>

<p class=MsoToc3><a href="#_Toc22433888" name="_TocRef22433888">Applying an operation to<br>
each element in a range.. 405</a></p>

<p class=MsoToc3><a href="#_Toc22433889" name="_TocRef22433889">Numeric algorithms......... 413</a></p>

<p class=MsoToc3><a href="#_Toc22433890" name="_TocRef22433890">General utilities.............. 417</a></p>

<p class=MsoToc2><a href="#_Toc22433891" name="_TocRef22433891">Creating your own<br>
STL–style algorithms................. 419</a></p>

<p class=MsoToc2><a href="#_Toc22433892" name="_TocRef22433892">Summary................................. 420</a></p>

<p class=MsoToc2><a href="#_Toc22433893" name="_TocRef22433893">Exercises................................. 421</a></p>

<p class=MsoToc1><a href="#_Toc53985769" name="_TocRef53985769">7: Generic Containers                               429</a></p>

<p class=MsoToc2><a href="#_Toc375545199" name="_TocRef375545199">Containers and iterators............ 429</a></p>

<p class=MsoToc3><a href="#_Toc53985771" name="_TocRef53985771">STL reference</br>
documentation................ 431</a></p>

<p class=MsoToc2><a href="#_Toc53985772" name="_TocRef53985772">A first look............................... 432</a></p>

<p class=MsoToc3><a href="#_Toc53985773" name="_TocRef53985773">Containers of strings....... 438</a></p>

<p class=MsoToc3><a href="#_Toc53985774" name="_TocRef53985774">Inheriting from</br>
STL containers................ 440</a></p>

<p class=MsoToc2><a href="#_Toc53985775" name="_TocRef53985775">A plethora of iterators............... 442</a></p>

<p class=MsoToc3><a href="#_Toc53985776" name="_TocRef53985776">Iterators in</br>
reversible containers....... 445</a></p>

<p class=MsoToc3><a href="#_Toc53985777" name="_TocRef53985777">Iterator categories.......... 446</a></p>

<p class=MsoToc3><a href="#_Toc53985778" name="_TocRef53985778">Predefined iterators........ 448</a></p>

<p class=MsoToc2><a href="#_Toc53985779" name="_TocRef53985779">The basic sequences:<br>
vector, list, deque..................... 454</a></p>

<p class=MsoToc3><a href="#_Toc53985780" name="_TocRef53985780">Basic sequence operations 454</a></p>

<p class=MsoToc3><a href="#_Toc53985781" name="_TocRef53985781">vector............................ 457</a></p>

<p class=MsoToc3><a href="#_Toc53985782" name="_TocRef53985782">deque............................ 465</a></p>

<p class=MsoToc3><a href="#_Toc53985783" name="_TocRef53985783">Converting between<br>
sequences...................... 467</a></p>

<p class=MsoToc3><a href="#_Toc53985784" name="_TocRef53985784">Checked random–access. 470</a></p>

<p class=MsoToc3><a href="#_Toc53985785" name="_TocRef53985785">list................................. 471</a></p>

<p class=MsoToc3><a href="#_Toc53985786" name="_TocRef53985786">Swapping sequences....... 477</a></p>

<p class=MsoToc2><a href="#_Toc53985787" name="_TocRef53985787">set.......................................... 479</a></p>

<p class=MsoToc3><a href="#_Toc53985788" name="_TocRef53985788">A completely<br>
reusable tokenizer.......... 482</a></p>

<p class=MsoToc2><a href="#_Toc53985789" name="_TocRef53985789">stack....................................... 487</a></p>

<p class=MsoToc2><a href="#_Toc53985790" name="_TocRef53985790">queue...................................... 491</a></p>

<p class=MsoToc2><a href="#_Toc53985791" name="_TocRef53985791">Priority queues......................... 496</a></p>

<p class=MsoToc2><a href="#_Toc53985792" name="_TocRef53985792">Holding bits.............................. 506</a></p>

<p class=MsoToc3><a href="#_Toc53985793" name="_TocRef53985793">bitset&lt;n&gt;....................... 507</a></p>

<p class=MsoToc3><a href="#_Toc53985794" name="_TocRef53985794">vector&lt;bool&gt;................. 511</a></p>

<p class=MsoToc2><a href="#_Toc53985795" name="_TocRef53985795">Associative containers............... 513</a></p>

<p class=MsoToc3><a href="#_Toc53985796" name="_TocRef53985796">Generators and fillers<br>
for associative containers 518</a></p>

<p class=MsoToc3><a href="#_Toc53985797" name="_TocRef53985797">The magic of maps......... 521</a></p>

<p class=MsoToc3><a href="#_Toc53985798" name="_TocRef53985798">Multimaps and<br>
duplicate keys................ 523</a></p>

<p class=MsoToc3><a href="#_Toc53985799" name="_TocRef53985799">Multisets........................ 527</a></p>

<p class=MsoToc2><a href="#_Toc53985800" name="_TocRef53985800">Combining STL containers.......... 530</a></p>

<p class=MsoToc2><a href="#_Toc53985801" name="_TocRef53985801">Cleaning up</br>
containers of pointers............... 534</a></p>

<p class=MsoToc2><a href="#_Toc53985802" name="_TocRef53985802">Creating your own containers..... 536</a></p>

<p class=MsoToc2><a href="#_Toc53985803" name="_TocRef53985803">STL extensions......................... 538</a></p>

<p class=MsoToc2><a href="#_Toc53985804" name="_TocRef53985804">Non–STL containers.................. 540</a></p>

<p class=MsoToc2><a href="#_Toc53985805" name="_TocRef53985805">Summary................................. 546</a></p>

<p class=MsoToc2><a href="#_Toc53985806" name="_TocRef53985806">Exercises................................. 546</a></p>

<p class=MsoToc1><a href="#_Toc53985807" name="_TocRef53985807">III: Special Topics                                    549</a></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal'>&nbsp;</p>

<p class=MsoToc1><a href="#_Toc53985808" name="_TocRef53985808">8: Runtime Type Identification                 551</a></p>

<p class=MsoToc2><a href="#_Toc53985809" name="_TocRef53985809">Runtime casts.......................... 551</a></p>

<p class=MsoToc2><a href="#_Toc53985810" name="_TocRef53985810">The typeid operator.................. 557</a></p>

<p class=MsoToc3><a href="#_Toc312374140" name="_TocRef312374140">Casting to</br>
intermediate levels......... 560</a></p>

<p class=MsoToc3><a href="#_Toc312374141" name="_TocRef312374141">void pointers.................. 561</a></p>

<p class=MsoToc3><a href="#_Toc312374142" name="_TocRef312374142">Using RTTI</br>
with templates................ 562</a></p>

<p class=MsoToc2><a href="#_Toc305593312" name="_TocRef305593312">Multiple inheritance.................... 563</a></p>

<p class=MsoToc2><a href="#_Toc305593313" name="_TocRef305593313">Sensible uses for RTTI............... 564</a></p>

<p class=MsoToc3><a href="#_Toc312374147" name="_TocRef312374147">A trash recycler.............. 565</a></p>

<p class=MsoToc2><a href="#_Toc312374148" name="_TocRef312374148">Mechanism and</br>
overhead of RTTI...................... 570</a></p>

<p class=MsoToc2><a href="#_Toc305593317" name="_TocRef305593317">Summary................................. 570</a></p>

<p class=MsoToc2><a href="#_Toc312374155" name="_TocRef312374155">Exercises................................. 571</a></p>

<p class=MsoToc1><a href="#_Toc53985820" name="_TocRef53985820">9: Multiple Inheritance                            573</a></p>

<p class=MsoToc2><a href="#_Toc305593286" name="_TocRef305593286">Perspective............................... 573</a></p>

<p class=MsoToc2><a href="#_Toc53985822" name="_TocRef53985822">Interface inheritance.................. 575</a></p>

<p class=MsoToc2><a href="#_Toc53985823" name="_TocRef53985823">Implementation inheritance........ 579</a></p>

<p class=MsoToc2><a href="#_Toc53985824" name="_TocRef53985824">Duplicate subobjects................. 585</a></p>

<p class=MsoToc2><a href="#_Toc53985825" name="_TocRef53985825">Virtual base classes................... 589</a></p>

<p class=MsoToc2><a href="#_Toc53985826" name="_TocRef53985826">Name lookup issues.................. 599</a></p>

<p class=MsoToc2><a href="#_Toc305593291" name="_TocRef305593291">Avoiding MI.............................. 603</a></p>

<p class=MsoToc2><a href="#_Toc305593292" name="_TocRef305593292">Extending an interface............... 603</a></p>

<p class=MsoToc2><a href="#_Toc305593293" name="_TocRef305593293">Summary................................. 608</a></p>

<p class=MsoToc2><a href="#_Toc312374109" name="_TocRef312374109">Exercises................................. 609</a></p>

<p class=MsoToc1><a href="#_Toc53985831" name="_TocRef53985831">10: Design Patterns                                 613</a></p>

<p class=MsoToc2><a href="#_Toc408018794" name="_TocRef408018794">The pattern concept.................. 613</a></p>

<p class=MsoToc3><a href="#_Toc53985833" name="_TocRef53985833">Prefer composition<br>
to inheritance................. 615</a></p>

<p class=MsoToc2><a href="#_Toc408018796" name="_TocRef408018796">Classifying patterns................... 615</a></p>

<p class=MsoToc3><a href="#_Toc11818297" name="_TocRef11818297">Features, idioms,</br>
patterns......................... 616</a></p>

<p class=MsoToc2><a href="#_Toc53985836" name="_TocRef53985836">Simplifying Idioms..................... 617</a></p>

<p class=MsoToc3><a href="#_Toc53985837" name="_TocRef53985837">Messenger..................... 617</a></p>

<p class=MsoToc3><a href="#_Toc53985838" name="_TocRef53985838">Collecting Parameter....... 618</a></p>

<p class=MsoToc2><a href="#_Toc53985839" name="_TocRef53985839">Singleton................................. 619</a></p>

<p class=MsoToc3><a href="#_Toc53985840" name="_TocRef53985840">Variations on Singleton.... 621</a></p>

<p class=MsoToc2><a href="#_Toc53985841" name="_TocRef53985841">Command: choosing</br>
the operation........................... 626</a></p>

<p class=MsoToc3><a href="#_Toc53985842" name="_TocRef53985842">Decoupling event handling<br>
with Command............... 628</a></p>

<p class=MsoToc2><a href="#_Toc41169699" name="_TocRef41169699">Object decoupling..................... 631</a></p>

<p class=MsoToc3><a href="#_Toc476705899" name="_TocRef476705899">Proxy: fronting for<br>
another object................ 632</a></p>

<p class=MsoToc3><a href="#_Toc476705900" name="_TocRef476705900">State: changing</br>
object behavior.............. 634</a></p>

<p class=MsoToc2><a href="#_Toc476705910" name="_TocRef476705910">Adapter................................... 636</a></p>

<p class=MsoToc2><a href="#_Toc53985847" name="_TocRef53985847">Template Method....................... 639</a></p>

<p class=MsoToc2><a href="#_Toc53985848" name="_TocRef53985848">Strategy: choosing the</br>
algorithm at runtime.................. 640</a></p>

<p class=MsoToc2><a href="#_Toc53985849" name="_TocRef53985849">Chain of Responsibility:</br>
trying a sequence of strategies... 642</a></p>

<p class=MsoToc2><a href="#_Toc53985850" name="_TocRef53985850">Factories: encapsulating</br>
object creation......................... 645</a></p>

<p class=MsoToc3><a href="#_Toc11818301" name="_TocRef11818301">Polymorphic factories...... 647</a></p>

<p class=MsoToc3><a href="#_Toc11818302" name="_TocRef11818302">Abstract factories............ 651</a></p>

<p class=MsoToc3><a href="#_Toc11818303" name="_TocRef11818303">Virtual constructors......... 654</a></p>

<p class=MsoToc2><a href="#_Toc53985854" name="_TocRef53985854">Builder: creating</br>
complex objects....................... 660</a></p>

<p class=MsoToc2><a href="#_Toc53985855" name="_TocRef53985855">Observer.................................. 667</a></p>

<p class=MsoToc3><a href="#_Toc53985856" name="_TocRef53985856">The “inner class” idiom.... 671</a></p>

<p class=MsoToc3><a href="#_Toc53985857" name="_TocRef53985857">The observer example.... 674</a></p>

<p class=MsoToc2><a href="#_Toc11818308" name="_TocRef11818308">Multiple dispatching................... 679</a></p>

<p class=MsoToc3><a href="#_Toc11818309" name="_TocRef11818309">Multiple dispatching</br>
with Visitor..................... 683</a></p>

<p class=MsoToc2><a href="#_Toc53985860" name="_TocRef53985860">Summary................................. 687</a></p>

<p class=MsoToc2><a href="#_Toc375545420" name="_TocRef375545420">Exercises................................. 688</a></p>

<p class=MsoToc1><a href="#_Toc53985862" name="_TocRef53985862">11: Concurrency                                       691</a></p>

<p class=MsoToc2><a href="#_Toc24775836" name="_TocRef24775836">Motivation................................ 692</a></p>

<p class=MsoToc2><a href="#_Toc40780395" name="_TocRef40780395">Concurrency in C++.................. 694</a></p>

<p class=MsoToc3><a href="#_Toc40780396" name="_TocRef40780396">Installing ZThreads......... 695</a></p>

<p class=MsoToc2><a href="#_Toc40780397" name="_TocRef40780397">Defining Tasks.......................... 696</a></p>

<p class=MsoToc2><a href="#_Toc40780398" name="_TocRef40780398">Using Threads.......................... 698</a></p>

<p class=MsoToc3><a href="#_Toc53985868" name="_TocRef53985868">Creating responsive</br>
user interfaces............... 700</a></p>

<p class=MsoToc3><a href="#_Toc40780406" name="_TocRef40780406">Simplifying with</br>
Executors....................... 702</a></p>

<p class=MsoToc3><a href="#_Toc44493771" name="_TocRef44493771">Yielding.......................... 706</a></p>

<p class=MsoToc3><a href="#_Toc24775839" name="_TocRef24775839">Sleeping........................ 707</a></p>

<p class=MsoToc3><a href="#_Toc40780405" name="_TocRef40780405">Priority.......................... 709</a></p>

<p class=MsoToc2><a href="#_Toc375545478" name="_TocRef375545478">Sharing limited resources........... 711</a></p>

<p class=MsoToc3><a href="#_Toc53985874" name="_TocRef53985874">Ensuring the</br>
existence of objects........ 711</a></p>

<p class=MsoToc3><a href="#_Toc53985875" name="_TocRef53985875">Improperly accessing</br>
resources....................... 715</a></p>

<p class=MsoToc3><a href="#_Toc44493777" name="_TocRef44493777">Controlling access........... 719</a></p>

<p class=MsoToc3><a href="#_Toc44493778" name="_TocRef44493778">Simplified coding</br>
with Guards.................... 721</a></p>

<p class=MsoToc3><a href="#_Toc53985878" name="_TocRef53985878">Thread local storage....... 724</a></p>

<p class=MsoToc2><a href="#_Toc53985879" name="_TocRef53985879">Terminating tasks...................... 727</a></p>

<p class=MsoToc3><a href="#_Toc53985880" name="_TocRef53985880">Preventing iostream</br>
collision......................... 727</a></p>

<p class=MsoToc3><a href="#_Toc53985881" name="_TocRef53985881">The ornamental garden... 728</a></p>

<p class=MsoToc3><a href="#_Toc53985882" name="_TocRef53985882">Terminating</br>
when blocked................. 733</a></p>

<p class=MsoToc3><a href="#_Toc53985883" name="_TocRef53985883">Interruption.................... 735</a></p>

<p class=MsoToc2><a href="#_Toc44493784" name="_TocRef44493784">Cooperation between threads..... 741</a></p>

<p class=MsoToc3><a href="#_Toc24775853" name="_TocRef24775853">Wait and signal............... 742</a></p>

<p class=MsoToc3><a href="#_Toc53985886" name="_TocRef53985886">Producer–consumer</br>
relationships................... 747</a></p>

<p class=MsoToc3><a href="#_Toc53985887" name="_TocRef53985887">Solving threading problems</br>
with queues.................... 750</a></p>

<p class=MsoToc3><a href="#_Toc53985888" name="_TocRef53985888">Broadcast...................... 757</a></p>

<p class=MsoToc2><a href="#_Toc375545483" name="_TocRef375545483">Deadlock.................................. 764</a></p>

<p class=MsoToc2><a href="#_Toc375545489" name="_TocRef375545489">Summary................................. 770</a></p>

<p class=MsoToc2><a href="#_Toc375545490" name="_TocRef375545490">Exercises................................. 773</a></p>

<p class=MsoToc1><a href="#_Toc53985892" name="_TocRef53985892">A: Recommended Reading                        777</a></p>

<p class=MsoToc2><a href="#_Toc53985893" name="_TocRef53985893">General C++............................ 777</a></p>

<p class=MsoToc3><a href="#_Toc53985894" name="_TocRef53985894">Bruce’s books................. 777</a></p>

<p class=MsoToc3><a href="#_Toc53985895" name="_TocRef53985895">Chuck’s books................ 779</a></p>

<p class=MsoToc2><a href="#_Toc53985896" name="_TocRef53985896">In–depth C++.......................... 779</a></p>

<p class=MsoToc2><a href="#_Toc53985897" name="_TocRef53985897">Design Patterns........................ 781</a></p>

<p class=MsoToc1><a href="#_Toc53985898" name="_TocRef53985898">B: Etc                                                       783</a></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoToc1><a href="#_Toc53985899" name="_TocRef53985899">Index                                                       791</a></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section7>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985602" name="_Toc53985602">Introduction</a></h1>

<p class=Intro style='margin-left:.25in'>In Volume 1 of this book, you learned the fundamentals of C and
C++. In this volume, we look at more advanced features, with an eye towards
developing techniques and ideas that produce robust C++ programs.</p>

<p class=MsoNormal>We assume you are familiar with the material presented in
Volume 1.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373771" name="_Toc312373771">Goals</a></h2>

<p class=MsoNormal>Our goals in this book are to:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Present the material a simple step at a time, so the reader can
easily digest each concept before moving on.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Teach “practical programming” techniques that you can use on a
day-to-day basis.</p>

<p class=Numbered><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Give you what we think is important for you to understand about
the language, rather than everything we know. We believe there is an
“information importance hierarchy,” and there are some facts that 95% of
programmers will never need to know, but that would just confuse people and add
to their perception of the complexity of the language. To take an example from
C, if you memorize the operator precedence table (we never did) you can write
clever code. But if <i>you</i> must think about it, it will confuse the
reader/maintainer of that code. So forget about precedence and use parentheses
when things aren’t clear. This same attitude will be taken with some
information in the C++ language, which is more important for compiler writers
than for programmers.</p>

<p class=Numbered><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Keep each section focused enough so the lecture time—and the time
between exercise periods—is small. Not only does this keep the audience’ minds
more active and involved during a hands-on seminar, but it gives the reader a
greater sense of accomplishment.</p>

<p class=Numbered><span style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>We have endeavored not to use any particular vendor’s version of
C++. We have tested the code on all the implementations we could (described
later in this introduction), and when one implementation absolutely refused to
work because it doesn’t conform to the C++ Standard, we’ve flagged that fact in
the example (you’ll see the flags in the source code) to exclude it from the
build process.</p>

<p class=Numbered><span style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Automate the compiling and testing of the code in the book. We
have discovered that code that isn’t compiled and tested is probably broken, so
in this volume we’ve instrumented the examples with test code. In addition, the
code that you can download from http://www.MindView.net has been extracted
directly from the text of the book using programs that automatically create
makefiles to compile and run the tests. This way we know that the code in the
book is correct.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373772" name="_Toc312373772">Chapters</a></h2>

<p class=MsoNormal>Here is a brief description of the chapters contained in
this book:</p>

<p class=MsoNormal><b>Part 1: Building Stable Systems</b></p>

<p class=MsoNormal><b>1. Exception handling</b>. Error handling has always been
a problem in programming. Even if you dutifully return error information or set
a flag, the function caller may simply ignore it. Exception handling is a
primary feature in C++ that solves this problem by allowing you to “throw” an
object out of your function when a critical error happens. You throw different
types of objects for different errors, and the function caller “catches” these
objects in separate error handling routines. If you throw an exception, it
cannot be ignored, so you can guarantee that <i>something</i> will happen in
response to your error. The decision to use exceptions affects code design in positive,
fundamental ways.</p>

<p class=MsoNormal><b>2. Defensive Programming</b>. Many software problems can
be prevented. To program defensively is to craft code in such a way that bugs are
found and fixed early before they can damage in the field. Using assertions is
the single most important way to validate your code during development, while
at the same time leaving an executable documentation trail in your code that
reveals your thoughts while you wrote the code in the first place. Rigorously
test your code before you let out of your hands. An automated unit testing framework
is an indispensable tool for successful, everyday software development.</p>

<p class=MsoNormal><b>Part 2: The Standard C++ Library</b></p>

<p class=MsoNormal><b>3. Strings in Depth</b>. The most common programming
activity is text processing. The C++ string class relieves the programmer from
memory management issues, while at the same time delivering a powerhouse of
text processing capability. C++ also supports the use of wide characters and
locales for internationalized applications.</p>

<p class=MsoNormal><b> 4. Iostreams</b>. One of the original C++ libraries—the
one that provides the essential I/O facility—is called iostreams. Iostreams is
intended to replace C’s <b>stdio.h </b>with an I/O library that is easier to
use, more flexible, and extensible—you can adapt it to work with your new
classes. This chapter teaches you how to make the best use of the existing
iostream library for standard I/O, file I/O, and in-memory formatting.</p>

<p class=MsoNormal><b>5. Templates in Depth</b>. The distinguishing feature of
“modern C++” is the broad power of templates. Templates do more than just create
generic containers. They support development of robust, generic,
high-performance libraries. There is a lot to know about templates—they
constitute, as it were, a sub-language within the C++ language, and give the
programmer an impressive degree of control over the compilation process. It is
not an overstatement to say that templates have revolutionized C++ programming.</p>

<p class=MsoNormal><b>6.</b> <b>Generic Algorithms</b>. Algorithms are at the
core of computing, and C++, through its template facility, supports an
impressive entourage of powerful, efficient, and easy-to-use generic
algorithms. The standard algorithms are also customizable through function
objects. This chapter looks at every algorithm in the library. (Chapters 6 and
7 cover that portion of the Standard C++ library commonly known as the Standard
Template Library, or STL.)</p>

<p class=MsoNormal><b>7.</b> <b>Generic Containers &amp; Iterators</b>. C++
supports all the common data structures in a type-safe manner. You never need
to worry about what such a container holds. The homogeneity of its objects is
guaranteed. Separating the traversing of a container from the container itself,
another accomplishment of templates, is made possible through iterators. This
ingenious arrangement allows a flexible application of algorithms to containers
using the simplest of designs.</p>

<b><span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:always'>
</span></b>

<p class=MsoNormal><b>Part 3: Special Topics</b></p>

<p class=MsoNormal><b>8. Runtime type identification</b>.<b> </b>Runtime type
identification (RTTI) finds the exact type of an object when you only have a
pointer or reference to the base type. Normally, you’ll want to intentionally
ignore the exact type of an object and let the virtual function mechanism
implement the correct behavior for that type. But occasionally (like when
writing software tools such as debuggers) it is helpful to know the exact type
of an object—with this information, you can often perform a special-case
operation more efficiently. This chapter explains what RTTI is for and how to
use it.</p>

<p class=MsoNormal><b>9. Multiple inheritance</b>. This sounds simple at first:
A new class is inherited from more than one existing class. However, you can
end up with ambiguities and multiple copies of base-class objects. That problem
is solved with virtual base classes, but the bigger issue remains: When do you
use it? Multiple inheritance is only essential when you need to manipulate an
object through more than one common base class. This chapter explains the
syntax for multiple inheritance and shows alternative approaches—in particular,
how templates solve one typical problem. Using multiple inheritance to repair a
“damaged” class interface is demonstrated as a valuable use of this feature.</p>

<p class=MsoNormal><b>10. Design Patterns</b>. The most revolutionary advance
in programming since objects is the introduction of <i>design patterns</i>. A
design pattern is a language-independent codification of a solution to a common
programming problem, expressed in such a way that it can apply to many
contexts. Patterns such as Singleton, Factory Method, and Visitor now find
their way into daily discussions around the keyboard. This chapter shows how to
implement and use some of the more useful design patterns in C++.</p>

<p class=MsoNormal><b>11. Concurrent Programming</b>. People have come to
expect responsive user interfaces that (seem to) process multiple tasks
simultaneously. Modern operating systems allow processes to have multiple
threads that share the process address space. Multithreaded programming
requires a different mindset, however, and comes with its own set of difficulties.
This chapter uses a freely available library (the ZThread library by Eric
Crahen of IBM) to show how to effectively manage multithreaded applications in
C++.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373773" name="_Toc312373773">Exercises</a></h2>

<p class=MsoNormal>We have discovered that simple exercises are exceptionally
useful during a seminar to complete a student’s understanding. You’ll find a
set at the end of each chapter.</p>

<p class=MsoNormal>These are fairly simple, so they can be finished in a
reasonable amount of time in a classroom situation while the instructor
observes, making sure all the students are absorbing the material. Some
exercises are a bit more challenging to keep advanced students entertained.
They’re all designed to be solved in a short time and are only there to test
and polish your knowledge rather than present major challenges (presumably,
you’ll find those on your own—or more likely they’ll find you).</p>

<h3><a href="#_TocRef53985606" name="_Toc53985606">Exercise solutions</a></h3>

<p class=MsoNormal>Solutions to exercises can be found in the electronic
document <i>The C++ Annotated Solution Guide</i>, Volume 2, available for a nominal
fee from http://www.MindView.net.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef310733137" name="_Toc310733137">Source
code</a></h2>

<p class=MsoNormal>The source code for this book is copyrighted freeware,
distributed via the web site http://www.MindView.net. The copyright prevents
you from republishing the code in print media without permission.</p>

<p class=MsoNormal>In the starting directory where you unpack the code you will
find the following copyright notice:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>//:! :CopyRight.txt</div>
<div class=CC1>(c) 1995-2004 MindView, Inc.  All rights reserved.</div>
<div class=CC1>Source code file from the book</div>
<div class=CC1>&quot;Thinking in C++, 2nd Edition, Volume 2.&quot;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>The following permissions are granted respecting the</div>
<div class=CC1>computer source code, which is contained in this file:</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Permission is granted to classroom educators to use
this</div>
<div class=CC1>file as part of instructional materials prepared for</div>
<div class=CC1>classes personally taught or supervised by the educator
who</div>
<div class=CC1>uses this permission, provided that (a) the book
&quot;Thinking</div>
<div class=CC1>in C++&quot; is cited as the origin on each page or
slide that</div>
<div class=CC1>contains any part of this file, and (b) that you may
not</div>
<div class=CC1>remove the above copyright legend nor this notice. This</div>
<div class=CC1>permission extends to handouts, slides and other</div>
<div class=CC1>presentation materials.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>For purposes that do not include the publication or</div>
<div class=CC1>presentation of educational or instructional materials,</div>
<div class=CC1>permission also is granted to computer program
designers</div>
<div class=CC1>and programmers, and to their employers and customers,
(a)</div>
<div class=CC1>to use and modify this file for the purpose of creating</div>
<div class=CC1>executable computer software, and (b) to distribute</div>
<div class=CC1>resulting computer programs in binary form only,
provided</div>
<div class=CC1>that (c) you may not remove the above copyright legend
nor</div>
<div class=CC1>this notice from retained source code copies of this
file,</div>
<div class=CC1>and (d) each copy distributed in binary form has
embedded</div>
<div class=CC1>within it the above copyright notice.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Apart from the permissions granted above, the sole</div>
<div class=CC1>authorized distribution point for additional copies of
this</div>
<div class=CC1>file is http://www.MindView.net (and official mirror
sites)</div>
<div class=CC1>where it is available, subject to the permissions and</div>
<div class=CC1>restrictions set forth herein.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>The following are clarifications of the limited
permissions</div>
<div class=CC1>granted above:</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>1. You may not publish or distribute originals or</div>
<div class=CC1>modified versions of the source code to the software
other</div>
<div class=CC1>than in classroom situations described above.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>2. You may not use the software file or portions</div>
<div class=CC1>thereof in printed media without the express permission
of</div>
<div class=CC1>the copyright owner.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>The copyright owner and author or authors make no</div>
<div class=CC1>representation about the suitability of this software
for</div>
<div class=CC1>any purpose.  It is provided &quot;as is,&quot; and all
express,</div>
<div class=CC1>implied, and statutory warranties and conditions of any</div>
<div class=CC1>kind including any warranties and conditions of</div>
<div class=CC1>merchantability, satisfactory quality, security,
fitness</div>
<div class=CC1>for a particular purpose and non-infringement, are</div>
<div class=CC1>disclaimed. The entire risk as to the quality and</div>
<div class=CC1>performance of the software is with you.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>In no event will the authors or the publisher be liable
for</div>
<div class=CC1>any lost revenue, savings, or data, or for direct,</div>
<div class=CC1>indirect, special, consequential, incidental, exemplary
or</div>
<div class=CC1>punitive damages, however caused and regardless of any</div>
<div class=CC1>related theory of liability, arising out of this
license</div>
<div class=CC1>and/or the use of or inability to use this software,
even</div>
<div class=CC1>if the vendors and/or the publisher have been advised
of</div>
<div class=CC1>the possibility of such damages. Should the software
prove</div>
<div class=CC1>defective, you assume the cost of all necessary
servicing,</div>
<div class=CC1>repair, or correction.</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>If you think you have a correction for an error in the</div>
<div class=CC1>software, please submit the correction to
www.MindView.net.</div>
<div class=CC1>(Please use the same process for non-code errors found
in</div>
<div class=CC1>the book.)</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>If you have a need for permissions not granted above,</div>
<div class=CC1>please inquire of MindView, Inc., at www.MindView.net
or</div>
<div class=CC1>send a request by email to Bruce@EckelObjects.com.</div>
<div class=CC1>///:~</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You may use the code in your projects and in the classroom
as long as the copyright notice is retained.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985608" name="_Toc53985608">Compilers</a></h2>

<p class=MsoNormal>Your compiler may not support all the features discussed in
this book, especially if you don’t have the newest version of your compiler.
Implementing a language like C++ is a Herculean task, and you can expect that
the features will appear in pieces rather than all at once. But if you attempt
one of the examples in the book and get a lot of errors from the compiler, it’s
not necessarily a bug in the code or the compiler—it may simply not be
implemented in your particular compiler yet.</p>

<p class=MsoNormal>We used a number of compilers to test the code in this book,
in an attempt to ensure that our code conforms to the C++ Standard and will
work with as many compilers as possible. Unfortunately, not all compilers
conform to the C++ Standard, and so we have a way of excluding certain files
from building with those compilers. These exclusions are reflected in the
makefiles automatically created for the package of code for this book that you
can download from www.MindView.net. You can see the exclusion tags embedded in
the comments at the beginning of each listing, so you will know whether to
expect a particular compiler to work on that code (in a few cases, the compiler
will actually compile the code but the execution behavior is wrong, and we
exclude those as well).</p>

<p class=MsoNormal>Here are the tags and the compilers that they exclude from
the build:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>{-dmc}</b> Walter Bright’s Digital Mars compiler for Windows,
freely downloadable at www.DigitalMars.com. This compiler is very conformant
and so you will see almost none of these tags throughout the book.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>{-g++}</b> The free Gnu C++ 3.3.1, which comes pre-installed
in most Linux packages and Macintosh OSX. It is also part of Cygwin for Windows
(see below). It is available for most other platforms from gcc.gnu.org.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>{-msc}</b> Microsoft Version 7 with Visual C++ .NET (only
comes with Visual Studio .NET; not freely downloadable).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>{-bor}</b> Borland C++ Version 6 (not the free download; this
one is more up to date).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>{-edg}</b> Edison Design Group (EDG) C++. This is the
benchmark compiler for standards conformance. This tag occurs only because of
library issues, and because we were using a complimentary copy of the EDG front
end with a complimentary library implementation from Dinkumware, Ltd. No
compile errors occurred because of the compiler alone.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>{-mwcc}</b> Metrowerks Code Warrior for Macintosh OS X. Note
that OS X comes with Gnu C++ pre-installed, as well.</p>

<p class=MsoNormal>If you download and unpack the code package for this book
from www.MindView.net, you’ll find the makefiles to build the code for the
above compilers. We used the freely-available GNU-<b>make</b>, which comes with
Linux, Cygwin (a free Unix shell that runs on top of Windows; see
www.Cygwin.com), or can be installed on your platform—see
www.gnu.org/software/make. (Other <b>make</b>s may or may not work with these
files, but are not supported.) Once you install <b>make</b>, if you type <b>make</b>
at the command line you’ll get instructions on how to build the book’s code for
the above compilers.</p>

<p class=MsoNormal>Note that the placement of these tags on the files in this
book indicates the state of the particular version of the compiler at the time
we tried it. It’s possible and likely that the compiler vendor has improved the
compiler since the publication of this book. It’s also possible that while
building the book with so many compilers, we may have misconfigured a
particular compiler that would otherwise have compiled the code correctly. Thus,
you should try the code yourself on your compiler, and also check the code
downloaded from www.MindView.net to see what is current.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985609" name="_Toc53985609">Language
standards</a></h2>

<p class=MsoNormal>Throughout this book, when referring to conformance to the
ANSI/ISO C standard, we will be referring to the 1989 standard, and will
generally just say ‘<b>C</b>.’ Only if it is necessary to distinguish between
Standard 1989 C and older, pre-Standard versions of C will we make the
distinction. We do not reference C99 in this book.</p>

<p class=MsoNormal>The ANSI/ISO C++ Committee long ago finished working on the first C++ Standard, commonly known as C++98. We will use the term <i>Standard
C++</i> to refer to this standardized language. If we simply refer to C++,
assume we mean “Standard C++.” The C++ Standards Committee continues to address
issues important to the C++ community that will become C++0x, a future C++
Standard not likely to be available for many years.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373778" name="_Toc312373778">Seminars, </a>CD–ROMs &amp;
consulting</h2>

<p class=MsoNormal>Bruce Eckel’s company, MindView, Inc., provides public
hands-on training seminars based on the material in this book, and also for
advanced topics. Selected material from each chapter represents a lesson, which
is followed by a monitored exercise period so each student receives personal
attention. We also provide on-site training, consulting, mentoring, and design
&amp; code walkthroughs. Information and sign-up forms for upcoming seminars
and other contact information is found at <b>http://www.MindView.net</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373779" name="_Toc312373779">Errors</a></h2>

<p class=MsoNormal>No matter how many tricks writers use to detect errors, some
always creep in and these often leap off the page for a fresh reader. If you
discover anything you believe to be an error, please use the feedback system
built into the electronic version of this book, which you will find at <b>http://www.MindView.net</b>.
Your help is appreciated.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985612" name="_Toc53985612">About the cover</a></h2>

<p class=MsoNormal>The cover artwork was painted by Larry O’Brien’s wife, Tina
Jensen (yes, the Larry O’Brien who was the editor of Software Development
Magazine for so many years). Not only are the pictures beautiful, they are also
excellent suggestions of polymorphism. The idea for using these images came
from Daniel Will-Harris, the cover designer (www.Will-Harris.com), working with
Bruce.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985613" name="_Toc53985613">Acknowledgements</a></h2>

<p class=MsoNormal>Volume 2 of this book languished in a half-completed state
for a long time while Bruce got distracted with other things, notably Java,
Design Patterns and especially Python (see www.Python.org). If Chuck hadn’t
been willing (foolishly, he has sometimes thought) to finish the other half and
bring things up-to-date, this book almost certainly wouldn’t have happened.
There aren’t that many people whom Bruce would have felt comfortable entrusting
this book to. Chuck’s penchant for precision, correctness and clear explanation
is what has made this book as good as it is.</p>

<p class=MsoNormal>Jamie King acted as an intern under Chuck’s direction during
the completion of this book. He was an essential part of making sure the book
got finished, not only by providing feedback for Chuck, but especially because
of his relentless questioning and picking of every single possible nit that he
didn’t completely understand. If your questions are answered by this book, it’s
probably because Jamie asked them first. Jamie also enhanced a number of the
sample programs and created many of the exercises at the end of each chapter.
Scott Baker, another of Chuck’s interns funded by MindView, Inc., helped with
the exercises for Chapter 3.</p>

<p class=MsoNormal>Eric Crahen of IBM was instrumental in the completion of
Chapter 11 (Concurrency). When we were looking for a threads package, we sought
out one that was intuitive and easy to use, while being sufficiently robust to
do the job. With Eric we got that and then some—he was extremely cooperative
and has used our feedback to enhance his library, while we have benefited from
his insights as well.</p>

<p class=MsoNormal>We are grateful to Pete Becker for being our technical
editor. Few people are as articulate and discriminating as Pete, not to mention
as expert in C++ and software development in general. We also thank Bjorn
Karlsson for his gracious and timely technical assistance as he reviewed the
entire manuscript with short notice.</p>

<p class=MsoNormal>Walter Bright made Herculean efforts to make sure that his
Digital Mars C++ compiler would compile the examples in this book. He makes the
compiler available for free downloads at http://www.DigitalMars.com. Thanks, Walter!</p>

<p class=MsoNormal>The ideas and understanding in this book have come from many
other sources, as well: friends like Andrea Provaglio, Dan Saks, Scott Meyers,
Charles Petzold, and Michael Wilk; pioneers of the language like Bjarne
Stroustrup, Andrew Koenig, and Rob Murray; members of the C++ Standards
Committee like Nathan Myers (who was particularly helpful and generous with his
insights), Herb Sutter, PJ Plauger, Kevlin Henney, David Abrahams, Tom Plum,
Reg Charney, Tom Penello, Sam Druker, Uwe Steinmueller, John Spicer, Steve
Adamczyk, and Daveed Vandevoorde; people who have spoken in the C++ track at
the Software Development Conference (which Bruce created and developed, and
Chuck spoke in); Colleagues of Chuck like Michael Seaver, Huston Franklin,
David Wagstaff, and often students in seminars, who ask the questions we need
to hear to make the material clearer.</p>

<p class=MsoNormal>The book design, typeface selection, cover design, and cover
photo were created by Bruce’s friend Daniel Will-Harris, noted author and
designer, who used to play with rub-on letters in junior high school while he
awaited the invention of computers and desktop publishing. However, we produced
the camera-ready pages ourselves, so the typesetting errors are ours. Microsoft<sup>®</sup>
Word XP was used to write the book and to create camera-ready pages. The body
typeface is Verdana and the headlines are in Verdana. The code type face is
Courier New.</p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Verdana'>We also wish to thank the
generous professionals at the Edison Design Group and Dinkumware, Ltd., for
giving us complimentary copies of their compiler and library (respectively).
Without their expert assistance, graciously given, some of the examples in this
book could not have been tested. We also wish to thank Howard Hinnant and the
folks at Metrowerks for a copy of their compiler, and Sandy Smith and the folks
at SlickEdit for keeping Chuck supplied with a world-class editing environment
for so many years. Greg Comeau also provided a copy of his successful EDG-based
compiler, Comeau C++.</span></p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Verdana'>A special thanks to all
our teachers, and all our students (who are our teachers as well).</span></p>

<p class=Figure style='margin-top:0in;margin-right:0in;margin-bottom:12.0pt;
margin-left:.25in'><span style='font-family:Verdana'>Evan Cofsky
(Evan@TheUnixMan.com) provided all sorts of assistance on the server as well as
development of programs in his now-favorite language, Python. Sharlynn Cobaugh
and Paula Steuer were instrumental assistants, preventing Bruce from being
washed away in a flood of projects.</span></p>

<p class=MsoNormal>Bruce’s sweetie Dawn McGee provided much-appreciated
inspiration and enthusiasm during this project. The supporting cast of friends
includes, but is not limited to: Mark Western, Gen Kiyooka, Kraig Brockschmidt,
Zack Urlocker, Andrew Binstock, Neil Rubenking, Steve Sinofsky, JD Hildebrandt,
Brian McElhinney, Brinkley Barr, Bill Gates at Midnight Engineering Magazine,
Larry Constantine &amp; Lucy Lockwood, Tom Keffer, Greg Perry, Dan Putterman,
Christi Westphal, Gene Wang, Dave Mayer, David Intersimone, Claire Sawyers, The
Italians (Andrea Provaglio, Laura Fallai, Marco Cantu, Corrado, Ilsa and
Christina Giustozzi), Chris &amp; Laura Strand, The Almquists, Brad Jerbic,
John Kruth &amp; Marilyn Cvitanic, Holly Payne (yes, the famous novelist!),
Mark Mabry, The Robbins Families, The Moelter Families (&amp; the McMillans),
The Wilks, Dave Stoner, Laurie Adams, The Cranstons, Larry Fogg, Mike &amp;
Karen Sequeira, Gary Entsminger &amp; Allison Brody, Chester Andersen, Joe
Lordi, Dave &amp; Brenda Bartlett, The Rentschlers, The Sudeks, Lynn &amp;
Todd, and their families. And of course, Mom &amp; Dad, Sandy, James &amp;
Natalie, Kim&amp; Jared, Isaac, and Abbi.</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section8>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985614" name="_Toc53985614">Part 1: Building Stable Systems</a></h1>

<p class=Intro style='margin-left:.25in'>Software engineers spend about as much time validating code as
they do creating it. Quality is or should be the goal of every programmer, and
one can go a long way towards that goal by eliminating problems before they happen.
In addition, software systems should be robust enough to behave reasonably in
the presence of unforeseen environmental problems.</p>

<p class=MsoNormal>Exceptions were introduced into C++ to support sophisticated
error handling without cluttering code with an inordinate amount of
error-handling logic. Chapter 1 shows how proper use of exceptions can make for
well-behaved software, and also introduces the design principles that underlie
exception-safe code. In Chapter 2 we cover unit testing and debugging
techniques intended to maximize code quality long before it’s released. The use
of assertions to express and enforce program invariants is a sure sign of an
experienced software engineer. We also introduce a simple framework to support
unit testing.</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section9>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985615" name="_Toc53985615">1: Exception Handling</a></h1>

<p class=Intro style='margin-left:.25in'>Improving error recovery is one of the most powerful ways you can increase the robustness of your code.</p>

<p class=MsoNormal>Unfortunately, it’s almost accepted practice to ignore error
conditions, as if we’re in a state of denial about errors. One reason, no
doubt, is the tediousness and code bloat of checking for many errors. For
example, <b>printf(&nbsp;)</b> returns the number of characters that were
successfully printed, but virtually no one checks this value. The proliferation
of code alone would be disgusting, not to mention the difficulty it would add
in reading the code.</p>

<p class=MsoNormal>The problem with C’s approach to error handling could be
thought of as coupling—the user of a function must tie the error-handling code
so closely to that function that it becomes too ungainly and awkward to use.</p>

<p class=MsoNormal>One of the major features in C++ is <i>exception handling</i>,
which is a better way of thinking about and handling errors. With exception handling:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Error-handling code is not nearly so tedious to write, and it
doesn’t become mixed up with your “normal” code. You write the code you <i>want</i>
to happen; later in a separate section you write the code to cope with the
problems. If you make multiple calls to a function, you handle the errors from
that function once, in one place.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Errors cannot be ignored. If a function needs to send an error
message to the caller of that function, it “throws” an object representing that
error out of the function. If the caller doesn’t “catch” the error and handle
it, it goes to the next enclosing dynamic scope, and so on until the error is
either caught or the program terminates because there was no handler to catch
that type of exception.</p>

<p class=MsoNormal>This chapter examines C’s approach to error handling (such as it is), discusses why it did not work well for C, and explains why it won’t work at all
for C++. This chapter also covers <b>try</b>, <b>throw</b>,<b> </b>and <b>catch</b>,
the C++ keywords that support exception handling.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593296" name="_Toc305593296">Traditional
error handling</a></h2>

<p class=MsoNormal>In most of the examples in these volumes, we use <b>assert(&nbsp;)</b>
as it was intended: for debugging during development with code that can be
disabled with <b>#define</b> <b>NDEBUG</b> for the shipping product. Runtime
error checking uses the <b>require.h</b> functions (<b>assure(&nbsp;)</b> and <b>require(&nbsp;)</b>)
developed in Chapter 9 in Volume 1 and repeated here in Appendix B. These
functions are a convenient way to say, “There’s a problem here you’ll probably
want to handle with some more sophisticated code, but you don’t need to be
distracted by it in this example.” The <b>require.h</b> functions might be
enough for small programs, but for complicated products you’ll want to write
more sophisticated error-handling code.</p>

<p class=MsoNormal>Error handling is quite straightforward when you know
exactly what to do, because you have all the necessary information in that
context. You can just handle the error at that point.</p>

<p class=MsoNormal>The problem occurs when you <i>don’t</i> have enough
information in that context, and you need to pass the error information into a
different context where that information does exist. In C, you can handle this
situation using three approaches:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Return error information from the function or, if the return
value cannot be used this way, set a global error condition flag. (Standard C
provides <b>errno</b> and <b>perror(&nbsp;)</b> to support this.) As mentioned
earlier, the programmer is likely to ignore the error information because
tedious and obfuscating error checking must occur with each function call. In
addition, returning from a function that hits an exceptional condition might
not make sense.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use the little-known Standard C library signal-handling system,
implemented with the <b>signal(&nbsp;)</b> function (to determine what happens
when the event occurs) and <b>raise(&nbsp;)</b> (to generate an event). Again,
this approach involves high coupling because it requires the user of any
library that generates signals to understand and install the appropriate
signal-handling mechanism. In large projects the signal numbers from different
libraries might clash.</p>

<p class=Numbered><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use the <i>nonlocal goto</i> functions in the Standard C library:
<b>setjmp(&nbsp;)</b> and <b>longjmp(&nbsp;)</b>. With <b>setjmp(&nbsp;)</b>
you save a known good state in the program, and if you get into trouble, <b>longjmp(&nbsp;)</b>
will restore that state. Again, there is high coupling between the place where
the state is stored and the place where the error occurs.</p>

<p class=MsoNormal>When considering error-handling schemes with C++, there’s an
additional critical problem: The C techniques of signals and <b>setjmp(&nbsp;)</b>/<b>longjmp(&nbsp;)</b>
do not call destructors, so objects aren’t properly cleaned up. (In fact, if <b>longjmp(&nbsp;)</b>
jumps past the end of a scope where destructors should be called, the behavior
of the program is undefined.) This makes it virtually impossible to effectively
recover from an exceptional condition because you’ll always leave objects
behind that haven’t been cleaned up and that can no longer be accessed. The
following example demonstrates this with <b>setjmp/longjmp</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Nonlocal.cpp</font></div>
<div class=CC1><font color=#dd0000>// setjmp() &amp; longjmp().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;csetjmp&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Rainbow {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Rainbow() { cout &lt;&lt; <font color=#007f00>&quot;Rainbow()&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>  ~Rainbow() { cout &lt;&lt; <font color=#007f00>&quot;~Rainbow()&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>jmp_buf kansas;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> oz() {</div>
<div class=CC1>  Rainbow rb;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 3; i++)</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;there's no place like
home&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  longjmp(kansas, 47);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>if</font>(setjmp(kansas) == 0) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;tornado, witch,
munchkins...&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    oz();</div>
<div class=CC1>  } <font color=#ff7700>else</font> {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Auntie Em! &quot;</font></div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;I had the strangest
dream...&quot;</font></div>
<div class=CC1>         &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>setjmp(&nbsp;)</b> function is odd because if you
call it directly, it stores all the relevant information about the current
processor state (such as the contents of the instruction pointer and runtime
stack pointer) in the <b>jmp_buf</b> and returns zero. In this case it behaves
like an ordinary function. However, if you call <b>longjmp(&nbsp;)</b> using
the same <b>jmp_buf</b>, it’s as if you’re returning from <b>setjmp(&nbsp;)</b>
again—you pop right out the back end of the <b>setjmp(&nbsp;)</b>. This time,
the value returned is the second argument to <b>longjmp(&nbsp;)</b>, so you can
detect that you’re actually coming back from a <b>longjmp(&nbsp;)</b>. You can
imagine that with many different <b>jmp_buf</b>s, you could pop around to many
different places in the program. The difference between a local <b>goto</b>
(with a label) and this nonlocal goto is that you can return to any
pre-determined location higher up in the runtime stack with <b>setjmp(&nbsp;)</b>/<b>longjmp(&nbsp;)</b>
(wherever you’ve placed a call to <b>setjmp(&nbsp;)</b>).</p>

<p class=MsoNormal>The problem in C++ is that <b>longjmp(&nbsp;)</b> doesn’t
respect objects; in particular it doesn’t call destructors when it jumps out of
a scope.<a href="#_ftn1" name="_ftnref1"><span
class=MsoFootnoteReference>[1]</span></a> Destructor
calls are essential, so this approach won’t work with C++. In fact, the C++
Standard states that branching into a scope with <b>goto</b> (effectively
bypassing constructor calls), or branching out of a scope with <b>longjmp(&nbsp;)</b>
where an object on the stack has a destructor, constitutes undefined behavior.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593297" name="_Toc305593297">Throwing
an exception</a></h2>

<p class=MsoNormal>If you encounter an exceptional situation in your code—that
is, if you don’t have enough information in the current context to decide what
to do—you can send information about the error into a larger context by
creating an object that contains that information and “throwing” it out of your
current context. This is called <i>throwing an exception</i>. Here’s what it
looks like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:MyError.cpp {RunByHand}</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MyError {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* <font color=#ff7700>const</font> data;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MyError(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* <font color=#ff7700>const</font> msg = 0) : data(msg) {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f() {</div>
<div class=CC1>  <font color=#dd0000>// Here we &quot;throw&quot; an exception object:</font></div>
<div class=CC1>  <font color=#ff7700>throw</font> MyError(<font color=#007f00>&quot;something bad happened&quot;</font>);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// As you’ll see shortly, we’ll want a &quot;try
block&quot; here:</font></div>
<div class=CC1>  f();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>MyError</b> is an ordinary class, which in this case
takes a <b>char*</b> as a constructor argument. You can use any type when you
throw (including built-in types), but usually you’ll create special classes for
throwing exceptions.</p>

<p class=MsoNormal>The keyword <b>throw</b> causes a number of relatively
magical things to happen. First, it creates a copy of the object you’re
throwing and, in effect, “returns” it from the function containing the throw
expression, even though that object type isn’t normally what the function is
designed to return. A naive way to think about exception handling is as an
alternate return mechanism (although you’ll find you can get into trouble if
you take that analogy too far). You can also exit from ordinary scopes by
throwing an exception. In any case, a value is returned, and the function or
scope exits.</p>

<p class=MsoNormal>Any similarity to a <b>return</b> statement ends there
because <i>where</i> you return is some place completely different from where a
normal function call returns. (You end up in an appropriate part of the
code—called an exception handler—that might be far removed from where the
exception was thrown.) In addition, any local objects created by the time the
exception occurs are destroyed. This automatic cleanup of local objects is
often called “stack unwinding.”</p>

<p class=MsoNormal>In addition, you can throw as many different types of
objects as you want. Typically, you’ll throw a different type for each category
of error. The idea is to store the information in the object and in the <i>name</i>
of its class so that someone in a calling context can figure out what to do
with your exception. </p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593298" name="_Toc305593298">Catching
an exception</a></h2>

<p class=MsoNormal>As mentioned earlier, one of the advantages of C++ exception
handling is that you can concentrate on the problem you’re trying to solve in
one place, and then deal with the errors from that code in another place.</p>

<h3><a href="#_TocRef312374114" name="_Toc312374114">The try block</a></h3>

<p class=MsoNormal>If you’re inside a function and you throw an exception (or a
called function throws an exception), the function exits because of the thrown
exception. If you don’t want a <b>throw </b>to leave a function, you can set up
a special block within the function where you try to solve your actual
programming problem (and potentially generate exceptions). This block is called
the <i>try</i> <i>block</i> because you try your various function calls there.
The try block is an ordinary scope, preceded by the keyword <b>try</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>try</font> {</div>
<div class=CC1>  <font color=#dd0000>// Code that may generate exceptions</font></div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you check for errors by carefully examining the return
codes from the functions you use, you need to surround every function call with
setup and test code, even if you call the same function several times. With
exception handling, you put everything in a <b>try</b> block and handle
exceptions after the <b>try</b> block. Thus, your code is a lot easier to write
and to read because the goal of the code is not confused with the error handling.</p>

<h3><a href="#_TocRef312374115" name="_Toc312374115">Exception handlers</a></h3>

<p class=MsoNormal>Of course, the thrown exception must end up some place. This
place is the <i>exception handler</i>, and you need one exception handler for every exception type you want to catch. However, polymorphism also works for
exceptions, so one exception handler can work with an exception type and
classes derived from that type.</p>

<p class=MsoNormal>Exception handlers immediately follow the <b>try</b> block
and are denoted by the keyword <b>catch</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>try</font> {</div>
<div class=CC1>  <font color=#dd0000>// Code that may generate exceptions</font></div>
<div class=CC1>} <font color=#ff7700>catch</font>(type1 id1) {</div>
<div class=CC1>  <font color=#dd0000>// Handle exceptions of type1</font></div>
<div class=CC1>} <font color=#ff7700>catch</font>(type2 id2) {</div>
<div class=CC1>  <font color=#dd0000>// Handle exceptions of type2</font></div>
<div class=CC1>} <font color=#ff7700>catch</font>(type3 id3)</div>
<div class=CC1>  <font color=#dd0000>// Etc...</font></div>
<div class=CC1>} <font color=#ff7700>catch</font>(typeN idN)</div>
<div class=CC1>  <font color=#dd0000>// Handle exceptions of typeN</font></div>
<div class=CC1>}</div>
<div class=CC1><font color=#dd0000>// Normal execution resumes here...</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The syntax of a <b>catch</b> clause resembles functions that
take a single argument. The identifier (<b>id1</b>, <b>id2</b>, and so on) can
be used inside the handler, just like a function argument, although you can
omit the identifier if it’s not needed in the handler. The exception type
usually gives you enough information to deal with it.</p>

<p class=MsoNormal>The handlers must appear directly after the <b>try</b>
block. If an exception is thrown, the exception-handling mechanism goes hunting
for the first handler with an argument that matches the type of the exception.
It then enters that <b>catch</b> clause, and the exception is considered
handled. (The search for handlers stops once the <b>catch</b> clause is found.)
Only the matching <b>catch</b> clause executes; control then resumes after the
last handler associated with that try block.</p>

<p class=MsoNormal>Notice that, within the <b>try</b> block, a number of
different function calls might generate the same type of exception, but you
need only one handler.</p>

<p class=MsoNormal>To illustrate <b>try</b> and <b>catch</b>, the following
variation of <b>Nonlocal.cpp</b> replaces the call to <b>setjmp(&nbsp;)</b>
with a <b>try</b> block and replaces the call to <b>longjmp(&nbsp;)</b> with a <b>throw</b>
statement:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Nonlocal2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates exceptions.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Rainbow {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Rainbow() { cout &lt;&lt; <font color=#007f00>&quot;Rainbow()&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>  ~Rainbow() { cout &lt;&lt; <font color=#007f00>&quot;~Rainbow()&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> oz() {</div>
<div class=CC1>  Rainbow rb;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 3; i++)</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;there's no place like
home&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>throw</font> 47;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;tornado, witch, munchkins...&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    oz();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(<font color=#ff7700>int</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Auntie Em! I had the strangest
dream...&quot;</font></div>
<div class=CC1>         &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When the <b>throw</b> statement in <b>oz(&nbsp;)</b>
executes, program control backtracks until it finds the <b>catch</b> clause
that takes an <b>int</b> parameter. Execution resumes with the body of that <b>catch</b>
clause. The most important difference between this program and <b>Nonlocal.cpp</b>
is that the destructor for the object <b>rb</b> is called when the <b>throw</b>
statement causes execution to leave the function <b>oz(&nbsp;)</b>.</p>

<h3><a href="#_TocRef53985621" name="_Toc53985621">Termination and resumption</a></h3>

<p class=MsoNormal>There are two basic models in exception-handling theory: termination and resumption. In <i>termination</i> (which is what C++
supports), you assume the error is so critical that there’s no way to
automatically resume execution at the point where the exception occurred. In
other words, whoever threw the exception decided there was no way to salvage
the situation, and they don’t <i>want</i> to come back.</p>

<p class=MsoNormal>The alternative error-handling model is called <i>resumption</i>,
first introduced with the PL/I language in the 1960s.<a href="#_ftn2" name="_ftnref2"><span
class=MsoFootnoteReference>[2]</span></a> Using
resumption semantics means that the exception handler is expected to do
something to rectify the situation, and then the faulting code is automatically
retried, presuming success the second time. If you want resumption in C++, you
must explicitly transfer execution back to the code where the error occurred,
usually by repeating the function call that sent you there in the first place.
It is not unusual to place your <b>try</b> block inside a <b>while</b> loop
that keeps reentering the <b>try</b> block until the result is satisfactory.</p>

<p class=MsoNormal>Historically, programmers using operating systems that
supported resumptive exception handling eventually ended up using
termination-like code and skipping resumption. Although resumption sounds
attractive at first, it seems it isn’t quite so useful in practice. One reason
may be the distance that can occur between the exception and its handler. It is
one thing to terminate to a handler that’s far away, but to jump to that
handler and then back again may be too conceptually difficult for large systems
where the exception is generated from many points.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593301" name="_Toc305593301">Exception matching</a></h2>

<p class=MsoNormal>When an exception is thrown, the exception-handling system
looks through the “nearest” handlers in the order they appear in the source
code. When it finds a match, the exception is considered handled and no further
searching occurs.</p>

<p class=MsoNormal>Matching an exception doesn’t require a perfect correlation
between the exception and its handler. An object or reference to a
derived-class object will match a handler for the base class. (However, if the
handler is for an object rather than a reference, the exception object is
“sliced”—truncated to the base type—as it is passed to the handler. This does no damage, but loses all the derived-type information.) For this reason, as
well as to avoid making yet another copy of the exception object, it is always better to catch an exception by <i>reference</i> instead of by value.<a href="#_ftn3" name="_ftnref3"><span
class=MsoFootnoteReference>[3]</span></a> If
a pointer is thrown, the usual standard pointer conversions are used to match
the exception. However, no automatic type conversions are used to convert from one exception type to another in the process of matching. For example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Autoexcp.cpp</font></div>
<div class=CC1><font color=#dd0000>// No matching conversions.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Except1 {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Except2 {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Except2(<font color=#ff7700>const</font> Except1&amp;) {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f() { <font color=#ff7700>throw</font> Except1(); }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> { f();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Except2&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;inside catch(Except2)&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Except1&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;inside catch(Except1)&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Even though you might think the first handler could be matched
by converting an <b>Except1</b> object into an <b>Except2</b> using the converting
constructor, the system will not perform such a conversion during exception
handling, and you’ll end up at the <b>Except1</b> handler.</p>

<p class=MsoNormal>The following example shows how a base-class handler can
catch a derived-class exception:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Basexcpt.cpp</font></div>
<div class=CC1><font color=#dd0000>// Exception hierarchies.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> X {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> Trouble {};</div>
<div class=CC1>  <font color=#ff7700>class</font> Small : <font color=#ff7700>public</font> Trouble {};</div>
<div class=CC1>  <font color=#ff7700>class</font> Big : <font color=#ff7700>public</font> Trouble {};</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { <font color=#ff7700>throw</font> Big(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  X x;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    x.f();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(X::Trouble&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;caught Trouble&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  <font color=#dd0000>// Hidden by previous handler:</font></div>
<div class=CC1>  } <font color=#ff7700>catch</font>(X::Small&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;caught Small Trouble&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(X::Big&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;caught Big Trouble&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here, the exception-handling mechanism will always match a <b>Trouble</b>
object, <i>or anything that is a</i> <b>Trouble</b> (through public
inheritance),<a href="#_ftn4" name="_ftnref4"><span
class=MsoFootnoteReference>[4]</span></a> to
the first handler. That means the second and third handlers are never called
because the first one captures them all. It makes more sense to catch the
derived types first and put the base type at the end to catch anything less
specific.</p>

<p class=MsoNormal>Notice that these examples catch exceptions by reference,
although for these classes it isn’t important because there are no additional
members in the derived classes, and there are no argument identifiers in the
handlers anyway. You’ll usually want to use reference arguments rather than
value arguments in your handlers to avoid slicing off information.</p>

<h3><a href="#_TocRef53985623" name="_Toc53985623">Catching any exception</a></h3>

<p class=MsoNormal> Sometimes you want to create a handler that catches <i>any</i>
type of exception. You do this using the ellipsis in the argument list:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;an exception was thrown&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because an ellipsis catches any exception, you’ll want to
put it at the <i>end</i> of your list of handlers to avoid pre-empting any that
follow it.</p>

<p class=MsoNormal>The ellipsis gives you no possibility to have an argument, so
you can’t know anything about the exception or its type. It’s a “catchall.”
Such a <b>catch</b> clause is often used to clean up some resources and then
rethrow the exception.</p>

<h3><a href="#_TocRef312374119" name="_Toc312374119">Rethrowing an exception</a></h3>

<p class=MsoNormal>You usually want to rethrow an exception when you have some
resource that needs to be released, such as a network connection or heap memory
that needs to be deallocated. (See the section “Resource Management” later in
this chapter for more detail). If an exception occurs, you don’t necessarily
care what error caused the exception—you just want to close the connection you
opened previously. After that, you’ll want to let some other context closer to
the user (that is, higher up in the call chain) handle the exception. In this
case the ellipsis specification is just what you want. You want to catch <i>any</i>
exception, clean up your resource, and then rethrow the exception for handling
elsewhere. You rethrow an exception by using <b>throw</b> with no argument
inside a handler:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>cout &lt;&lt; <font color=#007f00>&quot;an exception was
thrown&quot;</font> &lt;&lt; endl;</div>
<div class=CC1><font color=#dd0000>// Deallocate your resource here,
and then rethrow</font></div>
<div class=CC1>  <font color=#ff7700>throw</font>;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Any further <b>catch</b> clauses for the same <b>try</b>
block are still ignored—the <b>throw</b> causes the exception to go to the
exception handlers in the next-higher context. In addition, everything about
the exception object is preserved, so the handler at the higher context that
catches the specific exception type can extract any information the object may
contain.</p>

<h3><a href="#_TocRef312374120" name="_Toc312374120">Uncaught exceptions</a></h3>

<p class=MsoNormal>As we explained in the beginning of this chapter, exception
handling is considered better than the traditional return-an-error-code
technique because exceptions can’t be ignored, and because the error handling
logic is separated from the problem at hand. If none of the exception handlers following a particular <b>try</b> block matches an exception, that exception
moves to the next-higher context, that is, the function or <b>try</b> block
surrounding the <b>try</b> block that did not catch the exception. (The
location of this <b>try</b> block is not always obvious at first glance, since
it’s higher up in the call chain.) This process continues until, at some level,
a handler matches the exception. At that point, the exception is considered “caught,”
and no further searching occurs.</p>

<h4>The terminate(&nbsp;) function</h4>

<p class=MsoNormal>If no handler at any level catches the exception, the
special library function <b>terminate(&nbsp;)</b> (declared in the <b>&lt;exception&gt;</b>
header) is automatically called. By default, <b>terminate(&nbsp;)</b> calls the
Standard C library function <b>abort(&nbsp;) </b>, which abruptly exits the
program. On Unix systems, <b>abort(&nbsp;)</b> also causes a core dump. When <b>abort(&nbsp;)</b>
is called, no calls to normal program termination functions occur, which means
that destructors for global and static objects do not execute. The <b>terminate(&nbsp;)</b>
function also executes if a destructor for a local object throws an exception while
the stack is unwinding (interrupting the exception that was in progress) or if
a global or static object’s constructor or destructor throws an exception. (In
general, do not allow a destructor to throw an exception.)</p>

<h4>The set_terminate(&nbsp;) function</h4>

<p class=MsoNormal>You can install your own <b>terminate(&nbsp;)</b> function
using the standard <b>set_terminate(&nbsp;)</b> function, which returns a
pointer to the <b>terminate(&nbsp;)</b> function you are replacing (which will
be the default library version the first time you call it), so you can restore
it later if you want. Your custom <b>terminate(&nbsp;)</b> must take no
arguments and have a <b>void</b> return value. In addition, any <b>terminate(&nbsp;)</b>
handler you install must not return or throw an exception, but instead must
execute some sort of program-termination logic. If <b>terminate(&nbsp;)</b> is
called, the problem is unrecoverable.</p>

<p class=MsoNormal>The following example shows the use of <b>set_terminate(&nbsp;)</b>.
Here, the return value is saved and restored so that the <b>terminate(&nbsp;)</b>
function can be used to help isolate the section of code where the uncaught
exception occurs:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Terminator.cpp</font></div>
<div class=CC1><font color=#dd0000>// Use of set_terminate(). Also shows uncaught
exceptions.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;exception&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> terminator() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;I'll be back!&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  exit(0);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> (*old_terminate)() = set_terminate(terminator);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Botch {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> Fruit {};</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Botch::f()&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>throw</font> Fruit();</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Botch() { <font color=#ff7700>throw</font> 'c'; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Botch b;</div>
<div class=CC1>    b.f();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;inside catch(...)&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The definition of <b>old_terminate</b> looks a bit confusing
at first: it not only creates a pointer to a function, but it initializes that
pointer to the return value of <b>set_terminate(&nbsp;)</b>. Even though you
might be familiar with seeing a semicolon right after a pointer-to-function
declaration, here it’s just another kind of variable and can be initialized
when it is defined.</p>

<p class=MsoNormal>The class <b>Botch</b> not only throws an exception inside <b>f(&nbsp;)</b>,
but also in its destructor. This causes a call to <b>terminate(&nbsp;)</b>, as
you can see in <b>main(&nbsp;)</b>. Even though the exception handler says <b>catch(...)</b>,
which would seem to catch everything and leave no cause for <b>terminate(&nbsp;)</b>
to be called, <b>terminate(&nbsp;) </b>is called anyway. In the process of
cleaning up the objects on the stack to handle one exception, the <b>Botch</b>
destructor is called, and that generates a second exception, forcing a call to <b>terminate(&nbsp;)</b>.
Thus, a destructor that throws an exception or causes one to be thrown is
usually a sign of poor design or sloppy coding.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593299" name="_Toc305593299">Cleaning
up</a></h2>

<p class=MsoNormal>Part of the magic of exception handling is that you can pop from normal program flow into the appropriate exception handler. Doing so
wouldn’t be useful, however, if things weren’t cleaned up properly as the
exception was thrown. C++ exception handling guarantees that as you leave a
scope, all objects in that scope <i>whose constructors have been completed</i>
will have their destructors called.</p>

<p class=MsoNormal>Here’s an example that demonstrates that constructors that aren’t completed don’t have the associated destructors called. It also shows
what happens when an exception is thrown in the middle of the creation of an
array of objects:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Cleanup.cpp</font></div>
<div class=CC1><font color=#dd0000>// Exceptions clean up complete objects only.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Trace {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> counter;</div>
<div class=CC1>  <font color=#ff7700>int</font> objid;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Trace() {</div>
<div class=CC1>    objid = counter++;</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;constructing Trace #&quot;</font>
&lt;&lt; objid &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>if</font>(objid == 3) <font color=#ff7700>throw</font> 3;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Trace() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;destructing Trace #&quot;</font>
&lt;&lt; objid &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Trace::counter = 0;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Trace n1;</div>
<div class=CC1>    <font color=#dd0000>// Throws exception:</font></div>
<div class=CC1>    Trace array[5];</div>
<div class=CC1>    Trace n2;  <font color=#dd0000>// Won't get here.</font></div>
<div class=CC1>  } <font color=#ff7700>catch</font>(<font color=#ff7700>int</font> i) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;caught &quot;</font> &lt;&lt; i
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class <b>Trace</b> keeps track of objects so that you
can trace program progress. It keeps a count of the number of objects created
with a <b>static</b> data member <b>counter</b> and tracks the number of the
particular object with <b>objid</b>.</p>

<p class=MsoNormal>The main program creates a single object, <b>n1</b> (<b>objid</b>
0), and then attempts to create an array of five <b>Trace</b> objects, but an
exception is thrown before the fourth object (#3) is fully created. The object <b>n2</b>
is never created. You can see the results in the output of the program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>constructing Trace #0</div>
<div class=CC1>constructing Trace #1</div>
<div class=CC1>constructing Trace #2</div>
<div class=CC1>constructing Trace #3</div>
<div class=CC1>destructing Trace #2</div>
<div class=CC1>destructing Trace #1</div>
<div class=CC1>destructing Trace #0</div>
<div class=CC1>caught 3</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Three array elements are successfully created, but in the
middle of the constructor for the fourth element, an exception is thrown.
Because the fourth construction in <b>main(&nbsp;)</b> (for <b>array[2]</b>)
never completes, only the destructors for objects <b>array[1]</b> and <b>array[0]</b>
are called. Finally, object <b>n1</b> is destroyed, but not object <b>n2</b>,
because it was never created.</p>

<h3><a href="#_TocRef53985627" name="_Toc53985627">Resource management</a></h3>

<p class=MsoNormal>When writing code with exceptions, it’s particularly
important that you always ask, “If an exception occurs, will my resources be
properly cleaned up?” Most of the time you’re fairly safe, but in constructors
there’s a particular problem: if an exception is thrown before a constructor is
completed, the associated destructor will not be called for that object. Thus,
you must be especially diligent while writing your constructor.</p>

<p class=MsoNormal>The difficulty is in allocating resources in constructors.
If an exception occurs in the constructor, the destructor doesn’t get a chance
to deallocate the resource. This problem occurs most often with “naked”
pointers. For example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Rawp.cpp</font></div>
<div class=CC1><font color=#dd0000>// Naked pointers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Cat {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Cat() { cout &lt;&lt; <font color=#007f00>&quot;Cat()&quot;</font> &lt;&lt;
endl; }</div>
<div class=CC1>  ~Cat() { cout &lt;&lt; <font color=#007f00>&quot;~Cat()&quot;</font> &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Dog {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font>* <font color=#ff7700>operator</font> <font color=#ff7700>new</font>(size_t sz) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;allocating a Dog&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    <font color=#ff7700>throw</font> 47;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> <font color=#ff7700>operator</font> <font color=#ff7700>delete</font>(<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;deallocating a Dog&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    ::<font color=#ff7700>operator</font> <font color=#ff7700>delete</font>(p);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> UseResources {</div>
<div class=CC1>  Cat* bp;</div>
<div class=CC1>  Dog* op;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  UseResources(<font color=#ff7700>int</font> count = 1) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;UseResources()&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    bp = <font color=#ff7700>new</font> Cat[count];</div>
<div class=CC1>    op = <font color=#ff7700>new</font> Dog;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~UseResources() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;~UseResources()&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    <font color=#ff7700>delete</font> [] bp; <font color=#dd0000>// Array delete</font></div>
<div class=CC1>    <font color=#ff7700>delete</font> op;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    UseResources ur(3);</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(<font color=#ff7700>int</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;inside handler&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The output is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>UseResources()</div>
<div class=CC1>Cat()</div>
<div class=CC1>Cat()</div>
<div class=CC1>Cat()</div>
<div class=CC1>allocating a Dog</div>
<div class=CC1>inside handler</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>UseResources</b> constructor is entered, and the <b>Cat</b>
constructor is successfully completed for the three array objects. However,
inside <b>Dog::operator new(&nbsp;)</b>, an exception is thrown (to simulate an
out-of-memory error). Suddenly, you end up inside the handler, <i>without</i>
the <b>UseResources</b> destructor being called. This is correct because the <b>UseResources</b>
constructor was unable to finish, but it also means the <b>Cat</b> objects that
were successfully created on the heap were never destroyed.</p>

<h3><a href="#_TocRef312374123" name="_Toc312374123">Making everything an
object</a></h3>

<p class=MsoNormal>To prevent such resource leaks, you must guard against these
“raw” resource allocations in one of two ways:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You can catch exceptions inside the constructor and then release
the resource.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You can place the allocations inside an object’s constructor, and
you can place the deallocations inside an object’s destructor.</p>

<p class=MsoNormal>Using the latter approach, each allocation becomes atomic, by virtue of being part of the lifetime of a local object, and if it fails, the
other resource allocation objects are properly cleaned up during stack
unwinding. This technique is called Resource Acquisition Is Initialization (RAII for short)  because it equates resource control with object lifetime.
Using templates is an excellent way to modify the previous example to achieve
this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Wrapped.cpp</font></div>
<div class=CC1><font color=#dd0000>// Safe, atomic pointers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Simplified. Yours may have other arguments.</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>int</font> sz = 1&gt; <font color=#ff7700>class</font> PWrap {</div>
<div class=CC1>  T* ptr;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> RangeError {}; <font color=#dd0000>// Exception class</font></div>
<div class=CC1>  PWrap() {</div>
<div class=CC1>    ptr = <font color=#ff7700>new</font> T[sz];</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;PWrap constructor&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~PWrap() {</div>
<div class=CC1>    <font color=#ff7700>delete</font>[] ptr;</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;PWrap destructor&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  T&amp; <font color=#ff7700>operator</font>[](<font color=#ff7700>int</font> i) <font color=#ff7700>throw</font>(RangeError) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(i &gt;= 0 &amp;&amp; i &lt; sz) <font color=#ff7700>return</font> ptr[i];</div>
<div class=CC1>    <font color=#ff7700>throw</font> RangeError();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Cat {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Cat() { cout &lt;&lt; <font color=#007f00>&quot;Cat()&quot;</font> &lt;&lt;
endl; }</div>
<div class=CC1>  ~Cat() { cout &lt;&lt; <font color=#007f00>&quot;~Cat()&quot;</font> &lt;&lt;
endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> g() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Dog {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font>* <font color=#ff7700>operator</font> <font color=#ff7700>new</font>[](size_t) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Allocating a Dog&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    <font color=#ff7700>throw</font> 47;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> <font color=#ff7700>operator</font> <font color=#ff7700>delete</font>[](<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Deallocating a Dog&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    ::<font color=#ff7700>operator</font> <font color=#ff7700>delete</font>[](p);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> UseResources {</div>
<div class=CC1>  PWrap&lt;Cat, 3&gt; cats;</div>
<div class=CC1>  PWrap&lt;Dog&gt; dog;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  UseResources() { cout &lt;&lt;
<font color=#007f00>&quot;UseResources()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  ~UseResources() { cout &lt;&lt;
<font color=#007f00>&quot;~UseResources()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cats[1].g(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    UseResources ur;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(<font color=#ff7700>int</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;inside handler&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;inside catch(...)&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The difference is the use of the template to wrap the
pointers and make them into objects. The constructors for these objects are
called <i>before</i> the body of the <b>UseResources</b> constructor, and any
of these constructors that complete before an exception is thrown will have
their associated destructors called during stack unwinding.</p>

<p class=MsoNormal>The <b>PWrap</b> template shows a more typical use of
exceptions than you’ve seen so far: A nested class called <b>RangeError</b> is
created to use in <b>operator[&nbsp;]</b> if its argument is out of range.
Because <b>operator[&nbsp;]</b> returns a reference, it cannot return zero. (There are no null references.) This is a true exceptional condition—you don’t know
what to do in the current context and you can’t return an improbable value. In
this example, <b>RangeError</b><a href="#_ftn5" name="_ftnref5"><span
class=MsoFootnoteReference>[5]</span></a> is
simple and assumes all the necessary information is in the class name, but you
might also want to add a member that contains the value of the index, if that
is useful.</p>

<p class=MsoNormal>Now the output is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Cat()</div>
<div class=CC1>Cat()</div>
<div class=CC1>Cat()</div>
<div class=CC1>PWrap constructor</div>
<div class=CC1>allocating a Dog</div>
<div class=CC1>~Cat()</div>
<div class=CC1>~Cat()</div>
<div class=CC1>~Cat()</div>
<div class=CC1>PWrap destructor</div>
<div class=CC1>inside handler</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Again, the storage allocation for <b>Dog</b> throws an
exception, but this time the array of <b>Cat</b> objects is properly cleaned
up, so there is no memory leak.</p>

<h3><a href="#_TocRef53985629" name="_Toc53985629">auto_ptr</a></h3>

<p class=MsoNormal>Since dynamic memory is the most frequent resource used in a
typical C++ program, the standard provides an RAII wrapper for pointers to heap
memory that automatically frees the memory. The <b>auto_ptr</b> class template, defined in the <b>&lt;memory&gt;</b> header, has a constructor that takes a
pointer to its generic type (whatever you use in your code). The <b>auto_ptr</b>
class template also overloads the pointer operators <b>*</b> and <b>-&gt;</b>
to forward these operations to the original pointer the <b>auto_ptr</b> object
is holding. So you can use the <b>auto_ptr</b> object as if it were a raw pointer.
Here’s how it works:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Auto_ptr.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates the RAII nature of auto_ptr.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;memory&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TraceHeap {</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font>* <font color=#ff7700>operator</font> <font color=#ff7700>new</font>(size_t siz) {</div>
<div class=CC1>    <font color=#ff7700>void</font>* p = ::<font color=#ff7700>operator</font> <font color=#ff7700>new</font>(siz);</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Allocating TraceHeap object on
the heap &quot;</font></div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;at address &quot;</font> &lt;&lt; p
&lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> p;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> <font color=#ff7700>operator</font> <font color=#ff7700>delete</font>(<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Deleting TraceHeap object at
address &quot;</font></div>
<div class=CC1>         &lt;&lt; p &lt;&lt; endl;</div>
<div class=CC1>    ::<font color=#ff7700>operator</font> <font color=#ff7700>delete</font>(p);</div>
<div class=CC1>  }</div>
<div class=CC1>  TraceHeap(<font color=#ff7700>int</font> i) : i(i) {}</div>
<div class=CC1>  <font color=#ff7700>int</font> getVal() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> i; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  auto_ptr&lt;TraceHeap&gt; pMyObject(<font color=#ff7700>new</font>
TraceHeap(5));</div>
<div class=CC1>  cout &lt;&lt; pMyObject-&gt;getVal() &lt;&lt; endl; 
<font color=#dd0000>// Prints 5</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>TraceHeap</b> class overloads the <b>operator new</b>
and <b>operator delete</b> so you can see exactly what’s happening. Notice
that, like any other class template, you specify the type you’re going to use
in a template parameter. You don’t say <b>TraceHeap*</b>, however—<b>auto_ptr</b>
already knows that it will be storing a pointer to your type. The second line
of <b>main(&nbsp;)</b> verifies that <b>auto_ptr</b>’s <b>operator-&gt;(&nbsp;)</b>
function applies the indirection to the original, underlying pointer. Most
important, even though we didn’t explicitly delete the original pointer, <b>pMyObject</b>’s
destructor deletes the original pointer during stack unwinding, as the
following output verifies:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Allocating TraceHeap object on the heap at address
8930040</div>
<div class=CC1>5</div>
<div class=CC1>Deleting TraceHeap object at
address 8930040</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>The auto_ptr</b> class template is also handy for pointer
data members. Since class objects contained by value are always destructed, <b>auto_ptr</b>
members always delete the raw pointer they wrap when the containing object is
destructed.<a href="#_ftn6" name="_ftnref6"><span
class=MsoFootnoteReference>[6]</span></a></p>

<h3><a href="#_TocRef53985630" name="_Toc53985630">Function–level try blocks</a></h3>

<p class=MsoNormal>Since constructors can routinely throw exceptions, you might
want to handle exceptions that occur when an object’s member or base subobjects
are initialized. To do this, you can place the initialization of such
subobjects in a <i>function-level try block</i>. In a departure from the usual
syntax, the <b>try</b> block for constructor initializers is the constructor
body, and the associated <b>catch</b> block follows the body of the
constructor, as in the following example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:InitExcept.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Handles exceptions from subobjects.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Base {</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> BaseExcept {};</div>
<div class=CC1>  Base(<font color=#ff7700>int</font> i) : i(i) { <font color=#ff7700>throw</font> BaseExcept(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Derived : <font color=#ff7700>public</font> Base {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> DerivedExcept {</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    DerivedExcept(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg) : msg(msg) {}</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>char</font>* what() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> msg; }</div>
<div class=CC1>  };</div>
<div class=CC1>  Derived(<font color=#ff7700>int</font> j) <font color=#ff7700>try</font> : Base(j) {</div>
<div class=CC1>    <font color=#dd0000>// Constructor body</font></div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;This won't print&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(BaseExcept&amp;) {</div>
<div class=CC1>    <font color=#ff7700>throw</font> DerivedExcept(<font color=#007f00>&quot;Base subobject
threw&quot;</font>);;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Derived d(3);</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Derived::DerivedExcept&amp; d) {</div>
<div class=CC1>    cout &lt;&lt; d.what() &lt;&lt; endl;  <font color=#dd0000>//
&quot;Base subobject threw&quot;</font></div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that the initializer list in the constructor for <b>Derived</b>
goes after the <b>try</b> keyword but before the constructor body. If an
exception does occur, the contained object is not constructed, so it makes no
sense to return to the code that created it. For this reason, the only sensible
thing to do is to throw an exception in the function-level <b>catch</b> clause.</p>

<p class=MsoNormal>Although it is not terribly useful, C++ also allows
function-level <b>try</b> blocks for <i>any</i> function, as the following
example illustrates:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:FunctionTryBlock.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Function-level try blocks.</font></div>
<div class=CC1><font color=#dd0000>// {RunByHand} (Don’t run automatically by the
makefile)</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() <font color=#ff7700>try</font> {</div>
<div class=CC1>  <font color=#ff7700>throw</font> <font color=#007f00>&quot;main&quot;</font>;</div>
<div class=CC1>} <font color=#ff7700>catch</font>(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg) {</div>
<div class=CC1>cout &lt;&lt; msg &lt;&lt; endl;</div>
<div class=CC1><font color=#ff7700>return</font> 1;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this case, the <b>catch</b> block can return in the same
manner that the function body normally returns. Using this type of
function-level <b>try</b> block isn’t much different from inserting a <b>try-catch</b>
around the code inside of the function body.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985631" name="_Toc53985631">Standard
exceptions</a></h2>

<p class=MsoNormal>The exceptions used with the Standard C++ library are also available for your use. Generally it’s easier and faster to start with a
standard exception class than to try to define your own. If the standard class
doesn’t do exactly what you need, you can derive from it.</p>

<p class=MsoNormal>All standard exception classes derive ultimately from the class <b>exception</b>, defined in the header <b>&lt;exception&gt;</b>. The two main
derived classes are <b>logic_error</b> and <b>runtime_error</b>, which are found in <b>&lt;stdexcept&gt;</b> (which itself includes <b>&lt;exception&gt;</b>). The class <b>logic_error</b> represents errors in programming logic, such as passing an
invalid argument. Runtime errors are those that occur as the result of
unforeseen forces such as hardware failure or memory exhaustion. Both <b>runtime_error</b>
and <b>logic_error</b> provide a constructor that takes a <b>std::string</b>
argument so that you can store a message in the exception object and extract it
later with <b>exception::what(&nbsp;)</b> , as the following program illustrates:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:StdExcept.cpp</font></div>
<div class=CC1><font color=#dd0000>// Derives an exception class from std::runtime_error.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MyError : <font color=#ff7700>public</font> runtime_error {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MyError(<font color=#ff7700>const</font> string&amp; msg = <font color=#007f00>&quot;&quot;</font>) :
runtime_error(msg) {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    <font color=#ff7700>throw</font> MyError(<font color=#007f00>&quot;my message&quot;</font>);</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(MyError&amp; x) {</div>
<div class=CC1>    cout &lt;&lt; x.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Although the <b>runtime_error</b> constructor inserts the
message into its <b>std::exception</b> subobject, <b>std::exception</b> does
not provide a constructor that takes a <b>std::string</b> argument. You’ll usually
want to derive your exception classes from either <b>runtime_error</b> or <b>logic_error</b>
(or one of their derivatives), and not from <b>std::exception</b>.</p>

<p class=MsoNormal>The following tables describe the standard exception
classes:</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.5in;border-collapse:collapse;border-collapse:collapse !msorm'>
 <tr>
  <td width=140 valign=top style='width:104.75pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.75pt 0in 5.75pt;border-top:solid windowtext 1.0pt !msorm;
  border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  border-right:none !msorm;padding:0in 5.75pt 0in 5.75pt !msorm'>
  <p class=tabletext><b>exception</b></p>
  </td>
  <td width=288 valign=top style='width:215.65pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.75pt 0in 5.75pt;border-top:solid windowtext 1.0pt !msorm;
  border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  border-right:none !msorm;padding:0in 5.75pt 0in 5.75pt !msorm'>
  <p class=tabletext>The base class for all the exceptions thrown by the C++
  Standard library. You can ask <b>what(&nbsp;)</b> and retrieve the optional
  string with which the exception was initialized.</p>
  </td>
 </tr>
 <tr>
  <td width=140 valign=top style='width:104.75pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.75pt 0in 5.75pt !msorm'>
  <p class=tabletext><b>logic_error</b></p>
  </td>
  <td width=288 valign=top style='width:215.65pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.75pt 0in 5.75pt !msorm'>
  <p class=tabletext>Derived from <b>exception</b>. Reports program logic
  errors, which could presumably be detected by inspection.</p>
  </td>
 </tr>
 <tr>
  <td width=140 valign=top style='width:104.75pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.75pt 0in 5.75pt !msorm'>
  <p class=tabletext><b>runtime_error</b></p>
  </td>
  <td width=288 valign=top style='width:215.65pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.75pt 0in 5.75pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.75pt 0in 5.75pt !msorm'>
  <p class=tabletext>Derived from <b>exception</b>.<b> </b>Reports runtime
  errors, which can presumably be detected only when the program executes.</p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The iostream exception class <b>ios::failure</b> is also
derived from <b>exception</b>, but it has no further subclasses.</p>

<p class=MsoNormal>You can use the classes in both of the following tables as
they are, or you can use them as base classes from which to derive your own
more specific types of exceptions.</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.5in;border-collapse:collapse;border-collapse:collapse !msorm'>
 <thead>
  <tr>
   <td width=427 colspan=2 valign=top style='width:4.45in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Exception classes derived from logic_error</p>
   </td>
  </tr>
 </thead>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>domain_error</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Reports violations of a precondition.</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>invalid_argument</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Indicates an invalid argument to the function from which
  it is thrown.</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext style='page-break-after:avoid'><b>length_error</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext style='page-break-after:avoid'>Indicates an attempt to
  produce an object whose length is greater than or equal to <b>npos</b> (the
  largest representable value of context’s size type, usually <b>std::size_t</b>).</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>out_of_range</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Reports an out-of-range argument.</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>bad_cast</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Thrown for executing an invalid <b>dynamic_cast</b>
  expression in runtime type identification (see Chapter 8).</p>
  </td>
 </tr>
 <tr>
  <td width=193 valign=top style='width:144.9pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext style='page-break-after:avoid'><b>bad_typeid</b></p>
  </td>
  <td width=234 valign=top style='width:175.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext style='page-break-after:avoid'>Reports a null pointer <b>p</b>
  in an expression <b>typeid(*p)</b>. (Again, a runtime type identification
  feature in Chapter 8).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal></p>

<p class=MsoNormal>&nbsp;</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.5in;border-collapse:collapse;border-collapse:collapse !msorm'>
 <thead>
  <tr>
   <td width=427 colspan=2 valign=top style='width:4.45in;border:none;
   border-bottom:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:
   none !msorm;border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Exception classes derived from runtime_error</p>
   </td>
  </tr>
 </thead>
 <tr>
  <td width=175 valign=top style='width:131.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>range_error</b></p>
  </td>
  <td width=252 valign=top style='width:189.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Reports violation of a postcondition.</p>
  </td>
 </tr>
 <tr>
  <td width=175 valign=top style='width:131.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>overflow_error</b></p>
  </td>
  <td width=252 valign=top style='width:189.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Reports an arithmetic overflow.</p>
  </td>
 </tr>
 <tr>
  <td width=175 valign=top style='width:131.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>bad_alloc</b></p>
  </td>
  <td width=252 valign=top style='width:189.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Reports a failure to allocate storage.</p>
  </td>
 </tr>
</table>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312374116" name="_Toc312374116">Exception specification</a>s</h2>

<p class=MsoNormal>You’re not required to inform the people using your function
what exceptions you might throw. However, failure to do so can be considered
uncivilized because it means that users cannot be sure what code to write to
catch all potential exceptions. If they have your source code, they can hunt
through and look for <b>throw</b> statements, but often a library doesn’t come
with sources. Good documentation can help alleviate this problem, but how many
software projects are well documented? C++ provides syntax to tell the user the
exceptions that are thrown by this function, so the user can handle them. This
is the optional <i>exception specification</i>, which adorns a function’s
declaration, appearing after the argument list.</p>

<p class=MsoNormal>The exception specification reuses the keyword <b>throw</b>,
followed by a parenthesized list of all the types of potential exceptions that
the function can throw. Your function declaration might look like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>(toobig, toosmall, divzero);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As far as exceptions are concerned, the traditional function
declaration</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>means that <i>any</i> type of exception can be thrown from
the function. If you say</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><i>no exceptions whatsoever</i> will be thrown from the
function (so you’d better be sure that no functions farther down in the call
chain let any exceptions propagate up!).</p>

<p class=MsoNormal>For good coding policy, good documentation, and ease-of-use
for the function caller, consider using exception specifications when you write
functions that throw exceptions. (Variations on this guideline are discussed
later in this chapter.)</p>

<h4>The unexpected(&nbsp;) function</h4>

<p class=MsoNormal>If your exception specification claims you’re going to throw a certain set of exceptions and then you throw something that isn’t in that set,
what’s the penalty? The special function <b>unexpected(&nbsp;)</b> is called
when you throw something other than what appears in the exception
specification. Should this unfortunate situation occur, the default <b>unexpected(&nbsp;)
</b>calls the <b>terminate(&nbsp;)</b> function described earlier in this
chapter.</p>

<h4>The set_unexpected(&nbsp;) function</h4>

<p class=MsoNormal>Like <b>terminate(&nbsp;)</b>, the <b>unexpected(&nbsp;)</b> mechanism installs your own function to respond to unexpected exceptions. You do so
with a function called <b>set_unexpected(&nbsp;)</b>, which, like <b>set_terminate(&nbsp;)</b>,
takes the address of a function with no arguments and <b>void</b> return value.
Also, because it returns the previous value of the <b>unexpected(&nbsp;)</b>
pointer, you can save it and restore it later. To use <b>set_unexpected(&nbsp;)</b>,
include the header file <b>&lt;exception&gt;</b>. Here’s an example that shows a
simple use of the features discussed so far in this section:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Unexpected.cpp</font></div>
<div class=CC1><font color=#dd0000>// Exception specifications &amp; unexpected(),</font></div>
<div class=CC1><font color=#dd0000>//{-msc} (Doesn’t terminate properly)</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;exception&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Up {};</div>
<div class=CC1><font color=#ff7700>class</font> Fit {};</div>
<div class=CC1><font color=#ff7700>void</font> g();</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f(<font color=#ff7700>int</font> i) <font color=#ff7700>throw</font>(Up, Fit) {</div>
<div class=CC1>  <font color=#ff7700>switch</font>(i) {</div>
<div class=CC1>    <font color=#ff7700>case</font> 1: <font color=#ff7700>throw</font> Up();</div>
<div class=CC1>    <font color=#ff7700>case</font> 2: <font color=#ff7700>throw</font> Fit();</div>
<div class=CC1>  }</div>
<div class=CC1>  g();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// void g() {}         // Version 1</font></div>
<div class=CC1><font color=#ff7700>void</font> g() { <font color=#ff7700>throw</font> 47; } <font color=#dd0000>// Version 2</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> my_unexpected() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;unexpected exception thrown&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  exit(0);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  set_unexpected(my_unexpected); <font color=#dd0000>// (Ignores return
value)</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 1; i &lt;=3; i++)</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      f(i);</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Up) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Up caught&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Fit) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Fit caught&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The classes <b>Up</b> and <b>Fit</b> are created solely to
throw as exceptions. Often exception classes will be small, but they can
certainly hold additional information so that the handlers can query for it.</p>

<p class=MsoNormal>The<b> f(&nbsp;)</b> function promises in its exception specification
to throw only exceptions of type <b>Up</b> and <b>Fit</b>, and from looking at
the function definition, this seems plausible. Version one of <b>g(&nbsp;)</b>,
called by <b>f(&nbsp;)</b>, doesn’t throw any exceptions, so this is true. But
if someone changes <b>g(&nbsp;)</b> so that it throws a different type of
exception (like the second version in this example, which throws an <b>int</b>),
the exception specification for <b>f(&nbsp;)</b> is violated.</p>

<p class=MsoNormal>The <b>my_unexpected(&nbsp;)</b> function has no arguments
or return value, following the proper form for a custom <b>unexpected(&nbsp;)</b>
function. It simply displays a message so that you can see that it was called,
and then exits the program (<b>exit(0)</b> is used here so that the book’s <b>make</b>
process is not aborted). Your new <b>unexpected(&nbsp;)</b> function should not
have a <b>return</b> statement.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, the <b>try</b> block is within a <b>for</b>
loop, so all the possibilities are exercised. In this way, you can achieve
something like resumption. Nest the <b>try</b> block inside a <b>for</b>, <b>while</b>,
<b>do</b>, or <b>if</b> and cause any exceptions to attempt to repair the
problem; then attempt the <b>try</b> block again.</p>

<p class=MsoNormal>Only the <b>Up</b> and <b>Fit</b> exceptions are caught
because those are the only exceptions that the programmer of <b>f(&nbsp;)</b>
said would be thrown. Version two of <b>g(&nbsp;)</b> causes <b>my_unexpected(&nbsp;)</b>
to be called because <b>f(&nbsp;)</b> then throws an <b>int</b>.</p>

<p class=MsoNormal>In the call to <b>set_unexpected(&nbsp;)</b>, the return
value is ignored, but it can also be saved in a pointer to function and be
restored later, as we did in the <b>set_terminate(&nbsp;)</b> example earlier
in this chapter.</p>

<p class=MsoNormal>A typical <b>unexpected</b> handler logs the error and
terminates the program by calling <b>exit(&nbsp;)</b>. It can, however, throw
another exception (or rethrow the same exception) or call <b>abort(&nbsp;)</b>.
If it throws an exception of a type allowed by the function whose specification
was originally violated, the search resumes at the <i>call</i> of the function
with this exception specification. (This behavior is unique to <b>unexpected(&nbsp;)</b>.)</p>

<p class=MsoNormal>If the exception thrown from your <b>unexpected</b> handler
is not allowed by the original function’s specification, one of the following
occurs:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;If
<b>std::bad_exception</b> (defined in <b>&lt;exception&gt;</b>) was in the function’s exception specification, the exception thrown from the unexpected
handler is replaced with a <b>std::bad_exception</b> object, and the search resumes
from the function as before.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;If
the original function’s specification did not include <b>std::bad_exception</b>,
<b>terminate(&nbsp;)</b> is called.</p>

<p class=MsoNormal>The following program illustrates this behavior:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:BadException.cpp {-bor}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;exception&gt;    </font><font color=#dd0000>// For std::bad_exception</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Exception classes:</font></div>
<div class=CC1><font color=#ff7700>class</font> A {};</div>
<div class=CC1><font color=#ff7700>class</font> B {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// terminate() handler</font></div>
<div class=CC1><font color=#ff7700>void</font> my_thandler() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;terminate called&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  exit(0);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// unexpected() handlers</font></div>
<div class=CC1><font color=#ff7700>void</font> my_uhandler1() { <font color=#ff7700>throw</font> A(); }</div>
<div class=CC1><font color=#ff7700>void</font> my_uhandler2() { <font color=#ff7700>throw</font>; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// If we embed this throw statement in f or g,</font></div>
<div class=CC1><font color=#dd0000>// the compiler detects the violation and reports</font></div>
<div class=CC1><font color=#dd0000>// an error, so we put it in its own function.</font></div>
<div class=CC1><font color=#ff7700>void</font> t() { <font color=#ff7700>throw</font> B(); }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>(A) { t(); }</div>
<div class=CC1><font color=#ff7700>void</font> g() <font color=#ff7700>throw</font>(A, bad_exception) { t(); }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  set_terminate(my_thandler);</div>
<div class=CC1>  set_unexpected(my_uhandler1);</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    f();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(A&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;caught an A from f&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  set_unexpected(my_uhandler2);</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    g();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(bad_exception&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;caught a bad_exception from
g&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    f();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;This will never print&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1><a href="#_TocRef312374117" name="_Toc312374117">&nbsp;</a></div>

<p class=MsoNormal>The<b> my_uhandler1(&nbsp;)</b> handler throws an acceptable
exception (<b>A</b>), so execution resumes at the first catch, which succeeds.
The <b>my_uhandler2(&nbsp;)</b> handler does not throw a valid exception (<b>B</b>),
but since <b>g</b> specifies <b>bad_exception</b>, the <b>B</b> exception is
replaced by a <b>bad_exception</b> object, and the second catch also succeeds.
Since <b>f</b> does not include <b>bad_exception</b> in its specification, <b>my_thandler(&nbsp;)</b>
is called as a terminate handler. Here’s the output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>caught an A from f</div>
<div class=CC1>caught a bad_exception from g</div>
<div class=CC1>terminate called</div>

</div>

<p class=MsoNormal>&nbsp;</p>

<h3><a href="#_TocRef53985633" name="_Toc53985633">Better exception specifications?</a></h3>

<p class=MsoNormal>You may feel that the existing exception specification rules
aren’t very safe, and that</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><i>should</i> mean that no exceptions are thrown from this
function. If the programmer wants to throw any type of exception, you might
think he or she <i>should </i>have to say</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>(...); <font color=#dd0000>// Not in C++</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This would surely be an improvement because function
declarations would be more explicit. Unfortunately, you can’t always know by
looking at the code in a function whether an exception will be thrown—it could
happen because of a memory allocation, for example. Worse, existing functions
written before exception handling was introduced into the language may find
themselves inadvertently throwing exceptions because of the functions they call
(which might be linked into new, exception-throwing versions). Hence, the
uninformative situation whereby</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>means, “Maybe I’ll throw an exception, maybe I won’t.” This
ambiguity is necessary to avoid hindering code evolution. If you want to
specify that <b>f</b> throws no exceptions, use the empty list, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>();</div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef53985634" name="_Toc53985634">Exception specifications and
inheritance</a></h3>

<p class=MsoNormal>Each public function in a class essentially forms a contract with the user; if you pass it certain arguments, it will perform
certain operations and/or return a result. The same contract must hold true in
derived classes; otherwise the expected “is-a” relationship between derived and
base classes is violated. Since exception specifications are logically part of
a function’s declaration, they too must remain consistent across an inheritance
hierarchy. For example, if a member function in a base class says it will only
throw an exception of type <b>A</b>, an override of that function in a derived
class must not add any other exception types to the specification list because
that would break any programs that adhere to the base class interface. You can,
however, specify <i>fewer</i> exceptions or <i>none at all</i>, since that
doesn’t require the user to do anything differently. You can also specify
anything that “is-a” <b>A</b> in place of <b>A</b> in the derived function’s
specification. Here’s an example.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:Covariance.cpp {-xo}</font></div>
<div class=CC1><font color=#dd0000>// Should cause compile error. {-mwcc}{-msc}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Base {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> BaseException {};</div>
<div class=CC1>  <font color=#ff7700>class</font> DerivedException : <font color=#ff7700>public</font> BaseException {};</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>(DerivedException) {</div>
<div class=CC1>    <font color=#ff7700>throw</font> DerivedException();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> g() <font color=#ff7700>throw</font>(BaseException) {</div>
<div class=CC1>    <font color=#ff7700>throw</font> BaseException();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Derived : <font color=#ff7700>public</font> Base {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() <font color=#ff7700>throw</font>(BaseException) {</div>
<div class=CC1>    <font color=#ff7700>throw</font> BaseException();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> g() <font color=#ff7700>throw</font>(DerivedException) {</div>
<div class=CC1>    <font color=#ff7700>throw</font> DerivedException();</div>
<div class=CC1>  }</div>
<div class=CC1>}; <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A compiler should flag the override of <b>Derived::f(&nbsp;)</b>
with an error (or at least a warning) since it changes its exception
specification in a way that violates the specification of <b>Base::f(&nbsp;)</b>.
The specification for <b>Derived::g(&nbsp;)</b> is acceptable because <b>DerivedException</b>
“is-a” <b>BaseException</b> (not the other way around). You can think of <b>Base/Derived</b>
and <b>BaseException/DerivedException</b> as parallel class hierarchies; when
you are in <b>Derived</b>, you can replace references to <b>BaseException</b>
in exception specifications and return values with <b>DerivedException</b>.
This behavior is called <i>covariance</i>  (since both sets of classes vary down their respective hierarchies together). (Reminder from Volume 1: parameter types are <i>not</i>
covariant—you are not allowed to change the signature of an overridden virtual
function.)</p>

<h3><a href="#_TocRef53985635" name="_Toc53985635">When not to use exception specifications</a></h3>

<p class=MsoNormal>If you peruse the function declarations throughout the Standard C++ library, you’ll find that not a single exception specification occurs
anywhere! Although this might seem strange, there is a good reason for this
seeming incongruity: the library consists mainly of templates, and you never
know what a generic type or function might do. For example, suppose you are
developing a generic stack template and attempt to affix an exception
specification to your pop function, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>T pop() <font color=#ff7700>throw</font>(logic_error);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since the only error you anticipate is a stack underflow,
you might think it’s safe to specify a <b>logic_error</b> or some other
appropriate exception type. But type <b>T</b>’s copy constructor could throw an
exception. Then <b>unexpected(&nbsp;)</b> would be called, and your program
would terminate. You can’t make unsupportable guarantees. If you don’t know
what exceptions might occur, don’t use exception specifications. That’s why
template classes, which constitute the majority of the Standard C++ library, do
not use exception specifications—they specify the exceptions they know about in
<i>documentation</i> and leave the rest to you. Exception specifications are
mainly for non-template classes.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985636" name="_Toc53985636">Exception
safety</a></h2>

<p class=MsoNormal>In Chapter 7 we’ll take an in-depth look at the containers
in the Standard C++ library, including the <b>stack</b> container. One thing
you’ll notice is that the declaration of the <b>pop(&nbsp;)</b> member function
looks like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> pop();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You might think it strange that <b>pop(&nbsp;)</b> doesn’t
return a value. Instead, it just removes the element at the top of the stack.
To retrieve the top value, call <b>top(&nbsp;)</b> before you call <b>pop(&nbsp;)</b>.
There is an important reason for this behavior, and it has to do with <i>exception
safety</i>, a crucial consideration in library design. There are different
levels of exception safety, but most importantly, and just as the name implies,
exception safety is about correct semantics in the face of exceptions.</p>

<p class=MsoNormal>Suppose you are implementing a stack with a dynamic array
(we’ll call it <b>data</b> and the counter integer <b>count</b>), and you try
to write <b>pop(&nbsp;)</b> so that it returns a value. The code for such a <b>pop(&nbsp;)</b>
might look something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; T stack&lt;T&gt;::pop() {</div>
<div class=CC1>  <font color=#ff7700>if</font>(count == 0)</div>
<div class=CC1>    <font color=#ff7700>throw</font> logic_error(<font color=#007f00>&quot;stack underflow&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    <font color=#ff7700>return</font> data[--count];</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>What happens if the copy constructor that is called for the
return value in the last line throws an exception when the value is returned?
The popped element is not returned because of the exception, and yet <b>count</b>
has already been decremented, so the top element you wanted is lost forever!
The problem is that this function attempts to do two things at once: (1) return
a value, and (2) change the state of the stack. It is better to separate these
two actions into two separate member functions, which is exactly what the
standard <b>stack</b> class does. (In other words, follow the design practice
of <i>cohesion</i>—every function should do <i>one thing well</i>.) Exception-safe
code leaves objects in a consistent state and does not leak resources.</p>

<p class=MsoNormal>You also need to be careful writing custom assignment
operators. In Chapter 12 of Volume 1, you saw that <b>operator=</b> should
adhere to the following pattern:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;Make
sure you’re not assigning to self. If you are, go to step 6. (This is strictly
an optimization.)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;Allocate
new memory required by pointer data members.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.&nbsp;&nbsp;Copy
data from the old memory to the new.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>4.&nbsp;&nbsp;Delete
the old memory.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>5.&nbsp;&nbsp;Update
the object’s state by assigning the new heap pointers to the pointer data
members.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>6.&nbsp;&nbsp;Return
<b>*this</b>.</p>

<p class=MsoNormal>It’s important to not change the state of your object until
all the new pieces have been safely allocated and initialized. A good technique
is to move steps 2 and 3 into a separate function, often called <b>clone(&nbsp;)</b>.
The following example does this for a class that has two pointer members, <b>theString</b>
and <b>theInts</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:SafeAssign.cpp</font></div>
<div class=CC1><font color=#dd0000>// An Exception-safe operator=.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;new&gt;       </font><font color=#dd0000>// For std::bad_alloc</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A class that has two pointer members using the heap</font></div>
<div class=CC1><font color=#ff7700>class</font> HasPointers {</div>
<div class=CC1>  <font color=#dd0000>// A Handle class to hold the data</font></div>
<div class=CC1>  <font color=#ff7700>struct</font> MyData {</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>char</font>* theString;</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>int</font>* theInts;</div>
<div class=CC1>    size_t numInts;</div>
<div class=CC1>    MyData(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* pString, <font color=#ff7700>const</font> <font color=#ff7700>int</font>* pInts,</div>
<div class=CC1>      size_t nInts)</div>
<div class=CC1>    : theString(pString), theInts(pInts),
numInts(nInts) {}</div>
<div class=CC1>  } *theData;  <font color=#dd0000>// The handle</font></div>
<div class=CC1>  <font color=#dd0000>// Clone and cleanup functions:</font></div>
<div class=CC1>  <font color=#ff7700>static</font> MyData* clone(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* otherString,</div>
<div class=CC1>      <font color=#ff7700>const</font> <font color=#ff7700>int</font>* otherInts, size_t nInts) {</div>
<div class=CC1>    <font color=#ff7700>char</font>* newChars = <font color=#ff7700>new</font> <font color=#ff7700>char</font>[strlen(otherString)+1];</div>
<div class=CC1>    <font color=#ff7700>int</font>* newInts;</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      newInts = <font color=#ff7700>new</font> <font color=#ff7700>int</font>[nInts];</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(bad_alloc&amp;) {</div>
<div class=CC1>      <font color=#ff7700>delete</font> [] newChars;</div>
<div class=CC1>      <font color=#ff7700>throw</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#dd0000>// This example uses built-in types, so it won't</font></div>
<div class=CC1>      <font color=#dd0000>// throw, but for class types it could throw, so
we</font></div>
<div class=CC1>      <font color=#dd0000>// use a try block for illustration. (This is the</font></div>
<div class=CC1>      <font color=#dd0000>// point of the example!)</font></div>
<div class=CC1>      strcpy(newChars, otherString);</div>
<div class=CC1>      <font color=#ff7700>for</font>(size_t i = 0; i &lt; nInts; ++i)</div>
<div class=CC1>        newInts[i] = otherInts[i];</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>      <font color=#ff7700>delete</font> [] newInts;</div>
<div class=CC1>      <font color=#ff7700>delete</font> [] newChars;</div>
<div class=CC1>      <font color=#ff7700>throw</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>return</font> <font color=#ff7700>new</font> MyData(newChars, newInts, nInts);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> MyData* clone(<font color=#ff7700>const</font> MyData* otherData) {</div>
<div class=CC1>    <font color=#ff7700>return</font> clone(otherData-&gt;theString, otherData-&gt;theInts,</div>
<div class=CC1>                 otherData-&gt;numInts);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> cleanup(<font color=#ff7700>const</font> MyData* theData) {</div>
<div class=CC1>    <font color=#ff7700>delete</font> [] theData-&gt;theString;</div>
<div class=CC1>    <font color=#ff7700>delete</font> [] theData-&gt;theInts;</div>
<div class=CC1>    <font color=#ff7700>delete</font> theData;</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  HasPointers(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* someString, <font color=#ff7700>const</font> <font color=#ff7700>int</font>*
someInts,</div>
<div class=CC1>              size_t numInts) {</div>
<div class=CC1>    theData = clone(someString, someInts, numInts);</div>
<div class=CC1>  }</div>
<div class=CC1>  HasPointers(<font color=#ff7700>const</font> HasPointers&amp; source) {</div>
<div class=CC1>    theData = clone(source.theData);</div>
<div class=CC1>  }</div>
<div class=CC1>  HasPointers&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> HasPointers&amp;
rhs) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(<font color=#ff7700>this</font> != &amp;rhs) {</div>
<div class=CC1>      MyData* newData = clone(rhs.theData-&gt;theString,</div>
<div class=CC1>        rhs.theData-&gt;theInts,
rhs.theData-&gt;numInts);</div>
<div class=CC1>      cleanup(theData);</div>
<div class=CC1>      theData = newData;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~HasPointers() { cleanup(theData); }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> HasPointers&amp;
obj) {</div>
<div class=CC1>    os &lt;&lt; obj.theData-&gt;theString &lt;&lt;
<font color=#007f00>&quot;: &quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; obj.theData-&gt;numInts;
++i)</div>
<div class=CC1>      os &lt;&lt; obj.theData-&gt;theInts[i] &lt;&lt; '
';</div>
<div class=CC1>    <font color=#ff7700>return</font> os;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> someNums[] = { 1, 2, 3, 4 };</div>
<div class=CC1>  size_t someCount = <font color=#ff7700>sizeof</font> someNums / <font color=#ff7700>sizeof</font>
someNums[0];</div>
<div class=CC1>  <font color=#ff7700>int</font> someMoreNums[] = { 5, 6, 7 };</div>
<div class=CC1>  size_t someMoreCount =</div>
<div class=CC1>  <font color=#ff7700>sizeof</font> someMoreNums / <font color=#ff7700>sizeof</font> someMoreNums[0];</div>
<div class=CC1>  HasPointers h1(<font color=#007f00>&quot;Hello&quot;</font>, someNums,
someCount);</div>
<div class=CC1>  HasPointers h2(<font color=#007f00>&quot;Goodbye&quot;</font>, someMoreNums,
someMoreCount);</div>
<div class=CC1>  cout &lt;&lt; h1 &lt;&lt; endl;  <font color=#dd0000>// Hello: 1 2 3 4</font></div>
<div class=CC1>  h1 = h2;</div>
<div class=CC1>  cout &lt;&lt; h1 &lt;&lt; endl;  <font color=#dd0000>// Goodbye: 5 6 7</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>For convenience, <b>HasPointers</b> uses the <b>MyData</b>
class as a handle to the two pointers. Whenever it’s time to allocate more
memory, whether during construction or assignment, the first <b>clone</b>
function is ultimately called to do the job. If memory fails for the first call
to the <b>new</b> operator, a <b>bad_alloc</b> exception is thrown
automatically. If it happens on the second allocation (for <b>theInts</b>), we must
clean up the memory for <b>theString</b>—hence the first <b>try</b> block that
catches a <b>bad_alloc</b> exception. The second <b>try</b> block isn’t crucial
here because we’re just copying <b>int</b>s and pointers (so no exceptions will
occur), but whenever you copy objects, their assignment operators can possibly
cause an exception, so everything needs to be cleaned up. In both exception
handlers, notice that we <i>rethrow</i> the exception. That’s because we’re just managing resources here; the user still needs to know that something
went wrong, so we let the exception propagate up the dynamic chain. Software
libraries that don’t silently swallow exceptions are called <i>exception
neutral</i>. Always strive to write libraries that are both exception safe and
exception neutral.<a href="#_ftn7" name="_ftnref7"><span
class=MsoFootnoteReference>[7]</span></a></p>

<p class=MsoNormal>If you inspect the previous code closely, you’ll notice that
none of the <b>delete</b> operations will throw an exception. This code depends
on that fact. Recall that when you call <b>delete</b> on an object, the
object’s destructor is called. It turns out to be practically impossible to
design exception-safe code without assuming that destructors don’t throw
exceptions. Don’t let destructors throw exceptions. (We’re going to remind you
about this once more before this chapter is done).<a href="#_ftn8" name="_ftnref8"><span
class=MsoFootnoteReference>[8]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985637" name="_Toc53985637">Programming
with exceptions</a></h2>

<p class=MsoNormal>For most programmers, especially C programmers, exceptions
are not available in their existing language and require some adjustment. Here
are guidelines for programming with exceptions.</p>

<h3><a href="#_TocRef312374127" name="_Toc312374127">When to avoid exceptions</a></h3>

<p class=MsoNormal>Exceptions aren’t the answer to all problems; overuse can
cause trouble. The following sections point out situations where exceptions are
<i>not</i> warranted. The best advice for deciding when to use exceptions is to
throw exceptions only when a function fails to meet its specification.</p>

<h4>Not for asynchronous events</h4>

<p class=MsoNormal>The Standard C <b>signal(&nbsp;)</b><b> </b>system and any similar system handle asynchronous events: events that
happen outside the flow of a program, and thus events the program cannot
anticipate. You cannot use C++ exceptions to handle asynchronous events because
the exception and its handler are on the same call stack. That is, exceptions
rely on the dynamic chain of function calls on the program’s runtime stack (they
have “dynamic scope”), whereas asynchronous events must be handled by
completely separate code that is not part of the normal program flow
(typically, interrupt service routines or event loops). Don’t throw exceptions
from interrupt handlers.</p>

<p class=MsoNormal>This is not to say that asynchronous events cannot be <i>associated</i>
with exceptions. But the interrupt handler should do its job as quickly as
possible and then return. The typical way to handle this situation is to set a
flag in the interrupt handler, and check it synchronously in the mainline code.</p>

<h4>Not for benign error conditions</h4>

<p class=MsoNormal>If you have enough information to handle an error, it’s not
an exception. Take care of it in the current context rather than throwing an
exception to a larger context.</p>

<p class=MsoNormal>Also, C++ exceptions are not thrown for machine-level events
such as divide-by-zero.<a href="#_ftn9" name="_ftnref9"><span
class=MsoFootnoteReference>[9]</span></a> It’s
assumed that some other mechanism, such as the operating system or hardware,
deals with these events. In this way, C++ exceptions can be reasonably
efficient, and their use is isolated to program-level exceptional conditions.</p>

<h4>Not for flow–of–control</h4>

<p class=MsoNormal>An exception looks somewhat like an alternate return
mechanism and somewhat like a <b>switch</b> statement, so you might be tempted
to use an exception instead of these ordinary language mechanisms. This is a
bad idea, partly because the exception-handling system is significantly less
efficient than normal program execution. Exceptions are a rare event, so the
normal program shouldn’t pay for them. Also, exceptions from anything other
than error conditions are quite confusing to the user of your class or
function.</p>

<h4>You’re not forced to use exceptions</h4>

<p class=MsoNormal>Some programs are quite simple (small utilities, for
example). You might only need to take input and perform some processing. In
these programs, you might attempt to allocate memory and fail, try to open a
file and fail, and so on. It is acceptable in these programs to display a
message and exit the program, allowing the system to clean up the mess, rather
than to work hard to catch all exceptions and recover all the resources
yourself. Basically, if you don’t need exceptions, you’re not forced to use
them.</p>

<h4>New exceptions, old code</h4>

<p class=MsoNormal>Another situation that arises is the modification of an
existing program that doesn’t use exceptions. You might introduce a library
that <i>does</i> use exceptions and wonder if you need to modify all your code
throughout the program. Assuming you have an acceptable error-handling scheme
already in place, the most straightforward thing to do is surround the largest
block that uses the new library (this might be all the code in <b>main(&nbsp;)</b>)<b>
</b>with a <b>try</b> block, followed by a <b>catch(...)</b> and basic error
message). You can refine this to whatever degree necessary by adding more
specific handlers, but, in any case, the code you must add can be minimal. It’s
even better to isolate your exception-generating code in a <b>try</b> block and
write handlers to convert the exceptions into your existing error-handling
scheme.</p>

<p class=MsoNormal>It’s truly important to think about exceptions when you’re
creating a library for someone else to use, especially if you can’t know how
they need to respond to critical error conditions (recall the earlier
discussions on exception safety and why there are no exception specifications
in the Standard C++ Library).</p>

<h3><a href="#_TocRef312374128" name="_Toc312374128">Typical uses of
exceptions</a></h3>

<p class=MsoNormal>Do use exceptions to do the following:</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Fix the problem and retry the function that caused the exception.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Patch things up and continue without retrying the function.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Do whatever you can in the current context and rethrow the <i>same</i>
exception to a higher context.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Do whatever you can in the current context and throw a <i>different</i>
exception to a higher context.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Terminate the program.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Wrap functions (especially C library functions) that use ordinary
error schemes so they produce exceptions instead.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Simplify. If your error handling scheme makes things more
complicated, it is painful and annoying to use. Exceptions can be used to make
error handling simpler and more effective.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Make your library and program safer. This is a short-term
investment (for debugging) and a long-term investment (for application
robustness).</p>

<h4>When to use exception specifications</h4>

<p class=MsoNormal>The exception specification is like a function prototype: it
tells the user to write exception-handling code and what exceptions to handle.
It tells the compiler the exceptions that might come out of this function so
that it can detect violations at runtime.</p>

<p class=MsoNormal>You can’t always look at the code and anticipate which
exceptions will arise from a particular function. Sometimes, the functions it
calls produce an unexpected exception, and sometimes an old function that
didn’t throw an exception is replaced with a new one that does, and you get a
call to <b>unexpected(&nbsp;)</b>. Any time you use exception specifications or
call functions that do, consider creating your own <b>unexpected(&nbsp;)</b>
function that logs a message and then either throws an exception or aborts the
program.</p>

<p class=MsoNormal>As we explained earlier, you should avoid using exception
specifications in template classes, since you can’t anticipate what types of
exceptions the template parameter classes might throw.</p>

<h4>Start with standard exceptions</h4>

<p class=MsoNormal>Check out the Standard C++ library exceptions before
creating your own. If a standard exception does what you need, chances are it’s
a lot easier for your user to understand and handle.</p>

<p class=MsoNormal>If the exception type you want isn’t part of the standard
library, try to inherit one from an existing standard exception. It’s nice if
your users can always write their code to expect the <b>what(&nbsp;) </b>function
defined in the <b>exception(&nbsp;)</b> class interface.</p>

<h4>Nest your own exceptions</h4>

<p class=MsoNormal>If you create exceptions for your particular class, it’s a
good idea to nest the exception classes either inside your class or inside a
namespace containing your class, to provide a clear message to the reader that
this exception is only for your class. In addition, it prevents pollution of
the global namespace.</p>

<p class=MsoNormal>You can nest your exceptions even if you’re deriving them
from C++ Standard exceptions.</p>

<h4>Use exception hierarchies</h4>

<p class=MsoNormal>Using exception hierarchies is a valuable way to classify the types of critical errors that might be encountered with your class or library. This
gives helpful information to users, assists them in organizing their code, and
gives them the option of ignoring all the specific types of exceptions and just
catching the base-class type. Also, any exceptions added later by inheriting
from the same base class will not force all existing code to be rewritten—the
base-class handler will catch the new exception.</p>

<p class=MsoNormal>The Standard C++ exceptions are a good example of an
exception hierarchy. Build your exceptions on top of it if you can.</p>

<h4>Multiple inheritance (MI)</h4>

<p class=MsoNormal>As you’ll read in Chapter 9, the only <i>essential </i>place
for MI is if you need to upcast an object pointer to two different base
classes—that is, if you need polymorphic behavior with both of those base
classes. It turns out that exception hierarchies are useful places for multiple
inheritance because a base-class handler from any of the roots of the multiply
inherited exception class can handle the exception.</p>

<h4>Catch by reference, not by value</h4>

<p class=MsoNormal>As you saw in the section “Exception matching,” you should
catch exceptions by reference for two reasons:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>To avoid making a needless copy of the exception object when it
is passed to the handler.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>To avoid object slicing when catching a derived exception as a
base class object.</p>

<p class=MsoNormal>Although you can also throw and catch pointers, by doing so you introduce more coupling—the thrower and the catcher must agree on
how the exception object is allocated and cleaned up. This is a problem because
the exception itself might have occurred from heap exhaustion. If you throw exception
objects, the exception-handling system takes care of all storage.</p>

<h4>Throw exceptions in constructors</h4>

<p class=MsoNormal>Because a constructor has no return value, you’ve previously had two ways to report an error during construction:</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Set a nonlocal flag and hope the user checks it.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Return an incompletely created object and hope the user checks
it.</p>

<p class=MsoNormal>This problem is serious because C programmers expect that
object creation is always successful, which is not unreasonable in C because
the types are so primitive. But continuing execution after construction fails in a C++ program is a guaranteed disaster, so constructors are one of the most
important places to throw exceptions—now you have a safe, effective way to
handle constructor errors. However, you must also pay attention to pointers
inside objects and the way cleanup occurs when an exception is thrown inside a
constructor.</p>

<h4>Don’t cause exceptions in destructors</h4>

<p class=MsoNormal>Because destructors are called in the process of throwing other exceptions, you’ll never want to throw an exception in a destructor
or cause another exception to be thrown by some action you perform in the
destructor. If this happens, a new exception can be thrown <i>before</i> the
catch-clause for an existing exception is reached, which will cause a call to <b>terminate(&nbsp;)</b>.</p>

<p class=MsoNormal>If you call any functions inside a destructor that can throw
exceptions, those calls should be within a <b>try</b> block in the destructor,
and the destructor must handle all exceptions itself. None must escape from the
destructor.</p>

<h4>Avoid naked pointers</h4>

<p class=MsoNormal>See <b>Wrapped.cpp</b> earlier in this chapter. A naked
pointer usually means vulnerability in the constructor if resources are
allocated for that pointer. A pointer doesn’t have a destructor, so those
resources aren’t released if an exception is thrown in the constructor. Use <b>auto_ptr</b>
or other smart pointer types<a href="#_ftn10" name="_ftnref10"><span
class=MsoFootnoteReference>[10]</span></a> for
pointers that reference heap memory.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593304" name="_Toc305593304">Overhead</a></h2>

<p class=MsoNormal>When an exception is thrown, there’s considerable runtime
overhead (but it’s <i>good </i>overhead, since objects are cleaned up
automatically!). For this reason, you never want to use exceptions as part of
your normal flow-of-control, no matter how tempting and clever it may seem.
Exceptions should occur only rarely, so the overhead is piled on the exception
and not on the normally executing code. One of the important design goals for
exception handling was that it could be implemented with no impact on execution
speed when it <i>wasn’t</i> used; that is, as long as you don’t throw an
exception, your code runs as fast as it would without exception handling.
Whether this is true depends on the particular compiler implementation you’re
using. (See the description of the “zero-cost model” later in this section.)</p>

<p class=MsoNormal>You can think of a <b>throw</b> expression as a call to a
special system function that takes the exception object as an argument and backtracks
up the chain of execution. For this to work, extra information needs to be put
on the stack by the compiler, to aid in stack unwinding. To understand this,
you need to know about the runtime stack.</p>

<p class=MsoNormal>Whenever a function is called, information about that
function is pushed onto the runtime stack in an <i>activation record instance</i> (ARI), also called a <i>stack frame</i>. A typical stack frame contains
the address of the calling function (so execution can return to it), a pointer
to the ARI of the function’s static parent (the scope that lexically contains
the called function, so variables global to the function can be accessed), and
a pointer to the function that called it (its <i>dynamic parent</i>). The path
that logically results from repetitively following the dynamic parent links is
the <i>dynamic chain</i>, or <i>call chain</i>, that we’ve mentioned previously
in this chapter. This is how execution can backtrack when an exception is
thrown, and it is the mechanism that makes it possible for components developed
without knowledge of one another to communicate errors at runtime.</p>

<p class=MsoNormal>To enable stack unwinding for exception handling, extra
exception-related information about each function needs to be available for
each stack frame. This information describes which destructors need to be
called (so that local objects can be cleaned up), indicates whether the current
function has a <b>try</b> block, and lists which exceptions the associated
catch clauses can handle. There is space penalty for this extra information, so
programs that support exception handling can be somewhat larger than those that
don’t.<a href="#_ftn11" name="_ftnref11"><span
class=MsoFootnoteReference>[11]</span></a> Even the
compile-time size of programs using exception handling is greater, since the
logic of how to generate the expanded stack frames during runtime must be
generated by the compiler.</p>

<p class=MsoNormal>To illustrate this, we compiled the following program both
with and without exception-handling support in Borland C++ Builder and
Microsoft Visual C++:<a href="#_ftn12" name="_ftnref12"><span
class=MsoFootnoteReference>[12]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C01:HasDestructor.cpp {O}</font></div>
<div class=CC1><font color=#ff7700>class</font> HasDestructor {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  ~HasDestructor() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> g(); <font color=#dd0000>// For all we know, g may throw.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f() {</div>
<div class=CC1>  HasDestructor h;</div>
<div class=CC1>  g();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If exception handling is enabled, the compiler must keep
information about <b>~HasDestructor(&nbsp;)</b> available at runtime in the ARI
for <b>f(&nbsp;)</b> (so it can destroy <b>h</b> properly should <b>g(&nbsp;)</b>
throw an exception). The following table summarizes the result of the
compilations in terms of the size of the compiled (.obj) files (in bytes).</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:23.4pt;border-collapse:collapse'>
 <tr>
  <td width=150 valign=top style='width:112.5pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0><span style='font-weight:normal'>Compiler\Mode</span></p>
  </td>
  <td width=144 valign=top style='width:1.5in;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0><span style='font-weight:normal'>With Exception Support</span></p>
  </td>
  <td width=180 valign=top style='width:135.0pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0><span style='font-weight:normal'>Without Exception
  Support</span></p>
  </td>
 </tr>
 <tr>
  <td width=150 valign=top style='width:112.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Borland</p>
  </td>
  <td width=144 valign=top style='width:1.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>616</p>
  </td>
  <td width=180 valign=top style='width:135.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>234</p>
  </td>
 </tr>
 <tr>
  <td width=150 valign=top style='width:112.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Microsoft</p>
  </td>
  <td width=144 valign=top style='width:1.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>1162</p>
  </td>
  <td width=180 valign=top style='width:135.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>680</p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:8.0pt'>Don’t take the percentage
differences between the two modes too seriously. Remember that exceptions
(should) typically constitute a small part of a program, so the space overhead
tends to be much smaller (usually between 5 and 15 percent).</p>

<p class=MsoNormal>This extra housekeeping slows down execution, but a clever
compiler implementation avoids this. Since information about exception-handling
code and the offsets of local objects can be computed once at compile time,
such information can be kept in a single place associated with each function,
but not in each ARI. You essentially remove exception overhead from each ARI
and thus avoid the extra time to push them onto the stack. This approach is
called the <i>zero-cost</i> model<a href="#_ftn13" name="_ftnref13"><span
class=MsoFootnoteReference>[13]</span></a> of exception handling, and the optimized storage mentioned earlier is known as the <i>shadow
stack</i>.<a href="#_ftn14" name="_ftnref14"><span
class=MsoFootnoteReference>[14]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593305" name="_Toc305593305">Summary</a></h2>

<p class=MsoNormal>Error recovery is a fundamental concern for every program
you write. It’s especially important in C++ when creating program components
for others to use. To create a robust system, each component must be robust.</p>

<p class=MsoNormal>The goals for exception handling in C++ are to simplify the
creation of large, reliable programs using less code than currently possible,
with more confidence that your application doesn’t have an unhandled error.
This is accomplished with little or no performance penalty and with low impact
on existing code.</p>

<p class=MsoNormal>Basic exceptions are not terribly difficult to learn; begin
using them in your programs as soon as you can. Exceptions are one of those
features that provide immediate and significant benefits to your project.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312374131" name="_Toc312374131">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write three functions: one
that returns an error value to indicate an error condition, one that sets <b>errno</b>,
and one that uses <b>signal(&nbsp;)</b>. Write code that calls these functions
and responds to the errors. Now write a fourth function that throws an
exception. Call this function and catch the exception. Describe the differences
between these four approaches, and why exception handling is an improvement.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a class with member functions that throw exceptions.
Within this class, make a nested class to use as an exception object. It takes
a single <b>const char*</b> as its argument; this represents a description
string. Create a member function that throws this exception. (State this in the
function’s exception specification.) Write a <b>try</b> block that calls this
function and a <b>catch</b> clause that handles the exception by displaying its
description string.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Rewrite the <b>Stash</b> class from Chapter 13 of Volume 1 so
that it throws <b>out_of_range</b> exceptions for <b>operator[&nbsp;]</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a generic <b>main(&nbsp;)</b> that takes all exceptions and
reports them as errors.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a class with its own <b>operator new</b>. This operator
should allocate ten objects, and on the eleventh object “run out of memory” and
throw an exception. Also add a <b>static</b> member function that reclaims this
memory. Now create a <b>main(&nbsp;)</b> with a <b>try</b> block and a <b>catch</b>
clause that calls the memory-restoration routine. Put these inside a <b>while</b>
loop, to demonstrate recovering from an exception and continuing execution.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a destructor that throws an exception, and write code to
prove to yourself that this is a bad idea by showing that if a new exception is
thrown before the handler for the existing one is reached, <b>terminate(&nbsp;)</b>
is called.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Prove to yourself that all exception objects (the ones that are
thrown) are properly destroyed.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Prove to yourself that if you create an exception object on the
heap and throw the pointer to that object, it will not be cleaned up.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a function with an exception specification that can throw
four exception types: a <b>char</b>, an <b>int</b>, a <b>bool</b>, and your own
exception class. Catch each in <b>main(&nbsp;)</b> and verify the catch. Derive
your exception class from a standard exception. Write the function in such a
way that the system recovers and tries to execute it again.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify your solution to the previous exercise to throw a <b>double</b>
from the function, violating the exception specification. Catch the violation
with your own unexpected handler that displays a message and exits the program
gracefully (meaning <b>abort(&nbsp;)</b> is not called).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a <b>Garage</b> class that has a <b>Car</b> that is having
troubles with its <b>Motor</b>. Use a function-level <b>try</b> block in the <b>Garage</b>
class constructor to catch an exception (thrown from the <b>Motor</b> class)
when its <b>Car</b> object is initialized. Throw a different exception from the
body of the <b>Garage</b> constructor’s handler and catch it in <b>main(&nbsp;)</b>.</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section10>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985643" name="_Toc53985643">2: Defensive Programming</a></h1>

<p class=Intro style='margin-left:.25in'>Writing “perfect software” may be an elusive goal for
developers, but a few defensive techniques, routinely applied, can go a long
way toward improving the quality of your code.</p>

<p class=MsoNormal>Although the complexity of typical production software
guarantees that testers will always have a job, we hope you still yearn to
produce defect-free software. Object-oriented design techniques do much to
corral the difficulty of large projects, but eventually you must write loops
and functions. These details of “programming in the small” become the building
blocks of the larger components needed for your designs. If your loops are off
by one or your functions calculate the correct values only “most” of the time,
you’re in trouble no matter how fancy your overall methodology. In this chapter, you’ll see practices that help create robust code regardless of the size of your
project.</p>

<p class=MsoNormal>Your code is, among other things, an expression of your attempt
to solve a problem. It should be clear to the reader (including yourself)
exactly what you were thinking when you designed that loop. At certain points
in your program, you should be able to make bold statements that some condition
or other holds. (If you can’t, you really haven’t yet solved the problem.) Such
statements are called <i>invariants</i>, since they should invariably be true
at the point where they appear in the code; if not, either your design is faulty,
or your code does not accurately reflect your design.</p>

<p class=MsoNormal>Consider a program that plays the guessing game of Hi-Lo. One
person thinks of a number between 1 and 100, and the other person guesses the
number. (We’ll let the computer do the guessing.) The person who holds the
number tells the guesser whether their guess is high, low or correct. The best
strategy for the guesser is a <i>binary search</i>, which chooses the midpoint
of the range of numbers where the sought-after number resides. The high-low
response tells the guesser which half of the list holds the number, and the
process repeats, halving the size of the active search range on each iteration.
So how do you write a loop to drive the repetition properly? It’s not
sufficient to just say</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>bool</font> guessed = <font color=#ff7700>false</font>;</div>
<div class=CC1><font color=#ff7700>while</font>(!guessed) {</div>
<div class=CC1>  ...</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>because a malicious user might respond deceitfully, and you
could spend all day guessing. What assumption, however simple, are you making
each time you guess? In other words, what condition should hold <i>by design</i>
on each loop iteration?</p>

<p class=MsoNormal>The simple assumption is that the secret number is within
the current active range of unguessed numbers: [1, 100]. Suppose we label the
endpoints of the range with the variables <b><i>low</i></b> and <b><i>high</i></b>.
Each time you pass through the loop you need to make sure that if the number
was in the range [<b>low</b>, <b>high</b>] at the beginning of the loop, you
calculate the new range so that it still contains the number at the end of the
current loop iteration.</p>

<p class=MsoNormal>The goal is to express the loop invariant in code so that a
violation can be detected at runtime. Unfortunately, since the computer doesn’t
know the secret number, you can’t express this condition directly in code, but
you can at least make a comment to that effect:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>while</font>(!guessed) {</div>
<div class=CC1>  <font color=#dd0000>// INVARIANT: the number is in the range [low, high]</font></div>
<div class=CC1>  ...</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>What happens when the user says that a guess is too high or
too low when it isn’t? The deception will exclude the secret number from the
new subrange. Because one lie always leads to another, eventually your range
will diminish to nothing (since you shrink it by half each time and the secret
number isn’t in there). We can express this condition in the following program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:HiLo.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Plays the game of Hi-Lo to illustrate a loop
invariant.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Think of a number between 1 and
100&quot;</font> &lt;&lt; endl</div>
<div class=CC1>     &lt;&lt; <font color=#007f00>&quot;I will make a
guess; &quot;</font></div>
<div class=CC1>     &lt;&lt; <font color=#007f00>&quot;tell me if I'm
(H)igh or (L)ow&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>int</font> low = 1, high = 100;</div>
<div class=CC1>  <font color=#ff7700>bool</font> guessed = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!guessed) {</div>
<div class=CC1>    <font color=#dd0000>// Invariant: the number is in the range [low,
high]</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(low &gt; high) {  <font color=#dd0000>// Invariant violation</font></div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;You cheated! I quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>      <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>int</font> guess = (low + high) / 2;</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;My guess is &quot;</font> &lt;&lt;
guess &lt;&lt; <font color=#007f00>&quot;. &quot;</font>;</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;(H)igh, (L)ow, or (E)qual?
&quot;</font>;</div>
<div class=CC1>    string response;</div>
<div class=CC1>    cin &gt;&gt; response;</div>
<div class=CC1>    <font color=#ff7700>switch</font>(toupper(response[0])) {</div>
<div class=CC1>      <font color=#ff7700>case</font> 'H':</div>
<div class=CC1>        high = guess - 1;</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> 'L':</div>
<div class=CC1>        low = guess + 1;</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> 'E':</div>
<div class=CC1>        guessed = <font color=#ff7700>true</font>;</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>default</font>:</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Invalid response&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>        <font color=#ff7700>continue</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;I got it!&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>return</font> EXIT_SUCCESS;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The violation of the invariant is detected with the
condition <b>if(low &gt; high)</b>, because if the user always tells the truth,
we will always find the secret number before we run out of guesses.</p>

<p class=MsoNormal>We also use a standard C technique for reporting program
status to the calling context by returning different values from <b>main(&nbsp;)</b>.
It is portable to use the statement <b>return 0;</b> to indicate success, but
there is no portable value to indicate failure. For this reason we use the
macro declared for this purpose in <b>&lt;cstdlib&gt;</b>: <b>EXIT_FAILURE</b>.
For consistency, whenever we use <b>EXIT_FAILURE</b> we also use <b>EXIT_SUCCESS</b>,
even though the latter is always defined as zero.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985644" name="_Toc53985644">Assertions</a></h2>

<p class=MsoNormal>The condition in the Hi-Lo program depends on user input, so
you can’t prevent a violation of the invariant. However, invariants usually depend
only on the code you write, so they will always hold if you’ve implemented your
design correctly. In this case, it is clearer to make an <i>assertion</i>, which is a positive statement that reveals your design decisions.</p>

<p class=MsoNormal>Suppose you are implementing a vector of integers: an
expandable array that grows on demand. The function that adds an element to the
vector must first verify that there is an open slot in the underlying array
that holds the elements; otherwise, it needs to request more heap space and
copy the existing elements to the new space before adding the new element (and
deleting the old array). Such a function might look like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> MyVector::push_back(<font color=#ff7700>int</font> x) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(nextSlot == capacity)</div>
<div class=CC1>    grow();</div>
<div class=CC1>  assert(nextSlot &lt; capacity);</div>
<div class=CC1>  data[nextSlot++] = x;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this example, <b>data</b> is a dynamic array of <b>int</b>s
with <b>capacity</b> slots and <b>nextSlot</b> slots in use. The purpose of <b>grow(&nbsp;)</b>
is to expand the size of <b>data</b> so that the new value of <b>capacity</b>
is strictly greater than <b>nextSlot</b>. Proper behavior of <b>MyVector</b>
depends on this design decision, and it will never fail if the rest of the
supporting code is correct. We <i>assert</i> the condition with the <b>assert(&nbsp;)</b>
macro, which is defined in the header <b>&lt;cassert&gt;</b>.</p>

<p class=MsoNormal>The Standard C library <b>assert(&nbsp;)</b> macro is brief,
to the point, and portable. If the condition in its parameter evaluates to
non-zero, execution continues uninterrupted; if it doesn’t, a message
containing the text of the offending expression along with its source file name
and line number is printed to the standard error channel and the program
aborts. Is that too drastic? In practice, it is much more drastic to let
execution continue when a basic design assumption has failed. Your program
needs to be fixed.</p>

<p class=MsoNormal>If all goes well, you will thoroughly test your code with
all assertions intact by the time the final product is deployed. (We’ll say
more about testing later.) Depending on the nature of your application, the
machine cycles needed to test all assertions at runtime might be too much of a
performance hit in the field. If that’s the case, you can remove all the
assertion code automatically by defining the macro <b>NDEBUG</b> and rebuilding
the application.</p>

<p class=MsoNormal>To see how this works, note that a typical implementation of
<b>assert(&nbsp;)</b> looks something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#7F7F00>#ifdef NDEBUG</font></div>
<div class=CC1><font color=#7F7F00>  #define assert(cond) ((void)0)</font></div>
<div class=CC1><font color=#7F7F00>#else</font></div>
<div class=CC1>  <font color=#ff7700>void</font> assertImpl(<font color=#ff7700>const</font> <font color=#ff7700>char</font>*, <font color=#ff7700>const</font> <font color=#ff7700>char</font>*, <font color=#ff7700>long</font>);</div>
<div class=CC1><font color=#7F7F00>#define assert(cond) \</font></div>
<div class=CC1>  ((cond) ? (<font color=#ff7700>void</font>)0 : assertImpl(???))</div>
<div class=CC1><font color=#7F7F00>#endif</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When the macro <b>NDEBUG</b> is defined, the code decays to
the expression <b>(void) 0</b>, so all that’s left in the compilation stream is
an essentially empty statement as a result of the semicolon you appended to
each <b>assert(&nbsp;)</b> invocation. If <b>NDEBUG</b> is not defined, <b>assert(cond)</b>
expands to a conditional statement that, when <b>cond</b> is zero, calls a
compiler-dependent function (which we named <b>assertImpl(&nbsp;)</b>) with a
string argument representing the text of <b>cond</b>, along with the file name
and line number where the assertion appeared. (We used “???” as a place holder
in the example, but the string mentioned is actually computed there, along with
the file name and the line number where the macro occurs in that file. How
these values are obtained is immaterial to our discussion.) If you want to turn
assertions on and off at different points in your program, you must not only <b>#define</b>
or <b>#undef</b> <b>NDEBUG</b>, but you must also re-include <b>&lt;cassert&gt;</b>.
Macros are evaluated as the preprocessor encounters them and thus use whatever <b>NDEBUG</b>
state applies at the point of inclusion. The most common way to define <b>NDEBUG</b>
once for an entire program is as a compiler option, whether through project
settings in your visual environment or via the command line, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>mycc –DNDEBUG myfile.cpp</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Most compilers use the <b>–D</b> flag to define macro names.
(Substitute the name of your compiler’s executable for <b>mycc</b> above.) The
advantage of this approach is that you can leave your assertions in the source
code as an invaluable bit of documentation, and yet there is no runtime
penalty. Because the code in an assertion disappears when <b>NDEBUG</b> is
defined, it is important that you <i>never do work in an assertion</i>. Only
test conditions that do not change the state of your program.</p>

<p class=MsoNormal>Whether using <b>NDEBUG</b> for released code is a good idea
remains a subject of debate. Tony Hoare, one of the most influential computer
scientists of all time,<a href="#_ftn15" name="_ftnref15"><span
class=MsoFootnoteReference>[15]</span></a> has
suggested that turning off runtime checks such as assertions is similar to a
sailing enthusiast who wears a life jacket while training on land and then
discards it when he goes to sea.<a href="#_ftn16" name="_ftnref16"><span
class=MsoFootnoteReference>[16]</span></a> If
an assertion fails in production, you have a problem much worse than
degradation in performance, so choose wisely.</p>

<p class=MsoNormal>Not all conditions should be enforced by assertions. User
errors and runtime resource failures should be signaled by throwing exceptions,
as we explained in detail in Chapter 1. It is tempting to use assertions for
most error conditions while roughing out code, with the intent to replace many
of them later with robust exception handling. Like any other temptation, use
caution, since you might forget to make all the necessary changes later.
Remember: assertions are intended to verify design decisions that will only
fail because of faulty programmer logic. The ideal is to solve all assertion
violations during development. Don’t use assertions for conditions that aren’t
totally in your control (for example, conditions that depend on user input). In
particular, you wouldn’t want to use assertions to validate function arguments;
throw a <b>logic_error</b> instead.</p>

<p class=MsoNormal>The use of assertions as a tool to ensure program
correctness was formalized by Bertrand Meyer in his <i>Design by Contract</i> methodology.<a href="#_ftn17" name="_ftnref17"><span
class=MsoFootnoteReference>[17]</span></a> Every
function has an implicit contract with clients that, given certain <i>preconditions</i>, guarantees certain <i>postconditions</i>. In other words, the preconditions
are the requirements for using the function, such as supplying arguments within
certain ranges, and the postconditions are the results delivered by the
function, either by return value or by side-effect.</p>

<p class=MsoNormal>When client programs fail to give you valid input, you must
tell them they have broken the contract. This is not the best time to abort the
program (although you’re justified in doing so since the contract was
violated), but an exception is certainly appropriate. This is why the Standard
C++ library throws exceptions derived from <b>logic_error</b>, such as <b>out_of_range</b>.<a href="#_ftn18" name="_ftnref18"><span
class=MsoFootnoteReference>[18]</span></a> If there are
functions that only you call, however, such as private functions in a class of
your own design, the <b>assert(&nbsp;)</b> macro is appropriate, since you have
total control over the situation and you certainly want to debug your code
before shipping.</p>

<p class=MsoNormal>A postcondition failure indicates a program error, and it is
appropriate to use assertions for <i>any invariant at any time</i>, including the
postcondition test at the end of a function. This applies in particular to
class member functions that maintain the state of an object. In the <b>MyVector</b>
example earlier, for instance, a reasonable invariant for all public member
functions would be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>assert(0 &lt;= nextSlot &amp;&amp; nextSlot &lt;=
capacity);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>or, if <b>nextSlot</b> is an unsigned integer, simply</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>assert(nextSlot &lt;= capacity);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Such an invariant is called a <i>class invariant</i> and can reasonably be enforced by an assertion. Subclasses play the role of <i>subcontractor</i>
to their base classes because they must maintain the original contract between the
base class and its clients. For this reason, the preconditions in derived
classes must impose no extra requirements beyond those in the base contract,
and the postconditions must deliver at least as much.<a href="#_ftn19" name="_ftnref19"><span
class=MsoFootnoteReference>[19]</span></a></p>

<p class=MsoNormal>Validating results returned to the client, however, is
nothing more or less than <i>testing</i>, so using post-condition assertions in
this case would be duplicating work. Yes, it’s good documentation, but more
than one developer has been fooled into improperly using post-condition
assertions as a substitute for unit testing.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985645" name="_Toc53985645">A
simple unit test framework</a></h2>

<p class=MsoNormal>Writing software is all about meeting requirements.<a href="#_ftn20" name="_ftnref20"><span
class=MsoFootnoteReference>[20]</span></a> Creating these
requirements is difficult, and they can change from day to day; you might
discover at a weekly project meeting that what you just spent the week doing is
not exactly what the users really want.</p>

<p class=MsoNormal>People cannot articulate software requirements without
sampling an evolving, working system. It’s much better to specify a little,
design a little, code a little, and test a little. Then, after evaluating the
outcome, do it all over again. The ability to develop in such an iterative
fashion is one of the great advances of the object-oriented approach, but it
requires nimble programmers who can craft resilient code. Change is hard.</p>

<p class=MsoNormal>Another impetus for change comes from you, the programmer.
The craftsperson in you wants to continually improve the design of your code.
What maintenance programmer hasn’t cursed the aging, flagship company product
as a convoluted, unmodifiable patchwork of spaghetti? Management’s reluctance
to let you tamper with a functioning system robs code of the resilience it
needs to endure. “If it’s not broken, don’t fix it” eventually gives way to, “We
can’t fix it—rewrite it.” Change is necessary.</p>

<p class=MsoNormal>Fortunately, our industry is growing accustomed to the
discipline of <i>refactoring</i>, the art of internally restructuring code to
improve its design, without changing its behavior.<a href="#_ftn21" name="_ftnref21"><span
class=MsoFootnoteReference>[21]</span></a> Such
improvements include extracting a new function from another, or inversely,
combining member functions; replacing a member function with an object;
parameterizing a member function or class; and replacing conditionals with
polymorphism. Refactoring helps code evolve.</p>

<p class=MsoNormal>Whether the force for change comes from users or
programmers, changes today may break what worked yesterday. We need a way to
build code that withstands change and improves over time.</p>

<p class=MsoNormal><i>Extreme Programming</i> (XP)<a href="#_ftn22" name="_ftnref22"><span
class=MsoFootnoteReference>[22]</span></a> is only one of
many practices that support a quick-on-your-feet motif. In this section we
explore what we think is the key to making flexible, incremental development
succeed: an easy-to-use automated unit test framework. (Note that <i>testers</i>,
software professionals who test others’ code for a living, are still indispensable.
Here, we are merely describing a way to help developers write better code.)</p>

<p class=MsoNormal>Developers write <i>unit tests</i> to gain the confidence to
say the two most important things that any developer can say:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>I understand the requirements.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>My code meets those requirements (to the best of my knowledge).</p>

<p class=MsoNormal>There is no better way to ensure that you know what the code
you’re about to write should do than to write the unit tests first. This simple
exercise helps focus the mind on the task ahead and will likely lead to working
code faster than just jumping into coding. Or, to express it in XP terms:</p>

<p class=MsoNormal style='margin-left:.5in'><i>Testing + programming is faster
than just programming</i>.</p>

<p class=MsoNormal>Writing tests first also guards you against boundary
conditions that might break your code, so your code is more robust.</p>

<p class=MsoNormal>When your code passes all your tests, you know that if the
system isn’t working, your code is probably not the problem. The statement “All
my tests pass” is a powerful argument.</p>

<h3><a href="#_TocRef53985646" name="_Toc53985646">Automated testing</a></h3>

<p class=MsoNormal>So what does a unit test look like? Too often developers
just use some well-behaved input to produce some expected output, which they
inspect visually. Two dangers exist in this approach. First, programs don’t
always receive only well-behaved input. We all know that we should test the
boundaries of program input, but it’s hard to think about this when you’re
trying to just get things working. If you write the test for a function first
before you start coding, you can wear your “tester hat” and ask yourself, “What
could possibly make this break?” Code a test that will prove the function you’ll
write isn’t broken, and then put on your developer hat and make it happen. You’ll
write better code than if you hadn’t written the test first.</p>

<p class=MsoNormal>The second danger is that inspecting output visually is
tedious and error prone. Most any such thing a human can do a computer can do,
but without human error. It’s better to formulate tests as collections of <i>Boolean expressions</i> and have a test program report any failures.</p>

<p class=MsoNormal>For example, suppose you need to build a <b>Date</b> class
that has the following properties:</p>

<p class=MsoList3><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A date can be initialized with a string (YYYYMMDD), three
integers (Y, M, D), or nothing (giving today’s date).</p>

<p class=MsoList3><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A date object can yield its year, month, and day or a string of
the form “YYYYMMDD”.</p>

<p class=MsoList3><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>All relational comparisons are available, as well as computing
the duration between two dates (in years, months, and days).</p>

<p class=MsoList3><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Dates to be compared need to be able to span an arbitrary number
of centuries (for example, 1600–2200).</p>

<p class=MsoNormal>Your class can store three integers representing the year,
month, and day. (Just be sure the year is at least 16 bits in size to satisfy
the last bulleted item.) The interface for your <b>Date</b> class might look
like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:Date1.h</font></div>
<div class=CC1><font color=#dd0000>// A first pass at Date.h.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DATE1_H</font></div>
<div class=CC1><font color=#7F7F00>#define DATE1_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Date {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// A struct to hold elapsed time:</font></div>
<div class=CC1>  <font color=#ff7700>struct</font> Duration {</div>
<div class=CC1>    <font color=#ff7700>int</font> years;</div>
<div class=CC1>    <font color=#ff7700>int</font> months;</div>
<div class=CC1>    <font color=#ff7700>int</font> days;</div>
<div class=CC1>    Duration(<font color=#ff7700>int</font> y, <font color=#ff7700>int</font> m, <font color=#ff7700>int</font> d)</div>
<div class=CC1>    : years(y), months(m), days(d) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  Date();</div>
<div class=CC1>  Date(<font color=#ff7700>int</font> year, <font color=#ff7700>int</font> month, <font color=#ff7700>int</font> day);</div>
<div class=CC1>  Date(<font color=#ff7700>const</font> std::string&amp;);</div>
<div class=CC1>  <font color=#ff7700>int</font> getYear() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>int</font> getMonth() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>int</font> getDay() <font color=#ff7700>const</font>;</div>
<div class=CC1>  std::string toString() <font color=#ff7700>const</font>;</div>
<div class=CC1><font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font>
Date&amp;, <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1><font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;(<font color=#ff7700>const</font>
Date&amp;, <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1><font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;=(<font color=#ff7700>const</font>
Date&amp;, <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1><font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;=(<font color=#ff7700>const</font>
Date&amp;, <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1><font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font>
Date&amp;, <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1><font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font>
Date&amp;, <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> Duration duration(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DATE1_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Before you implement this class, you can solidify your grasp
of the requirements by writing the beginnings of a test program. You might come
up with something like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:SimpleDateTest.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Date</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Date.h&quot; </font><font color=#dd0000>// From Appendix B</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Test machinery</font></div>
<div class=CC1><font color=#ff7700>int</font> nPass = 0, nFail = 0;</div>
<div class=CC1><font color=#ff7700>void</font> test(<font color=#ff7700>bool</font> t) { <font color=#ff7700>if</font>(t) nPass++; <font color=#ff7700>else</font> nFail++; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Date mybday(1951, 10, 1);</div>
<div class=CC1>  test(mybday.getYear() == 1951);</div>
<div class=CC1>  test(mybday.getMonth() == 10);</div>
<div class=CC1>  test(mybday.getDay() == 1);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Passed: &quot;</font> &lt;&lt; nPass
&lt;&lt; <font color=#007f00>&quot;, Failed: &quot;</font></div>
<div class=CC1>       &lt;&lt; nFail &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F7F>/* Expected output:</div>
<div class=CC1>Passed: 3, Failed: 0</div>
<div class=CC1>*/</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this trivial case, the function <b>test(&nbsp;)</b>
maintains the global variables <b>nPass</b> and <b>nFail</b>. The only visual
inspection you do is to read the final score. If a test failed, a more
sophisticated <b>test(&nbsp;)</b> displays an appropriate message. The
framework described later in this chapter has such a test function, among other
things.</p>

<p class=MsoNormal>You can now implement enough of the <b>Date</b> class to get
these tests to pass, and then you can proceed iteratively until all the
requirements are met. By writing tests first, you are more likely to think of
corner cases that might break your upcoming implementation, and you’re more
likely to write the code correctly the first time. Such an exercise might
produce the following version of a test for the <b>Date</b> class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:SimpleDateTest2.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Date</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Date.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Test machinery</font></div>
<div class=CC1><font color=#ff7700>int</font> nPass = 0, nFail = 0;</div>
<div class=CC1><font color=#ff7700>void</font> test(<font color=#ff7700>bool</font> t) { <font color=#ff7700>if</font>(t) ++nPass; <font color=#ff7700>else</font> ++nFail; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Date mybday(1951, 10, 1);</div>
<div class=CC1>  Date today;</div>
<div class=CC1>Date
myevebday(<font color=#007f00>&quot;19510930&quot;</font>);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Test the operators</font></div>
<div class=CC1>  test(mybday &lt; today);</div>
<div class=CC1>  test(mybday &lt;= today);</div>
<div class=CC1>  test(mybday != today);</div>
<div class=CC1>  test(mybday == mybday);</div>
<div class=CC1>  test(mybday &gt;= mybday);</div>
<div class=CC1>  test(mybday &lt;= mybday);</div>
<div class=CC1>  test(myevebday &lt; mybday);</div>
<div class=CC1>  test(mybday &gt; myevebday);</div>
<div class=CC1>  test(mybday &gt;= myevebday);</div>
<div class=CC1>  test(mybday != myevebday);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Test the functions</font></div>
<div class=CC1>  test(mybday.getYear() == 1951);</div>
<div class=CC1>  test(mybday.getMonth() == 10);</div>
<div class=CC1>  test(mybday.getDay() == 1);</div>
<div class=CC1>  test(myevebday.getYear() == 1951);</div>
<div class=CC1>  test(myevebday.getMonth() == 9);</div>
<div class=CC1>  test(myevebday.getDay() == 30);</div>
<div class=CC1>  test(mybday.toString() == <font color=#007f00>&quot;19511001&quot;</font>);</div>
<div class=CC1>  test(myevebday.toString() == <font color=#007f00>&quot;19510930&quot;</font>);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Test duration</font></div>
<div class=CC1>  Date d2(2003, 7, 4);</div>
<div class=CC1>  Date::Duration dur = duration(mybday, d2);</div>
<div class=CC1>  test(dur.years == 51);</div>
<div class=CC1>  test(dur.months == 9);</div>
<div class=CC1>  test(dur.days == 3);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Report results:</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Passed: &quot;</font> &lt;&lt; nPass
&lt;&lt; <font color=#007f00>&quot;, Failed: &quot;</font></div>
<div class=CC1>       &lt;&lt; nFail &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This test can be more fully developed. For example, we haven’t
tested that long durations are handled correctly. We’ll stop here, but you get
the idea. The full implementation for the <b>Date</b> class is available in the
files <b>Date.h</b> and <b>Date.cpp</b> in the appendix.<a href="#_ftn23" name="_ftnref23"><span
class=MsoFootnoteReference>[23]</span></a></p>

<h3><a href="#_TocRef53985647" name="_Toc53985647">The TestSuite Framework</a></h3>

<p class=MsoNormal>Some automated C++ unit test tools are available on the
World Wide Web for download, such as <b>CppUnit</b>.<a href="#_ftn24" name="_ftnref24"><span
class=MsoFootnoteReference>[24]</span></a> Our
purpose here is not only to present a test mechanism that is easy to use, but
also easy to understand internally and even modify if necessary. So, in the
spirit of “Do The Simplest Thing That Could Possibly Work,”<a href="#_ftn25" name="_ftnref25"><span
class=MsoFootnoteReference>[25]</span></a> we
have developed the <i>TestSuite Framework</i>, a namespace named <b>TestSuite</b>
that contains two key classes: <b>Test</b> and <b>Suite</b>.</p>

<p class=MsoNormal>The <b>Test</b> class is an abstract base class from which you
derive a test object. It keeps track of the number of passes and failures and
displays the text of any test condition that fails. You simply to override the <b>run(&nbsp;)</b>
member function, which should in turn call the <b>test_(&nbsp;)</b> macro for
each Boolean test condition you define.</p>

<p class=MsoNormal>To define a test for the <b>Date</b> class using the
framework, you can inherit from <b>Test</b> as shown in the following program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=SV><font color=#dd0000>//: C02:DateTest.h</span></font></div>
<div class=CC1><span lang=SV>#ifndef DATETEST_H</span></div>
<div class=CC1><font color=#7F7F00>#define DATETEST_H</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Date.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DateTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1>  Date mybday;</div>
<div class=CC1>  Date today;</div>
<div class=CC1>  Date myevebday;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DateTest(): mybday(1951, 10, 1),
myevebday(<font color=#007f00>&quot;19510930&quot;</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    testOps();</div>
<div class=CC1>    testFunctions();</div>
<div class=CC1>    testDuration();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testOps() {</div>
<div class=CC1>    test_(mybday &lt; today);</div>
<div class=CC1>    test_(mybday &lt;= today);</div>
<div class=CC1>    test_(mybday != today);</div>
<div class=CC1>    test_(mybday == mybday);</div>
<div class=CC1>    test_(mybday &gt;= mybday);</div>
<div class=CC1>    test_(mybday &lt;= mybday);</div>
<div class=CC1>    test_(myevebday &lt; mybday);</div>
<div class=CC1>    test_(mybday &gt; myevebday);</div>
<div class=CC1>    test_(mybday &gt;= myevebday);</div>
<div class=CC1>    test_(mybday != myevebday);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testFunctions() {</div>
<div class=CC1>    test_(mybday.getYear() == 1951);</div>
<div class=CC1>    test_(mybday.getMonth() == 10);</div>
<div class=CC1>    test_(mybday.getDay() == 1);</div>
<div class=CC1>    test_(myevebday.getYear() == 1951);</div>
<div class=CC1>    test_(myevebday.getMonth() == 9);</div>
<div class=CC1>    test_(myevebday.getDay() == 30);</div>
<div class=CC1>    test_(mybday.toString() == <font color=#007f00>&quot;19511001&quot;</font>);</div>
<div class=CC1>    test_(myevebday.toString() ==
<font color=#007f00>&quot;19510930&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testDuration() {</div>
<div class=CC1>    Date d2(2003, 7, 4);</div>
<div class=CC1>    Date::Duration dur = duration(mybday, d2);</div>
<div class=CC1>    test_(dur.years == 51);</div>
<div class=CC1>    test_(dur.months == 9);</div>
<div class=CC1>    test_(dur.days == 3);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DATETEST_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Running the test is a simple matter of instantiating a <b>DateTest</b>
object and calling its <b>run(&nbsp;)</b> member function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:DateTest.cpp</font></div>
<div class=CC1><font color=#dd0000>// Automated testing (with a framework).</font></div>
<div class=CC1><font color=#dd0000>//{L} Date ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DateTest.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  DateTest test;</div>
<div class=CC1>  test.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> test.report();</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F7F>/* Output:</div>
<div class=CC1>Test &quot;DateTest&quot;:</div>
<div class=CC1>        Passed: 21,      Failed: 0</div>
<div class=CC1>*/</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Test::report(&nbsp;)</b> function displays the
previous output and returns the number of failures, so it is suitable to use as
a return value from <b>main(&nbsp;)</b>.</p>

<p class=MsoNormal>The <b>Test</b> class uses RTTI<a href="#_ftn26" name="_ftnref26"><span
class=MsoFootnoteReference>[26]</span></a> to
get the name of your class (for example, <b>DateTest</b>) for the report. There
is also a <b>setStream(&nbsp;)</b> member function if you want the test results
sent to a file instead of to the standard output (the default). You’ll see the <b>Test</b>
class implementation later in this chapter.</p>

<p class=MsoNormal>The <b>test_(&nbsp;)</b> macro can extract the text of the
Boolean condition that fails, along with its file name and line number.<a href="#_ftn27" name="_ftnref27"><span
class=MsoFootnoteReference>[27]</span></a> To see what
happens when a failure occurs, you can introduce an intentional error in the
code, for example by reversing the condition in the first call to <b>test_(&nbsp;)</b>
in <b>DateTest::testOps(&nbsp;)</b> in the previous example code. The output
indicates exactly what test was in error and where it happened:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>DateTest failure: (mybday &gt; today) , DateTest.h
(line 31)</div>
<div class=CC1>Test <font color=#007f00>&quot;DateTest&quot;</font>:</div>
<div class=CC1>        Passed: 20      Failed: 1</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In addition to <b>test_(&nbsp;)</b>, the framework includes
the functions <b>succeed_(&nbsp;)</b> and <b>fail_(&nbsp;)</b>, for cases where
a Boolean test won’t do. These functions apply when the class you’re testing
might throw exceptions. During testing, create an input set that will cause the
exception to occur. If it doesn’t, it’s an error and you call <b>fail_(&nbsp;)</b>
explicitly to display a message and update the failure count. If it does throw
the exception as expected, you call <b>succeed_(&nbsp;)</b> to update the
success count.</p>

<p class=MsoNormal>To illustrate, suppose we modify the specification of the
two non-default <b>Date</b> constructors to throw a <b>DateError</b> exception
(a type nested inside <b>Date</b> and derived from <b>std::logic_error</b>) if
the input parameters do not represent a valid date:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Date(<font color=#ff7700>const</font> string&amp; s) <font color=#ff7700>throw</font>(DateError);</div>
<div class=CC1>Date(<font color=#ff7700>int</font> year, <font color=#ff7700>int</font> month, <font color=#ff7700>int</font> day) <font color=#ff7700>throw</font>(DateError);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>DateTest::run(&nbsp;)</b> member function can now
call the following function to test the exception handling:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <font color=#ff7700>void</font> testExceptions() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      Date d(0,0,0);  <font color=#dd0000>// Invalid</font></div>
<div class=CC1>      fail_(<font color=#007f00>&quot;Invalid date undetected in Date int
ctor&quot;</font>);</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Date::DateError&amp;) {</div>
<div class=CC1>      succeed_();</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      Date d(<font color=#007f00>&quot;&quot;</font>);  <font color=#dd0000>// Invalid</font></div>
<div class=CC1>      fail_(<font color=#007f00>&quot;Invalid date undetected in Date
string ctor&quot;</font>);</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Date::DateError&amp;) {</div>
<div class=CC1>      succeed_();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In both cases, if an exception is not thrown, it is an
error. Notice that you must manually pass a message to <b>fail_(&nbsp;)</b>,
since no Boolean expression is being evaluated.</p>

<h3><a href="#_TocRef53985648" name="_Toc53985648">Test suites</a></h3>

<p class=MsoNormal>Real projects usually contain many classes, so you need a
way to group tests so that you can just push a single button to test the entire
project.<a href="#_ftn28" name="_ftnref28"><span
class=MsoFootnoteReference>[28]</span></a> The <b>Suite</b>
class collects tests into a functional unit. You add <b>Test</b> objects to a <b>Suite</b>
with the <b>addTest(&nbsp;)</b> member function, or you can include an entire
existing suite with <b>addSuite(&nbsp;)</b>. To illustrate, the following
example collects the programs in Chapter 3 that use the <b>Test</b> class into
a single suite. Note that this file will appear in the Chapter 3 subdirectory:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StringSuite.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test
../TestSuite/Suite</font></div>
<div class=CC1><font color=#dd0000>//{L} TrimTest</font></div>
<div class=CC1><font color=#dd0000>// Illustrates a test suite
for code from Chapter 3</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include
&quot;../TestSuite/Suite.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include
&quot;StringStorage.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Sieve.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Find.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Rparse.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include
&quot;TrimTest.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;CompStr.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> TestSuite;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>    Suite suite(<font color=#007f00>&quot;String
Tests&quot;</font>);</div>
<div class=CC1>    suite.addTest(<font color=#ff7700>new</font>
StringStorageTest);</div>
<div class=CC1>    suite.addTest(<font color=#ff7700>new</font>
SieveTest);</div>
<div class=CC1>    suite.addTest(<font color=#ff7700>new</font>
FindTest);</div>
<div class=CC1>    suite.addTest(<font color=#ff7700>new</font>
RparseTest);</div>
<div class=CC1>    suite.addTest(<font color=#ff7700>new</font> TrimTest);</div>
<div class=CC1>    suite.addTest(<font color=#ff7700>new</font>
CompStrTest);</div>
<div class=CC1>    suite.run();</div>
<div class=CC1>    <font color=#ff7700>long</font> nFail =
suite.report();</div>
<div class=CC1>    suite.free();</div>
<div class=CC1>    <font color=#ff7700>return</font> nFail;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F7F>/* Output:</div>
<div class=CC1>s1 = 62345</div>
<div class=CC1>s2 = 12345</div>
<div class=CC1>Suite &quot;String Tests&quot;</div>
<div class=CC1>====================</div>
<div class=CC1>Test
&quot;StringStorageTest&quot;:</div>
<div class=CC1>   Passed: 2   Failed: 0</div>
<div class=CC1>Test &quot;SieveTest&quot;:</div>
<div class=CC1>   Passed: 50  Failed: 0</div>
<div class=CC1>Test &quot;FindTest&quot;:</div>
<div class=CC1>   Passed: 9   Failed: 0</div>
<div class=CC1>Test &quot;RparseTest&quot;:</div>
<div class=CC1>   Passed: 8   Failed: 0</div>
<div class=CC1>Test &quot;TrimTest&quot;:</div>
<div class=CC1>   Passed: 11  Failed: 0</div>
<div class=CC1>Test &quot;CompStrTest&quot;:</div>
<div class=CC1>   Passed: 8   Failed: 0</div>
<div class=CC1>*/</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Five of the above tests are completely contained in header
files. <b>TrimTest</b> is not, because it contains static data that must be defined
in an implementation file. The two first two output lines are trace lines from
the <b>StringStorage</b> test. You must give the suite a name as a constructor
argument. The <b>Suite::run(&nbsp;)</b> member function calls <b>Test::run(&nbsp;)</b>
for each of its contained tests. Much the same thing happens for <b>Suite::report(&nbsp;)</b>,
except that you can send the individual test reports to a different destination
stream than that of the suite report. If the test passed to <b>addSuite(&nbsp;)</b>
already has a stream pointer assigned, it keeps it. Otherwise, it gets its
stream from the <b>Suite</b> object. (As with <b>Test</b>, there is an optional
second argument to the suite constructor that defaults to <b>std::cout</b>.)
The destructor for <b>Suite</b> does not automatically delete the contained <b>Test</b>
pointers because they don’t need to reside on the heap; that’s the job of <b>Suite::free(&nbsp;)</b>.</p>

<h3><a href="#_TocRef53985649" name="_Toc53985649">The test framework code</a></h3>

<p class=MsoNormal>The test framework code is in a subdirectory called <b>TestSuite</b>
in the code distribution available at www.MindView.net. To use it, include the
search path for the <b>TestSuite</b> subdirectory in your header, link the
object files, and include the <b>TestSuite</b> subdirectory in the library
search path. Here is the header for <b>Test.h</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: TestSuite:Test.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TEST_H</font></div>
<div class=CC1><font color=#7F7F00>#define TEST_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1><font color=#ff7700>using</font> std::ostream;</div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// fail_() has an underscore to prevent collision with</font></div>
<div class=CC1><font color=#dd0000>// ios::fail(). For consistency, test_() and succeed_()</font></div>
<div class=CC1><font color=#dd0000>// also have underscores.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#define test_(cond) \</font></div>
<div class=CC1>  do_test(cond, #cond, __FILE__, __LINE__)</div>
<div class=CC1><font color=#7F7F00>#define fail_(str) \</font></div>
<div class=CC1>  do_fail(str, __FILE__, __LINE__)</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>namespace</font> TestSuite {</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Test {</div>
<div class=CC1>  ostream* osptr;</div>
<div class=CC1>  <font color=#ff7700>long</font> nPass;</div>
<div class=CC1>  <font color=#ff7700>long</font> nFail;</div>
<div class=CC1>  <font color=#dd0000>// Disallowed:</font></div>
<div class=CC1>  Test(<font color=#ff7700>const</font> Test&amp;);</div>
<div class=CC1>  Test&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> Test&amp;);</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> do_test(<font color=#ff7700>bool</font> cond, <font color=#ff7700>const</font> string&amp; lbl,</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname, <font color=#ff7700>long</font> lineno);</div>
<div class=CC1>  <font color=#ff7700>void</font> do_fail(<font color=#ff7700>const</font> string&amp; lbl,</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname, <font color=#ff7700>long</font> lineno);</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Test(ostream* osptr = &amp;cout) {</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;osptr = osptr;</div>
<div class=CC1>    nPass = nFail = 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Test() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> run() = 0;</div>
<div class=CC1>  <font color=#ff7700>long</font> getNumPassed() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> nPass; }</div>
<div class=CC1>  <font color=#ff7700>long</font> getNumFailed() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> nFail; }</div>
<div class=CC1>  <font color=#ff7700>const</font> ostream* getStream() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> osptr; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setStream(ostream* osptr) { <font color=#ff7700>this</font>-&gt;osptr =
osptr; }</div>
<div class=CC1>  <font color=#ff7700>void</font> succeed_() { ++nPass; }</div>
<div class=CC1>  <font color=#ff7700>long</font> report() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> reset() { nPass = nFail = 0; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>} <font color=#dd0000>// namespace TestSuite</font></div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TEST_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>There are three virtual functions in the <b>Test</b> class:</p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A virtual destructor</p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The function <b>reset(&nbsp;)</b></p>

<p class=MsoList3 style='margin-left:1.0in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The pure virtual function <b>run(&nbsp;)</b></p>

<p class=MsoNormal>As explained in Volume 1, it is an error to delete a derived
heap object through a base pointer unless the base class has a virtual
destructor. Any class intended to be a base class (usually evidenced by the
presence of at least one other virtual function) should have a virtual
destructor. The default implementation of the <b>Test::reset(&nbsp;)</b> resets
the success and failure counters to zero. You might want to override this function
to reset the state of the data in your derived test object; just be sure to
call <b>Test::reset(&nbsp;)</b> explicitly in your override so that the
counters are reset. The <b>Test::run(&nbsp;)</b> member function is pure
virtual since you are required to override it in your derived class.</p>

<p class=MsoNormal>The <b>test_(&nbsp;)</b> and <b>fail_(&nbsp;)</b> macros can
include file name and line number information available from the preprocessor.
We originally omitted the trailing underscores in the names, but the <b>fail(&nbsp;)</b>
macro then collided with <b>ios::fail(&nbsp;)</b>, causing compiler errors.</p>

<p class=MsoNormal>Here is the implementation of the remainder of the <b>Test</b>
functions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: TestSuite:Test.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Test.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> TestSuite;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Test::do_test(<font color=#ff7700>bool</font> cond, <font color=#ff7700>const</font> std::string&amp;
lbl,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname, <font color=#ff7700>long</font> lineno) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(!cond)</div>
<div class=CC1>    do_fail(lbl, fname, lineno);</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    succeed_();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Test::do_fail(<font color=#ff7700>const</font> std::string&amp; lbl,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname, <font color=#ff7700>long</font> lineno) {</div>
<div class=CC1>  ++nFail;</div>
<div class=CC1>  <font color=#ff7700>if</font>(osptr) {</div>
<div class=CC1>    *osptr &lt;&lt; <font color=#ff7700>typeid</font>(*<font color=#ff7700>this</font>).name()</div>
<div class=CC1>           &lt;&lt; <font color=#007f00>&quot;failure: (&quot;</font> &lt;&lt; lbl
&lt;&lt; <font color=#007f00>&quot;) , &quot;</font> &lt;&lt; fname</div>
<div class=CC1>           &lt;&lt; <font color=#007f00>&quot; (line &quot;</font> &lt;&lt; lineno
&lt;&lt; <font color=#007f00>&quot;)&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>long</font> Test::report() <font color=#ff7700>const</font> {</div>
<div class=CC1>  <font color=#ff7700>if</font>(osptr) {</div>
<div class=CC1>    *osptr &lt;&lt; <font color=#007f00>&quot;Test \&quot;&quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(*<font color=#ff7700>this</font>).name()</div>
<div class=CC1>           &lt;&lt; <font color=#007f00>&quot;\&quot;:\n\tPassed: &quot;</font>
&lt;&lt; nPass</div>
<div class=CC1>           &lt;&lt; <font color=#007f00>&quot;\tFailed: &quot;</font> &lt;&lt;
nFail</div>
<div class=CC1>           &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> nFail;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Test</b> class keeps track of the number of successes
and failures as well as the stream where you want <b>Test::report(&nbsp;)</b>
to display the results. The <b>test_(&nbsp;)</b> and <b>fail_(&nbsp;)</b>
macros extract the current file name and line number information from the
preprocessor and pass the file name to <b>do_test(&nbsp;)</b> and the line
number to <b>do_fail(&nbsp;)</b>, which do the actual work of displaying a
message and updating the appropriate counter. We can’t think of a good reason
to allow copy and assignment of test objects, so we have disallowed these
operations by making their prototypes private and omitting their respective
function bodies.</p>

<p class=MsoNormal>Here is the header file for <b>Suite</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: TestSuite:Suite.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef SUITE_H</font></div>
<div class=CC1><font color=#7F7F00>#define SUITE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::vector;</div>
<div class=CC1><font color=#ff7700>using</font> std::logic_error;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>namespace</font> TestSuite {</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TestSuiteError : <font color=#ff7700>public</font> logic_error {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  TestSuiteError(<font color=#ff7700>const</font> string&amp; s = <font color=#007f00>&quot;&quot;</font>)</div>
<div class=CC1>  : logic_error(s) {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Suite {</div>
<div class=CC1>  string name;</div>
<div class=CC1>  ostream* osptr;</div>
<div class=CC1>  vector&lt;Test*&gt; tests;</div>
<div class=CC1>  <font color=#ff7700>void</font> reset();</div>
<div class=CC1>  <font color=#dd0000>// Disallowed ops:</font></div>
<div class=CC1>  Suite(<font color=#ff7700>const</font> Suite&amp;);</div>
<div class=CC1>  Suite&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> Suite&amp;);</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Suite(<font color=#ff7700>const</font> string&amp; name, ostream* osptr =
&amp;cout)</div>
<div class=CC1>  : name(name) { <font color=#ff7700>this</font>-&gt;osptr = osptr; }</div>
<div class=CC1>  string getName() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> name; }</div>
<div class=CC1>  <font color=#ff7700>long</font> getNumPassed() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>long</font> getNumFailed() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>const</font> ostream* getStream() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> osptr; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setStream(ostream* osptr) { <font color=#ff7700>this</font>-&gt;osptr =
osptr; }</div>
<div class=CC1>  <font color=#ff7700>void</font> addTest(Test* t) <font color=#ff7700>throw</font>(TestSuiteError);</div>
<div class=CC1>  <font color=#ff7700>void</font> addSuite(<font color=#ff7700>const</font> Suite&amp;);</div>
<div class=CC1>  <font color=#ff7700>void</font> run();  <font color=#dd0000>// Calls Test::run() repeatedly</font></div>
<div class=CC1>  <font color=#ff7700>long</font> report() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>void</font> free();  <font color=#dd0000>// Deletes tests</font></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>} <font color=#dd0000>// namespace TestSuite</font></div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// SUITE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Suite</b> class holds pointers to its <b>Test</b>
objects in a <b>vector</b>. Notice the exception specification on the <b>addTest(&nbsp;)</b>
member function. When you add a test to a suite, <b>Suite::addTest(&nbsp;)</b>
verifies that the pointer you pass is not null; if it is null, it throws a <b>TestSuiteError</b>
exception. Since this makes it impossible to add a null pointer to a suite, <b>addSuite(&nbsp;)</b>
asserts this condition on each of its tests, as do the other functions that
traverse the <b>vector</b> of tests (see the following implementation). Copy
and assignment are disallowed as they are in the <b>Test</b> class.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: TestSuite:Suite.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Suite.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> TestSuite;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Suite::addTest(Test* t) <font color=#ff7700>throw</font>(TestSuiteError) {</div>
<div class=CC1>  <font color=#dd0000>// Verify test is valid and has a stream:</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(t == 0)</div>
<div class=CC1>    <font color=#ff7700>throw</font> TestSuiteError(<font color=#007f00>&quot;Null test in
Suite::addTest&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>else</font> <font color=#ff7700>if</font>(osptr &amp;&amp; !t-&gt;getStream())</div>
<div class=CC1>    t-&gt;setStream(osptr);</div>
<div class=CC1>  tests.push_back(t);</div>
<div class=CC1>  t-&gt;reset();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Suite::addSuite(<font color=#ff7700>const</font> Suite&amp; s) {</div>
<div class=CC1><font color=#ff7700>for</font>(size_t i = 0; i &lt;
s.tests.size(); ++i) {</div>
<div class=CC1>  assert(tests[i]);</div>
<div class=CC1>addTest(s.tests[i]);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Suite::free() {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; tests.size(); ++i) {</div>
<div class=CC1>    <font color=#ff7700>delete</font> tests[i];</div>
<div class=CC1>    tests[i] = 0;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Suite::run() {</div>
<div class=CC1>  reset();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; tests.size(); ++i) {</div>
<div class=CC1>    assert(tests[i]);</div>
<div class=CC1>    tests[i]-&gt;run();</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>long</font> Suite::report() <font color=#ff7700>const</font> {</div>
<div class=CC1>  <font color=#ff7700>if</font>(osptr) {</div>
<div class=CC1>    <font color=#ff7700>long</font> totFail = 0;</div>
<div class=CC1>    *osptr &lt;&lt; <font color=#007f00>&quot;Suite \&quot;&quot;</font> &lt;&lt;
name</div>
<div class=CC1>             &lt;&lt; <font color=#007f00>&quot;\&quot;\n=======&quot;</font>;</div>
<div class=CC1>    size_t i;</div>
<div class=CC1>    <font color=#ff7700>for</font>(i = 0; i &lt; name.size(); ++i)</div>
<div class=CC1>      <span lang=SV>*osptr &lt;&lt; '=';</span></div>
<div class=CC1><span lang=SV>    *osptr &lt;&lt; <font color=#007f00>&quot;=&quot;</font>
&lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>for</font>(i = 0; i &lt;
tests.size(); ++i) {</div>
<div class=CC1>      assert(tests[i]);</div>
<div class=CC1>      totFail += tests[i]-&gt;report();</div>
<div class=CC1>    }</div>
<div class=CC1>    *osptr &lt;&lt; <font color=#007f00>&quot;=======&quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>for</font>(i = 0; i &lt; name.size(); ++i)</div>
<div class=CC1>      <span lang=SV>*osptr &lt;&lt; '=';</span></div>
<div class=CC1><span lang=SV>    *osptr &lt;&lt; <font color=#007f00>&quot;=&quot;</font>
&lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>return</font> totFail;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    <font color=#ff7700>return</font> getNumFailed();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>long</font> Suite::getNumPassed() <font color=#ff7700>const</font> {</div>
<div class=CC1>  <font color=#ff7700>long</font> totPass = 0;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; tests.size(); ++i) {</div>
<div class=CC1>    assert(tests[i]);</div>
<div class=CC1>    totPass += tests[i]-&gt;getNumPassed();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> totPass;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>long</font> Suite::getNumFailed() <font color=#ff7700>const</font> {</div>
<div class=CC1>  <font color=#ff7700>long</font> totFail = 0;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; tests.size(); ++i) {</div>
<div class=CC1>    assert(tests[i]);</div>
<div class=CC1>    totFail += tests[i]-&gt;getNumFailed();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> totFail;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Suite::reset() {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; tests.size(); ++i) {</div>
<div class=CC1>    assert(tests[i]);</div>
<div class=CC1>    tests[i]-&gt;reset();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We will be using the <b>TestSuite</b> framework wherever it
applies throughout the rest of this book.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985650" name="_Toc53985650">Debugging
techniques</a></h2>

<p class=MsoNormal>The best debugging habit is to use assertions as explained
in the beginning of this chapter; by doing so you’ll help find logic errors
before they cause real trouble. This section contains some other tips and
techniques that might help during debugging.</p>

<h3><a href="#_TocRef53985651" name="_Toc53985651">Trace macros</a></h3>

<p class=MsoNormal>Sometimes it’s useful to print the code of each statement as
it is executed, either to <b>cout</b> or to a trace file. Here’s a preprocessor
macro to accomplish this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#7F7F00>#define TRACE(ARG) cout &lt;&lt; #ARG &lt;&lt; endl; ARG</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now you can go through and surround the statements you trace
with this macro. However, this can introduce problems. For example, if you take
the statement:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>  cout &lt;&lt; i &lt;&lt; endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>and put both lines inside <b>TRACE(&nbsp;)</b> macros, you
get this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>TRACE(<font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++))</div>
<div class=CC1>TRACE(  cout &lt;&lt; i &lt;&lt; endl;)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which expands to this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout &lt;&lt; <font color=#007f00>&quot;for(int i = 0; i &lt; 100;
i++)&quot;</font> &lt;&lt; endl;</div>
<div class=CC1><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;cout &lt;&lt; i &lt;&lt;
endl;&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>cout &lt;&lt; i &lt;&lt; endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which isn’t exactly what you want. Thus, you must use this
technique carefully.</p>

<p class=MsoNormal>The following is a variation on the <b>TRACE(&nbsp;)</b>
macro:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#7F7F00>#define D(a) cout &lt;&lt; #a &quot;=[&quot; &lt;&lt; a &lt;&lt;
&quot;]&quot; &lt;&lt; endl;</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you want to display an expression, you simply put it
inside a call to <b>D(&nbsp;)</b>. The expression is displayed, followed by its
value (assuming there’s an overloaded operator <b>&lt;&lt;</b> for the result
type). For example, you can say <b>D(a + b)</b>. You can use this macro any
time you want to check an intermediate value.</p>

<p class=MsoNormal>These two macros represent the two most fundamental things
you do with a debugger: trace through the code execution and display values. A
good debugger is an excellent productivity tool, but sometimes debuggers are
not available, or it’s not convenient to use them. These techniques always
work, regardless of the situation.</p>

<h3><a href="#_TocRef53985652" name="_Toc53985652">Trace file</a></h3>

<p class=MsoNormal>DISCLAIMER: This section and the next contain code which is
officially unsanctioned by the C++ Standard. In particular, we redefine <b>cout</b>
and <b>new</b> via macros, which can cause surprising results if you’re not
careful. Our examples work on all the compilers we use, however, and provide
useful information. This is the only place in this book where we will depart
from the sanctity of standard-compliant coding practice. Use at your own risk!
Note that in order for this to work, a using-declaration must be used, so that <b>cout</b>
isn’t prefixed by its namespace, i.e. <b>std::cout</b> will not work.</p>

<p class=MsoNormal>The following code easily creates a trace file and sends all
the output that would normally go to <b>cout</b> into that file. All you must
do is <b>#define</b> TRACEON and include the header file (of course, it’s
fairly easy just to write the two key lines right into your file):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Trace.h</font></div>
<div class=CC1><font color=#dd0000>// Creating a trace file.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TRACE_H</font></div>
<div class=CC1><font color=#7F7F00>#define TRACE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#ifdef TRACEON</font></div>
<div class=CC1>std::ofstream TRACEFILE__(<font color=#007f00>&quot;TRACE.OUT&quot;</font>);</div>
<div class=CC1><font color=#7F7F00>#define cout TRACEFILE__</font></div>
<div class=CC1><font color=#7F7F00>#endif</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TRACE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here’s a simple test of the previous file:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Tracetst.cpp {-bor}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#define TRACEON</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Trace.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream
f(<font color=#007f00>&quot;Tracetst.cpp&quot;</font>);</div>
<div class=CC1>  assure(f, <font color=#007f00>&quot;Tracetst.cpp&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; f.rdbuf(); <font color=#dd0000>// Dumps file contents to
file</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because <b>cout</b> has been textually turned into something
else by <b>Trace.h</b>, all the <b>cout</b> statements in your program now send
information to the trace file. This is a convenient way of capturing your
output into a file, in case your operating system doesn’t make output
redirection easy.</p>

<h3><a href="#_TocRef53985653" name="_Toc53985653">Finding memory leaks</a></h3>

<p class=MsoNormal>The following straightforward debugging techniques are
explained in Volume 1:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;For
array bounds checking, use the <b>Array</b> template in <b>C16:Array3.cpp</b>
of Volume 1 for all arrays. You can turn off the checking and increase
efficiency when you’re ready to ship. (Although this doesn’t deal with the case
of taking a pointer to an array.)</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;Check
for non-virtual destructors in base classes.</p>

<h4>Tracking new/delete and malloc/free</h4>

<p class=MsoNormal>Common problems with memory allocation include mistakenly
calling <b>delete</b> for memory that’s not on the free store, deleting the
free store more than once, and, most often, forgetting to delete a pointer.
This section discusses a system that can help you track down these kinds of
problems.</p>

<p class=MsoNormal>As an <i>additional disclaimer</i> beyond that of the
preceding section: because of the way we overload <b>new</b>, the following
technique may not work on all platforms, and will only work for programs that
do not call the <i>function</i> <b>operator new(&nbsp;)</b> explicitly. We have been quite careful in this book to only present code that fully conforms to the C++
Standard, but in this one instance we’re making an exception for the following
reasons:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:4.0pt;
margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;Even though it’s technically illegal, it works on many compilers.<a href="#_ftn29" name="_ftnref29"><span
class=MsoFootnoteReference>[29]</span></a></p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:4.0pt;
margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;We illustrate some useful thinking along the way.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:0in;text-indent:0in'>&nbsp;</p>

<p class=MsoNormal>To use the memory checking system, you simply include the
header file <b>MemCheck.h</b>, link the <b>MemCheck.obj</b> file into your
application to intercept all the calls to <b>new</b> and <b>delete</b>, and
call the macro <b>MEM_ON(&nbsp;)</b> (explained later in this section) to
initiate memory tracing. A trace of all allocations and deallocations is
printed to the standard output (via <b>stdout</b>). When you use this system,
all calls to <b>new</b> store information about the file and line where they were called. This is accomplished by using the <i>placement syntax</i> for <b>operator
new</b>.<a href="#_ftn30" name="_ftnref30"><span
class=MsoFootnoteReference>[30]</span></a> Although you
typically use the placement syntax when you need to place objects at a specific
point in memory, it can also create an <b>operator new(&nbsp;)</b> with any
number of arguments. This is used in the following example to store the results
of the <b>__FILE__</b> and <b>__LINE__</b> macros whenever <b>new</b> is
called:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:MemCheck.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef MEMCHECK_H</font></div>
<div class=CC1><font color=#7F7F00>#define MEMCHECK_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;  </font><font color=#dd0000>// For size_t</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Usurp the new operator (both scalar and array
versions)</font></div>
<div class=CC1><font color=#ff7700>void</font>* <font color=#ff7700>operator</font> <font color=#ff7700>new</font>(std::size_t, <font color=#ff7700>const</font> <font color=#ff7700>char</font>*, <font color=#ff7700>long</font>);</div>
<div class=CC1><font color=#ff7700>void</font>* <font color=#ff7700>operator</font> <font color=#ff7700>new</font>[](std::size_t, <font color=#ff7700>const</font> <font color=#ff7700>char</font>*, <font color=#ff7700>long</font>);</div>
<div class=CC1><font color=#7F7F00>#define new new (__FILE__, __LINE__)</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>extern</font> <font color=#ff7700>bool</font> traceFlag;</div>
<div class=CC1><font color=#7F7F00>#define TRACE_ON() traceFlag = true</font></div>
<div class=CC1><font color=#7F7F00>#define TRACE_OFF() traceFlag = false</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>extern</font> <font color=#ff7700>bool</font> activeFlag;</div>
<div class=CC1><font color=#7F7F00>#define MEM_ON() activeFlag = true</font></div>
<div class=CC1><font color=#7F7F00>#define MEM_OFF() activeFlag = false</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// MEMCHECK_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>It is important to include this file in any source file in
which you want to track free store activity, but include it <i>last</i> (after
your other <b>#include</b> directives). Most headers in the standard library
are templates, and since most compilers use the <i>inclusion model</i> of
template compilation (meaning all source code is in the headers), the macro
that replaces <b>new</b> in <b>MemCheck.h</b> would usurp all instances of the <b>new</b>
operator in the library source code (and would likely result in compile
errors). Besides, you are only interested in tracking your own memory errors,
not the library’s.</p>

<p class=MsoNormal>In the following file, which contains the memory tracking
implementation, everything is done with C standard I/O rather than with C++
iostreams. It shouldn’t make a difference, since we’re not interfering with
iostreams’ use of the free store, but when we tried it, some compilers
complained. All compilers were happy with the <b>&lt;cstdio&gt;</b> version.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:MemCheck.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#7F7F00>#undef new</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Global flags set by macros in MemCheck.h</font></div>
<div class=CC1><font color=#ff7700>bool</font> traceFlag = <font color=#ff7700>true</font>;</div>
<div class=CC1><font color=#ff7700>bool</font> activeFlag = <font color=#ff7700>false</font>;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>namespace</font> {</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Memory map entry type</font></div>
<div class=CC1><font color=#ff7700>struct</font> Info {</div>
<div class=CC1>  <font color=#ff7700>void</font>* ptr;</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* file;</div>
<div class=CC1>  <font color=#ff7700>long</font> line;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Memory map data</font></div>
<div class=CC1><font color=#ff7700>const</font> size_t MAXPTRS = 10000u;</div>
<div class=CC1>Info memMap[MAXPTRS];</div>
<div class=CC1>size_t nptrs = 0;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Searches the map for an address</font></div>
<div class=CC1><font color=#ff7700>int</font> findPtr(<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; nptrs; ++i)</div>
<div class=CC1>    <font color=#ff7700>if</font>(memMap[i].ptr == p)</div>
<div class=CC1>      <font color=#ff7700>return</font> i;</div>
<div class=CC1>  <font color=#ff7700>return</font> -1;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> delPtr(<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>  <font color=#ff7700>int</font> pos = findPtr(p);</div>
<div class=CC1>  assert(pos &gt;= 0);</div>
<div class=CC1>  <font color=#dd0000>// Remove pointer from map</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = pos; i &lt; nptrs-1; ++i)</div>
<div class=CC1>    <span lang=SV>memMap[i] = memMap[i+1];</span></div>
<div class=CC1><span lang=SV>  --nptrs;</span></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Dummy type for static destructor</font></div>
<div class=CC1><font color=#ff7700>struct</font> Sentinel {</div>
<div class=CC1>  ~Sentinel() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(nptrs &gt; 0) {</div>
<div class=CC1>      printf(<font color=#007f00>&quot;Leaked memory at:\n&quot;</font>);</div>
<div class=CC1>      <font color=#ff7700>for</font>(size_t i = 0; i &lt; nptrs; ++i)</div>
<div class=CC1>        printf(<font color=#007f00>&quot;\t%p (file: %s, line %ld)\n&quot;</font>,</div>
<div class=CC1>          <span lang=SV>memMap[i].ptr, memMap[i].file,
memMap[i].line);</span></div>
<div class=CC1><span lang=SV>    </span>}</div>
<div class=CC1>    <font color=#ff7700>else</font></div>
<div class=CC1>      printf(<font color=#007f00>&quot;No user memory leaks!\n&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Static dummy object</font></div>
<div class=CC1>Sentinel s;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>} <font color=#dd0000>// End anonymous namespace</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Overload scalar new</font></div>
<div class=CC1><font color=#ff7700>void</font>*</div>
<div class=CC1><font color=#ff7700>operator</font> <font color=#ff7700>new</font>(size_t siz, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* file, <font color=#ff7700>long</font> line) {</div>
<div class=CC1>  <font color=#ff7700>void</font>* p = malloc(siz);</div>
<div class=CC1>  <font color=#ff7700>if</font>(activeFlag) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(nptrs == MAXPTRS) {</div>
<div class=CC1>      printf(<font color=#007f00>&quot;memory map too small (increase
MAXPTRS)\n&quot;</font>);</div>
<div class=CC1>      exit(1);</div>
<div class=CC1>    }</div>
<div class=CC1>    memMap[nptrs].ptr = p;</div>
<div class=CC1>    memMap[nptrs].file = file;</div>
<div class=CC1>    memMap[nptrs].line = line;</div>
<div class=CC1>    ++nptrs;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>if</font>(traceFlag) {</div>
<div class=CC1>    printf(<font color=#007f00>&quot;Allocated %u bytes at address %p
&quot;</font>, siz, p);</div>
<div class=CC1>    printf(<font color=#007f00>&quot;(file: %s, line: %ld)\n&quot;</font>, file,
line);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> p;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Overload array new</font></div>
<div class=CC1><font color=#ff7700>void</font>*</div>
<div class=CC1><font color=#ff7700>operator</font> <font color=#ff7700>new</font>[](size_t siz, <font color=#ff7700>const</font>
<font color=#ff7700>char</font>* file, <font color=#ff7700>long</font> line) {</div>
<div class=CC1>  <font color=#ff7700>return</font> <font color=#ff7700>operator</font> <font color=#ff7700>new</font>(siz, file, line);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Override scalar delete</font></div>
<div class=CC1><font color=#ff7700>void</font> <font color=#ff7700>operator</font> <font color=#ff7700>delete</font>(<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(findPtr(p) &gt;= 0) {</div>
<div class=CC1>    free(p);</div>
<div class=CC1>    assert(nptrs &gt; 0);</div>
<div class=CC1>    delPtr(p);</div>
<div class=CC1>    <font color=#ff7700>if</font>(traceFlag)</div>
<div class=CC1>      printf(<font color=#007f00>&quot;Deleted memory at address
%p\n&quot;</font>, p);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>else</font> <font color=#ff7700>if</font>(!p &amp;&amp; activeFlag)</div>
<div class=CC1>    printf(<font color=#007f00>&quot;Attempt to delete unknown pointer:
%p\n&quot;</font>, p);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Override array delete</font></div>
<div class=CC1><font color=#ff7700>void</font> <font color=#ff7700>operator</font> <font color=#ff7700>delete</font>[](<font color=#ff7700>void</font>* p) {</div>
<div class=CC1>  <font color=#ff7700>operator</font> <font color=#ff7700>delete</font>(p);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The Boolean flags <b>traceFlag</b> and <b>activeFlag</b> are
global, so they can be modified in your code by the macros <b>TRACE_ON(&nbsp;)</b>,
<b>TRACE_OFF(&nbsp;)</b>, <b>MEM_ON(&nbsp;)</b>, and <b>MEM_OFF(&nbsp;)</b>. In
general, enclose all the code in your <b>main(&nbsp;)</b> within a <b>MEM_ON(&nbsp;)</b>-<b>MEM_OFF(&nbsp;)</b>
pair so that memory is always tracked. Tracing, which echoes the activity of
the replacement functions for <b>operator new(&nbsp;)</b> and <b>operator
delete(&nbsp;)</b>, is on by default, but you can turn it off with <b>TRACE_OFF(&nbsp;)</b>.
In any case, the final results are always printed (see the test runs later in this
chapter).</p>

<p class=MsoNormal>The <b>MemCheck</b> facility tracks memory by keeping all
addresses allocated by <b>operator new(&nbsp;)</b> in an array of <b>Info</b>
structures, which also holds the file name and line number where the call to <b>new</b>
occurred. To prevent collision with any names you have placed in the global
namespace, as much information as possible is kept inside the anonymous
namespace. The <b>Sentinel</b> class exists solely to call a static object
destructor as the program shuts down. This destructor inspects <b>memMap</b> to
see if any pointers are waiting to be deleted (indicating a memory leak).</p>

<p class=MsoNormal>Our <b>operator new(&nbsp;)</b> uses <b>malloc(&nbsp;)</b>
to get memory, and then adds the pointer and its associated file information to
<b>memMap</b>. The <b>operator delete(&nbsp;)</b> function undoes all that work
by calling <b>free(&nbsp;)</b> and decrementing <b>nptrs</b>, but first it
checks to see if the pointer in question is in the map in the first place. If
it isn’t, either you’re trying to delete an address that isn’t on the free
store, or you’re trying to delete one that’s already been deleted and removed
from the map. The <b>activeFlag</b> variable is important here because we don’t
want to process any deallocations from any system shutdown activity. By calling
<b>MEM_OFF(&nbsp;)</b> at the end of your code, <b>activeFlag</b> will be set
to <b>false</b>, and such subsequent calls to <b>delete</b> will be ignored. (That’s
bad in a real program, but our purpose here is to find <i>your</i> leaks; we’re
not debugging the library.) For simplicity, we forward all work for array <b>new</b>
and <b>delete</b> to their scalar counterparts.</p>

<p class=MsoNormal>The following is a simple test using the <b>MemCheck</b>
facility:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:MemTest.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} MemCheck</font></div>
<div class=CC1><font color=#dd0000>// Test of MemCheck system.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;MemCheck.h&quot;   </font><font color=#dd0000>// Must appear last!</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Foo {</div>
<div class=CC1>  <font color=#ff7700>char</font>* s;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Foo(<font color=#ff7700>const</font> <font color=#ff7700>char</font>*s ) {</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;s = <font color=#ff7700>new</font> <font color=#ff7700>char</font>[strlen(s) + 1];</div>
<div class=CC1>    strcpy(<font color=#ff7700>this</font>-&gt;s, s);</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Foo() { <font color=#ff7700>delete</font> [] s; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  MEM_ON();</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;hello&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>int</font>* p = <font color=#ff7700>new</font> <font color=#ff7700>int</font>;</div>
<div class=CC1>  <font color=#ff7700>delete</font> p;</div>
<div class=CC1>  <font color=#ff7700>int</font>* q = <font color=#ff7700>new</font> <font color=#ff7700>int</font>[3];</div>
<div class=CC1>  <font color=#ff7700>delete</font> [] q;</div>
<div class=CC1>  <font color=#ff7700>int</font>* r;</div>
<div class=CC1>  <font color=#ff7700>delete</font> r;</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v;</div>
<div class=CC1>  v.push_back(1);</div>
<div class=CC1>  Foo s(<font color=#007f00>&quot;goodbye&quot;</font>);</div>
<div class=CC1>  MEM_OFF();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example verifies that you can use <b>MemCheck</b> in
the presence of streams, standard containers, and classes that allocate memory
in constructors. The pointers <b>p</b> and <b>q</b> are allocated and
deallocated without any problem, but <b>r</b> is not a valid heap pointer, so
the output indicates the error as an attempt to delete an unknown pointer:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>hello</div>
<div class=CC1>Allocated 4 bytes at address 0xa010778 (file:
memtest.cpp, line: 25)</div>
<div class=CC1>Deleted memory at address 0xa010778</div>
<div class=CC1>Allocated 12 bytes at address 0xa010778 (file:
memtest.cpp, line: 27)</div>
<div class=CC1>Deleted memory at address 0xa010778</div>
<div class=CC1>Attempt to <font color=#ff7700>delete</font> unknown pointer: 0x1</div>
<div class=CC1>Allocated 8 bytes at address 0xa0108c0 (file:
memtest.cpp, line: 14)</div>
<div class=CC1>Deleted memory at address 0xa0108c0</div>
<div class=CC1>No user memory leaks!</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because of the call to <b>MEM_OFF(&nbsp;)</b>, no subsequent
calls to <b>operator delete(&nbsp;)</b> by <b>vector</b> or <b>ostream</b> are
processed. You still might get some calls to <b>delete</b> from reallocations
performed by the containers.</p>

<p class=MsoNormal>If you call <b>TRACE_OFF(&nbsp;)</b> at the beginning of the
program, the output is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>hello</div>
<div class=CC1>Attempt to <font color=#ff7700>delete</font> unknown pointer: 0x1</div>
<div class=CC1>No user memory leaks!</div>

</div>

<div class=CC1>&nbsp;</div>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985654" name="_Toc53985654">Summary</a></h2>

<p class=MsoNormal>Much of the headache of software engineering can be avoided
by being deliberate about what you’re doing. You’ve probably been using mental
assertions as you’ve crafted your loops and functions, even if you haven’t
routinely used the <b>assert(&nbsp;)</b> macro. If you’ll use <b>assert(&nbsp;)</b>,
you’ll find logic errors sooner and end up with more readable code as well.
Remember to only use assertions for invariants, though, and not for runtime
error handling.</p>

<p class=MsoNormal>Nothing will give you more peace of mind than thoroughly
tested code. If it’s been a hassle for you in the past, use an automated
framework, such as the one we’ve presented here, to integrate routine testing
into your daily work. You (and your users!) will be glad you did.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985655" name="_Toc53985655">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a test program using the <b>TestSuite</b> Framework for the
standard <b>vector</b> class that thoroughly tests the following member
functions with a <b>vector</b> of integers: <b>push_back(&nbsp;)</b> (appends
an element to the end of the <b>vector</b>), <b>front(&nbsp;)</b> (returns the
first element in the <b>vector</b>), <b>back(&nbsp;)</b> (returns the last
element in the <b>vector</b>), <b>pop_back(&nbsp;)</b> (removes the last
element without returning it), <b>at(&nbsp;)</b> (returns the element in a
specified index position), and <b>size(&nbsp;)</b> (returns the number of
elements). Be sure to verify that <b>vector::at(&nbsp;)</b> throws a <b>std::out_of_range</b>
exception if the supplied index is out of range.</p>

<p class=ExercisesCharCharCharCharChar style='margin-bottom:6.0pt'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Suppose you are asked to develop a class named <b>Rational</b>
that supports rational numbers (fractions). The fraction in a <b>Rational</b>
object should always be stored in lowest terms, and a denominator of zero is an
error. Here is a sample interface for such a <b>Rational</b> class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:Rational.h {-xo}</font></div>
<div class=CC1><font color=#7F7F00>#ifndef RATIONAL_H</font></div>
<div class=CC1><font color=#7F7F00>#define RATIONAL_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iosfwd&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Rational {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Rational(<font color=#ff7700>int</font> numerator = 0, <font color=#ff7700>int</font> denominator = 1);</div>
<div class=CC1>  Rational <font color=#ff7700>operator</font>-() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>friend</font> Rational <font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                            <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> Rational <font color=#ff7700>operator</font>-(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                            <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> Rational <font color=#ff7700>operator</font>*(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                            <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> Rational <font color=#ff7700>operator</font>/(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                            <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(std::ostream&amp;, <font color=#ff7700>const</font>
Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::istream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&gt;&gt;(std::istream&amp;, Rational&amp;);</div>
<div class=CC1>  Rational&amp; <font color=#ff7700>operator</font>+=(<font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  Rational&amp; <font color=#ff7700>operator</font>-=(<font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  Rational&amp; <font color=#ff7700>operator</font>*=(<font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  Rational&amp; <font color=#ff7700>operator</font>/=(<font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                        <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                        <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;=(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                         <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;=(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                         <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                         <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font> Rational&amp;,</div>
<div class=CC1>                         <font color=#ff7700>const</font> Rational&amp;);</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// RATIONAL_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Write a complete
specification for this class, including preconditions, postconditions, and
exception specifications.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a test using the <b>TestSuite</b> framework that thoroughly
tests all the specifications from the previous exercise, including testing
exceptions.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Implement the <b>Rational</b> class so that all the tests from
the previous exercise pass. Use assertions only for invariants.</p>

<p class=ExercisesCharCharCharCharChar style='margin-bottom:6.0pt'><span
style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The file <b>BuggedSearch.cpp</b> below contains a binary search
function that searches the range <b>[beg, end)</b> for <b>what</b>. There are
some bugs in the algorithm. Use the trace techniques from this chapter to debug
the search function.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:BuggedSearch.cpp {-xo}</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// This function is only one with bugs</font></div>
<div class=CC1><font color=#ff7700>int</font>* binarySearch(<font color=#ff7700>int</font>* beg, <font color=#ff7700>int</font>* end, <font color=#ff7700>int</font> what) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(end - beg != 1) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(*beg == what) <font color=#ff7700>return</font> beg;</div>
<div class=CC1>    <font color=#ff7700>int</font> mid = (end - beg) / 2;</div>
<div class=CC1>    <font color=#ff7700>if</font>(what &lt;= beg[mid]) end = beg + mid;</div>
<div class=CC1>    <font color=#ff7700>else</font> beg = beg + mid;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> 0;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> BinarySearchTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { SZ = 10 };</div>
<div class=CC1>  <font color=#ff7700>int</font>* data;</div>
<div class=CC1>  <font color=#ff7700>int</font> max; <font color=#dd0000>// Track largest number</font></div>
<div class=CC1>  <font color=#ff7700>int</font> current; <font color=#dd0000>// Current non-contained number</font></div>
<div class=CC1>               <font color=#dd0000>// Used in notContained()</font></div>
<div class=CC1>  <font color=#dd0000>// Find the next number not contained in the array</font></div>
<div class=CC1>  <font color=#ff7700>int</font> notContained() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(data[current] + 1 == data[current + 1])</div>
<div class=CC1>      ++current;</div>
<div class=CC1>    <font color=#ff7700>if</font>(current &gt;= SZ) <font color=#ff7700>return</font> max + 1;</div>
<div class=CC1>    <font color=#ff7700>int</font> retValue = data[current++] + 1;</div>
<div class=CC1>    <font color=#ff7700>return</font> retValue;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> setData() {</div>
<div class=CC1>    data = <font color=#ff7700>new</font> <font color=#ff7700>int</font>[SZ];</div>
<div class=CC1>    assert(!max);</div>
<div class=CC1>    <font color=#dd0000>// Input values with increments of one.  Leave</font></div>
<div class=CC1>    <font color=#dd0000>// out some values on both odd and even indexes.</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ;</div>
<div class=CC1>        rand() % 2 == 0 ? max += 1 : max += 2)</div>
<div class=CC1>      data[i++] = max;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testInBound() {</div>
<div class=CC1>    <font color=#dd0000>// Test locations both odd and even</font></div>
<div class=CC1>    <font color=#dd0000>// not contained and contained</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = SZ; --i &gt;=0;)</div>
<div class=CC1>      test_(binarySearch(data, data + SZ, data[i]));</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = notContained(); i &lt; max;</div>
<div class=CC1>        i = notContained())</div>
<div class=CC1>      test_(!binarySearch(data, data + SZ, i));</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testOutBounds() {</div>
<div class=CC1>    <font color=#dd0000>// Test lower values</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = data[0]; --i &gt; data[0] - 100;)</div>
<div class=CC1>      test_(!binarySearch(data, data + SZ, i));</div>
<div class=CC1>    <font color=#dd0000>// Test higher values</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = data[SZ - 1];</div>
<div class=CC1>        ++i &lt; data[SZ -1] + 100;)</div>
<div class=CC1>      test_(!binarySearch(data, data + SZ, i));</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BinarySearchTest() { max = current = 0; }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    setData();</div>
<div class=CC1>    testInBound();</div>
<div class=CC1>    testOutBounds();</div>
<div class=CC1>    <font color=#ff7700>delete</font> [] data;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  BinarySearchTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section11>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985656" name="_Toc53985656">Part 2: The Standard C++ Library</a></h1>

<p class=Intro style='margin-left:.25in'>Standard C++ not only incorporates all the Standard C libraries
(with small additions and changes to support type safety), it also adds
libraries of its own. These libraries are far more powerful than those in
Standard C; the leverage you get from them is analogous to the leverage you get
from changing from C to C++.</p>

<p class=MsoNormal>This section of the book gives you an in-depth introduction
to key portions of the Standard C++ library.</p>

<p class=MsoNormal>The most complete and also the most obscure reference to the
full libraries is the Standard itself. Bjarne Stroustrup’s <i>The C++
Programming Language, Third Edition </i>(Addison Wesley, 2000) remains a
reliable reference for both the language and the library. The most celebrated
library-only reference is <i>The C++ Standard Library: A Tutorial and Reference</i>,
by Nicolai Josuttis (Addison Wesley, 1999). The goal of the chapters in this
part of the book is to provide you with an encyclopedia of descriptions and
examples so that you’ll have a good starting point for solving any problem that
requires the use of the Standard libraries. However, some techniques and topics
are rarely used and are not covered here. If you can’t find it in these
chapters, reach for the other two books; this book is not intended to replace
those books but rather to complement them. In particular, we hope that after
going through the material in the following chapters you’ll have a much easier
time understanding those books.</p>

<p class=MsoNormal>You will notice that these chapters do not contain
exhaustive documentation describing every function and class in the Standard
C++ library. We’ve left the full descriptions to others; in particular to P.J. Plauger’s <i>Dinkumware C/C++ Library Reference</i> at http://www.dinkumware.com.
This is an excellent online source of standard library documentation in HTML format that you can keep resident on your computer and view with a
Web browser whenever you need to look something up. You can view this online or
purchase it for local viewing. It contains complete reference pages for the
both the C and C++ libraries (so it’s good to use for all your Standard C/C++
programming questions). Electronic documentation is effective not only because
you can always have it with you, but also because you can do an electronic
search.</p>

<p class=MsoNormal>When you’re actively programming, these resources should
satisfy your reference needs (and you can use them to look up anything in this
chapter that isn’t clear to you). Appendix A lists additional references.</p>

<p class=MsoNormal>The first chapter in this section introduces the Standard
C++ <b>string</b> class, which is a powerful tool that simplifies most of the
text-processing chores you might have. Chances are, anything you’ve done to
character strings with lines of code in C can be done with a member function
call in the <b>string</b> class.</p>

<p class=MsoNormal>Chapter 4 covers the <b>iostreams</b> library, which
contains classes for processing input and output with files, string targets,
and the system console.</p>

<p class=MsoNormal>Although Chapter 5, “Templates in Depth,” is not explicitly
a library chapter, it is necessary preparation for the two chapters that
follow. In Chapter 6 we examine the generic algorithms offered by the Standard
C++ library. Because they are implemented with templates, these algorithms can
be applied to any <i>sequence</i> of objects. Chapter 7 covers the standard
containers and their associated iterators. We cover algorithms first because
they can be fully explored by using only arrays and the <b>vector</b> container
(which we have been using since early in Volume 1). It is also natural to use
the standard algorithms in connection with containers, so it’s good to be
familiar with the algorithms before studying the containers.</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section12>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985657" name="_Toc53985657">3: Strings in Depth</a></h1>

<p class=Intro style='margin-left:.25in'>String processing with character arrays is one of the biggest
time–wasters in C. Character arrays require the programmer to keep track of the
difference between static quoted strings and arrays created on the stack and
the heap, and the fact that sometimes you’re passing around a <b>char*</b> and
sometimes you must copy the whole array.</p>

<p class=MsoNormal>Especially because string manipulation is so common,
character arrays are a great source of misunderstandings and bugs. Despite
this, creating string classes remained a common exercise for beginning C++ programmers
for many years. The Standard C++ library <b>string</b> class solves the problem of character array manipulation once and for all, keeping track of memory even during
assignments and copy-constructions. You simply don’t need to think about it.</p>

<p class=MsoNormal>This chapter<a href="#_ftn31" name="_ftnref31"><span
class=MsoFootnoteReference>[31]</span></a> examines
the Standard C++ <b>string</b> class, beginning with a look at what constitutes
a C++ string and how the C++ version differs from a traditional C character
array. You’ll learn about operations and manipulations using <b>string</b>
objects, and you’ll see how C++ <b>string</b>s accommodate variation in
character sets and string data conversion.</p>

<p class=MsoNormal>Handling text is one of the oldest programming applications,
so it’s not surprising that the C++ <b>string</b> draws heavily on the ideas and
terminology that have long been used in C and other languages. As you begin to
acquaint yourself with C++ <b>string</b>s, this fact should be reassuring. No
matter which programming idiom you choose, there are three common things you
want to do with a <b>string</b>:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create or modify the sequence of characters stored in the <b>string</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Detect the presence or absence of elements within the <b>string</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Translate between various schemes for representing <b>string</b>
characters.</p>

<p class=MsoNormal>You’ll see how each of these jobs is accomplished using C++ <b>string</b>
objects.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef15743851" name="_Toc15743851">What’s in a string?</a></h2>

<p class=MsoNormal>In C, a string is simply an array of characters that always
includes a binary zero (often called the <i>null terminator</i>) as its final
array element. There are significant differences between C++ <b>string</b>s and
their C progenitors. First, and most important, C++ <b>string</b>s hide the
physical representation of the sequence of characters they contain. You don’t need
to be concerned about array dimensions or null terminators. A <b>string</b>
also contains certain “housekeeping” information about the size and storage
location of its data. Specifically, a C++ <b>string</b> object knows its
starting location in memory, its content, its length in characters, and the
length in characters to which it can grow before the <b>string</b> object must
resize its internal data buffer. C++ strings thus greatly reduce the likelihood
of making three of the most common and destructive C programming errors:
overwriting array bounds, trying to access arrays through uninitialized or
incorrectly valued pointers, and leaving pointers “dangling” after an array
ceases to occupy the storage that was once allocated to it.</p>

<p class=MsoNormal>The exact implementation of memory layout for the string
class is not defined by the C++ Standard. This architecture is intended to be
flexible enough to allow differing implementations by compiler vendors, yet
guarantee predictable behavior for users. In particular, the exact conditions
under which storage is allocated to hold data for a string object are not
defined. String allocation rules were formulated to allow but not require a
reference-counted implementation, but whether or not the implementation uses reference counting, the semantics must be the same. To put this a bit differently,
in C, every <b>char</b> array occupies a unique physical region of memory. In
C++, individual <b>string</b> objects may or may not occupy unique physical
regions of memory, but if reference counting avoids storing duplicate copies of
data, the individual objects must look and act as though they exclusively own unique
regions of storage. For example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StringStorage.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef STRINGSTORAGE_H</font></div>
<div class=CC1><font color=#7F7F00>#define STRINGSTORAGE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1><font color=#ff7700>using</font> std::endl;</div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> StringStorageTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    string s1(<font color=#007f00>&quot;12345&quot;</font>);</div>
<div class=CC1>    <font color=#dd0000>// This may copy the first to the second or</font></div>
<div class=CC1>    <font color=#dd0000>// use reference counting to simulate a copy:</font></div>
<div class=CC1>    string s2 = s1;</div>
<div class=CC1>    test_(s1 == s2);</div>
<div class=CC1>    <font color=#dd0000>// Either way, this statement must ONLY modify s1:</font></div>
<div class=CC1>    s1[0] = '6';</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;s1 = &quot;</font> &lt;&lt; s1
&lt;&lt; endl;  <font color=#dd0000>// 62345</font></div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;s2 = &quot;</font> &lt;&lt; s2
&lt;&lt; endl;  <font color=#dd0000>// 12345</font></div>
<div class=CC1>    test_(s1 != s2);</div>
<div class=CC1>  <span lang=SV>}</span></div>
<div class=CC1><span lang=SV>};</span></div>
<div class=CC1><span lang=SV>#endif <font color=#dd0000>//
STRINGSTORAGE_H ///:~</span></font></div>

</div>

<div class=CC1><span lang=SV>&nbsp;</span></div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=SV><font color=#dd0000>//: C03:StringStorage.cpp</span></font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;StringStorage.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  StringStorageTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We say that an implementation that only makes unique copies
when a string is modified uses a <i>copy-on-write</i> strategy. This approach
saves time and space when strings are used only as value parameters or in other
read-only situations.</p>

<p class=MsoNormal>Whether a library implementation uses reference counting or
not should be transparent to users of the <b>string</b> class. Unfortunately,
this is not always the case. In multithreaded programs, it is practically
impossible to use a reference-counting implementation safely.<a href="#_ftn32" name="_ftnref32"><span
class=MsoFootnoteReference>[32]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef424692472" name="_Toc424692472">Creating and initializing C++
strings</a></h2>

<p class=MsoNormal>Creating and initializing strings is a straightforward
proposition and fairly flexible. In the <b>SmallString.cpp</b> example below,
the first <b>string</b>, <b>imBlank</b>, is declared but contains no initial
value. Unlike a C <b>char</b> array, which would contain a random and
meaningless bit pattern until initialization, <b>imBlank</b> does contain
meaningful information. This <b>string</b> object is initialized to hold “no
characters” and can properly report its zero length and absence of data
elements using class member functions.</p>

<p class=MsoNormal>The next string, <b>heyMom</b>, is initialized by the
literal argument “Where are my socks?” This form of initialization uses a
quoted character array as a parameter to the <b>string</b> constructor. By
contrast, <b>standardReply</b> is simply initialized with an assignment. The
last string of the group, <b>useThisOneAgain</b>, is initialized using an
existing C++ <b>string</b> object. Put another way, this example illustrates
that <b>string</b> objects let you do the following:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create an empty <b>string</b> and defer initializing it with
character data.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Initialize a <b>string</b> by passing a literal, quoted character
array as an argument to the constructor.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Initialize a <b>string</b> using the equal sign (<b>=</b>).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use one <b>string</b> to initialize another.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:SmallString.cpp</a></font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string imBlank;</div>
<div class=CC1>  string heyMom(<font color=#007f00>&quot;Where are my socks?&quot;</font>);</div>
<div class=CC1>  string standardReply = <font color=#007f00>&quot;Beamed into deep &quot;</font></div>
<div class=CC1>    <font color=#007f00>&quot;space on wide angle dispersion?&quot;</font>;</div>
<div class=CC1>  string useThisOneAgain(standardReply);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>These are the simplest forms of <b>string</b>
initialization, but variations offer more flexibility and control. You can do
the following:</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use a portion of either a C <b>char</b> array or a C++ <b>string</b>.</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Combine different sources of initialization data using <b>operator+</b>.</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use the <b>string</b> object’s <b>substr(&nbsp;)</b> member function to create a substring.</p>

<p class=MsoNormal style='margin-left:0in'>Here’s a program that illustrates
these features:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:SmallString2.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s1(<font color=#007f00>&quot;What is the sound of one clam
napping?&quot;</font>);</div>
<div class=CC1>  string s2(<font color=#007f00>&quot;Anything worth doing is worth
overdoing.&quot;</font>);</div>
<div class=CC1>  string s3(<font color=#007f00>&quot;I saw Elvis in a UFO&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Copy the first 8 chars:</font></div>
<div class=CC1>  string s4(s1, 0, 8);</div>
<div class=CC1>  cout &lt;&lt; s4 &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Copy 6 chars from the middle of the source:</font></div>
<div class=CC1>  string s5(s2, 15, 6);</div>
<div class=CC1>  cout &lt;&lt; s5 &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Copy from middle to end:</font></div>
<div class=CC1>  string s6(s3, 6, 15);</div>
<div class=CC1>  cout &lt;&lt; s6 &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Copy many different things:</font></div>
<div class=CC1>  string quoteMe = s4 + <font color=#007f00>&quot;that&quot;</font> +</div>
<div class=CC1>  <font color=#dd0000>// substr() copies 10 chars at element 20</font></div>
<div class=CC1>  s1.substr(20, 10) + s5 +</div>
<div class=CC1>  <font color=#dd0000>// substr() copies up to either 100 char</font></div>
<div class=CC1>  <font color=#dd0000>// or eos starting at element 5</font></div>
<div class=CC1>  <font color=#007f00>&quot;with&quot;</font> + s3.substr(5, 100) +</div>
<div class=CC1>  <font color=#dd0000>// OK to copy a single char this way</font></div>
<div class=CC1>  s1.substr(37, 1);</div>
<div class=CC1>  cout &lt;&lt; quoteMe &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>string</b> member function <b>substr(&nbsp;)</b>
takes a starting position as its first argument and the number of characters to
select as the second argument. Both arguments have default values. If you say <b>substr(&nbsp;)</b>
with an empty argument list, you produce a copy of the entire <b>string</b>, so
this is a convenient way to duplicate a <b>string</b>.</p>

<p class=MsoNormal>Here’s the output from the program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>What is</div>
<div class=CC1>doing</div>
<div class=CC1>Elvis in a UFO</div>
<div class=CC1>What is that one clam doing
with Elvis in a UFO?</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice the final line of the example. C++ allows <b>string</b>
initialization techniques to be mixed in a single statement, a flexible and
convenient feature. Also notice that the last initializer copies <i>just one
character</i> from the source <b>string</b>.</p>

<p class=MsoNormal>Another slightly more subtle initialization technique
involves the use of the <b>string</b> iterators <b>string::begin(&nbsp;)</b>
and <b>string::end(&nbsp;)</b>. This technique treats a <b>string</b> like a <i>container</i>
object (which you’ve seen primarily in the form of <b>vector</b> so far—you’ll
see many more containers in Chapter 7), which uses <i>iterators</i> to indicate
the start and end of a sequence of characters. In this way you can hand a <b>string</b>
constructor two iterators, and it copies from one to the other into the new <b>string</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StringIterators.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string source(<font color=#007f00>&quot;xxx&quot;</font>);</div>
<div class=CC1>  string s(source.begin(), source.end());</div>
<div class=CC1>  assert(s == source);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The iterators are not restricted to <b>begin(&nbsp;)</b> and
<b>end(&nbsp;)</b>; you can increment, decrement, and add integer offsets to
them, allowing you to extract a subset of characters from the source <b>string</b>.</p>

<p class=MsoNormal>C++ strings may <i>not</i> be initialized with single
characters or with ASCII or other integer values. You can initialize a string
with a number of copies of a single character, however:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:UhOh.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Error: no single char inits</font></div>
<div class=CC1>  <font color=#dd0000>//! string nothingDoing1('a');</font></div>
<div class=CC1>  <font color=#dd0000>// Error: no integer inits</font></div>
<div class=CC1>  <font color=#dd0000>//! string nothingDoing2(0x37);</font></div>
<div class=CC1>  <font color=#dd0000>// The following is legal:</font></div>
<div class=CC1>  string okay(5, 'a');</div>
<div class=CC1>  assert(okay == string(<font color=#007f00>&quot;aaaaa&quot;</font>));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first argument indicates the number of copies of the
second argument to place in the string. The second argument can only be a
single <b>char</b>, not a <b>char</b> array.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef15743853" name="_Toc15743853">Operating on strings</a></h2>

<p class=MsoNormal>If you’ve programmed in C, you are accustomed to the family
of functions that write, search, modify, and copy <b>char</b> arrays. There are
two unfortunate aspects of the Standard C library functions for handling <b>char</b>
arrays. First, there are two loosely organized families of them: the “plain”
group, and the ones that require you to supply a count of the number of
characters to be considered in the operation at hand. The roster of functions
in the C <b>char</b> array library shocks the unsuspecting user with a long
list of cryptic, mostly unpronounceable names. Although the type and number of
arguments to the functions are somewhat consistent, to use them properly you
must be attentive to details of function naming and parameter passing.</p>

<p class=MsoNormal>The second inherent trap of the standard C <b>char</b> array
tools is that they all rely explicitly on the assumption that the character
array includes a null terminator. If by oversight or error the null is omitted
or overwritten, there’s little to keep the C <b>char</b> array functions from
manipulating the memory beyond the limits of the allocated space, sometimes
with disastrous results.</p>

<p class=MsoNormal>C++ provides a vast improvement in the convenience and
safety of <b>string</b> objects. For purposes of actual string handling
operations, there are about the same number of distinct member function names
in the <b>string</b> class as there are functions in the C library, but because
of overloading the functionality is much greater. Coupled with sensible naming
practices and the judicious use of default arguments, these features combine to
make the <b>string</b> class much easier to use than the C library <b>char</b>
array functions.</p>

<h3><a href="#_TocRef15743854" name="_Toc15743854">Appending, inserting,<br>
and concatenating strings</a></h3>

<p class=MsoNormal>One of the most valuable and convenient aspects of C++ strings
is that they grow as needed, without intervention on the part of the
programmer. Not only does this make string-handling code inherently more
trustworthy, it also almost entirely eliminates a tedious “housekeeping”
chore—keeping track of the bounds of the storage where your strings live. For
example, if you create a string object and initialize it with a string of 50
copies of ‘X’, and later store in it 50 copies of “Zowie”, the object itself
will reallocate sufficient storage to accommodate the growth of the data.
Perhaps nowhere is this property more appreciated than when the strings
manipulated in your code change size and you don’t know how big the change is. The
string member functions <b>append(&nbsp;)</b> and <b>insert(&nbsp;)</b>
transparently reallocate storage when a string grows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StrSize.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string bigNews(<font color=#007f00>&quot;I saw Elvis in a UFO. &quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; bigNews &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// How much data have we actually got?</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Size = &quot;</font> &lt;&lt;
bigNews.size() &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// How much can we store without reallocating?</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Capacity = &quot;</font> &lt;&lt;
bigNews.capacity() &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Insert this string in bigNews immediately</font></div>
<div class=CC1>  <font color=#dd0000>// before bigNews[1]:</font></div>
<div class=CC1>  bigNews.insert(1, <font color=#007f00>&quot; thought I&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; bigNews &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Size = &quot;</font> &lt;&lt;
bigNews.size() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Capacity = &quot;</font> &lt;&lt;
bigNews.capacity() &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Make sure that there will be this much space</font></div>
<div class=CC1>  bigNews.reserve(500);</div>
<div class=CC1>  <font color=#dd0000>// Add this to the end of the string:</font></div>
<div class=CC1>  bigNews.append(<font color=#007f00>&quot;I've been working too
hard.&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; bigNews &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Size = &quot;</font> &lt;&lt;
bigNews.size() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Capacity = &quot;</font> &lt;&lt;
bigNews.capacity() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here is the output from one particular compiler:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>I saw Elvis in a UFO.</div>
<div class=CC1>Size = 22</div>
<div class=CC1>Capacity = 31</div>
<div class=CC1>I thought I saw Elvis in a UFO.</div>
<div class=CC1>Size = 32</div>
<div class=CC1>Capacity = 47</div>
<div class=CC1>I thought I saw Elvis in a UFO. I've been</div>
<div class=CC1>working too hard.</div>
<div class=CC1>Size = 59</div>
<div class=CC1>Capacity = 511</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example demonstrates that even though you can safely
relinquish much of the responsibility for allocating and managing the memory
your <b>string</b>s occupy, C++ <b>string</b>s provide you with several tools
to monitor and manage their size. Notice the ease with which we changed the
size of the storage allocated to the string. The <b>size(&nbsp;) </b>function returns the number of characters currently stored in the string and is identical to the <b>length(&nbsp;)</b> member function. The <b>capacity(&nbsp;) </b>function<b> </b>returns
the size of the current underlying allocation, meaning the number of characters
the string can hold without requesting more storage. The <b>reserve(&nbsp;)</b>
function is an optimization mechanism that indicates your intention to specify
a certain amount of storage for future use; <b>capacity(&nbsp;)</b> always
returns a value at least as large as the most recent call to <b>reserve(&nbsp;)</b>.
A <b>resize(&nbsp;)</b> function appends spaces if the new size is greater than
the current string size or truncates the string otherwise. (An overload of <b>resize(&nbsp;)</b>
can specify a different character to append.)</p>

<p class=MsoNormal>The exact fashion that the <b>string</b> member functions
allocate space for your data depends on the implementation of the library. When
we tested one implementation with the previous example, it appeared that
reallocations occurred on even word (that is, full-integer) boundaries, with
one byte held back. The architects of the <b>string</b> class have endeavored
to make it possible to mix the use of C <b>char</b> arrays and C++ string
objects, so it is likely that figures reported by <b>StrSize.cpp</b> for capacity
reflect that, in this particular implementation, a byte is set aside to easily
accommodate the insertion of a null terminator.</p>

<h3><a href="#_TocRef15743855" name="_Toc15743855">Replacing string
characters</a></h3>

<p class=MsoNormal>The<b> insert(&nbsp;) </b>function<b> </b>is particularly
nice because it absolves you from making sure the insertion of characters in a
string won’t overrun the storage space or overwrite the characters immediately
following the insertion point. Space grows, and existing characters politely
move over to accommodate the new elements. Sometimes this might not be what you
want. If you want the size of the string to remain unchanged, use the <b>replace(&nbsp;)</b> function to overwrite characters. There are a number of
overloaded versions of <b>replace(&nbsp;)</b>, but the simplest one takes three
arguments: an integer indicating where to start in the string, an integer
indicating how many characters to eliminate from the original string, and the
replacement string (which can be a different number of characters than the
eliminated quantity). Here’s a simple example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StringReplace.cpp</font></div>
<div class=CC1><font color=#dd0000>// Simple find-and-replace in strings.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;A piece of text&quot;</font>);</div>
<div class=CC1>  <span lang=SV>string tag(<font color=#007f00>&quot;$tag$&quot;</font>);</span></div>
<div class=CC1><span lang=SV>  s.insert(8, tag + ' ');</span></div>
<div class=CC1><span lang=SV>  </span>assert(s == <font color=#007f00>&quot;A piece $tag$
of text&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> start = s.find(tag);</div>
<div class=CC1>  assert(start == 8);</div>
<div class=CC1>  assert(tag.size() == 5);</div>
<div class=CC1>  s.replace(start, tag.size(), <font color=#007f00>&quot;hello
there&quot;</font>);</div>
<div class=CC1>  assert(s == <font color=#007f00>&quot;A piece hello there of text&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>tag</b> is first inserted into <b>s</b> (notice that
the insert happens <i>before</i> the value indicating the insert point and that
an extra space was added after <b>tag</b>), and then it is found and replaced.</p>

<p class=MsoNormal>You should check to see if you’ve found anything before you
perform a <b>replace(&nbsp;)</b>.<b> </b>The previous example replaces with a <b>char*</b>,
but there’s an overloaded version that replaces with a <b>string</b>.<b> </b>Here’s
a more complete demonstration <b>replace(&nbsp;):</b></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Replace.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;  </font><font color=#dd0000>// For size_t</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> replaceChars(string&amp; modifyMe,</div>
<div class=CC1>  <font color=#ff7700>const</font> string&amp; findMe, <font color=#ff7700>const</font> string&amp; newChars)
{</div>
<div class=CC1>  <font color=#dd0000>// Look in modifyMe for the &quot;find string&quot;</font></div>
<div class=CC1>  <font color=#dd0000>// starting at position 0:</font></div>
<div class=CC1>  size_t i = modifyMe.find(findMe, 0);</div>
<div class=CC1>  <font color=#dd0000>// Did we find the string to replace?</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(i != string::npos)</div>
<div class=CC1>    <font color=#dd0000>// Replace the find string with newChars:</font></div>
<div class=CC1>    modifyMe.replace(i, findMe.size(), newChars);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string bigNews = <font color=#007f00>&quot;I thought I saw Elvis in a
UFO. &quot;</font></div>
<div class=CC1>                   <font color=#007f00>&quot;I have been working too
hard.&quot;</font>;</div>
<div class=CC1>  string replacement(<font color=#007f00>&quot;wig&quot;</font>);</div>
<div class=CC1>  string findMe(<font color=#007f00>&quot;UFO&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Find &quot;UFO&quot; in bigNews and overwrite it:</font></div>
<div class=CC1>  replaceChars(bigNews, findMe, replacement);</div>
<div class=CC1>  assert(bigNews == <font color=#007f00>&quot;I thought I saw Elvis in a
&quot;</font></div>
<div class=CC1>         <font color=#007f00>&quot;wig. I have been working too
hard.&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If <b>replace</b> doesn’t find the search string, it returns
<b>string::npos</b>. The <b>npos</b> data member is a static constant member of
the <b>string</b> class that represents a nonexistent character position.<a href="#_ftn33" name="_ftnref33"><span
class=MsoFootnoteReference>[33]</span></a></p>

<p class=MsoNormal>Unlike <b>insert(&nbsp;)</b>, <b>replace(&nbsp;)</b> won’t
grow the <b>string</b>’s storage space if you copy new characters into the
middle of an existing series of array elements. However, it <i>will</i> grow the storage space if needed, for example, when you make a “replacement” that would
expand the original string beyond the end of the current allocation. Here’s an
example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ReplaceAndGrow.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string bigNews(<font color=#007f00>&quot;I have been working the
grave.&quot;</font>);</div>
<div class=CC1>  string replacement(<font color=#007f00>&quot;yard shift.&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// The first argument says &quot;replace chars</font></div>
<div class=CC1>  <font color=#dd0000>// beyond the end of the existing string&quot;:</font></div>
<div class=CC1>  bigNews.replace(bigNews.size() - 1,</div>
<div class=CC1>    replacement.size(), replacement);</div>
<div class=CC1>  assert(bigNews == <font color=#007f00>&quot;I have been working the
&quot;</font></div>
<div class=CC1>         <font color=#007f00>&quot;graveyard shift.&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The call to <b>replace(&nbsp;) </b>begins “replacing” beyond
the end of the existing array, which is equivalent to an append operation.
Notice that in this example <b>replace(&nbsp;)</b> expands the array
accordingly.</p>

<p class=MsoNormal>You may have been hunting through this chapter trying to do
something relatively simple such as replace all the instances of one character
with a different character. Upon finding the previous material on replacing,
you thought you found the answer, but then you started seeing groups of
characters and counts and other things that looked a bit too complex. Doesn’t <b>string</b>
have a way to just replace one character with another everywhere?</p>

<p class=MsoNormal>You can easily write such a function using the <b>find(&nbsp;)</b>
and <b>replace(&nbsp;)</b> member functions as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ReplaceAll.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef REPLACEALL_H</font></div>
<div class=CC1><font color=#7F7F00>#define REPLACEALL_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1>std::string&amp; replaceAll(std::string&amp; context,</div>
<div class=CC1>  <font color=#ff7700>const</font> std::string&amp; from, <font color=#ff7700>const</font> std::string&amp;
to);</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// REPLACEALL_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ReplaceAll.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;ReplaceAll.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string&amp; replaceAll(string&amp; context, <font color=#ff7700>const</font>
string&amp; from,</div>
<div class=CC1>  <font color=#ff7700>const</font> string&amp; to) {</div>
<div class=CC1>  size_t lookHere = 0;</div>
<div class=CC1>  size_t foundHere;</div>
<div class=CC1>  <font color=#ff7700>while</font>((foundHere = context.find(from, lookHere))</div>
<div class=CC1>    != string::npos) {</div>
<div class=CC1>    context.replace(foundHere, from.size(), to);</div>
<div class=CC1>    lookHere = foundHere + to.size();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> context;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The version of <b>find(&nbsp;)</b> used here takes as a
second argument the position to start looking in and returns <b>string::npos</b>
if it doesn’t find it. It is important to advance the position held in the
variable <b>lookHere</b> past the replacement string, in case <b>from</b> is a
substring of <b>to</b>. The following program tests the <b>replaceAll</b>
function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ReplaceAllTest.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ReplaceAll</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;ReplaceAll.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string text = <font color=#007f00>&quot;a man, a plan, a canal, Panama&quot;</font>;</div>
<div class=CC1>  replaceAll(text, <font color=#007f00>&quot;an&quot;</font>, <font color=#007f00>&quot;XXX&quot;</font>);</div>
<div class=CC1>  assert(text == <font color=#007f00>&quot;a mXXX, a plXXX, a cXXXal, PXXXama&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As you can see, the <b>string</b> class by itself doesn’t
solve all possible problems. Many solutions have been left to the algorithms in
the Standard library<a href="#_ftn34" name="_ftnref34"><span
class=MsoFootnoteReference>[34]</span></a> because
the <b>string</b> class can look just like an STL sequence (by virtue of the
iterators discussed earlier). All the generic algorithms work on a “range” of
elements within a container. Usually that range is just “from the beginning of
the container to the end.” A <b>string</b> object looks like a container of
characters: to get the beginning of the range you use <b>string::begin(&nbsp;)</b>,
and to get the end of the range you use <b>string::end(&nbsp;)</b>. The
following example shows the use of the <b>replace(&nbsp;)</b> algorithm to
replace all the instances of the single character ‘X’ with ‘Y’:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StringCharReplace.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;aaaXaaaXXaaXXXaXXXXaaa&quot;</font>);</div>
<div class=CC1>  replace(s.begin(), s.end(), 'X', 'Y');</div>
<div class=CC1>  assert(s == <font color=#007f00>&quot;aaaYaaaYYaaYYYaYYYYaaa&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that this <b>replace(&nbsp;)</b> is <i>not</i> called
as a member function of <b>string</b>. Also, unlike the <b>string::replace(&nbsp;)</b>
functions that only perform one replacement, the <b>replace(&nbsp;)</b>
algorithm replaces <i>all instances</i> of one character with another.</p>

<p class=MsoNormal>The <b>replace(&nbsp;)</b> algorithm only works with single
objects (in this case, <b>char</b> objects) and will not replace quoted <b>char</b>
arrays or <b>string</b> objects. Since a <b>string</b> behaves like an STL
sequence, a number of other algorithms can be applied to it, which might solve
other problems that are not directly addressed by the <b>string</b> member
functions.</p>

<h3><a href="#_TocRef15743856" name="_Toc15743856">Concatenation using<br>
nonmember overloaded operators</a></h3>

<p class=MsoNormal>One of the most delightful discoveries awaiting a C
programmer learning about C++ <b>string</b> handling is how simply <b>string</b>s
can be combined and appended using <b>operator+</b> and <b>operator+=</b>.<b> </b>These
operators make combining <b>string</b>s syntactically similar to adding numeric
data:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:AddStrings.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s1(<font color=#007f00>&quot;This &quot;</font>);</div>
<div class=CC1>  string s2(<font color=#007f00>&quot;That &quot;</font>);</div>
<div class=CC1>  string s3(<font color=#007f00>&quot;The other &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// operator+ concatenates strings</font></div>
<div class=CC1>  s1 = s1 + s2;</div>
<div class=CC1>  assert(s1 == <font color=#007f00>&quot;This That &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Another way to concatenates strings</font></div>
<div class=CC1>  s1 += s3;</div>
<div class=CC1>  assert(s1 == <font color=#007f00>&quot;This That The other &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// You can index the string on the right</font></div>
<div class=CC1>  s1 += s3 + s3[4] + <font color=#007f00>&quot;ooh lala&quot;</font>;</div>
<div class=CC1>  assert(s1 == <font color=#007f00>&quot;This That The other The other oooh
lala&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Using the<b> operator+</b> and <b>operator+= </b>operators<b>
</b>is a flexible and<b> </b>convenient way to combine <b>string</b> data. On
the right side of the statement, you can use almost any type that evaluates to
a group of one or more characters.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef15743857" name="_Toc15743857">Searching in strings</a></h2>

<p class=MsoNormal>The <b>find</b> family of <b>string</b> member functions
locates a character or group of characters within a given string. Here are the
members of the <b>find</b> family and their general usage :</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border-collapse:collapse !msorm'>
 <tr>
  <td width=259 valign=top style='width:2.7in;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
  border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=TableHead>string find member function</p>
  </td>
  <td width=259 valign=top style='width:2.7in;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
  border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=TableHead>What/how it finds </p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b> find(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Searches a string for a specified character or group of
  characters and returns the starting position of the first occurrence found or
  <b>npos</b> if no match is found. </p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b> </b><b>find_first_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Searches a target string and returns the position of the
  first match of <i>any</i> character in a specified group. If no match is
  found, it returns <b>npos</b>.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b> </b><b>find_last_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Searches a target string and returns the position of the
  last match of <i>any</i> character in a specified group. If no match is
  found, it returns <b>npos</b>.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b> </b><b>find_first_not_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Searches a target string and returns the position of the
  first element that <i>doesn’t</i> match <i>any</i> character in a specified
  group. If no such element is found, it returns <b>npos</b>.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b> </b><b>find_last_not_of(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Searches a target string and returns the position of the
  element with the largest subscript that <i>doesn’t</i> match <i>any</i>
  character in a specified group. If no such element is found, it returns <b>npos</b>.</p>
  </td>
 </tr>
 <tr>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b> </b><b>rfind(&nbsp;)</b></p>
  </td>
  <td width=259 valign=top style='width:2.7in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Searches a string from end to beginning for a specified
  character or group of characters and returns the starting position of the
  match if one is found. If no match is found, it returns <b>npos</b>.</p>
  </td>
 </tr>
</table>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal style='margin-top:6.0pt'>The simplest use of <b>find(&nbsp;)
</b>searches for one or more characters in a <b>string</b>. This overloaded
version of <b>find(&nbsp;) </b>takes a parameter that specifies the
character(s) for which to search and optionally a parameter that tells it where
in the string to begin searching for the occurrence of a substring. (The default
position at which to begin searching is 0.) By setting the call to <b>find </b>inside
a loop, you can easily move through a string, repeating a search to find all
the occurrences of a given character or group of characters within the string.</p>

<p class=MsoNormal>The following program uses the method of <i>The Sieve of
Eratosthenes</i> to find prime numbers less than 50. This method starts with
the number 2, marks all subsequent multiples of 2 as not prime, and repeats the
process for the next prime candidate. The <b>SieveTest</b> constructor
initializes <b>sieveChars</b> by setting the initial size of the character
array and writing the value ‘P’ to each of its members.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Sieve.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef SIEVE_H</font></div>
<div class=CC1><font color=#7F7F00>#define SIEVE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::sqrt;</div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> SieveTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1>  string sieveChars;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// Create a 50 char string and set each</font></div>
<div class=CC1>  <font color=#dd0000>// element to 'P' for Prime:</font></div>
<div class=CC1>  SieveTest() : sieveChars(50, 'P') {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    findPrimes();</div>
<div class=CC1>    testPrimes();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isPrime(<font color=#ff7700>int</font> p) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(p == 0 || p == 1) <font color=#ff7700>return</font> <font color=#ff7700>false</font>;</div>
<div class=CC1>    <font color=#ff7700>int</font> root = <font color=#ff7700>int</font>(sqrt(<font color=#ff7700>double</font>(p)));</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 2; i &lt;= root; ++i)</div>
<div class=CC1>      <font color=#ff7700>if</font>(p % i == 0) <font color=#ff7700>return</font> <font color=#ff7700>false</font>;</div>
<div class=CC1>    <font color=#ff7700>return</font> <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> findPrimes() {</div>
<div class=CC1>    <font color=#dd0000>// By definition neither 0 nor 1 is prime.</font></div>
<div class=CC1>    <font color=#dd0000>// Change these elements to &quot;N&quot; for Not
Prime:</font></div>
<div class=CC1>    sieveChars.replace(0, 2, <font color=#007f00>&quot;NN&quot;</font>);</div>
<div class=CC1>    <font color=#dd0000>// Walk through the array:</font></div>
<div class=CC1>    size_t sieveSize = sieveChars.size();</div>
<div class=CC1>    <font color=#ff7700>int</font> root = <font color=#ff7700>int</font>(sqrt(<font color=#ff7700>double</font>(sieveSize)));</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 2; i &lt;= root; ++i)</div>
<div class=CC1>      <font color=#dd0000>// Find all the multiples:</font></div>
<div class=CC1>      <font color=#ff7700>for</font>(size_t factor = 2; factor * i &lt; sieveSize;</div>
<div class=CC1>           ++factor)</div>
<div class=CC1>        sieveChars[factor * i] = 'N';</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testPrimes() {</div>
<div class=CC1>    size_t i = sieveChars.find('P');</div>
<div class=CC1>    <font color=#ff7700>while</font>(i != string::npos) {</div>
<div class=CC1>      test_(isPrime(i++));</div>
<div class=CC1>      i = sieveChars.find('P', i);</div>
<div class=CC1>    }</div>
<div class=CC1>    i = sieveChars.find_first_not_of('P');</div>
<div class=CC1>    <font color=#ff7700>while</font>(i != string::npos) {</div>
<div class=CC1>      test_(!isPrime(i++));</div>
<div class=CC1>      i = sieveChars.find_first_not_of('P', i);</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// SIEVE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Sieve.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Sieve.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  SieveTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The<b> find(&nbsp;)</b> function can walk forward through a <b>string</b>,
detecting multiple occurrences of a character or a group of characters, and <b>find_first_not_of(&nbsp;)</b>
finds other characters or substrings.</p>

<p class=MsoNormal>There are no functions in the <b>string </b>class to change
the case of a string, but you can easily create these functions using the
Standard C library functions <b>toupper(&nbsp;)</b> and <b>tolower(&nbsp;)</b>,
which change the case of one character at a time. The following example
illustrates a case-insensitive search:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Find.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef FIND_H</font></div>
<div class=CC1><font color=#7F7F00>#define FIND_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1><font color=#ff7700>using</font> std::tolower;</div>
<div class=CC1><font color=#ff7700>using</font> std::toupper;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Make an uppercase copy of s</font></div>
<div class=CC1><font color=#ff7700>inline</font> string upperCase(<font color=#ff7700>const</font> string&amp; s) {</div>
<div class=CC1>  string upper(s);</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; s.length(); ++i)</div>
<div class=CC1>    <span lang=SV>upper[i] = toupper(upper[i]);</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>return</font> upper;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Make a lowercase copy of s</font></div>
<div class=CC1><font color=#ff7700>inline</font> string lowerCase(<font color=#ff7700>const</font> string&amp; s) {</div>
<div class=CC1>  string lower(s);</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; s.length(); ++i)</div>
<div class=CC1>    lower[i] = tolower(lower[i]);</div>
<div class=CC1>  <font color=#ff7700>return</font> lower;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> FindTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1>  string chooseOne;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  FindTest() : chooseOne(<font color=#007f00>&quot;Eenie, Meenie, Miney,
Mo&quot;</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> testUpper() {</div>
<div class=CC1>    string upper = upperCase(chooseOne);</div>
<div class=CC1>    <font color=#ff7700>const</font> string LOWER =
<font color=#007f00>&quot;abcdefghijklmnopqrstuvwxyz&quot;</font>;</div>
<div class=CC1>    test_(upper.find_first_of(LOWER) == string::npos);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testLower() {</div>
<div class=CC1>    string lower = lowerCase(chooseOne);</div>
<div class=CC1>    <font color=#ff7700>const</font> string UPPER =
<font color=#007f00>&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</font>;</div>
<div class=CC1>    test_(lower.find_first_of(UPPER) == string::npos);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testSearch() {</div>
<div class=CC1>    <font color=#dd0000>// Case sensitive search</font></div>
<div class=CC1>    size_t i = chooseOne.find(<font color=#007f00>&quot;een&quot;</font>);</div>
<div class=CC1>    test_(i == 8);</div>
<div class=CC1>    <font color=#dd0000>// Search lowercase:</font></div>
<div class=CC1>    string test = lowerCase(chooseOne);</div>
<div class=CC1>    i = test.find(<font color=#007f00>&quot;een&quot;</font>);</div>
<div class=CC1>    test_(i == 0);</div>
<div class=CC1>    i = test.find(<font color=#007f00>&quot;een&quot;</font>, ++i);</div>
<div class=CC1>    test_(i == 8);</div>
<div class=CC1>    i = test.find(<font color=#007f00>&quot;een&quot;</font>, ++i);</div>
<div class=CC1>    test_(i == string::npos);</div>
<div class=CC1>    <font color=#dd0000>// Search uppercase:</font></div>
<div class=CC1>    test = upperCase(chooseOne);</div>
<div class=CC1>    i = test.find(<font color=#007f00>&quot;EEN&quot;</font>);</div>
<div class=CC1>    test_(i == 0);</div>
<div class=CC1>    i = test.find(<font color=#007f00>&quot;EEN&quot;</font>, ++i);</div>
<div class=CC1>    test_(i == 8);</div>
<div class=CC1>    i = test.find(<font color=#007f00>&quot;EEN&quot;</font>, ++i);</div>
<div class=CC1>    test_(i == string::npos);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    testUpper();</div>
<div class=CC1>    testLower();</div>
<div class=CC1>    testSearch();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// FIND_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Find.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Find.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  FindTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Both the <b>upperCase(&nbsp;)</b> and <b>lowerCase(&nbsp;)</b>
functions follow the same form: they make a copy of the argument <b>string</b>
and change the case. The <b>Find.cpp</b> program isn’t the best solution to the
case-sensitivity problem, so we’ll revisit it when we examine <b>string</b>
comparisons.</p>

<h3><a href="#_TocRef15743858" name="_Toc15743858">Finding in reverse</a></h3>

<p class=MsoNormal>If you need to search through a <b>string</b> from end to
beginning (to find the data in “last in / first out” order), you can use the
string member function <b>rfind(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=IT><font color=#dd0000>//: C03:Rparse.h</span></font></div>
<div class=CC1><span lang=IT>#ifndef RPARSE_H</span></div>
<div class=CC1><span lang=IT>#define RPARSE_H</span></div>
<div class=CC1><span lang=IT>#include &lt;cstddef&gt;</span></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1><font color=#ff7700>using</font> std::vector;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> RparseTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1>  <font color=#dd0000>// To store the words:</font></div>
<div class=CC1>  vector&lt;string&gt; strings;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> parseForData() {</div>
<div class=CC1>    <font color=#dd0000>// The ';' characters will be delimiters</font></div>
<div class=CC1>    string
s(<font color=#007f00>&quot;now.;sense;make;to;going;is;This&quot;</font>);</div>
<div class=CC1>    <font color=#dd0000>// The last element of the string:</font></div>
<div class=CC1>    <font color=#ff7700>int</font> last = s.size();</div>
<div class=CC1>    <font color=#dd0000>// The beginning of the current word:</font></div>
<div class=CC1>    size_t current = s.rfind(';');</div>
<div class=CC1>    <font color=#dd0000>// Walk backward through the string:</font></div>
<div class=CC1>    <font color=#ff7700>while</font>(current != string::npos) {</div>
<div class=CC1>      <font color=#dd0000>// Push each word into the vector.</font></div>
<div class=CC1>      <font color=#dd0000>// Current is incremented before copying</font></div>
<div class=CC1>      <font color=#dd0000>// to avoid copying the delimiter:</font></div>
<div class=CC1>      ++current;</div>
<div class=CC1>      strings.push_back(s.substr(current, last - current));</div>
<div class=CC1>      <font color=#dd0000>// Back over the delimiter we just found,</font></div>
<div class=CC1>      <font color=#dd0000>// and set last to the end of the next word:</font></div>
<div class=CC1>      current -= 2;</div>
<div class=CC1>      last = current + 1;</div>
<div class=CC1>      <font color=#dd0000>// Find the next delimiter:</font></div>
<div class=CC1>      current = s.rfind(';', current);</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#dd0000>// Pick up the first word -- it's not</font></div>
<div class=CC1>    <font color=#dd0000>// preceded by a delimiter:</font></div>
<div class=CC1>    strings.push_back(s.substr(0, last));</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> testData() {</div>
<div class=CC1>    <font color=#dd0000>// Test them in the new order:</font></div>
<div class=CC1>    test_(strings[0] == <font color=#007f00>&quot;This&quot;</font>);</div>
<div class=CC1>    test_(strings[1] == <font color=#007f00>&quot;is&quot;</font>);</div>
<div class=CC1>    test_(strings[2] == <font color=#007f00>&quot;going&quot;</font>);</div>
<div class=CC1>    test_(strings[3] == <font color=#007f00>&quot;to&quot;</font>);</div>
<div class=CC1>    test_(strings[4] == <font color=#007f00>&quot;make&quot;</font>);</div>
<div class=CC1>    test_(strings[5] == <font color=#007f00>&quot;sense&quot;</font>);</div>
<div class=CC1>    test_(strings[6] == <font color=#007f00>&quot;now.&quot;</font>);</div>
<div class=CC1>    string sentence;</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; strings.size() - 1; i++)</div>
<div class=CC1>      sentence += strings[i] += <font color=#007f00>&quot; &quot;</font>;</div>
<div class=CC1>    <font color=#dd0000>// Manually put last word in to avoid an extra
space:</font></div>
<div class=CC1>    sentence += strings[strings.size() - 1];</div>
<div class=CC1>    test_(sentence == <font color=#007f00>&quot;This is going to make sense
now.&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    parseForData();</div>
<div class=CC1>    testData();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// RPARSE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Rparse.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Rparse.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  RparseTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The string member function<b> rfind(&nbsp;)</b> backs
through the string looking for tokens and reports the array index of matching
characters or <b>string::npos</b> if it is unsuccessful.</p>

<h3><a href="#_TocRef15743859" name="_Toc15743859">Finding first/last of a
set of characters</a></h3>

<p class=MsoNormal>The <b>find_first_of(&nbsp;)</b> and <b>find_last_of(&nbsp;)</b>
member functions can be conveniently put to work to create a little utility
that will strip whitespace characters from both ends of a string. Notice that
it doesn’t touch the original string, but instead returns a new string:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Trim.h</font></div>
<div class=CC1><font color=#dd0000>// General tool to strip spaces from both ends.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TRIM_H</font></div>
<div class=CC1><font color=#7F7F00>#define TRIM_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> std::string trim(<font color=#ff7700>const</font> std::string&amp; s) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(s.length() == 0)</div>
<div class=CC1>    <font color=#ff7700>return</font> s;</div>
<div class=CC1>  std::size_t beg = s.find_first_not_of(<font color=#007f00>&quot;
\a\b\f\n\r\t\v&quot;</font>);</div>
<div class=CC1>  std::size_t end = s.find_last_not_of(<font color=#007f00>&quot;
\a\b\f\n\r\t\v&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>if</font>(beg == std::string::npos) <font color=#dd0000>// No non-spaces</font></div>
<div class=CC1>    <font color=#ff7700>return</font> <font color=#007f00>&quot;&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>return</font> std::string(s, beg, end - beg + 1);</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TRIM_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first test checks for an empty <b>string</b>; in that
case, no tests are made, and a copy is returned. Notice that once the end
points are found, the <b>string</b> constructor builds a new <b>string</b> from
the old one, giving the starting count and the length.</p>

<p class=MsoNormal>Testing such a general-purpose tool needs to be thorough:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:TrimTest.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TRIMTEST_H</font></div>
<div class=CC1><font color=#7F7F00>#define TRIMTEST_H</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Trim.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TrimTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1>  <font color=#ff7700>enum</font> {NTESTS = 11};</div>
<div class=CC1>  <font color=#ff7700>static</font> std::string s[NTESTS];</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> testTrim() {</div>
<div class=CC1>    test_(trim(s[0]) == <font color=#007f00>&quot;abcdefghijklmnop&quot;</font>);</div>
<div class=CC1>    test_(trim(s[1]) == <font color=#007f00>&quot;abcdefghijklmnop&quot;</font>);</div>
<div class=CC1>    test_(trim(s[2]) == <font color=#007f00>&quot;abcdefghijklmnop&quot;</font>);</div>
<div class=CC1>    test_(trim(s[3]) == <font color=#007f00>&quot;a&quot;</font>);</div>
<div class=CC1>    test_(trim(s[4]) == <font color=#007f00>&quot;ab&quot;</font>);</div>
<div class=CC1>    test_(trim(s[5]) == <font color=#007f00>&quot;abc&quot;</font>);</div>
<div class=CC1>    test_(trim(s[6]) == <font color=#007f00>&quot;a b c&quot;</font>);</div>
<div class=CC1>    test_(trim(s[7]) == <font color=#007f00>&quot;a b c&quot;</font>);</div>
<div class=CC1>    test_(trim(s[8]) == <font color=#007f00>&quot;a \t b \t c&quot;</font>);</div>
<div class=CC1>    test_(trim(s[9]) == <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>    test_(trim(s[10]) == <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    testTrim();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TRIMTEST_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:TrimTest.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;TrimTest.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Initialize static data</font></div>
<div class=CC1>std::string TrimTest::s[TrimTest::NTESTS] = {</div>
<div class=CC1>  <font color=#007f00>&quot; \t abcdefghijklmnop \t &quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;abcdefghijklmnop \t &quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot; \t abcdefghijklmnop&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;a&quot;</font>, <font color=#007f00>&quot;ab&quot;</font>, <font color=#007f00>&quot;abc&quot;</font>,
<font color=#007f00>&quot;a b c&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot; \t a b c \t &quot;</font>, <font color=#007f00>&quot; \t a \t b \t c \t
&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;\t \n \r \v \f&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;&quot;</font> <font color=#dd0000>// Must also test the empty string</font></div>
<div class=CC1>}; <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:TrimTestMain.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test TrimTest</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;TrimTest.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  TrimTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In the array of <b>strings</b>, you can see that the
character arrays are automatically converted to <b>string</b> objects. This
array provides cases to check the removal of spaces and tabs from both ends, as
well as ensuring that spaces and tabs are not removed from the middle of a <b>string</b>.</p>

<h3><a href="#_TocRef15743860" name="_Toc15743860">Removing characters from
strings</a></h3>

<p class=MsoNormal>Removing characters is easy and efficient with the <b>erase(&nbsp;)</b> member function, which takes two arguments: where to start
removing characters (which defaults to <b>0</b>), and how many to remove (which
defaults to <b>string::npos</b>). If you specify more characters than remain in
the string, the remaining characters are all erased anyway (so calling <b>erase(&nbsp;)</b>
without any arguments removes all characters from a string). Sometimes it’s
useful to take an HTML file and strip its tags and special characters so that
you have something approximating the text that would be displayed in the Web
browser, only as a plain text file. The following example uses <b>erase(&nbsp;)</b>
to do the job:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:HTMLStripper.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>//{L} ReplaceAll</font></div>
<div class=CC1><font color=#dd0000>// Filter to remove html tags and markers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;ReplaceAll.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string&amp; stripHTMLTags(string&amp; s) {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> inTag = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>bool</font> done = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!done) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(inTag) {</div>
<div class=CC1>      <font color=#dd0000>// The previous line started an HTML tag</font></div>
<div class=CC1>      <font color=#dd0000>// but didn't finish. Must search for '&gt;'.</font></div>
<div class=CC1>      size_t rightPos = s.find('&gt;');</div>
<div class=CC1>      <font color=#ff7700>if</font>(rightPos != string::npos) {</div>
<div class=CC1>        inTag = <font color=#ff7700>false</font>;</div>
<div class=CC1>        s.erase(0, rightPos + 1);</div>
<div class=CC1>      }</div>
<div class=CC1>      <font color=#ff7700>else</font> {</div>
<div class=CC1>        done = <font color=#ff7700>true</font>;</div>
<div class=CC1>        s.erase();</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>else</font> {</div>
<div class=CC1>      <font color=#dd0000>// Look for start of tag:</font></div>
<div class=CC1>      size_t leftPos = s.find('&lt;');</div>
<div class=CC1>      <font color=#ff7700>if</font>(leftPos != string::npos) {</div>
<div class=CC1>        <font color=#dd0000>// See if tag close is in this line:</font></div>
<div class=CC1>        size_t rightPos = s.find('&gt;');</div>
<div class=CC1>        <font color=#ff7700>if</font>(rightPos == string::npos) {</div>
<div class=CC1>          inTag = done = <font color=#ff7700>true</font>;</div>
<div class=CC1>          s.erase(leftPos);</div>
<div class=CC1>        }</div>
<div class=CC1>        <font color=#ff7700>else</font></div>
<div class=CC1>          s.erase(leftPos, rightPos - leftPos + 1);</div>
<div class=CC1>      }</div>
<div class=CC1>      <font color=#ff7700>else</font></div>
<div class=CC1>        done = <font color=#ff7700>true</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Remove all special HTML characters</font></div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;lt;&quot;</font>,
<font color=#007f00>&quot;&lt;&quot;</font>);</div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;gt;&quot;</font>,
<font color=#007f00>&quot;&gt;&quot;</font>);</div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;amp;&quot;</font>,
<font color=#007f00>&quot;&amp;&quot;</font>);</div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;nbsp;&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Etc...</font></div>
<div class=CC1>  <font color=#ff7700>return</font> s;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  requireArgs(argc, 1,</div>
<div class=CC1>    <font color=#007f00>&quot;usage: HTMLStripper InputFile&quot;</font>);</div>
<div class=CC1>  ifstream in(argv[1]);</div>
<div class=CC1>  assure(in, argv[1]);</div>
<div class=CC1>  string s;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, s))</div>
<div class=CC1>    <font color=#ff7700>if</font>(!stripHTMLTags(s).empty())</div>
<div class=CC1>      cout &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example will even strip HTML tags that span multiple
lines.<a href="#_ftn35" name="_ftnref35"><span
class=MsoFootnoteReference>[35]</span></a> This is
accomplished with the static flag, <b>inTag</b>, which is <b>true</b> whenever
the start of a tag is found, but the accompanying tag end is not found in the
same line. All forms of <b>erase(&nbsp;)</b> appear in the <b>stripHTMLFlags(&nbsp;)</b>
function.<a href="#_ftn36" name="_ftnref36"><span
class=MsoFootnoteReference>[36]</span></a> The
version of <b>getline(&nbsp;)</b> we use here is a (global) function declared
in the <b>&lt;string&gt;</b> header and is handy because it stores an
arbitrarily long line in its <b>string</b> argument. You don’t need to worry
about the dimension of a character array as you do with <b>istream::getline(&nbsp;)</b>.
Notice that this program uses the <b>replaceAll(&nbsp;)</b> function from
earlier in this chapter. In the next chapter, we’ll use string streams to
create a more elegant solution.</p>

<h3><a href="#_TocRef15743861" name="_Toc15743861">Comparing strings</a></h3>

<p class=MsoNormal>Comparing strings is inherently different from comparing
numbers. Numbers have constant, universally meaningful values. To evaluate the
relationship between the magnitudes of two strings, you must make a <i>lexical
comparison</i>. Lexical comparison means that when you test a character to see
if it is “greater than” or “less than” another character, you are actually
comparing the numeric representation of those characters as specified in the
collating sequence of the character set being used. Most often this will be the
ASCII collating sequence, which assigns the printable characters for the
English language numbers in the range 32 through 127 decimal. In the ASCII
collating sequence, the first “character” in the list is the space, followed by
several common punctuation marks, and then uppercase and lowercase letters.
With respect to the alphabet, this means that the letters nearer the front have
lower ASCII values than those nearer the end. With these details in mind, it
becomes easier to remember that when a lexical comparison that reports <b>s1</b>
is “greater than” <b>s2</b>, it simply means that when the two were compared,
the first differing character in <b>s1</b> came later in the alphabet than the
character in that same position in <b>s2</b>.</p>

<p class=MsoNormal>C++ provides several ways to compare strings, and each has
advantages. The simplest to use are the nonmember, overloaded operator
functions: <b>operator ==</b>,<b> operator != operator &gt;</b>,<b> operator
&lt;</b>,<b> operator &gt;=</b>,<b> </b>and<b> operator &lt;=</b>.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:CompStr.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef COMPSTR_H</font></div>
<div class=CC1><font color=#7F7F00>#define COMPSTR_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../TestSuite/Test.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> CompStrTest : <font color=#ff7700>public</font> TestSuite::Test {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#dd0000>// Strings to compare</font></div>
<div class=CC1>    string s1(<font color=#007f00>&quot;This&quot;</font>);</div>
<div class=CC1>    string s2(<font color=#007f00>&quot;That&quot;</font>);</div>
<div class=CC1>    test_(s1 == s1);</div>
<div class=CC1>    test_(s1 != s2);</div>
<div class=CC1>    test_(s1 &gt; s2);</div>
<div class=CC1>    test_(s1 &gt;= s2);</div>
<div class=CC1>    test_(s1 &gt;= s1);</div>
<div class=CC1>    test_(s2 &lt; s1);</div>
<div class=CC1>    test_(s2 &lt;= s1);</div>
<div class=CC1>    test_(s1 &lt;= s1);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// COMPSTR_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:CompStr.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;CompStr.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CompStrTest t;</div>
<div class=CC1>  t.run();</div>
<div class=CC1>  <font color=#ff7700>return</font> t.report();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The overloaded comparison operators are useful for comparing
both full strings and individual string character elements.</p>

<p class=MsoNormal>Notice in the following example the flexibility of argument
types on both the left and right side of the comparison operators. For
efficiency, the <b>string</b> class provides overloaded operators for the
direct comparison of string objects, quoted literals, and pointers to C-style
strings without having to create temporary <b>string</b> objects.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Equivalence.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s2(<font color=#007f00>&quot;That&quot;</font>), s1(<font color=#007f00>&quot;This&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// The lvalue is a quoted literal</font></div>
<div class=CC1>  <font color=#dd0000>// and the rvalue is a string:</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(<font color=#007f00>&quot;That&quot;</font> == s2)</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;A match&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// The left operand is a string and the right is</font></div>
<div class=CC1>  <font color=#dd0000>// a pointer to a C-style null terminated string:</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(s1 != s2.c_str())</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;No match&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>c_str(&nbsp;)</b> function returns a <b>const char*</b>
that points to a C-style, null-terminated string equivalent to the contents of
the <b>string</b> object. This comes in handy when you want to pass a string to
a standard C function, such as <b>atoi(&nbsp;)</b> or any of the functions
defined in the <b>&lt;cstring&gt;</b> header. It is an error to use the value
returned by <b>c_str(&nbsp;)</b> as non-<b>const</b> argument to any function.</p>

<p class=MsoNormal>You won’t find the logical not (<b>!</b>) or the logical
comparison operators (<b>&amp;&amp;</b> and <b>||</b>) among operators for a
string. (Neither will you find overloaded versions of the bitwise C operators <b>&amp;</b>,
<b>|</b>, <b>^</b>, or <b>~</b>.) The overloaded nonmember comparison operators
for the string class are limited to the subset that has clear, unambiguous
application to single characters or groups of characters.</p>

<p class=MsoNormal>The <b>compare(&nbsp;)</b> member function offers you a
great deal more sophisticated and precise comparison than the nonmember
operator set. It provides overloaded versions to compare:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.75in;text-indent:-.25in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Two complete strings.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.75in;text-indent:-.25in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Part of either string to a complete string.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Subsets of two strings.</p>

<p class=MsoNormal>The following example compares complete strings:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Compare.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstrates compare() and swap().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string first(<font color=#007f00>&quot;This&quot;</font>);</div>
<div class=CC1>  string second(<font color=#007f00>&quot;That&quot;</font>);</div>
<div class=CC1>  assert(first.compare(first) == 0);</div>
<div class=CC1>  assert(second.compare(second) == 0);</div>
<div class=CC1>  <font color=#dd0000>// Which is lexically greater?</font></div>
<div class=CC1>  assert(first.compare(second) &gt; 0);</div>
<div class=CC1>  assert(second.compare(first) &lt; 0);</div>
<div class=CC1>  first.swap(second);</div>
<div class=CC1>  assert(first.compare(second) &lt; 0);</div>
<div class=CC1>  assert(second.compare(first) &gt; 0);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>swap(&nbsp;)</b> function in this example does what
its name implies: it exchanges the contents of its object and argument. To
compare a subset of the characters in one or both strings, you add arguments
that define where to start the comparison and how many characters to consider.
For example, we can use the following overloaded version of <b>compare(&nbsp;)</b>:</p>

<p class=MsoNormal><b>s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos,<br>
                         s2NumberChars);</b></p>

<p class=MsoNormal>Here’s an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:Compare2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrate overloaded compare().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string first(<font color=#007f00>&quot;This is a day that will live in
infamy&quot;</font>);</div>
<div class=CC1>  string second(<font color=#007f00>&quot;I don't believe that this is what
&quot;</font></div>
<div class=CC1>                <font color=#007f00>&quot;I signed up for&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Compare &quot;his is&quot; in both strings:</font></div>
<div class=CC1>  assert(first.compare(1, 7, second, 22, 7) == 0);</div>
<div class=CC1>  <font color=#dd0000>// Compare &quot;his is a&quot; to &quot;his is w&quot;:</font></div>
<div class=CC1>  assert(first.compare(1, 9, second, 22, 9) &lt; 0);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In the examples so far, we have used C-style array indexing
syntax to refer to an individual character in a string. C++ strings provide an
alternative to the <b>s[n] </b>notation: the <b>at(&nbsp;)</b> member. These two indexing mechanisms produce the same result in C++ if all goes well:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:StringIndexing.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;1234&quot;</font>);</div>
<div class=CC1>  assert(s[1] == '2');</div>
<div class=CC1>  assert(s.at(1) == '2');</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>There is one important difference, however, between <b>[&nbsp;]</b>
and <b>at(&nbsp;)</b>. When you try to reference an array element that is out
of bounds, <b>at(&nbsp;) </b>will do you the kindness of throwing an exception,
while ordinary <b>[&nbsp;] </b>subscripting syntax will leave you to your own
devices:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:BadStringIndexing.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;exception&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;1234&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// at() saves you by throwing an exception:</font></div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    s.at(5);</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Responsible programmers will not use errant indexes, but
should you want to benefits of automatic index checking, using <b>at(&nbsp;) </b>in
place of <b>[&nbsp;] </b>will give you a chance to gracefully recover from
references to array elements that don’t exist. Execution of this program on one
of our test compilers gave the following output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>invalid string position</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The<b> at(&nbsp;)</b> member throws an object of class <b>out_of_range</b>,
which derives (ultimately) from <b>std::exception</b>. By catching this object
in an exception handler, you can take appropriate remedial actions such as
recalculating the offending subscript or growing the array. Using <b>string::operator[&nbsp;](&nbsp;)</b>
gives no such protection and is as dangerous as <b>char</b> array processing in
C.<a href="#_ftn37" name="_ftnref37"><span
class=MsoFootnoteReference>[37]</span></a></p>

<h3><a href="#_TocRef15743862" name="_Toc15743862">Strings and character
traits</a></h3>

<p class=MsoNormal>The program <b>Find.cpp</b> earlier in this chapter leads us
to ask the obvious question: Why isn’t case-insensitive comparison part of the
standard <b>string</b> class? The answer provides interesting background on the
true nature of C++ string objects.</p>

<p class=MsoNormal>Consider what it means for a character to have “case.”
Written Hebrew, Farsi, and Kanji don’t use the concept of upper- and lowercase,
so for those languages this idea has no meaning. It would seem that if there
were a way to designate some languages as “all uppercase” or “all lowercase,”
we could design a generalized solution. However, some languages that employ the
concept of “case” <i>also</i> change the meaning of particular characters with
diacritical marks, for example: the cedilla in Spanish, the circumflex in
French, and the umlaut in German. For this reason, any case-sensitive collating
scheme that attempts to be comprehensive will be nightmarishly complex to use.</p>

<p class=MsoNormal>Although we usually treat the C++ <b>string</b> as a class,
this is really not the case. The <b>string</b> type is a specialization of a
more general constituent, the <b>basic_string&lt;</b>&nbsp;<b>&gt;</b>
template. Observe how <b>string</b> is declared in the Standard C++ header file:<a href="#_ftn38" name="_ftnref38"><span
class=MsoFootnoteReference>[38]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> basic_string&lt;<font color=#ff7700>char</font>&gt; string;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To understand the nature of the string class, look at the <b>basic_string&lt;</b>&nbsp;<b>&gt;</b>
template:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, <font color=#ff7700>class</font> traits =
char_traits&lt;charT&gt;,</div>
<div class=CC1>  <font color=#ff7700>class</font> allocator =
allocator&lt;charT&gt; &gt; <font color=#ff7700>class</font> basic_string;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In Chapter 5, we examine templates in great detail (much
more than in Chapter 16 of Volume 1). For now, just notice that the <b>string</b>
type is created when the <b>basic_string</b> template is instantiated with <b>char</b>.
Inside the <b>basic_string&lt;</b>&nbsp;<b>&gt; </b>template declaration, the
line:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>class</font> traits = char_traits&lt;charT&gt;,</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>tells us that the behavior of the class made from the <b>basic_string&lt;</b>&nbsp;<b>&gt;
</b>template is specified by a class based on the template <b>char_traits&lt;</b>&nbsp;<b>&gt;</b>.
Thus, the <b>basic_string&lt;</b>&nbsp;<b>&gt;</b> template produces
string-oriented classes that manipulate types other than <b>char</b> (wide
characters, for example). To do this, the <b>char_traits&lt;</b>&nbsp;<b>&gt; </b>template
controls the content and collating behaviors of a variety of character sets
using the character comparison functions <b>eq(&nbsp;)</b> (equal), <b>ne(&nbsp;)</b>
(not equal), and <b>lt(&nbsp;)</b> (less than). The <b>basic_string&lt;</b>&nbsp;<b>&gt;
</b>string comparison functions rely on these.</p>

<p class=MsoNormal>This is why the string class doesn’t include
case-insensitive member functions: that’s not in its job description. To change
the way the string class treats character comparison, you must supply a
different <b>char_traits&lt;</b>&nbsp;<b>&gt;</b> template because that defines
the behavior of the individual character comparison member functions.</p>

<p class=MsoNormal>You can use this information to make a new type of <b>string
</b>class that ignores case. First, we’ll define a new case-insensitive <b>char_traits&lt;</b>&nbsp;<b>&gt;</b>
template that inherits from the existing template. Next, we’ll override only
the members we need to change to make character-by-character comparison case
insensitive. (In addition to the three lexical character comparison members
mentioned earlier, we’ll also supply a new implementation for the <b>char_traits</b>
functions <b>find(&nbsp;)</b> and <b>compare(&nbsp;)</b>) . Finally, we’ll <b>typedef</b>
a new class based on <b>basic_string</b>, but using the case-insensitive <b>ichar_traits</b>
template for its second argument:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ichar_traits.h</font></div>
<div class=CC1><font color=#dd0000>// Creating your own character traits.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef ICHAR_TRAITS_H</font></div>
<div class=CC1><font color=#7F7F00>#define ICHAR_TRAITS_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::allocator;</div>
<div class=CC1><font color=#ff7700>using</font> std::basic_string;</div>
<div class=CC1><font color=#ff7700>using</font> std::char_traits;</div>
<div class=CC1><font color=#ff7700>using</font> std::ostream;</div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1><font color=#ff7700>using</font> std::toupper;</div>
<div class=CC1><font color=#ff7700>using</font> std::tolower;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> ichar_traits : char_traits&lt;<font color=#ff7700>char</font>&gt; {</div>
<div class=CC1>  <font color=#dd0000>// We'll only change character-by-</font></div>
<div class=CC1>  <font color=#dd0000>// character comparison functions</font></div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> eq(<font color=#ff7700>char</font> c1st, <font color=#ff7700>char</font> c2nd) {</div>
<div class=CC1>    <font color=#ff7700>return</font> toupper(c1st) == toupper(c2nd);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> ne(<font color=#ff7700>char</font> c1st, <font color=#ff7700>char</font> c2nd) {</div>
<div class=CC1>    <font color=#ff7700>return</font> !eq(c1st, c2nd);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> lt(<font color=#ff7700>char</font> c1st, <font color=#ff7700>char</font> c2nd) {</div>
<div class=CC1>    <font color=#ff7700>return</font> toupper(c1st) &lt; toupper(c2nd);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font></div>
<div class=CC1>  compare(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* str1, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* str2, size_t n)
{</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; n; ++i) {</div>
<div class=CC1>      <font color=#ff7700>if</font>(str1 == 0)</div>
<div class=CC1>        <font color=#ff7700>return</font> -1;</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(str2 == 0)</div>
<div class=CC1>        <font color=#ff7700>return</font> 1;</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(tolower(*str1) &lt; tolower(*str2))</div>
<div class=CC1>        <font color=#ff7700>return</font> -1;</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(tolower(*str1) &gt; tolower(*str2))</div>
<div class=CC1>        <font color=#ff7700>return</font> 1;</div>
<div class=CC1>      assert(tolower(*str1) == tolower(*str2));</div>
<div class=CC1>      ++str1; ++str2; <font color=#dd0000>// Compare the other chars</font></div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>return</font> 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>char</font>*</div>
<div class=CC1>  find(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* s1, size_t n, <font color=#ff7700>char</font> c) {</div>
<div class=CC1>    <font color=#ff7700>while</font>(n-- &gt; 0)</div>
<div class=CC1>      <font color=#ff7700>if</font>(toupper(*s1) == toupper(c))</div>
<div class=CC1>        <font color=#ff7700>return</font> s1;</div>
<div class=CC1>      <font color=#ff7700>else</font></div>
<div class=CC1>        ++s1;</div>
<div class=CC1>    <font color=#ff7700>return</font> 0;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> basic_string&lt;<font color=#ff7700>char</font>, ichar_traits&gt; istring;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> istring&amp; s) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; string(s.c_str(), s.length());</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// ICHAR_TRAITS_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We provide a <b>typedef</b> named <b>istring</b> so that our
class will act like an ordinary <b>string</b> in every way, except that it will
make all comparisons without respect to case. For convenience, we’ve also
provided an overloaded <b>operator&lt;&lt;(&nbsp;)</b> so that you can print <b>istring</b>s.
Here’s an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ICompare.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;ichar_traits.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// The same letters except for case:</font></div>
<div class=CC1>  istring first = <font color=#007f00>&quot;tHis&quot;</font>;</div>
<div class=CC1>  istring second = <font color=#007f00>&quot;ThIS&quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; first &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; second &lt;&lt; endl;</div>
<div class=CC1>  assert(first.compare(second) == 0);</div>
<div class=CC1>  assert(first.find('h') == 1);</div>
<div class=CC1>  assert(first.find('I') == 2);</div>
<div class=CC1>  assert(first.find('x') == string::npos);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This is just a toy example. To make <b>istring</b> fully
equivalent to <b>string</b>, we’d have to create the other functions necessary
to support the new <b>istring</b> type.</p>

<p class=MsoNormal>The <b>&lt;string&gt;</b> header provides a wide string
class via the following <b>typedef</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> basic_string&lt;<font color=#ff7700>wchar_t</font>&gt; wstring;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Wide string support also reveals itself in <i>wide streams</i>
(<b>wostream</b> in place of <b>ostream</b>, also defined in <b>&lt;iostream&gt;</b>)
and in the header <b>&lt;cwctype&gt;</b>, a wide-character version of <b>&lt;cctype&gt;</b>.
This along with the <b>wchar_t</b> specialization of <b>char_traits</b> in the
standard library allows us to do a wide-character version of <b>ichar_traits</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:iwchar_traits.h {-g++}</font></div>
<div class=CC1><font color=#dd0000>// Creating your own wide-character traits.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef IWCHAR_TRAITS_H</font></div>
<div class=CC1><font color=#7F7F00>#define IWCHAR_TRAITS_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cwctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>using</font> std::allocator;</div>
<div class=CC1><font color=#ff7700>using</font> std::basic_string;</div>
<div class=CC1><font color=#ff7700>using</font> std::char_traits;</div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::towlower;</div>
<div class=CC1><font color=#ff7700>using</font> std::towupper;</div>
<div class=CC1><font color=#ff7700>using</font> std::wostream;</div>
<div class=CC1><font color=#ff7700>using</font> std::wstring;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> iwchar_traits : char_traits&lt;<font color=#ff7700>wchar_t</font>&gt; {</div>
<div class=CC1>  <font color=#dd0000>// We'll only change character-by-</font></div>
<div class=CC1>  <font color=#dd0000>// character comparison functions</font></div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> eq(<font color=#ff7700>wchar_t</font> c1st, <font color=#ff7700>wchar_t</font> c2nd) {</div>
<div class=CC1>    <font color=#ff7700>return</font> towupper(c1st) == towupper(c2nd);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> ne(<font color=#ff7700>wchar_t</font> c1st, <font color=#ff7700>wchar_t</font> c2nd) {</div>
<div class=CC1>    <font color=#ff7700>return</font> towupper(c1st) != towupper(c2nd);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> lt(<font color=#ff7700>wchar_t</font> c1st, <font color=#ff7700>wchar_t</font> c2nd) {</div>
<div class=CC1>    <font color=#ff7700>return</font> towupper(c1st) &lt; towupper(c2nd);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> compare(</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>wchar_t</font>* str1, <font color=#ff7700>const</font> <font color=#ff7700>wchar_t</font>* str2, size_t n)
{</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; n; i++) {</div>
<div class=CC1>      <font color=#ff7700>if</font>(str1 == 0)</div>
<div class=CC1>        <font color=#ff7700>return</font> -1;</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(str2 == 0)</div>
<div class=CC1>        <font color=#ff7700>return</font> 1;</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(towlower(*str1) &lt; towlower(*str2))</div>
<div class=CC1>        <font color=#ff7700>return</font> -1;</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(towlower(*str1) &gt; towlower(*str2))</div>
<div class=CC1>        <font color=#ff7700>return</font> 1;</div>
<div class=CC1>      assert(towlower(*str1) == towlower(*str2));</div>
<div class=CC1>      ++str1; ++str2; <font color=#dd0000>// Compare the other wchar_ts</font></div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>return</font> 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>wchar_t</font>*</div>
<div class=CC1>  find(<font color=#ff7700>const</font> <font color=#ff7700>wchar_t</font>* s1, size_t n, <font color=#ff7700>wchar_t</font> c) {</div>
<div class=CC1>    <font color=#ff7700>while</font>(n-- &gt; 0)</div>
<div class=CC1>      <font color=#ff7700>if</font>(towupper(*s1) == towupper(c))</div>
<div class=CC1>        <font color=#ff7700>return</font> s1;</div>
<div class=CC1>      <font color=#ff7700>else</font></div>
<div class=CC1>        ++s1;</div>
<div class=CC1>    <font color=#ff7700>return</font> 0;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> basic_string&lt;<font color=#ff7700>wchar_t</font>, iwchar_traits&gt;
iwstring;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> wostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(wostream&amp; os,</div>
<div class=CC1>  <font color=#ff7700>const</font> iwstring&amp; s) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; wstring(s.c_str(), s.length());</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// IWCHAR_TRAITS_H  ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As you can see, this is mostly an exercise in placing a ‘w’
in the appropriate place in the source code. The test program looks like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:IWCompare.cpp {-g++}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;iwchar_traits.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// The same letters except for case:</font></div>
<div class=CC1>  iwstring wfirst = L<font color=#007f00>&quot;tHis&quot;</font>;</div>
<div class=CC1>  iwstring wsecond = L<font color=#007f00>&quot;ThIS&quot;</font>;</div>
<div class=CC1>  wcout &lt;&lt; wfirst &lt;&lt; endl;</div>
<div class=CC1>  wcout &lt;&lt; wsecond &lt;&lt; endl;</div>
<div class=CC1>  assert(wfirst.compare(wsecond) == 0);</div>
<div class=CC1>  assert(wfirst.find('h') == 1);</div>
<div class=CC1>  assert(wfirst.find('I') == 2);</div>
<div class=CC1>  assert(wfirst.find('x') == wstring::npos);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Unfortunately, some compilers still do not provide robust
support for wide characters.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef15743863" name="_Toc15743863">A string application</a></h2>

<p class=MsoNormal>If you’ve looked at the sample code
in this book closely, you’ve noticed that certain tokens in the comments
surround the code. These are used by a Python program that Bruce wrote to
extract the code into files and set up makefiles for building the code. For
example, a double-slash followed by a colon at the beginning of a line denotes
the first line of a source file. The rest of the line contains information
describing the file’s name and location and whether it should be only compiled
rather than fully built into an executable file. For example, the first line in
the previous program above contains the string <b>C03:IWCompare.cpp</b>,
indicating that the file <b>IWCompare.cpp</b> should be extracted into the
directory <b>C03</b>.</a></p>

<p class=MsoNormal>The last line of a source file contains a triple-slash
followed by a colon and a tilde. If the first line has an exclamation point
immediately after the colon, the first and last lines of the source code are
not to be output to the file (this is for data-only files). (If you’re
wondering why we’re avoiding showing you these tokens, it’s because we don’t
want to break the code extractor when applied to the text of the book!)</p>

<p class=MsoNormal>Bruce’s Python program does a lot more than just extract
code. If the token <b>“{O}”</b> follows the file name, its makefile entry will
only be set up to compile the file and not to link it into an executable. (The
Test Framework in Chapter 2 is built this way.) To link such a file with
another source example, the target executable’s source file will contain an <b>“{L}”</b>
directive, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//{L} ../TestSuite/Test</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This section will present a program to just extract all the
code so that you can compile and inspect it manually. You can use this program
to extract all the code in this book by saving the document file as a text file<a href="#_ftn39" name="_ftnref39"><span
class=MsoFootnoteReference>[39]</span></a> (let’s call it
TICV2.txt) and by executing something like the following on a shell command
line:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>C:&gt; extractCode TICV2.txt /TheCode</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This command reads the text file <b>TICV2.txt</b> and writes
all the source code files in subdirectories under the top-level directory <b>/TheCode</b>.
The directory tree will look like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>TheCode/</div>
<div class=CC1>   C0B/</div>
<div class=CC1>   C01/</div>
<div class=CC1>   C02/</div>
<div class=CC1>   C03/</div>
<div class=CC1>   C04/</div>
<div class=CC1>   C05/</div>
<div class=CC1>   C06/</div>
<div class=CC1>   C07/</div>
<div class=CC1>   C08/</div>
<div class=CC1>   C09/</div>
<div class=CC1>   C10/</div>
<div class=CC1>   C11/</div>
<div class=CC1>   TestSuite/</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The source files containing the examples from each chapter
will be in the corresponding directory.</p>

<p class=MsoNormal>Here’s the program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C03:ExtractCode.cpp {-edg} {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Extracts code from text.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Legacy non-standard C header for mkdir()</font></div>
<div class=CC1><font color=#7F7F00>#if defined(__GNUC__) || defined(__MWERKS__)</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sys/stat.h&gt;</font></div>
<div class=CC1><font color=#7F7F00>#elif defined(__BORLANDC__) || defined(_MSC_VER) \</font></div>
<div class=CC1>  || defined(__DMC__)</div>
<div class=CC1><font color=#7F7F00>#include &lt;direct.h&gt;</font></div>
<div class=CC1><font color=#7F7F00>#else</font></div>
<div class=CC1><font color=#7F7F00>#error Compiler not supported</font></div>
<div class=CC1><font color=#7F7F00>#endif</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Check to see if directory exists</font></div>
<div class=CC1><font color=#dd0000>// by attempting to open a new file</font></div>
<div class=CC1><font color=#dd0000>// for output within it.</font></div>
<div class=CC1><font color=#ff7700>bool</font> exists(string fname) {</div>
<div class=CC1>  size_t len = fname.length();</div>
<div class=CC1>  <font color=#ff7700>if</font>(fname[len-1] != '/' &amp;&amp; fname[len-1] !=
'\\')</div>
<div class=CC1>    fname.append(<font color=#007f00>&quot;/&quot;</font>);</div>
<div class=CC1>  fname.append(<font color=#007f00>&quot;000.tmp&quot;</font>);</div>
<div class=CC1>  ofstream outf(fname.c_str());</div>
<div class=CC1>  <font color=#ff7700>bool</font> existFlag = outf;</div>
<div class=CC1>  <font color=#ff7700>if</font>(outf) {</div>
<div class=CC1>    outf.close();</div>
<div class=CC1>    remove(fname.c_str());</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> existFlag;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#dd0000>// See if input file name provided</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(argc == 1) {</div>
<div class=CC1>    cerr &lt;&lt; <font color=#007f00>&quot;usage: extractCode file
[dir]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// See if input file exists</font></div>
<div class=CC1>  ifstream inf(argv[1]);</div>
<div class=CC1>  <font color=#ff7700>if</font>(!inf) {</div>
<div class=CC1>    cerr &lt;&lt; <font color=#007f00>&quot;error opening file: &quot;</font>
&lt;&lt; argv[1] &lt;&lt; endl;</div>
<div class=CC1>    exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Check for optional output directory</font></div>
<div class=CC1>  string root(<font color=#007f00>&quot;./&quot;</font>);  <font color=#dd0000>// current is default</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(argc == 3) {</div>
<div class=CC1>    <font color=#dd0000>// See if output directory exists</font></div>
<div class=CC1>    root = argv[2];</div>
<div class=CC1>    <font color=#ff7700>if</font>(!exists(root)) {</div>
<div class=CC1>      cerr &lt;&lt; <font color=#007f00>&quot;no such directory: &quot;</font>
&lt;&lt; root &lt;&lt; endl;</div>
<div class=CC1>      exit(EXIT_FAILURE);</div>
<div class=CC1>    }</div>
<div class=CC1>    size_t rootLen = root.length();</div>
<div class=CC1>    <font color=#ff7700>if</font>(root[rootLen-1] != '/' &amp;&amp;
root[rootLen-1] != '\\')</div>
<div class=CC1>      root.append(<font color=#007f00>&quot;/&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Read input file line by line</font></div>
<div class=CC1>  <font color=#dd0000>// checking for code delimiters</font></div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>bool</font> inCode = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>bool</font> printDelims = <font color=#ff7700>true</font>;</div>
<div class=CC1>  ofstream outf;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(inf, line)) {</div>
<div class=CC1>    size_t findDelim = line.find(&quot;<font color=#dd0000>//&quot;
&quot;/:~&quot;);</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(findDelim != string::npos) {</div>
<div class=CC1>      <font color=#dd0000>// Output last line and close file</font></div>
<div class=CC1>      <font color=#ff7700>if</font>(!inCode) {</div>
<div class=CC1>        cerr &lt;&lt; <font color=#007f00>&quot;Lines out of order&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>        exit(EXIT_FAILURE);</div>
<div class=CC1>      }</div>
<div class=CC1>      assert(outf);</div>
<div class=CC1>      <font color=#ff7700>if</font>(printDelims)</div>
<div class=CC1>        outf &lt;&lt; line &lt;&lt; endl;</div>
<div class=CC1>      outf.close();</div>
<div class=CC1>      inCode = <font color=#ff7700>false</font>;</div>
<div class=CC1>      printDelims = <font color=#ff7700>true</font>;</div>
<div class=CC1>    } <font color=#ff7700>else</font> {</div>
<div class=CC1>      findDelim = line.find(&quot;<font color=#dd0000>//&quot;
&quot;:&quot;);</font></div>
<div class=CC1>      <font color=#ff7700>if</font>(findDelim == 0) {</div>
<div class=CC1>        <font color=#dd0000>// Check for '!' directive</font></div>
<div class=CC1>        <font color=#ff7700>if</font>(line[3] == '!') {</div>
<div class=CC1>          printDelims = <font color=#ff7700>false</font>;</div>
<div class=CC1>          ++findDelim;  <font color=#dd0000>// To skip '!' for next search</font></div>
<div class=CC1>        }</div>
<div class=CC1>        <font color=#dd0000>// Extract subdirectory name, if any</font></div>
<div class=CC1>        size_t startOfSubdir =</div>
<div class=CC1>          line.find_first_not_of(<font color=#007f00>&quot; \t&quot;</font>,
findDelim+3);</div>
<div class=CC1>        findDelim = line.find(':', startOfSubdir);</div>
<div class=CC1>        <font color=#ff7700>if</font>(findDelim == string::npos) {</div>
<div class=CC1>          cerr &lt;&lt; <font color=#007f00>&quot;missing filename
information\n&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>          exit(EXIT_FAILURE);</div>
<div class=CC1>        }</div>
<div class=CC1>        string subdir;</div>
<div class=CC1>        <font color=#ff7700>if</font>(findDelim &gt; startOfSubdir)</div>
<div class=CC1>          subdir = line.substr(startOfSubdir,</div>
<div class=CC1>                               findDelim -
startOfSubdir);</div>
<div class=CC1>        <font color=#dd0000>// Extract file name (better be one!)</font></div>
<div class=CC1>        size_t startOfFile = findDelim + 1;</div>
<div class=CC1>        size_t endOfFile =</div>
<div class=CC1>          line.find_first_of(<font color=#007f00>&quot; \t&quot;</font>,
startOfFile);</div>
<div class=CC1>        <font color=#ff7700>if</font>(endOfFile == startOfFile) {</div>
<div class=CC1>          cerr &lt;&lt; <font color=#007f00>&quot;missing filename&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>          exit(EXIT_FAILURE);</div>
<div class=CC1>        }</div>
<div class=CC1>        <font color=#dd0000>// We have all the pieces; build fullPath name</font></div>
<div class=CC1>        string fullPath(root);</div>
<div class=CC1>        <font color=#ff7700>if</font>(subdir.length() &gt; 0)</div>
<div class=CC1>         
fullPath.append(subdir).append(<font color=#007f00>&quot;/&quot;</font>);</div>
<div class=CC1>        assert(fullPath[fullPath.length()-1] == '/');</div>
<div class=CC1>        <font color=#ff7700>if</font>(!exists(fullPath))</div>
<div class=CC1><font color=#7F7F00>#if defined(__GNUC__) || defined(__MWERKS__)</font></div>
<div class=CC1>          mkdir(fullPath.c_str(), 0);  <font color=#dd0000>// Create subdir</font></div>
<div class=CC1><font color=#7F7F00>#else</font></div>
<div class=CC1>          mkdir(fullPath.c_str());  <font color=#dd0000>// Create subdir</font></div>
<div class=CC1><font color=#7F7F00>#endif</font></div>
<div class=CC1>        fullPath.append(line.substr(startOfFile,</div>
<div class=CC1>                        endOfFile - startOfFile));</div>
<div class=CC1>        outf.open(fullPath.c_str());</div>
<div class=CC1>        <font color=#ff7700>if</font>(!outf) {</div>
<div class=CC1>          cerr &lt;&lt; <font color=#007f00>&quot;error opening &quot;</font>
&lt;&lt; fullPath</div>
<div class=CC1>               &lt;&lt; <font color=#007f00>&quot; for output&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>          exit(EXIT_FAILURE);</div>
<div class=CC1>        }</div>
<div class=CC1>        inCode = <font color=#ff7700>true</font>;</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Processing &quot;</font> &lt;&lt;
fullPath &lt;&lt; endl;</div>
<div class=CC1>        <font color=#ff7700>if</font>(printDelims)</div>
<div class=CC1>          outf &lt;&lt; line &lt;&lt; endl;</div>
<div class=CC1>      }</div>
<div class=CC1>      <font color=#ff7700>else</font> <font color=#ff7700>if</font>(inCode) {</div>
<div class=CC1>        assert(outf);</div>
<div class=CC1>        outf &lt;&lt; line &lt;&lt; endl;  <font color=#dd0000>// Output middle
code line</font></div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  exit(EXIT_SUCCESS);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>First, you’ll notice some conditional compilation directives.
The <b>mkdir(&nbsp;)</b> function, which creates a directory in the file
system, is defined by the POSIX<a href="#_ftn40" name="_ftnref40"><span
class=MsoFootnoteReference>[40]</span></a> standard
in the header <b>&lt;sys/stat.h&gt;</b>. Unfortunately, many compilers still
use a different header (<b>&lt;direct.h&gt;</b>). The respective signatures for
<b>mkdir(&nbsp;)</b> also differ: POSIX specifies two arguments, the older
versions just one. For this reason, there is more conditional compilation later
in the program to choose the right call to <b>mkdir(&nbsp;)</b>. We normally
don’t use conditional compilation in the examples in this book, but this
particular program is too useful not to put a little extra work into, since you
can use it to extract all the code with it.</p>

<p class=MsoNormal>The <b>exists(&nbsp;)</b> function in <b>ExtractCode.cpp</b>
tests whether a directory exists by opening a temporary file in it. If the open
fails, the directory doesn’t exist. You remove a file by sending its name as a <b>char*</b>
to <b>std::remove(&nbsp;)</b>.</p>

<p class=MsoNormal>The main program validates the command-line arguments and
then reads the input file a line at a time, looking for the special source code
delimiters. The Boolean flag <b>inCode</b> indicates that the program is in the
middle of a source file, so lines should be output. The <b>printDelims</b> flag
will be true if the opening token is not followed by an exclamation point;
otherwise the first and last lines are not written. It is important to check
for the closing delimiter first, because the start token is a subset, and
searching for the start token first would return a successful find for both
cases. If we encounter the closing token, we verify that we are in the middle
of processing a source file; otherwise, something is wrong with the way the
delimiters are laid out in the text file. If <b>inCode</b> is true, all is
well, and we (optionally) write the last line and close the file. When the
opening token is found, we parse the directory and file name components and
open the file. The following <b>string</b>-related functions were used in this
example: <b>length(&nbsp;)</b>, <b>append(&nbsp;)</b>, <b>getline(&nbsp;)</b>, <b>find(&nbsp;)</b>
(two versions), <b>find_first_not_of(&nbsp;)</b>, <b>substr(&nbsp;)</b>, <b>find_first_of(&nbsp;)</b>,
<b>c_str(&nbsp;)</b>, and, of course, <b>operator&lt;&lt;(&nbsp;)</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985671" name="_Toc53985671">Summary</a></h2>

<p class=MsoNormal>C++ <b>string</b> objects provide developers with a number
of great advantages over their C counterparts. For the most part, the <b>string</b>
class makes referring to strings with character pointers unnecessary. This
eliminates an entire class of software defects that arise from the use of
uninitialized and incorrectly valued pointers.</p>

<p class=MsoNormal>C++ strings dynamically and transparently grow their
internal data storage space to accommodate increases in the size of the string
data. When the data in a string grows beyond the limits of the memory initially
allocated to it, the string object will make the memory management calls that
take space from and return space to the heap. Consistent allocation schemes
prevent memory leaks and have the potential to be much more efficient than
“roll your own” memory management.</p>

<p class=MsoNormal>The <b>string</b> class member functions provide a fairly
comprehensive set of tools for creating, modifying, and searching in strings.
String comparisons are always case sensitive, but you can work around this by
copying string data to C-style null-terminated strings and using
case-insensitive string comparison functions, temporarily converting the data
held in string objects to a single case, or by creating a case-insensitive
string class that overrides the character traits used to create the <b>basic_string</b>
object.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef15743865" name="_Toc15743865">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write and test a function that reverses the order of the
characters in a string.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A palindrome is a word or group of words that read the same
forward and backward. For example “madam” or “wow.” Write a program that takes
a string argument from the command line and, using the function from the
previous exercise, prints whether the string was a palindrome or not.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Make your program from Exercise 2 return <b>true</b> even if
symmetric letters differ in case. For example, “Civic” would still return <b>true</b>
although the first letter is capitalized.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Change your program from Exercise 3 to ignore punctuation and
spaces as well. For example “Able was I, ere I saw Elba.” would report <b>true</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Using the following string declarations and only <b>char</b>s (no
string literals or magic numbers):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.7in;margin-right:0in'>
<div class=CC1>string one(<font color=#007f00>&quot;I walked down the canyon with the
moving mountain bikers.&quot;</font>);</div>
<div class=CC1>string
two(<font color=#007f00>&quot;The bikers passed by me too close for comfort.&quot;</font>);<br>
string three(<font color=#007f00>&quot;I went hiking instead.&quot;</font>);</div>

</div>

<p class=MsoNormal style='margin-left:.7in'>produce the following sentence:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.7in;margin-right:0in'>
<div class=CC1>I
moved down the canyon with the mountain bikers. The mountain bikers passed by
me too close <font color=#ff7700>for</font> comfort. So I went hiking instead.</div>

</div>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program named <b>replace</b> that takes three
command-line arguments representing an input text file, a string to replace
(call it <b>from</b>), and a replacement string (call it <b>to</b>). The
program should write a new file to standard output with all occurrences of <b>from</b>
replaced by <b>to</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Repeat the previous exercise but replace all instances of <b>from</b>
regardless of case.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Make your program from Exercise 3 take a filename from the command-line,
and then display all words that are palindromes (ignoring case) in the file. Do
not display duplicates (even if their case differs). Do not try to look for
palindromes that are larger than a word (unlike in Exercise 4).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>HTMLStripper.cpp</b> so that when it encounters a tag,
it displays the tag’s name, then displays the file’s contents between the tag
and the file’s ending tag. Assume no nesting of tags, and that all tags have
ending tags (denoted with &lt;/TAGNAME&gt;).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that takes three command-line arguments (a
filename and two strings) and displays to the console all lines in the file
that have both strings in the line, either string, only one string, or neither
string, based on user input at the beginning of the program (the user will
choose which matching mode to use). For all but the “neither string” option,
highlight the input string(s) by placing an asterisk (*) at the beginning and
end of each string’s occurrence when it is displayed.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that takes two command-line arguments (a filename
and a string) and counts the number of times the string occurs in the file,
even as a substring (but ignoring overlaps). For example, an input string of “ba”
would match twice in the word “basketball,” but an input string of “ana” would
match only once in the word “banana.” Display to the console the number of
times the string is matched in the file, as well as the average length of the
words where the string occurred. (If the string occurs more than once in a
word, only count the word once in figuring the average.)</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>12.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that takes a filename from the command line and
profiles the character usage, including punctuation and spaces (all character
values of 0x21 [33] through 0x7E [126], as well as the space character). That is,
count the number of occurrences of each character in the file, then display the
results sorted either sequentially (space, then !, &quot;, #, etc.) or by
ascending or descending frequency based on user input at the beginning of the
program. For space, display the word “Space” instead of the character ' '. A
sample run might look something like this:<br>
<span class=CodeInlineCharChar>Format sequentially, ascending, or descending
(S/A/D): D<br>
t:  526<br>
r:  490<br>
etc.</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>13.&nbsp;&nbsp;&nbsp;&nbsp;</span>Using <b>find(&nbsp;)</b> and <b>rfind(&nbsp;)</b>, write a
program that takes two command-line arguments (a filename and a string) and
displays the first and last words (and their indexes) not matching the string,
as well as the indexes of the first and last instances of the string. Display “Not
Found” if any of the searches fail.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>14.&nbsp;&nbsp;&nbsp;&nbsp;</span>Using the <b>find_first_of</b> “family” of functions (but not
exclusively), write a program that will remove all non-alphanumeric characters
except spaces and periods from a file, then capitalize the first letter
following a period.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>15.&nbsp;&nbsp;&nbsp;&nbsp;</span>Again using the <b>find_first_of</b> “family” of functions, write
a program that accepts a filename as a command-line argument and then formats
all numbers in the file to currency. Ignore decimal points after the first
until a non-numeric character is found, and round to the nearest hundredth. For
example, the string 12.399abc29.00.6a would be formatted (in the USA) to
$12.40abc$29.01a.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>16.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that accepts two command-line arguments (a
filename and a number) and scrambles each word in the file by randomly
switching two of its letters the number of times specified in the second
argument. (That is, if 0 is passed into your program from the command-line, the
words should not be scrambled; if 1 is passed in, one pair of randomly-chosen
letters should be swapped, for an input of 2, two random pairs should be
swapped, etc.).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>17.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that accepts a filename from the command line and
displays the number of sentences (defined as the number of periods in the
file), average number of characters per sentence, and the total number of
characters in the file.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>18.&nbsp;&nbsp;&nbsp;&nbsp;</span>Prove to yourself that the <b>at(&nbsp;)</b> member function
really will throw an exception if an attempt is made to go out of bounds, and
that the indexing operator (<b>[&nbsp;]</b>) won’t.</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section13>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985673" name="_Toc53985673">4: Iostreams</a></h1>

<p class=Intro style='margin-left:.25in'>You can do much more with the general
I/O problem than just take standard I/O and turn it into a class.</p>

<p class=MsoNormal>Wouldn’t it be nice if you could make all the usual
“receptacles”—standard I/O, files, and even blocks of memory—look the same so
that you need to remember only one interface? That’s the idea behind iostreams.
They’re much easier, safer, and sometimes even more efficient than the assorted
functions from the Standard C <b>stdio</b> library.</p>

<p class=MsoNormal>The iostreams classes are usually the first part of the C++
library that new C++ programmers learn to use. This chapter discusses how
iostreams are an improvement over C’s <b>stdio</b> facilities and explores the
behavior of file and string streams in addition to the standard console
streams.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305628663" name="_Toc305628663">Why iostreams?</a></h2>

<p class=MsoNormal>You might wonder what’s wrong with the good old C library.
Why not “wrap” the C library in a class and be done with it? Sometimes this is a
fine solution. For example, suppose you want to make sure that the file
represented by a <b>stdio</b> <b>FILE</b> pointer is always safely opened and
properly closed without having to rely on the user to remember to call the <b>close(&nbsp;)</b>
function. The following program is such an attempt:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:FileClass.h</font></div>
<div class=CC1><font color=#dd0000>// stdio files wrapped.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef FILECLASS_H</font></div>
<div class=CC1><font color=#7F7F00>#define FILECLASS_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> FileClass {</div>
<div class=CC1>  std::FILE* f;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>struct</font> FileClassError : std::runtime_error {</div>
<div class=CC1>    FileClassError(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg)</div>
<div class=CC1>    : std::runtime_error(msg) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  FileClass(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* mode =
<font color=#007f00>&quot;r&quot;</font>);</div>
<div class=CC1>  ~FileClass();</div>
<div class=CC1>  std::FILE* fp();</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// FILECLASS_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you perform file I/O in C, you work with a naked
pointer to a FILE <b>struct</b>, but this class wraps around the pointer and
guarantees it is properly initialized and cleaned up using the constructor and
destructor. The second constructor argument is the file mode, which defaults to
“r” for “read.”</p>

<p class=MsoNormal>To fetch the value of the pointer to use in the file I/O
functions, you use the <b>fp(&nbsp;)</b> access function. Here are the member
function definitions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:FileClass.cpp {O}</font></div>
<div class=CC1><font color=#dd0000>// FileClass Implementation.</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;FileClass.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>FileClass::FileClass(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname, <font color=#ff7700>const</font> <font color=#ff7700>char</font>*
mode) {</div>
<div class=CC1>  <font color=#ff7700>if</font>((f = fopen(fname, mode)) == 0)</div>
<div class=CC1>    <font color=#ff7700>throw</font> FileClassError(<font color=#007f00>&quot;Error opening
file&quot;</font>);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>FileClass::~FileClass() { fclose(f); }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>FILE* FileClass::fp() { <font color=#ff7700>return</font>
f; } <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The constructor calls <b>fopen(&nbsp;)</b>, as you would
normally do, but it also ensures that the result isn’t zero, which indicates a
failure upon opening the file. If the file does not open as expected, an exception
is thrown.</p>

<p class=MsoNormal>The destructor closes the file, and the access function <b>fp(&nbsp;)
</b>returns <b>f</b>. Here’s a simple example using <b>FileClass</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:FileClassTest.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} FileClass</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;FileClass.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    FileClass f(<font color=#007f00>&quot;FileClassTest.cpp&quot;</font>);</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>int</font> BSIZE = 100;</div>
<div class=CC1>    <font color=#ff7700>char</font> buf[BSIZE];</div>
<div class=CC1>    <font color=#ff7700>while</font>(fgets(buf, BSIZE, f.fp()))</div>
<div class=CC1>      fputs(buf, stdout);</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(FileClass::FileClassError&amp; e) {</div>
<div class=CC1>    cout &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> EXIT_SUCCESS;</div>
<div class=CC1>} <font color=#dd0000>// File automatically closed by destructor</font></div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You create the <b>FileClass</b> object and use it in normal
C file I/O function calls by calling <b>fp(&nbsp;)</b>. When you’re done with
it, just forget about it; the file is closed by the destructor at the end of
its scope.</p>

<p class=MsoNormal>Even though the <b>FILE</b> pointer is private, it isn’t
particularly safe because <b>fp(&nbsp;)</b> retrieves it. Since the only effect
seems to be guaranteed initialization and cleanup, why not make it public or
use a <b>struct</b> instead? Notice that while you can get a copy of <b>f</b>
using <b>fp(&nbsp;)</b>, you cannot assign to <b>f</b>—that’s completely under
the control of the class. After capturing the pointer returned by <b>fp(&nbsp;)</b>,
the client programmer can still assign to the structure elements or even close
it, so the safety is in guaranteeing a valid <b>FILE</b> pointer rather than
proper contents of the structure.</p>

<p class=MsoNormal>If you want complete safety, you must prevent the user from
directly accessing the <b>FILE</b> pointer. Some version of all the normal file
I/O functions must show up as class members so that everything you can do with
the C approach is available in the C++ class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Fullwrap.h</font></div>
<div class=CC1><font color=#dd0000>// Completely hidden file IO.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef FULLWRAP_H</font></div>
<div class=CC1><font color=#7F7F00>#define FULLWRAP_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#7F7F00>#undef getc</font></div>
<div class=CC1><font color=#7F7F00>#undef putc</font></div>
<div class=CC1><font color=#7F7F00>#undef ungetc</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::fpos_t;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> File {</div>
<div class=CC1>  std::FILE* f;</div>
<div class=CC1>  std::FILE* F(); <font color=#dd0000>// Produces checked pointer to f</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  File(); <font color=#dd0000>// Create object but don't open file</font></div>
<div class=CC1>  File(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* path, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* mode =
<font color=#007f00>&quot;r&quot;</font>);</div>
<div class=CC1>  ~File();</div>
<div class=CC1>  <font color=#ff7700>int</font> open(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* path, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* mode =
<font color=#007f00>&quot;r&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> reopen(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* path, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* mode);</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>int</font> getc();</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>int</font> ungetc(<font color=#ff7700>int</font> c);</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>int</font> putc(<font color=#ff7700>int</font> c);</div>
<div class=CC1>  <font color=#ff7700>int</font> puts(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* s);</div>
<div class=CC1>  <font color=#ff7700>char</font>* gets(<font color=#ff7700>char</font>* s, <font color=#ff7700>int</font> n);</div>
<div class=CC1>  <font color=#ff7700>int</font> printf(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* format, ...);</div>
<div class=CC1>  size_t read(<font color=#ff7700>void</font>* ptr, size_t size, size_t n);</div>
<div class=CC1>  size_t write(<font color=#ff7700>const</font> <font color=#ff7700>void</font>* ptr, size_t size, size_t n);</div>
<div class=CC1>  <font color=#ff7700>int</font> eof();</div>
<div class=CC1>  <font color=#ff7700>int</font> close();</div>
<div class=CC1>  <font color=#ff7700>int</font> flush();</div>
<div class=CC1>  <font color=#ff7700>int</font> seek(<font color=#ff7700>long</font> offset, <font color=#ff7700>int</font> whence);</div>
<div class=CC1>  <font color=#ff7700>int</font> getpos(fpos_t* pos);</div>
<div class=CC1>  <font color=#ff7700>int</font> setpos(<font color=#ff7700>const</font> fpos_t* pos);</div>
<div class=CC1>  <font color=#ff7700>long</font> tell();</div>
<div class=CC1>  <font color=#ff7700>void</font> rewind();</div>
<div class=CC1>  <font color=#ff7700>void</font> setbuf(<font color=#ff7700>char</font>* buf);</div>
<div class=CC1>  <font color=#ff7700>int</font> setvbuf(<font color=#ff7700>char</font>* buf, <font color=#ff7700>int</font> type, size_t sz);</div>
<div class=CC1>  <font color=#ff7700>int</font> error();</div>
<div class=CC1>  <font color=#ff7700>void</font> clearErr();</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// FULLWRAP_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This class contains almost all the file I/O functions from <b>&lt;cstdio&gt;</b>.
(<b>vfprintf(&nbsp;)</b> is missing; it implements the <b>printf(&nbsp;)</b> member function.)</p>

<p class=MsoNormal><b>File</b> has the same constructor as in the previous
example, and it also has a default constructor. The default constructor is
important if you want to create an array of <b>File</b> objects or use a <b>File</b>
object as a member of another class where the initialization doesn’t happen in
the constructor, but some time after the enclosing object is created.</p>

<p class=MsoNormal>The default constructor sets the private <b>FILE</b> pointer
<b>f</b> to zero. But now, before any reference to <b>f</b>, its value must be
checked to ensure it isn’t zero. This is accomplished with <b>F(&nbsp;)</b>,
which is <b>private</b> because it is intended to be used only by other member
functions. (We don’t want to give the user direct access to the underlying <b>FILE</b>
structure in this class.)</p>

<p class=MsoNormal>This approach is not a terrible solution by any means. It’s
quite functional, and you could imagine making similar classes for standard
(console) I/O and for in-core formatting (reading/writing a piece of memory
rather than a file or the console).</p>

<p class=MsoNormal>The stumbling block is the runtime interpreter used for the
variable argument list functions. This is the code that parses your format
string at runtime and grabs and interprets arguments from the variable argument
list. It’s a problem for four reasons.</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Even if you use only a fraction of the functionality of the
interpreter, the whole thing gets loaded into your executable. So if you say <b>printf(&quot;%c&quot;,
'x');</b>, you’ll get the whole package, including the parts that print
floating-point numbers and strings. There’s no standard option for reducing the
amount of space used by the program.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Because the interpretation happens at runtime, you can’t get rid
of a performance overhead. It’s frustrating because all the information is <i>there</i>
in the format string at compile time, but it’s not evaluated until runtime.
However, if you could parse the arguments in the format string at compile time,
you could make direct function calls that have the potential to be much faster
than a runtime interpreter (although the <b>printf(&nbsp;)</b> family of
functions is usually quite well optimized).</p>

<p class=Numbered><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Because the format string is not evaluated until runtime, there
can be no compile-time error checking. You’re probably familiar with this problem if you’ve tried to find bugs that came from using the wrong number or type of
arguments in a <b>printf(&nbsp;)</b> statement. C++ makes a big deal out of
compile-time error checking to find errors early and make your life easier. It
seems a shame to throw type safety away for an I/O library, especially since
I/O is used a lot.</p>

<p class=Numbered><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>For C++, the most crucial problem is that the <b>printf(&nbsp;)</b>
family of functions is not particularly extensible. They’re really designed to
handle only the basic data types in C (<b>char</b>, <b>int</b>, <b>float</b>, <b>double</b>,
<b>wchar_t</b>, <b>char*</b>, <b>wchar_t*</b>, and <b>void*)</b> and their
variations. You might think that every time you add a new class, you could add
overloaded <b>printf(&nbsp;)</b> and <b>scanf(&nbsp;)</b> functions (and their
variants for files and strings), but remember, overloaded functions must have
different types in their argument lists, and the <b>printf(&nbsp;)</b> family
hides its type information in the format string and in the variable argument
list. For a language such as C++, whose goal is to be able to easily add new
data types, this is an unacceptable restriction.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305628664" name="_Toc305628664">Iostreams to the rescue</a></h2>

<p class=MsoNormal>These issues make it clear that I/O is one of the first
priorities for the Standard C++ class libraries. Because “hello, world” is the
first program just about everyone writes in a new language, and because I/O is
part of virtually every program, the I/O library in C++ must be particularly
easy to use. It also has the much greater challenge that it must accommodate
any new class. Thus, its constraints require that this foundation class library
be a truly inspired design. In addition to gaining a great deal of leverage and
clarity in your dealings with I/O and formatting, you’ll also see in this
chapter how a really powerful C++ library can work.</p>

<h3><a href="#_TocRef312373878" name="_Toc312373878">Inserters and extractors</a></h3>

<p class=MsoNormal>A <i>stream</i> is an object that transports and formats
characters of a fixed width. You can have an input stream (via descendants of
the <b>istream</b> class), an output stream (with <b>ostream</b> objects), or a stream that does both simultaneously (with objects derived from <b>iostream</b>).
The iostreams library provides different types of such classes: <b>ifstream</b>,<i>
</i><b>ofstream</b>, and <b>fstream</b> for files, and <b>istringstream</b>, <b>ostringstream</b>, and <b>stringstream</b> for interfacing with the Standard C++ <b>string</b>
class. All these stream classes have nearly identical interfaces, so you can
use streams in a uniform manner, whether you’re working with a file, standard
I/O, a region of memory, or a <b>string</b> object. The single interface you
learn also works for extensions added to support new classes. Some functions
implement your formatting commands, and some functions read and write
characters without formatting.</p>

<p class=MsoNormal>The stream classes mentioned earlier are actually template
specializations,<a href="#_ftn41" name="_ftnref41"><span
class=MsoFootnoteReference>[41]</span></a> much
like the standard <b>string</b> class is a specialization of the <b>basic_string</b>
template. The basic classes in the iostreams inheritance hierarchy are shown in
the following figure:</p>

<p class=MsoNormal style='page-break-after:avoid'><img width=483 height=354
src="TicV2_files/image007.gif"></p>

<p class=MsoNormal>The <b>ios_base</b> class declares everything that is common
to all streams, independent of the type of character the stream handles. These
declarations are mostly constants and functions to manage them, some of which
you’ll see throughout this chapter. The rest of the classes are templates that
have the underlying character type as a parameter. The <b>istream</b> class,
for example, is defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> basic_istream&lt;<font color=#ff7700>char</font>&gt; istream;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>All the classes mentioned earlier are defined via similar
type definitions. There are also type definitions for all stream classes using <b>wchar_t</b>
(the wide character type discussed in Chapter 3) instead of <b>char</b>. We’ll
look at these at the end of this chapter. The <b>basic_ios</b> template defines
functions common to both input and output, but that depends on the underlying
character type (we won’t use these much). The template <b>basic_istream</b> defines generic functions for input, and <b>basic_ostream</b> does the same for output. The classes for file and string streams introduced later add functionality for their
specific stream types.</p>

<p class=MsoNormal>In the iostreams library, two operators are overloaded to
simplify the use of iostreams. The operator <b>&lt;&lt;</b> is often referred to as an <i>inserter</i> for iostreams, and the operator <b>&gt;&gt;</b> is often referred to as an <i>extractor</i>.</p>

<p class=MsoNormal>Extractors parse the information that’s expected by the
destination object according to its type. To see an example of this, you can
use the <b>cin</b> object, which is the iostream equivalent of <b>stdin</b> in
C, that is, redirectable standard input. This object is predefined whenever you
include the <b>&lt;iostream&gt; </b>header.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <span lang=SV><font color=#ff7700>int</font> i;</span></div>
<div class=CC1><span lang=SV>  cin &gt;&gt; i;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>float</font> f;</span></div>
<div class=CC1><span lang=SV>  cin &gt;&gt; f;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>char</font> c;</span></div>
<div class=CC1><span lang=SV>  cin &gt;&gt; c;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>char</font> buf[100];</div>
<div class=CC1>  cin &gt;&gt; buf;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>There’s an overloaded <b>operator &gt;&gt;</b> for every
built-in data type. You can also overload your own, as you’ll see later.</p>

<p class=MsoNormal>To find out what you have in the various variables, you can
use the <b>cout</b> object (corresponding to standard output; there’s also a <b>cerr</b> object corresponding to standard error) with the inserter <b>&lt;&lt;</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;i = &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; i;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n&quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;f = &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; f;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n&quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c = &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; c;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n&quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;buf = &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; buf;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n&quot;</font>;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This is tedious and doesn’t seem like much of an improvement
over <b>printf(&nbsp;)</b>, despite improved type checking. Fortunately, the
overloaded inserters and extractors are designed to be chained into a more complex expression that is much easier to write (and read):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;i = &quot;</font> &lt;&lt; i &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;f = &quot;</font> &lt;&lt; f &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c = &quot;</font> &lt;&lt; c &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;buf = &quot;</font> &lt;&lt; buf &lt;&lt; endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Defining inserters and extractors for your own classes is
just a matter of overloading the associated operators to do the right things,
namely:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Make the first parameter a non-<b>const</b> reference to the
stream (<b>istream</b> for input, <b>ostream</b> for output).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Perform the operation by inserting/extracting data to/from the
stream (by processing the components of the object).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Return a reference to the stream.</p>

<p class=MsoNormal>The stream should be non-<b>const</b> because processing
stream data changes the state of the stream. By returning the stream, you allow
for chaining stream operations in a single statement, as shown earlier.</p>

<p class=MsoNormal>As an example, consider how to output the representation of
a <b>Date</b> object in MM-DD-YYYY format. The following inserter does the job:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
Date&amp; d) {</div>
<div class=CC1>  <font color=#ff7700>char</font> fillc = os.fill('0');</div>
<div class=CC1>  os &lt;&lt; setw(2) &lt;&lt; d.getMonth() &lt;&lt;
'-'</div>
<div class=CC1>     &lt;&lt; setw(2) &lt;&lt; d.getDay() &lt;&lt; '-'</div>
<div class=CC1>     &lt;&lt; setw(4) &lt;&lt; setfill(fillc) &lt;&lt;
d.getYear();</div>
<div class=CC1>  <font color=#ff7700>return</font> os;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This function cannot be a member of the <b>Date</b> class
because the left operand of the <b>&lt;&lt;</b> operator must be the output
stream. The <b>fill(&nbsp;)</b> member function of <b>ostream</b> changes the
padding character used when the width of an output field, determined by the <i>manipulator</i>
<b>setw(&nbsp;)</b>, is greater than needed for the data. We use a ‘0’
character so that months preceding October will display a leading zero, such as
“09” for September. The <b>fill(&nbsp;)</b> function also returns the previous
fill character (which defaults to a single space) so that we can restore it
later with the manipulator <b>setfill(&nbsp;)</b>. We discuss manipulators in
depth later in this chapter.</p>

<p class=MsoNormal>Extractors require a little more care because things can go
wrong with input data. The way to signal a stream error is to set the stream’s <i>fail
bit</i>, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>istream&amp; <font color=#ff7700>operator</font>&gt;&gt;(istream&amp; is,
Date&amp; d) {</div>
<div class=CC1>  is &gt;&gt; d.month;</div>
<div class=CC1>  <font color=#ff7700>char</font> dash;</div>
<div class=CC1>  is &gt;&gt; dash;</div>
<div class=CC1>  <font color=#ff7700>if</font>(dash != '-')</div>
<div class=CC1>    is.setstate(ios::failbit);</div>
<div class=CC1>  is &gt;&gt; d.day;</div>
<div class=CC1>  is &gt;&gt; dash;</div>
<div class=CC1>  <font color=#ff7700>if</font>(dash != '-')</div>
<div class=CC1>    is.setstate(ios::failbit);</div>
<div class=CC1>  is &gt;&gt; d.year;</div>
<div class=CC1>  <font color=#ff7700>return</font> is;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When an error bit is set in a stream, all further streams
operations are ignored until the stream is restored to a good state (explained
shortly). That’s why the code above continues extracting even if <b>ios::failbit</b> gets set. This implementation is somewhat forgiving in that it allows white space between
the numbers and dashes in a date string (because the <b>&gt;&gt;</b> operator
skips white space by default when reading built-in types). The following are
valid date strings for this extractor:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#007f00>&quot;08-10-2003&quot;</font></div>
<div class=CC1><font color=#007f00>&quot;8-10-2003&quot;</font></div>
<div class=CC1><font color=#007f00>&quot;08 - 10 - 2003&quot;</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>but these are not:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#007f00>&quot;A-10-2003&quot;</font> <font color=#dd0000>// No alpha characters allowed</font></div>
<div class=CC1><font color=#007f00>&quot;08%10/2003&quot;</font> <font color=#dd0000>// Only
dashes allowed as a delimiter</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We’ll discuss stream state in more depth in the section
“Handling stream errors” later in this chapter.</p>

<h3><a href="#_TocRef312373879" name="_Toc312373879">Common usage</a></h3>

<p class=MsoNormal>As the <b>Date</b> extractor illustrated, you must be on
guard for erroneous input. If the input produces an unexpected value, the
process is skewed, and it’s difficult to recover. In addition, formatted input
defaults to white space delimiters. Consider what happens when we collect the
code fragments from earlier in this chapter into a single program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Iosexamp.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Iostream examples.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><span lang=SV><font color=#ff7700>int</font> main() {</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>int</font> i;</span></div>
<div class=CC1><span lang=SV>  cin &gt;&gt; i;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>float</font> f;</div>
<div class=CC1>  cin &gt;&gt; f;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#ff7700>char</font> c;</div>
<div class=CC1>  <span lang=SV>cin &gt;&gt; c;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>char</font> buf[100];</span></div>
<div class=CC1><span lang=SV>  cin &gt;&gt; buf;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  </span>cout &lt;&lt; <font color=#007f00>&quot;i = &quot;</font>
&lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;f = &quot;</font> &lt;&lt; f &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c = &quot;</font> &lt;&lt; c &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;buf = &quot;</font> &lt;&lt; buf
&lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  cout &lt;&lt; flush;</div>
<div class=CC1>  cout &lt;&lt; hex &lt;&lt; <font color=#007f00>&quot;0x&quot;</font> &lt;&lt; i
&lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>and give it the following input:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>12 1.4 c <font color=#ff7700>this</font> is a test</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We expect the same output as if we gave it</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>12</div>
<div class=CC1>1.4</div>
<div class=CC1>c</div>
<div class=CC1><font color=#ff7700>this</font> is a test</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>but the output is, somewhat unexpectedly</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>i = 12</div>
<div class=CC1>f = 1.4</div>
<div class=CC1>c = c</div>
<div class=CC1>buf = <font color=#ff7700>this</font></div>
<div class=CC1>0xc</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that <b>buf</b> got only the first word because the
input routine looked for a space to delimit the input, which it saw after
“this.” In addition, if the continuous input string is longer than the storage
allocated for <b>buf</b>, we overrun the buffer.</p>

<p class=MsoNormal>In practice, you’ll usually want to get input from
interactive programs a line at a time as a sequence of characters, scan them,
and then perform conversions once they’re safely in a buffer. This way you
don’t need to worry about the input routine choking on unexpected data.</p>

<p class=MsoNormal>Another consideration is the whole concept of a command-line
interface. This made sense in the past when the console was little more than a
glass typewriter, but the world is rapidly changing to one where the graphical
user interface (GUI) dominates. What is the meaning of console I/O in such a world? It makes much more sense to ignore <b>cin</b> altogether, other
than for simple examples or tests, and take the following approaches:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>If your program requires input, read that input from a
file—you’ll soon see that it’s remarkably easy to use files with iostreams.
Iostreams for files still works fine with a GUI.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Read the input without attempting to convert it, as we just
suggested. When the input is some place where it can’t foul things up during
conversion, you can safely scan it.</p>

<p class=Numbered><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Output is different. If you’re using a GUI, <b>cout</b> doesn’t
necessarily work, and you must send it to a file (which is identical to sending
it to <b>cout</b>) or use the GUI facilities for data display. Otherwise it
often makes sense to send it to <b>cout</b>. In both cases, the output
formatting functions of iostreams are highly useful.</p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>Another common
practice saves compile time on large projects. Consider, for example, how you
would declare the <b>Date</b> stream operators introduced earlier in the
chapter in a header file. You only need to include the prototypes for the
functions, so it’s not really necessary to include the entire <b>&lt;iostream&gt;</b>
header in <b>Date.h</b>. The standard practice is to only declare classes,
something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>class</font> ostream;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>This is an age-old
technique for separating interface from implementation and is often called a <i>forward
declaration</i> (and <b>ostream</b> at this point would be considered an <i>incomplete
type</i>, since the class definition has not yet been seen by the compiler).</p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>This will not work
as is, however, for two reasons:</p>

<p class=Numbered style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;The
stream classes are defined in the <b>std</b> namespace.</p>

<p class=Numbered style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;They
are templates.</p>

<p class=Numbered style='margin-left:.25in;text-indent:0in'>The proper
declaration would be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>namespace</font> std {</div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, <font color=#ff7700>class</font> traits =
char_traits&lt;charT&gt; &gt;</div>
<div class=CC1>    <font color=#ff7700>class</font> basic_ostream;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> basic_ostream&lt;<font color=#ff7700>char</font>&gt; ostream;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>(As you can see, like the <b>string</b>
class, the streams classes use the character traits classes mentioned in
Chapter 3). Since it would be terribly tedious to type all that for every
stream class you want to reference, the standard provides a header that does it
for you: <b>&lt;iosfwd&gt;</b></a>. The <b>Date</b> header would then look
something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// Date.h</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iosfwd&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Date {</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp;
<font color=#ff7700>operator</font>&lt;&lt;(std::ostream&amp;,</div>
<div class=CC1>                                  <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::istream&amp;
<font color=#ff7700>operator</font>&gt;&gt;(std::istream&amp;, Date&amp;);</div>
<div class=CC1>  <font color=#dd0000>// Etc.</font></div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef53985678" name="_Toc53985678">Line–oriented input</a></h3>

<p class=MsoNormal>To grab input a line at a time, you have three choices:</p>

<p class=MsoListNumber style='margin-left:.75in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The member function <b>get(&nbsp;)</b></p>

<p class=MsoListNumber style='margin-left:.75in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The member function <b>getline(&nbsp;)</b></p>

<p class=MsoListNumber style='margin-left:.75in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The global function <b>getline(&nbsp;)</b> defined in the <b>&lt;string&gt;</b>
header</p>

<p class=MsoNormal>The first two functions take three arguments:</p>

<p class=MsoListNumber style='margin-top:0in;margin-right:0in;margin-bottom:
6.0pt;margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A pointer to a character buffer in which to store the result.</p>

<p class=MsoListNumber style='margin-top:0in;margin-right:0in;margin-bottom:
6.0pt;margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The size of that buffer (so it’s not overrun).</p>

<p class=MsoListNumber style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The terminating character, to know when to stop reading input.</p>

<p class=MsoNormal>The terminating character has a default value of <b>'\n'</b>,
which is what you’ll usually use. Both functions store a zero in the result
buffer when they encounter the terminating character in the input.</p>

<p class=MsoNormal>So what’s the difference? Subtle, but important: <b>get(&nbsp;)</b>
stops when it <i>sees</i> the delimiter in the input stream, but it doesn’t
extract it from the input stream. Thus, if you did another <b>get(&nbsp;)</b>
using the same delimiter, it would immediately return with no fetched input.
(Presumably, you either use a different delimiter in the next <b>get(&nbsp;)</b>
statement or a different input function.) The <b>getline(&nbsp;) </b>function,
on the other hand, extracts the delimiter from the input stream, but still
doesn’t store it in the result buffer.</p>

<p class=MsoNormal>The <b>getline(&nbsp;)</b> function defined in <b>&lt;string&gt;</b>
is convenient. It is not a member function, but rather a stand-alone function
declared in the namespace <b>std</b>. It takes only two non-default arguments,
the input stream and the <b>string</b> object to populate. Like its namesake,
it reads characters until it encounters the first occurrence of the delimiter (<b>'\n'</b>
by default) and consumes and discards the delimiter. The advantage of this
function is that it reads into a <b>string</b> object, so you don’t need to
worry about buffer size.</p>

<p class=MsoNormal>Generally, when you’re processing a text file that you read
a line at a time, you’ll want to use one of the <b>getline(&nbsp;)</b>
functions.</p>

<h4>Overloaded versions of get(&nbsp;)</h4>

<p class=MsoNormal>The<b> get(&nbsp;)</b> function also comes in three other
overloaded versions: one with no arguments that returns the next character
using an <b>int</b> return value; one that stuffs a character into its <b>char</b>
argument using a reference; and one that stores directly into the underlying
buffer structure of another iostream object. The latter is explored later in
the chapter.</p>

<h4>Reading raw bytes</h4>

<p class=MsoNormal>If you know exactly what you’re dealing with and want to
move the bytes directly into a variable, an array, or a structure in memory,
you can use the unformatted I/O function <b>read(&nbsp;)</b>. The first argument for this function is a pointer to the destination memory, and the second is the number of bytes
to read. This is especially useful if you’ve previously stored the information
to a file, for example, in binary form using the complementary <b>write(&nbsp;)
</b> member function for an output stream (using the same compiler, of course).
You’ll see examples of all these functions later.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985679" name="_Toc53985679">Handling
stream errors</a></h2>

<p class=MsoNormal>The <b>Date</b> extractor shown earlier sets a stream’s fail
bit under certain conditions. How does the user know when such a failure
occurs? You can detect stream errors by either calling certain stream member
functions to see if an error state has occurred, or if you don’t care what the
particular error was, you can just evaluate the stream in a Boolean context.
Both techniques derive from the state of a stream’s error bits.</p>

<h4>Stream state</h4>

<p class=MsoNormal>The <b>ios_base</b> class, from which <b>ios</b> derives,<a href="#_ftn42" name="_ftnref42"><span
class=MsoFootnoteReference>[42]</span></a> defines four
flags that you can use to test the state of a stream:</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse'>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Flag</p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Meaning</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>badbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Some fatal (perhaps physical) error occurred. The stream
  should be considered unusable.</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>eofbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>End-of-input has occurred (either by encountering the
  physical end of a file stream or by the user terminating a console stream,
  such as with Ctrl-Z or Ctrl&#8209;D).</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>failbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>An I/O operation failed, most likely because of invalid
  data (e.g., letters were found when trying to read a number). The stream is
  still usable. The failbit flag is also set when end-of-input occurs.</p>
  </td>
 </tr>
 <tr>
  <td width=102 valign=top style='width:76.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>goodbit</b></p>
  </td>
  <td width=324 valign=top style='width:243.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>All is well; no errors. End-of-input has not yet occurred.</p>
  </td>
 </tr>
</table>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can test whether any of these conditions have occurred
by calling corresponding member functions that return a Boolean value
indicating whether any of these have been set. The <b>good(&nbsp;)</b> stream
member function returns true if none of the other three bits are set. The <b>eof(&nbsp;)</b>
function returns true if <b>eofbit</b> is set, which happens with an attempt to
read from a stream that has no more data (usually a file). Because end-of-input
happens in C++ when trying to read past the end of the physical medium, <b>failbit</b>
is also set to indicate that the “expected” data was not successfully read. The
<b>fail(&nbsp;)</b> function returns true if <i>either</i> <b>failbit</b> or <b>badbit</b>
is set, and <b>bad(&nbsp;)</b> returns true only if the <b>badbit</b> is set.</p>

<p class=MsoNormal>Once any of the error bits in a stream’s state are set, they
remain set, which is not always what you want. When reading a file, you might
want to reposition to an earlier place in the file before end-of-file occurred.
Just moving the file pointer doesn’t automatically reset <b>eofbit</b> or <b>failbit</b>;
you must do it yourself with the <b>clear(&nbsp;)</b> function, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>myStream.clear(); <font color=#dd0000>// Clears all error bits</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>After calling <b>clear(&nbsp;)</b>, <b>good(&nbsp;)</b> will
return <b>true</b> if called immediately. As you saw in the <b>Date</b>
extractor earlier, the <b>setstate(&nbsp;)</b> function sets the bits you pass
it. It turns out that <b>setstate(&nbsp;)</b> doesn’t affect any other bits—if
they’re already set, they stay set. If you want to set certain bits but at the
same time reset all the rest, you can call an overloaded version of <b>clear(&nbsp;)</b>,
passing it a bitwise expression representing the bits you want to set, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>myStream.clear(ios::failbit | ios::eofbit);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Most of the time you won’t be interested in checking the
stream state bits individually. Usually you just want to know if everything is
okay. This is the case when you read a file from beginning to end; you just
want to know when the input data is exhausted. You can use a conversion function
defined for <b>void*</b> that is automatically called when a stream occurs in a
Boolean expression. Reading a stream until end-of-input using this idiom looks
like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> i;</div>
<div class=CC1><font color=#ff7700>while</font>(myStream &gt;&gt; i)</div>
<div class=CC1>  cout &lt;&lt; i &lt;&lt;
endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Remember that <b>operator&gt;&gt;(&nbsp;)</b> returns its
stream argument, so the <b>while</b> statement above tests the stream as a
Boolean expression. This particular example assumes that the input stream <b>myStream</b>
contains integers separated by white space. The function <b>ios_base::operator
void*(&nbsp;)</b> simply calls <b>good(&nbsp;)</b> on its stream and returns
the result.<a href="#_ftn43" name="_ftnref43"><span
class=MsoFootnoteReference>[43]</span></a> Because
most stream operations return their stream, using this idiom is convenient.</p>

<h4>Streams and exceptions</h4>

<p class=MsoNormal>Iostreams existed as part of C++ long before there were
exceptions, so checking stream state manually was just the way things were done.
For backward compatibility, this is still the status quo, but modern iostreams
can throw exceptions instead. The <b>exceptions(&nbsp;)</b> stream member
function takes a parameter representing the state bits for which you want
exceptions to be thrown. Whenever the stream encounters such a state, it throws
an exception of type <b>std::ios_base::failure</b>, which inherits from <b>std::exception</b>.</p>

<p class=MsoNormal>Although you can trigger a failure exception for any of the
four stream states, it’s not necessarily a good idea to enable exceptions for
all of them. As Chapter 1 explains, use exceptions for truly exceptional
conditions, but end-of-file is not only <i>not</i> exceptional—it’s <i>expected</i>!
For that reason, you might want to enable exceptions only for the errors
represented by <b>badbit</b>, which you would do like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>myStream.exceptions(ios::badbit);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You enable exceptions on a stream-by-stream basis, since <b>exceptions(&nbsp;)</b>
is a member function for streams. The <b>exceptions(&nbsp;)</b> function
returns a bitmask<a href="#_ftn44" name="_ftnref44"><span
class=MsoFootnoteReference>[44]</span></a> (of
type <b>iostate</b>, which is some compiler-dependent type convertible to <b>int</b>)
indicating which stream states will cause exceptions. If those states have
already been set, an exception is thrown immediately. Of course, if you use
exceptions in connection with streams, you had better be ready to catch them,
which means that you need to wrap all stream processing with a <b>try</b> block
that has an <b>ios::failure</b> handler. Many programmers find this tedious and
just check states manually where they expect errors to occur (since, for
example, they don’t expect <b>bad(&nbsp;)</b> to return <b>true</b> most of the
time anyway). This is another reason that having streams throw exceptions is
optional and not the default. In any case, you can choose how you want to
handle stream errors. For the same reasons that we recommend using exceptions
for error handling in other contexts, we do so here.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305628665" name="_Toc305628665">File iostreams</a></h2>

<p class=MsoNormal>Manipulating files with iostreams is much easier and safer
than using <b>stdio </b>in C. All you do to open a file is create an object—the
constructor does the work. You don’t need to explicitly close a file (although
you can, using the <b>close(&nbsp;)</b> member function) because the destructor will close it when the object goes out of scope. To create a file that defaults to input,
make an <b>ifstream</b> object. To create one that defaults to output, make an <b>ofstream</b>
object. An <b>fstream</b> object can do both input and output.</p>

<p class=MsoNormal>The file stream classes fit into the iostreams classes as
shown in the following figure:</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt'><img
width=495 height=327 src="TicV2_files/image008.gif"></p>

<p class=MsoNormal>As before, the classes you actually use are template
specializations defined by type definitions. For example, <b>ifstream</b>,
which processes files of <b>char</b>, is defined as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> basic_ifstream&lt;<font color=#ff7700>char</font>&gt; ifstream;</div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef53985681" name="_Toc53985681">A File–Processing Example</a></h3>

<p class=MsoNormal>Here’s an example that shows many of the features discussed
so far. Notice the inclusion of <b>&lt;fstream&gt;</b><b> </b>to declare the file I/O classes. Although on many platforms this will also include <b>&lt;iostream&gt;</b>
automatically, compilers are not required to do so. If you want portable code,
always include both headers.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Strfile.cpp</font></div>
<div class=CC1><font color=#dd0000>// Stream I/O with files;</font></div>
<div class=CC1><font color=#dd0000>// The difference between get() &amp; getline().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 100; <font color=#dd0000>// Buffer size;</font></div>
<div class=CC1>  <font color=#ff7700>char</font> buf[SZ];</div>
<div class=CC1>  {</div>
<div class=CC1>    ifstream in(<font color=#007f00>&quot;Strfile.cpp&quot;</font>); <font color=#dd0000>// Read</font></div>
<div class=CC1>    assure(in, <font color=#007f00>&quot;Strfile.cpp&quot;</font>); <font color=#dd0000>// Verify open</font></div>
<div class=CC1>    ofstream out(<font color=#007f00>&quot;Strfile.out&quot;</font>); <font color=#dd0000>// Write</font></div>
<div class=CC1>    assure(out, <font color=#007f00>&quot;Strfile.out&quot;</font>);</div>
<div class=CC1>    <font color=#ff7700>int</font> i = 1; <font color=#dd0000>// Line counter</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1>    <font color=#dd0000>// A less-convenient approach for line input:</font></div>
<div class=CC1>    <font color=#ff7700>while</font>(in.get(buf, SZ)) { <font color=#dd0000>// Leaves \n in input</font></div>
<div class=CC1>      in.get(); <font color=#dd0000>// Throw away next character (\n)</font></div>
<div class=CC1>      cout &lt;&lt; buf &lt;&lt; endl; <font color=#dd0000>// Must add \n</font></div>
<div class=CC1>      <font color=#dd0000>// File output just like standard I/O:</font></div>
<div class=CC1>      out &lt;&lt; i++ &lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt;
buf &lt;&lt; endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  } <font color=#dd0000>// Destructors close in &amp; out</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Strfile.out&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;Strfile.out&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// More convenient line input:</font></div>
<div class=CC1>  <font color=#ff7700>while</font>(in.getline(buf, SZ)) { <font color=#dd0000>// Removes \n</font></div>
<div class=CC1>    <font color=#ff7700>char</font>* cp = buf;</div>
<div class=CC1>    <font color=#ff7700>while</font>(*cp != ':')</div>
<div class=CC1>      ++cp;</div>
<div class=CC1>    cp += 2; <font color=#dd0000>// Past &quot;: &quot;</font></div>
<div class=CC1>    cout &lt;&lt; cp &lt;&lt; endl; <font color=#dd0000>// Must still add
\n</font></div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The creation of both the <b>ifstream</b> and <b>ofstream</b>
are followed by an <b>assure(&nbsp;)</b> to guarantee the file was successfully
opened. Here again the object, used in a situation where the compiler expects a
Boolean result, produces a value that indicates success or failure.</p>

<p class=MsoNormal>The first <b>while</b> loop demonstrates the use of two
forms of the <b>get(&nbsp;)</b> function. The first gets characters into a
buffer and puts a zero terminator in the buffer when either <b>SZ-1</b>
characters have been read or the third argument (defaulted to <b>'\n'</b>) is
encountered. The <b>get(&nbsp;)</b> function leaves the terminator character in
the input stream, so this terminator must be thrown away via <b>in.get(&nbsp;)</b>
using the form of <b>get(&nbsp;)</b> with no argument, which fetches a single
byte and returns it as an <b>int</b>. You can also use the <b>ignore(&nbsp;)</b>
member function, which has two default arguments. The first argument is the
number of characters to throw away and defaults to one. The second argument is
the character at which the <b>ignore(&nbsp;)</b> function quits (after
extracting it) and defaults to <b>EOF</b>.</p>

<p class=MsoNormal>Next, you see two output statements that look similar: one
to <b>cout </b>and one to the file <b>out</b>. Notice the convenience here—you don’t
need to worry about the object type because the formatting statements work the
same with all <b>ostream</b> objects. The first one echoes the line to standard
output, and the second writes the line out to the new file and includes a line
number.</p>

<p class=MsoNormal>To demonstrate <b>getline(&nbsp;)</b>, open the file we just
created and strip off the line numbers. To ensure the file is properly closed
before opening it to read, you have two choices. You can surround the first
part of the program with braces to force the <b>out</b> object out of scope,
thus calling the destructor and closing the file, which is done here. You can
also call <b>close(&nbsp;)</b> for both files; if you do this, you can even
reuse the <b>in</b> object by calling the <b>open(&nbsp;)</b> member function.</p>

<p class=MsoNormal>The second <b>while</b> loop shows how <b>getline(&nbsp;)</b>
removes the terminator character (its third argument, which defaults to <b>'\n'</b>)
from the input stream when it’s encountered. Although <b>getline(&nbsp;)</b>,
like <b>get(&nbsp;)</b>, puts a zero in the buffer, it still doesn’t insert the
terminating character.</p>

<p class=MsoNormal>This example, as well as most of the examples in this
chapter, assumes that each call to any overload of <b>getline(&nbsp;)</b> will
encounter a newline character. If this is not the case, the eofbit state of the
stream will be set and the call to <b>getline(&nbsp;)</b> will return <b>false</b>,
causing the program to lose the last line of input.</p>

<h3><a href="#_TocRef312373882" name="_Toc312373882">Open modes</a></h3>

<p class=MsoNormal>You can control the way a file is opened by overriding the
constructor’s default arguments. The following table shows the flags that
control the mode of the file:</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border-collapse:collapse !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=108 valign=top style='width:81.0pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Flag</p>
   </td>
   <td width=321 valign=top style='width:240.55pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Function</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::in</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Opens an input file. Use this as an open mode for an <b>ofstream</b>
  to prevent truncating an existing file.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::out</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Opens an output file. When used for an <b>ofstream</b>
  without <b>ios::app</b>, <b>ios::ate</b> or <b>ios::in</b>, <b>ios::trunc</b>
  is implied.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::app</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Opens an output file for appending only.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::ate</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Opens an existing file (either input or output) and seeks
  to the end.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::trunc</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Truncates the old file if it already exists.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=108 valign=top style='width:81.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::binary</b></p>
  </td>
  <td width=321 valign=top style='width:240.55pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Opens a file in <i>binary mode</i>. The default is <i>text
  mode</i>.</p>
  </td>
 </tr>
</table>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can combine these flags using a bitwise <i>or</i>
operation.</p>

<p class=MsoNormal>The binary flag, while portable, only has an effect on some
non-UNIX systems, such as operating systems derived from MS-DOS, that have special
conventions for storing end-of-line delimiters. For example, on MS-DOS systems
in text mode (which is the default), every time you output a newline character (<b>'\n'</b>), the file system actually outputs two characters, a
carriage-return/linefeed pair (CRLF), which is the pair of ASCII characters <b>0x0D</b>
and <b>0x0A</b>. Conversely, when you read such a file back into memory in text
mode, each occurrence of this pair of bytes causes a <b>'\n'</b> to be sent to
the program in its place. If you want to bypass this special processing, you
open files in binary mode. Binary mode has nothing whatsoever to do with
whether you <i>can</i> write raw bytes to a file—you <i>always</i> can (by
calling <b>write(&nbsp;)</b>) . You should, however, open a file in binary mode
when you’ll be using <b>read(&nbsp;)</b> or <b>write(&nbsp;)</b>, because these
functions take a byte count parameter. Having the extra <b>'\r'</b> characters
will throw your byte count off in those instances. You should also open a file
in binary mode if you’re going to use the stream-positioning commands discussed
later in this chapter.</p>

<p class=MsoNormal>You can open a file for both input and output by declaring
an <b>fstream</b> object. When declaring an <b>fstream</b> object, you must use
enough of the open mode flags mentioned earlier to let the file system know
whether you want to input, output, or both. To switch from output to input, you
need to either flush the stream or change the file position. To change from
input to output, change the file position. To create a file via an <b>fstream</b>
object, use the <b>ios::trunc</b> open mode flag in the constructor call to do
both input and output.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305628666" name="_Toc305628666">Iostream buffering</a></h2>

<p class=MsoNormal>Good design practice dictates that, whenever you create a new class, you should endeavor to hide the details of the underlying
implementation as much as possible from the user of the class. You show them
only what they need to know and make the rest <b>private </b>to avoid
confusion. When using inserters and extractors, you normally don’t know or care
where the bytes are being produced or consumed, whether you’re dealing with
standard I/O, files, memory, or some newly created class or device.</p>

<p class=MsoNormal>A time comes, however, when it is important to communicate
with the part of the iostream that produces and consumes bytes. To provide this
part with a common interface and still hide its underlying implementation, the
standard library abstracts it into its own class, called <b>streambuf</b>. Each iostream object contains a pointer to some kind of <b>streambuf</b>. (The type
depends on whether it deals with standard I/O, files, memory, and so on.) You
can access the <b>streambuf </b>directly; for example, you can move raw bytes
into and out of the <b>streambuf</b> without formatting them through the
enclosing iostream. This is accomplished by calling member functions for the <b>streambuf</b>
object.</p>

<p class=MsoNormal>Currently, the most important thing for you to know is that
every iostream object contains a pointer to a <b>streambuf</b> object, and the <b>streambuf</b>
object has some member functions you can call if necessary. For file and string
streams, there are specialized types of stream buffers, as the following figure
illustrates:</p>

<p class=MsoNormal align=center style='margin-bottom:0in;margin-bottom:.0001pt;
text-align:center'><img width=416 height=191 src="TicV2_files/image009.gif"></p>

<p class=MsoNormal>To allow you to access the <b>streambuf</b>, every iostream
object has a member function called <b>rdbuf(&nbsp;)</b> that returns the pointer to the object’s <b>streambuf</b>. This way you can call any member function for
the underlying <b>streambuf</b>. However, one of the most interesting things
you can do with the <b>streambuf</b> pointer is to connect it to another
iostream object using the <b>&lt;&lt;</b> operator. This drains all the
characters from your object into the one on the left side of the <b>&lt;&lt;</b>.
If you want to move all the characters from one iostream to another, you don’t need
to go through the tedium (and potential coding errors) of reading them one
character or one line at a time. This is a much more elegant approach.</p>

<p class=MsoNormal>Here’s a simple program that opens a file and sends the
contents to standard output (similar to the previous example):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Stype.cpp</font></div>
<div class=CC1><font color=#dd0000>// Type a file to standard output.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Stype.cpp&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;Stype.cpp&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; in.rdbuf(); <font color=#dd0000>// Outputs entire file</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>An <b>ifstream</b> is created using the source code file for
this program as an argument. The <b>assure(&nbsp;) </b>function reports a
failure if the file cannot be opened. All the work really happens in the
statement</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout &lt;&lt; in.rdbuf();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which sends the entire contents of the file to <b>cout</b>.
This is not only more succinct to code, it is often more efficient than moving
the bytes one at a time.</p>

<p class=MsoNormal>A form of <b>get(&nbsp;)</b> writes directly into the <b>streambuf</b>
of another object. The first argument is a reference to the destination <b>streambuf</b>,
and the second is the terminating character (<b>‘\n’</b> by default), which
stops the <b>get(&nbsp;)</b> function. So there is yet another way to print a
file to standard output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Sbufget.cpp</font></div>
<div class=CC1><font color=#dd0000>// Copies a file to standard output.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Sbufget.cpp&quot;</font>);</div>
<div class=CC1>  assure(in);</div>
<div class=CC1>  streambuf&amp; sb = *cout.rdbuf();</div>
<div class=CC1>  <font color=#ff7700>while</font>(!in.get(sb).eof()) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(in.fail())          <font color=#dd0000>// Found blank line</font></div>
<div class=CC1>      in.clear();</div>
<div class=CC1>    cout &lt;&lt; <font color=#ff7700>char</font>(in.get()); <font color=#dd0000>// Process '\n'</font></div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The<b> rdbuf(&nbsp;)</b> function returns a pointer, so it
must be dereferenced to satisfy the function’s need to see an object. Stream
buffers are not meant to be copied (they have no copy constructor), so we define
<b>sb</b> as a <i>reference</i> to <b>cout</b>’s stream buffer. We need the
calls to <b>fail(&nbsp;)</b> and <b>clear(&nbsp;)</b> in case the input file has a blank line (this one does). When this particular overloaded version of <b>get(&nbsp;)</b>
sees two newlines in a row (evidence of a blank line), it sets the input
stream’s fail bit, so we must call <b>clear(&nbsp;)</b> to reset it so that the
stream can continue to be read. The second call to <b>get(&nbsp;)</b> extracts
and echoes each newline delimiter. (Remember, the <b>get(&nbsp;)</b> function
doesn’t extract its delimiter like <b>getline(&nbsp;)</b> does.)</p>

<p class=MsoNormal>You probably won’t need to use a technique like this often,
but it’s nice to know it exists.<a href="#_ftn45" name="_ftnref45"><span
class=MsoFootnoteReference>[45]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305628667" name="_Toc305628667">Seeking in iostreams</a></h2>

<p class=MsoNormal>Each type of iostream has a concept of where its “next”
character will come from (if it’s an <b>istream</b>) or go (if it’s an <b>ostream</b>).
In some situations, you might want to move this stream position. You can do so
using two models: one uses an absolute location in the stream called the <b>streampos</b>; the second works like the Standard C library functions <b>fseek(&nbsp;)</b> for a file and moves a given number of bytes from the beginning, end, or current
position in the file.</p>

<p class=MsoNormal>The <b>streampos</b> approach requires that you first call a
“tell” function: <b>tellp(&nbsp;)</b> for an <b>ostream</b> or <b>tellg(&nbsp;)</b> for an <b>istream</b>. (The “p” refers to the “put pointer,” and the “g” refers to the “get pointer.”) This function returns a <b>streampos</b> you can
later use in calls to <b>seekp(&nbsp;)</b> for an <b>ostream</b> or <b>seekg(&nbsp;)</b> for an <b>istream</b> when you want to return to that position in the stream.</p>

<p class=MsoNormal>The second approach is a relative seek and uses overloaded
versions of <b>seekp(&nbsp;)</b> and <b>seekg(&nbsp;)</b>. The first argument
is the number of characters to move: it can be positive or negative. The second
argument is the seek direction:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <tr>
  <td width=112 valign=top style='width:84.3pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
  border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::beg</b></p>
  </td>
  <td width=266 valign=top style='width:199.2pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
  border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>From beginning of stream</p>
  </td>
 </tr>
 <tr>
  <td width=112 valign=top style='width:84.3pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::cur</b></p>
  </td>
  <td width=266 valign=top style='width:199.2pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Current position in stream</p>
  </td>
 </tr>
 <tr>
  <td width=112 valign=top style='width:84.3pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::end</b></p>
  </td>
  <td width=266 valign=top style='width:199.2pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>From end of stream</p>
  </td>
 </tr>
</table>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here’s an example that shows the movement through a file,
but remember, you’re not limited to seeking within files as you are with C’s <b>stdio</b>.
With C++, you can seek in any type of iostream (although the standard stream
objects, such as <b>cin</b> and <b>cout</b>,<b> </b>explicitly disallow it):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Seeking.cpp</font></div>
<div class=CC1><font color=#dd0000>// Seeking in iostreams.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>const</font> <font color=#ff7700>int</font> STR_NUM = 5, STR_LEN = 30;</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>char</font> origData[STR_NUM][STR_LEN] = {</span></div>
<div class=CC1><span lang=SV>    </span><font color=#007f00>&quot;Hickory dickory dus. .
.&quot;</font>,</div>
<div class=CC1>    <font color=#007f00>&quot;Are you tired of C++?&quot;</font>,</div>
<div class=CC1>    <font color=#007f00>&quot;Well, if you have,&quot;</font>,</div>
<div class=CC1>    <font color=#007f00>&quot;That's just too bad,&quot;</font>,</div>
<div class=CC1>    <font color=#007f00>&quot;There's plenty more for us!&quot;</font></div>
<div class=CC1>  <span lang=SV>};</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>char</font> readData[STR_NUM][STR_LEN] = {{ 0
}};</span></div>
<div class=CC1><span lang=SV>  </span>ofstream
out(<font color=#007f00>&quot;Poem.bin&quot;</font>, ios::out | ios::binary);</div>
<div class=CC1>  assure(out, <font color=#007f00>&quot;Poem.bin&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; STR_NUM; i++)</div>
<div class=CC1>    out.write(origData[i], STR_LEN);</div>
<div class=CC1>  out.close();</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Poem.bin&quot;</font>, ios::in |
ios::binary);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;Poem.bin&quot;</font>);</div>
<div class=CC1>  in.read(readData[0], STR_LEN);</div>
<div class=CC1>  assert(strcmp(readData[0], <font color=#007f00>&quot;Hickory dickory dus.
. .&quot;</font>)</div>
<div class=CC1>    == 0);</div>
<div class=CC1>  <font color=#dd0000>// Seek -STR_LEN bytes from the end of file</font></div>
<div class=CC1>  in.seekg(-STR_LEN, ios::end);</div>
<div class=CC1>  in.read(readData[1], STR_LEN);</div>
<div class=CC1>  assert(strcmp(readData[1], <font color=#007f00>&quot;There's plenty more
for us!&quot;</font>)</div>
<div class=CC1>    == 0);</div>
<div class=CC1>  <font color=#dd0000>// Absolute seek (like using operator[] with a file)</font></div>
<div class=CC1>  in.seekg(3 * STR_LEN);</div>
<div class=CC1>  in.read(readData[2], STR_LEN);</div>
<div class=CC1>  assert(strcmp(readData[2], <font color=#007f00>&quot;That's just too
bad,&quot;</font>) == 0);</div>
<div class=CC1>  <font color=#dd0000>// Seek backwards from current position</font></div>
<div class=CC1>  in.seekg(-STR_LEN * 2, ios::cur);</div>
<div class=CC1>  in.read(readData[3], STR_LEN);</div>
<div class=CC1>  assert(strcmp(readData[3], <font color=#007f00>&quot;Well, if you
have,&quot;</font>) == 0);</div>
<div class=CC1>  <font color=#dd0000>// Seek from the begining of the file</font></div>
<div class=CC1>  in.seekg(1 * STR_LEN, ios::beg);</div>
<div class=CC1>  in.read(readData[4], STR_LEN);</div>
<div class=CC1>  assert(strcmp(readData[4], <font color=#007f00>&quot;Are you tired of
C++?&quot;</font>)</div>
<div class=CC1>    == 0);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This program writes a poem to a file using a binary output
stream. Since we reopen it as an <b>ifstream</b>, we use <b>seekg(&nbsp;)</b>
to position the “get pointer.” As you can see, you can seek from the beginning
or end of the file or from the current file position. Obviously, you must
provide a positive number to move from the beginning of the file and a negative
number to move back from the end.</p>

<p class=MsoNormal>Now that you know about the <b>streambuf</b> and how to
seek, you can understand an alternative method (besides using an <b>fstream</b>
object) for creating a stream object that will both read and write a file. The
following code first creates an <b>ifstream</b> with flags that say it’s both
an input and an output file. You can’t write to an <b>ifstream</b>, so you need
to create an <b>ostream</b> with the underlying stream buffer:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>ifstream in(<font color=#007f00>&quot;filename&quot;</font>, ios::in | ios::out);</div>
<div class=CC1>ostream out(in.rdbuf());</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You might wonder what happens when you write to one of these
objects. Here’s an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Iofile.cpp</font></div>
<div class=CC1><font color=#dd0000>// Reading &amp; writing one file.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Iofile.cpp&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;Iofile.cpp&quot;</font>);</div>
<div class=CC1>  ofstream out(<font color=#007f00>&quot;Iofile.out&quot;</font>);</div>
<div class=CC1>  assure(out, <font color=#007f00>&quot;Iofile.out&quot;</font>);</div>
<div class=CC1>  out &lt;&lt; in.rdbuf(); <font color=#dd0000>// Copy file</font></div>
<div class=CC1>  in.close();</div>
<div class=CC1>  out.close();</div>
<div class=CC1>  <font color=#dd0000>// Open for reading and writing:</font></div>
<div class=CC1>  ifstream in2(<font color=#007f00>&quot;Iofile.out&quot;</font>, ios::in |
ios::out);</div>
<div class=CC1>  assure(in2, <font color=#007f00>&quot;Iofile.out&quot;</font>);</div>
<div class=CC1>  ostream out2(in2.rdbuf());</div>
<div class=CC1>  cout &lt;&lt; in2.rdbuf();  <font color=#dd0000>// Print whole file</font></div>
<div class=CC1>  out2 &lt;&lt; <font color=#007f00>&quot;Where does this end up?&quot;</font>;</div>
<div class=CC1>  out2.seekp(0, ios::beg);</div>
<div class=CC1>  out2 &lt;&lt; <font color=#007f00>&quot;And what about this?&quot;</font>;</div>
<div class=CC1>  in2.seekg(0, ios::beg);</div>
<div class=CC1>  cout &lt;&lt; in2.rdbuf();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first five lines copy the source code for this program
into a file called <b>iofile.out</b> and then close the files. This gives us a
safe text file to play with. Then the aforementioned technique is used to
create two objects that read and write to the same file. In <b>cout &lt;&lt;
in2.rdbuf(&nbsp;)</b>, you can see the “get” pointer is initialized to the
beginning of the file. The “put” pointer, however, is set to the end of the
file because “Where does this end up?” appears appended to the file. However,
if the put pointer is moved to the beginning with a <b>seekp(&nbsp;)</b>, all
the inserted text <i>overwrites </i>the existing text. Both writes are seen
when the get pointer is moved back to the beginning with a <b>seekg(&nbsp;)</b>,
and the file is displayed. The file is automatically saved and closed when <b>out2</b>
goes out of scope and its destructor is called.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985685" name="_Toc53985685">String iostreams</a></h2>

<p class=MsoNormal>A string stream works directly with memory instead of a file
or standard output. It uses the same reading and formatting functions that you
use with <b>cin</b> and <b>cout</b> to manipulate bytes in memory. On old
computers, the memory was referred to as <i>core,</i> so this type of
functionality is often called <i>in-core formatting</i>.</p>

<p class=MsoNormal>The class names for string streams echo those for file
streams. If you want to create a string stream to extract characters from, you
create an <b>istringstream</b>. If you want to put characters into a string
stream, you create an <b>ostringstream</b>. All declarations for string streams
are in the standard header <b>&lt;sstream&gt;</b>. As usual, there are class templates that fit into the iostreams hierarchy, as shown in the following figure:</p>

<p class=MsoNormal align=center style='margin-bottom:0in;margin-bottom:.0001pt;
text-align:center'><img width=504 height=324 src="TicV2_files/image010.gif"></p>

<h3><a href="#_TocRef53985686" name="_Toc53985686">Input string streams</a></h3>

<p class=MsoNormal>To read from a string using stream operations, you create an
<b>istringstream</b> object initialized with the string. The following program
shows how to use an <b>istringstream</b> object:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Istring.cpp</font></div>
<div class=CC1><font color=#dd0000>// Input string streams.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;  </font><font color=#dd0000>// For fabs()</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;limits&gt; </font><font color=#dd0000>// For epsilon()</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  istringstream s(<font color=#007f00>&quot;47 1.414 This is a test&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1>  <font color=#ff7700>double</font> f;</div>
<div class=CC1>  s &gt;&gt; i &gt;&gt; f; <font color=#dd0000>// Whitespace-delimited
input</font></div>
<div class=CC1>  assert(i == 47);</div>
<div class=CC1>  <font color=#ff7700>double</font> relerr = (fabs(f) - 1.414) / 1.414;</div>
<div class=CC1>  assert(relerr &lt;=
numeric_limits&lt;<font color=#ff7700>double</font>&gt;::epsilon());</div>
<div class=CC1>  string buf2;</div>
<div class=CC1>  s &gt;&gt; buf2;</div>
<div class=CC1>  assert(buf2 == <font color=#007f00>&quot;This&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; s.rdbuf(); <font color=#dd0000>// &quot; is a test&quot;</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that this is a more flexible and general
approach to transforming character strings to typed values than the standard C library functions such as <b>atof(&nbsp;)</b><b> </b>or <b>atoi(&nbsp;)</b>, even though the latter may be more efficient for single conversions.</p>

<p class=MsoNormal>In the expression <b>s &gt;&gt; i &gt;&gt; f</b>, the first
number is extracted into <b>i</b>, and the second into <b>f</b>. This isn’t
“the first whitespace-delimited set of characters” because it depends on the
data type it’s being extracted into. For example, if the string were instead, “<b>1.414
47 This is a test</b>,” then <b>i</b> would get the value 1 because the input
routine would stop at the decimal point. Then <b>f</b> would get <b>0.414</b>.
This could be useful if you want to break a floating-point number into a whole
number and a fraction part. Otherwise it would seem to be an error. The second <b>assert(&nbsp;)</b>
calculates the relative error between what we read and what we expected; it’s
always better to do this than to compare floating-point numbers for equality.
The constant returned by <b>epsilon(&nbsp;)</b>, defined in <b>&lt;limits&gt;</b>, represents the <i>machine epsilon</i> for double-precision numbers, which is the
best tolerance you can expect comparisons of <b>double</b>s to satisfy.<a href="#_ftn46" name="_ftnref46"><span
class=MsoFootnoteReference>[46]</span></a></p>

<p class=MsoNormal>As you may already have guessed, <b>buf2</b> doesn’t get the
rest of the string, just the next white-space-delimited word. In general, it’s
best to use the extractor in iostreams when you know the exact sequence of data
in the input stream and you’re converting to some type other than a character
string. However, if you want to extract the rest of the string all at once and
send it to another iostream, you can use <b>rdbuf(&nbsp;)</b> as shown.</p>

<p class=MsoNormal>To test the <b>Date</b> extractor at the beginning of this
chapter, we used an input string stream with the following test program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:DateIOTest.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ../C02/Date</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../C02/Date.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> testDate(<font color=#ff7700>const</font> string&amp; s) {</div>
<div class=CC1>  istringstream os(s);</div>
<div class=CC1>  Date d;</div>
<div class=CC1>  os &gt;&gt; d;</div>
<div class=CC1>  <font color=#ff7700>if</font>(os)</div>
<div class=CC1>    cout &lt;&lt; d &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;input error with \&quot;&quot;</font>
&lt;&lt; s &lt;&lt; <font color=#007f00>&quot;\&quot;&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  testDate(<font color=#007f00>&quot;08-10-2003&quot;</font>);</div>
<div class=CC1>  testDate(<font color=#007f00>&quot;8-10-2003&quot;</font>);</div>
<div class=CC1>  testDate(<font color=#007f00>&quot;08 - 10 - 2003&quot;</font>);</div>
<div class=CC1>  testDate(<font color=#007f00>&quot;A-10-2003&quot;</font>);</div>
<div class=CC1>  testDate(<font color=#007f00>&quot;08%10/2003&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each string literal in <b>main(&nbsp;)</b> is passed by
reference to <b>testDate(&nbsp;)</b>, which in turn wraps it in an <b>istringstream</b>
so we can test the<b> </b>stream extractor we wrote for <b>Date</b> objects.
The function <b>testDate(&nbsp;)</b> also begins to test the inserter, <b>operator&lt;&lt;(&nbsp;)</b>.</p>

<h3><a href="#_TocRef53985687" name="_Toc53985687">Output string streams</a></h3>

<p class=MsoNormal>To create an output string stream, you just create an <b>ostringstream</b>
object, which manages a dynamically sized character buffer to hold whatever you
insert. To get the formatted result as a <b>string</b> object, you call the <b>str(&nbsp;)</b> member function. Here’s an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Ostring.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Illustrates ostringstream.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;type an int, a float and a
string: &quot;</font>;</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>int</font> i;</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>float</font> f;</span></div>
<div class=CC1><span lang=SV>  cin &gt;&gt; i &gt;&gt; f;</span></div>
<div class=CC1><span lang=SV>  </span>cin &gt;&gt; ws; <font color=#dd0000>// Throw away
white space</font></div>
<div class=CC1>  string stuff;</div>
<div class=CC1>  getline(cin, stuff); <font color=#dd0000>// Get rest of the line</font></div>
<div class=CC1>  <span lang=SV>ostringstream os;</span></div>
<div class=CC1><span lang=SV>  os &lt;&lt; <font color=#007f00>&quot;integer = &quot;</font>
&lt;&lt; i &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  os &lt;&lt; <font color=#007f00>&quot;float = &quot;</font> &lt;&lt;
f &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  os &lt;&lt; <font color=#007f00>&quot;string = &quot;</font>
&lt;&lt; stuff &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span>string result = os.str();</div>
<div class=CC1>  cout &lt;&lt; result &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This is similar to the <b>Istring.cpp</b> example earlier
that fetched an <b>int</b> and a <b>float</b>. A sample execution follows (the
keyboard input is in bold type).</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>type an <font color=#ff7700>int</font>, a <font color=#ff7700>float</font> <font color=#ff7700>and</font> a string: <b>10 20.5 the end</b></div>
<div class=CC1>integer = 10</div>
<div class=CC1><font color=#ff7700>float</font> = 20.5</div>
<div class=CC1>string = the end</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that, like the other output streams, you can use
the ordinary formatting tools, such as the <b>&lt;&lt;</b> operator and <b>endl</b>,
to send bytes to the <b>ostringstream</b>. The <b>str(&nbsp;)</b> function
returns a new <b>string</b> object every time you call it so the underlying <b>stringbuf</b> object owned by the string stream is left undisturbed.</p>

<p class=MsoNormal>In the previous chapter, we presented a program, <b>HTMLStripper.cpp</b>,
that removed all HTML tags and special codes from a text file. As promised,
here is a more elegant version using string streams.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:HTMLStripper2.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>//{L} ../C03/ReplaceAll</font></div>
<div class=CC1><font color=#dd0000>// Filter to remove html tags and markers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../C03/ReplaceAll.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string&amp; stripHTMLTags(string&amp; s)
<font color=#ff7700>throw</font>(runtime_error) {</div>
<div class=CC1>  size_t leftPos;</div>
<div class=CC1>  <font color=#ff7700>while</font>((leftPos = s.find('&lt;')) != string::npos) {</div>
<div class=CC1>    size_t rightPos = s.find('&gt;', leftPos+1);</div>
<div class=CC1>    <font color=#ff7700>if</font>(rightPos == string::npos) {</div>
<div class=CC1>      ostringstream msg;</div>
<div class=CC1>      msg &lt;&lt; <font color=#007f00>&quot;Incomplete HTML tag starting
in position &quot;</font></div>
<div class=CC1>          &lt;&lt; leftPos;</div>
<div class=CC1>      <font color=#ff7700>throw</font> runtime_error(msg.str());</div>
<div class=CC1>    }</div>
<div class=CC1>    s.erase(leftPos, rightPos - leftPos + 1);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Remove all special HTML characters</font></div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;lt;&quot;</font>,
<font color=#007f00>&quot;&lt;&quot;</font>);</div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;gt;&quot;</font>,
<font color=#007f00>&quot;&gt;&quot;</font>);</div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;amp;&quot;</font>,
<font color=#007f00>&quot;&amp;&quot;</font>);</div>
<div class=CC1>  replaceAll(s, <font color=#007f00>&quot;&amp;nbsp;&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Etc...</font></div>
<div class=CC1>  <font color=#ff7700>return</font> s;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  requireArgs(argc, 1,</div>
<div class=CC1>    <font color=#007f00>&quot;usage: HTMLStripper2 InputFile&quot;</font>);</div>
<div class=CC1>  ifstream in(argv[1]);</div>
<div class=CC1>  assure(in, argv[1]);</div>
<div class=CC1>  <font color=#dd0000>// Read entire file into string; then strip</font></div>
<div class=CC1>  ostringstream ss;</div>
<div class=CC1>  ss &lt;&lt; in.rdbuf();</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    string s = ss.str();</div>
<div class=CC1>    cout &lt;&lt; stripHTMLTags(s) &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> EXIT_SUCCESS;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(runtime_error&amp; x) {</div>
<div class=CC1>    cout &lt;&lt; x.what() &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this program we read the entire file into a string by
inserting a <b>rdbuf(&nbsp;)</b> call to the file stream into an <b>ostringstream</b>.
Now it’s an easy matter to search for HTML delimiter pairs and erase them
without having to worry about crossing line boundaries like we had to with the
previous version in Chapter 3.</p>

<p class=MsoNormal>The following example shows how to use a bidirectional (that
is, read/write) string stream:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:StringSeeking.cpp {-bor}{-dmc}</font></div>
<div class=CC1><font color=#dd0000>// Reads and writes a string stream.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string text = <font color=#007f00>&quot;We will hook no fish&quot;</font>;</div>
<div class=CC1>  stringstream ss(text);</div>
<div class=CC1>  ss.seekp(0, ios::end);</div>
<div class=CC1>  ss &lt;&lt; <font color=#007f00>&quot; before its time.&quot;</font>;</div>
<div class=CC1>  assert(ss.str() ==</div>
<div class=CC1>    <font color=#007f00>&quot;We will hook no fish before its time.&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Change &quot;hook&quot; to &quot;ship&quot;</font></div>
<div class=CC1>  ss.seekg(8, ios::beg);</div>
<div class=CC1>  string word;</div>
<div class=CC1>  ss &gt;&gt; word;</div>
<div class=CC1>  assert(word == <font color=#007f00>&quot;hook&quot;</font>);</div>
<div class=CC1>  ss.seekp(8, ios::beg);</div>
<div class=CC1>  ss &lt;&lt; <font color=#007f00>&quot;ship&quot;</font>;</div>
<div class=CC1>  <font color=#dd0000>// Change &quot;fish&quot; to &quot;code&quot;</font></div>
<div class=CC1>  ss.seekg(16, ios::beg);</div>
<div class=CC1>  ss &gt;&gt; word;</div>
<div class=CC1>  assert(word == <font color=#007f00>&quot;fish&quot;</font>);</div>
<div class=CC1>  ss.seekp(16, ios::beg);</div>
<div class=CC1>  ss &lt;&lt; <font color=#007f00>&quot;code&quot;</font>;</div>
<div class=CC1>  assert(ss.str() ==</div>
<div class=CC1>    <font color=#007f00>&quot;We will ship no code before its time.&quot;</font>);</div>
<div class=CC1>  ss.str(<font color=#007f00>&quot;A horse of a different color.&quot;</font>);</div>
<div class=CC1>  assert(ss.str() == <font color=#007f00>&quot;A horse of a different
color.&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As
always, to move the put pointer, you call <b>seekp(&nbsp;)</b>, and to
reposition the get pointer, you call <b>seekg(&nbsp;)</b>. Even though we
didn’t show it with this example, string streams are a little more forgiving
than file streams in that you can switch from reading to writing or vice-versa
at any time. You don’t need to reposition the get or put pointers or flush the
stream. This program also illustrates the overload of <b>str(&nbsp;)</b> that
replaces the stream’s underlying <b>stringbuf</b> with a new string.</a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985688" name="_Toc53985688">Output
stream formatting</a></h2>

<p class=MsoNormal>The goal of the iostreams design is to allow you to easily
move and/or format characters. It certainly wouldn’t be useful if you couldn’t
do most of the formatting provided by C’s <b>printf(&nbsp;)</b> family of
functions. In this section, you’ll learn all the output formatting functions
that are available for iostreams, so you can format your bytes the way you want
them.</p>

<p class=MsoNormal>The formatting functions in iostreams can be somewhat
confusing at first because there’s often more than one way to control the
formatting: through both member functions and manipulators. To further confuse
things, a generic member function sets state flags to control formatting, such
as left or right justification, to use uppercase letters for hex notation, to
always use a decimal point for floating-point values, and so on. On the other
hand, separate member functions set and read values for the fill character, the
field width, and the precision.</p>

<p class=MsoNormal>In an attempt to clarify all this, we’ll first examine the
internal formatting data of an iostream, along with the member functions that
can modify that data. (Everything can be controlled through the member
functions, if desired.) We’ll cover the manipulators separately.</p>

<h3><a href="#_TocRef53985689" name="_Toc53985689">Format flags</a></h3>

<p class=MsoNormal>The class <b>ios</b> contains data members to store all the
formatting information pertaining to a stream. Some of this data has a range of
values and is stored in variables: the floating-point precision, the output
field width, and the character used to pad the output (normally a space). The
rest of the formatting is determined by flags, which are usually combined to
save space and are referred to collectively as the <i>format flags</i>. You can
find out the value of the format flags with the <b>ios::flags(&nbsp;)</b> member function, which takes no arguments and returns an object of type <b>fmtflags</b> (usually a synonym for <b>long</b>) that contains the current format flags. All the
rest of the functions make changes to the format flags and return the previous
value of the format flags.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=SV>fmtflags ios::flags(fmtflags newflags);</span></div>
<div class=CC1><span lang=SV>fmtflags ios::setf(fmtflags ored_flag);</span></div>
<div class=CC1><span lang=SV>fmtflags ios::unsetf(fmtflags
clear_flag);</span></div>
<div class=CC1><span lang=SV>fmtflags ios::setf(fmtflags bits, fmtflags field);</span></div>

</div>

<div class=CC1><span lang=SV>&nbsp;</span></div>

<p class=MsoNormal>The first function forces <i>all</i> the flags to change,
which is sometimes what you want. More often, you change one flag at a time
using the remaining three functions.</p>

<p class=MsoNormal>The use of <b>setf(&nbsp;)</b> can seem somewhat confusing.
To know which overloaded version to use, you must know what type of flag you’re
changing. There are two types of flags: those that are simply on or off, and
those that work in a group with other flags. The on/off flags are the simplest
to understand because you turn them on with <b>setf(fmtflags)</b> and off with <b>unsetf(fmtflags)</b>.
These flags are shown in the following table:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=143 valign=top style='width:107.1pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>on/off flag</p>
   </td>
   <td width=258 valign=top style='width:193.5pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::skipws</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Skip white space. (For input; this is the default.)</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::showbase</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Indicate the numeric base (as set, for example, by <b>dec</b>,   <b>oct</b>, or <b>hex</b>) when printing an integral value. Input streams
  also recognize the base prefix when <b>showbase</b> is on.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::showpoint</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Show decimal point and trailing zeros for floating-point
  values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::uppercase</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Display uppercase <b>A-F</b> for hexadecimal values and <b>E</b>
  for scientific values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::showpos</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Show plus sign (+) for positive values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=143 valign=top style='width:107.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::unitbuf</b></p>
  </td>
  <td width=258 valign=top style='width:193.5pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>“Unit buffering.” The stream is flushed after each
  insertion.</p>
  </td>
 </tr>
</table>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>For example, to show the plus sign for <b>cout</b>, you say <b>cout.</b><b>setf(ios::showpos)</b>. To stop showing the plus sign, you say <b>cout.unsetf(ios::showpos)</b>.</p>

<p class=MsoNormal>The <b>unitbuf</b> flag controls <i>unit buffering</i>, which means that each insertion is flushed to its output stream immediately. This
is handy for error tracing, so that in case of a program crash, your data is
still written to the log file. The following program illustrates unit
buffering:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Unitbuf.cpp {RunByHand}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;  </font><font color=#dd0000>// For abort()</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ofstream out(<font color=#007f00>&quot;log.txt&quot;</font>);</div>
<div class=CC1>  out.setf(ios::unitbuf);</div>
<div class=CC1>  out &lt;&lt; <font color=#007f00>&quot;one&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  out &lt;&lt; <font color=#007f00>&quot;two&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  abort();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>It is necessary to turn on unit buffering before any
insertions are made to the stream. When we commented out the call to <b>setf(&nbsp;)</b>,
one particular compiler had written only the letter ‘o’ to the file <b>log.txt</b>.
With unit buffering, no data was lost.</p>

<p class=MsoNormal>The standard error output stream <b>cerr</b> has unit
buffering turned on by default. There is a cost for unit buffering, so if an
output stream is heavily used, don’t enable unit buffering unless efficiency is
not a consideration.</p>

<h3><a href="#_TocRef53985690" name="_Toc53985690">Format fields</a></h3>

<p class=MsoNormal>The second type of formatting flags work in a group. Only
one of these flags can be set at a time, like the buttons on old car radios—you
push one in, the rest pop out. Unfortunately this doesn’t happen automatically,
and you must pay attention to what flags you’re setting so that you don’t
accidentally call the wrong <b>setf(&nbsp;)</b> function. For example, there’s
a flag for each of the number bases: hexadecimal, decimal, and octal.
Collectively, these flags are referred to as the <b>ios::basefield</b>. If the <b>ios::dec</b> flag is set and you call <b>setf(ios::hex)</b>, you’ll set
the <b>ios::hex</b> flag, but you <i>won’t</i> clear the <b>ios::dec</b> bit,
resulting in undefined behavior. Instead, call the second form of <b>setf(&nbsp;)</b>
like this: <b>setf(ios::hex, ios::basefield)</b>. This function first clears
all the bits in the <b>ios::basefield</b> and <i>then</i> sets <b>ios::hex</b>.
Thus, this form of <b>setf(&nbsp;)</b> ensures that the other flags in the
group “pop out” whenever you set one. The <b>ios::hex</b> manipulator does all
this for you, automatically, so you don’t need to concern yourself with the
internal details of the implementation of this class or to even <i>care</i>
that it’s a set of binary flags. Later you’ll see that there are manipulators
to provide equivalent functionality in all the places you would use <b>setf(&nbsp;)</b>.</p>

<p class=MsoNormal>Here are the flag groups and their effects:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=159 valign=top style='width:119.25pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>ios::basefield</p>
   </td>
   <td width=290 valign=top style='width:217.35pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::dec</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Format integral values in base 10 (decimal) (the default
  radix—no prefix is visible).</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::hex</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Format integral values in base 16 (hexadecimal).</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::oct</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Format integral values in base 8 (octal).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup>&nbsp;</sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=159 valign=top style='width:119.25pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>ios::floatfield</p>
   </td>
   <td width=290 valign=top style='width:217.35pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::scientific</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Display floating-point numbers in scientific format.
  Precision field indicates number of digits after the decimal point.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext><b>ios::fixed</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Display floating-point numbers in fixed format. Precision
  field indicates number of digits after the decimal point.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>“automatic” (Neither bit is set.)</p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=tabletext>Precision field indicates the total number of significant
  digits.</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup>&nbsp;</sup></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=159 valign=top style='width:119.25pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=TableHead>ios::adjustfield</p>
   </td>
   <td width=290 valign=top style='width:217.35pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=TableHead>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>ios::left</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Left-align values; pad on the right with the fill character.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>ios::right</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Right-align values. Pad on the left with the fill character.
  This is the default alignment.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=159 valign=top style='width:119.25pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>ios::internal</b></p>
  </td>
  <td width=290 valign=top style='width:217.35pt;border:none;border-bottom:
  solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;border:none !msorm;
  border-bottom:solid windowtext 1.0pt !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Add fill characters after any leading sign or base indicator,
  but before the value. (In other words, the sign, if printed, is
  left-justified while the number is right-justified.)</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup>&nbsp;</sup></p>

<h3><a href="#_TocRef53985691" name="_Toc53985691">Width, fill, and precision</a></h3>

<p class=MsoNormal>The internal variables that control the width of the output
field, the fill character used to pad an output field, and the precision for
printing floating-point numbers are read and written by member functions of the
same name.</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.4in;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=215 valign=top style='width:161.1pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Function</p>
   </td>
   <td width=240 valign=top style='width:2.5in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=tablehead0>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>int ios::width(&nbsp;) </b><b> </b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Returns the current width. Default is 0. Used for both insertion
  and extraction.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>int ios::width(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Sets the width, returns the previous width.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>int ios::fill(&nbsp;) </b><b> </b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Returns the current fill character. Default is space.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>int ios::fill(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Sets the fill character, returns the previous fill character.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>int ios::precision(&nbsp;) </b><b> </b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Returns current floating-point precision. Default is 6.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=215 valign=top style='width:161.1pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>int ios::precision(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Sets floating-point precision, returns previous precision. See
  <b>ios::floatfield</b> table for the meaning of “precision.”</p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:6.0pt'>The <b>fill</b> and <b>precision</b>
values are fairly straightforward, but <b>width</b> requires some explanation.
When the width is zero, inserting a value produces the minimum number of
characters necessary to represent that value. A positive width means that
inserting a value will produce at least as many characters as the width; if the
value has fewer than width characters, the fill character pad the field.
However, the value will never be truncated, so if you try to print 123 with a
width of two, you’ll still get 123. The field width specifies a <i>minimum</i>
number of characters; there’s no way to specify a maximum number.</p>

<p class=MsoNormal>The width is also distinctly different because it’s reset to
zero by each inserter or extractor that could be influenced by its value. It’s
really not a state variable, but rather an implicit argument to the inserters
and extractors. If you want a constant width, call <b>width(&nbsp;)</b> after
each insertion or extraction.</p>

<h3><a href="#_TocRef312373892" name="_Toc312373892">An exhaustive example</a></h3>

<p class=MsoNormal>To make sure you know how to call all the functions
previously discussed, here’s an example that calls them all:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Format.cpp</font></div>
<div class=CC1><font color=#dd0000>// Formatting Functions.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#7F7F00>#define D(A) T &lt;&lt; #A &lt;&lt; endl; A</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ofstream T(<font color=#007f00>&quot;format.out&quot;</font>);</div>
<div class=CC1>  assure(T);</div>
<div class=CC1>  D(<font color=#ff7700>int</font> i = 47;)</div>
<div class=CC1>  D(<font color=#ff7700>float</font> f = 2300114.414159;)</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* s = <font color=#007f00>&quot;Is there any more?&quot;</font>;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  D(T.setf(ios::unitbuf);)</div>
<div class=CC1>  D(T.setf(ios::showbase);)</div>
<div class=CC1>  D(T.setf(ios::uppercase | ios::showpos);)</div>
<div class=CC1>  D(T &lt;&lt; i &lt;&lt; endl;) <font color=#dd0000>// Default is dec</font></div>
<div class=CC1>  D(T.setf(ios::hex, ios::basefield);)</div>
<div class=CC1>  D(T &lt;&lt; i &lt;&lt; endl;)</div>
<div class=CC1>  D(T.setf(ios::oct, ios::basefield);)</div>
<div class=CC1>  D(T &lt;&lt; i &lt;&lt; endl;)</div>
<div class=CC1>  D(T.unsetf(ios::showbase);)</div>
<div class=CC1>  D(T.setf(ios::dec, ios::basefield);)</div>
<div class=CC1>  D(T.setf(ios::left, ios::adjustfield);)</div>
<div class=CC1>  D(T.fill('0');)</div>
<div class=CC1>  D(T &lt;&lt; <font color=#007f00>&quot;fill char: &quot;</font> &lt;&lt;
T.fill() &lt;&lt; endl;)</div>
<div class=CC1>  <span lang=SV>D(T.width(10);)</span></div>
<div class=CC1><span lang=SV>  T &lt;&lt; i &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span>D(T.setf(ios::right,
ios::adjustfield);)</div>
<div class=CC1>  <span lang=SV>D(T.width(10);)</span></div>
<div class=CC1><span lang=SV>  T &lt;&lt; i &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span>D(T.setf(ios::internal,
ios::adjustfield);)</div>
<div class=CC1>  <span lang=SV>D(T.width(10);)</span></div>
<div class=CC1><span lang=SV>  T &lt;&lt; i &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span>D(T &lt;&lt; i &lt;&lt; endl;)
<font color=#dd0000>// Without width(10)</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  D(T.unsetf(ios::showpos);)</div>
<div class=CC1>  D(T.setf(ios::showpoint);)</div>
<div class=CC1>  D(T &lt;&lt; <font color=#007f00>&quot;prec = &quot;</font> &lt;&lt;
T.precision() &lt;&lt; endl;)</div>
<div class=CC1>  D(T.setf(ios::scientific, ios::floatfield);)</div>
<div class=CC1>  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)</div>
<div class=CC1>  D(T.unsetf(ios::uppercase);)</div>
<div class=CC1>  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)</div>
<div class=CC1>  D(T.setf(ios::fixed, ios::floatfield);)</div>
<div class=CC1>  D(T &lt;&lt; f &lt;&lt; endl;)</div>
<div class=CC1>  D(T.precision(20);)</div>
<div class=CC1>  D(T &lt;&lt; <font color=#007f00>&quot;prec = &quot;</font> &lt;&lt;
T.precision() &lt;&lt; endl;)</div>
<div class=CC1>  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)</div>
<div class=CC1>  D(T.setf(ios::scientific, ios::floatfield);)</div>
<div class=CC1>  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)</div>
<div class=CC1>  D(T.setf(ios::fixed, ios::floatfield);)</div>
<div class=CC1>  D(T &lt;&lt; f &lt;&lt; endl;)</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  D(T.width(10);)</div>
<div class=CC1>  T &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  D(T.width(40);)</div>
<div class=CC1>  T &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  D(T.setf(ios::left, ios::adjustfield);)</div>
<div class=CC1>  D(T.width(40);)</div>
<div class=CC1>  T &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example uses a trick to create a trace file so that you
can monitor what’s happening. The macro <b>D(a)</b> uses the preprocessor
“stringizing”  to turn <b>a</b> into a string to display. Then it reiterates <b>a</b>
so the statement is executed. The macro sends all the information to a file
called <b>T</b>, which is the trace file. The output is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> i = 47;</div>
<div class=CC1><font color=#ff7700>float</font> f = 2300114.414159;</div>
<div class=CC1>T.setf(ios::unitbuf);</div>
<div class=CC1>T.setf(ios::showbase);</div>
<div class=CC1>T.setf(ios::uppercase | ios::showpos);</div>
<div class=CC1>T &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>+47</div>
<div class=CC1>T.setf(ios::hex, ios::basefield);</div>
<div class=CC1>T &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>0X2F</div>
<div class=CC1>T.setf(ios::oct, ios::basefield);</div>
<div class=CC1>T &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>057</div>
<div class=CC1>T.unsetf(ios::showbase);</div>
<div class=CC1>T.setf(ios::dec, ios::basefield);</div>
<div class=CC1>T.setf(ios::left, ios::adjustfield);</div>
<div class=CC1>T.fill('0');</div>
<div class=CC1>T &lt;&lt; <font color=#007f00>&quot;fill char: &quot;</font> &lt;&lt; T.fill()
&lt;&lt; endl;</div>
<div class=CC1>fill <font color=#ff7700>char</font>: 0</div>
<div class=CC1>T.width(10);</div>
<div class=CC1>+470000000</div>
<div class=CC1>T.setf(ios::right, ios::adjustfield);</div>
<div class=CC1>T.width(10);</div>
<div class=CC1>0000000+47</div>
<div class=CC1>T.setf(ios::internal, ios::adjustfield);</div>
<div class=CC1><span lang=SV>T.width(10);</span></div>
<div class=CC1><span lang=SV>+000000047</span></div>
<div class=CC1><span lang=SV>T &lt;&lt; i &lt;&lt; endl;</span></div>
<div class=CC1>+47</div>
<div class=CC1>T.unsetf(ios::showpos);</div>
<div class=CC1>T.setf(ios::showpoint);</div>
<div class=CC1>T &lt;&lt; <font color=#007f00>&quot;prec = &quot;</font> &lt;&lt; T.precision()
&lt;&lt; endl;</div>
<div class=CC1>prec = 6</div>
<div class=CC1>T.setf(ios::scientific, ios::floatfield);</div>
<div class=CC1>T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>2.300114E+06</div>
<div class=CC1>T.unsetf(ios::uppercase);</div>
<div class=CC1>T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>2.300114e+06</div>
<div class=CC1>T.setf(ios::fixed, ios::floatfield);</div>
<div class=CC1>T &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>2300114.500000</div>
<div class=CC1>T.precision(20);</div>
<div class=CC1>T &lt;&lt; <font color=#007f00>&quot;prec = &quot;</font> &lt;&lt; T.precision()
&lt;&lt; endl;</div>
<div class=CC1>prec = 20</div>
<div class=CC1>T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>2300114.50000000000000000000</div>
<div class=CC1>T.setf(ios::scientific, ios::floatfield);</div>
<div class=CC1>T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>2.30011450000000000000e+06</div>
<div class=CC1>T.setf(ios::fixed, ios::floatfield);</div>
<div class=CC1>T &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>2300114.50000000000000000000</div>
<div class=CC1>T.width(10);</div>
<div class=CC1>Is there any more?</div>
<div class=CC1>T.width(40);</div>
<div class=CC1>0000000000000000000000Is there any more?</div>
<div class=CC1>T.setf(ios::left, ios::adjustfield);</div>
<div class=CC1>T.width(40);</div>
<div class=CC1>Is there any
more?0000000000000000000000</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Studying this output should clarify your understanding of
the iostream formatting member functions.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985693" name="_Toc53985693">Manipulators</a></h2>

<p class=MsoNormal>As you can see from the previous program, calling the member
functions for stream formatting operations can get a bit tedious. To make
things easier to read and write, a set of <i>manipulators</i> is supplied to
duplicate the actions provided by the member functions. Manipulators are a
convenience because you can insert them for their effect within a containing
expression; you don’t need to create a separate function-call statement.</p>

<p class=MsoNormal>Manipulators change the state of the stream instead of (or
in addition to) processing data. When you insert <b>endl</b> in an output expression, for example, it not only inserts a newline character, but it also <i>flushes</i>
the stream (that is, puts out all pending characters that have been stored in
the internal stream buffer but not yet output). You can also just flush a stream like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout &lt;&lt; flush;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which causes a call to the <b>flush(&nbsp;)</b> member function, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout.flush();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>as a side effect (nothing is inserted into the stream).
Additional basic manipulators will change the number base to <b>oct</b> (octal), <b>dec</b> (decimal) or <b>hex</b> (hexadecimal):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1> cout &lt;&lt; hex &lt;&lt; <font color=#007f00>&quot;0x&quot;</font> &lt;&lt; i &lt;&lt; endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this case, numeric output will continue in hexadecimal
mode until you change it by inserting either <b>dec</b> or <b>oct</b> in the
output stream.</p>

<p class=MsoNormal>There’s also a manipulator for extraction that “eats” white
space:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cin &gt;&gt; ws;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Manipulators with no arguments are provided in <b>&lt;iostream&gt;</b>.
These include <b>dec</b>, <b>oct</b>, and <b>hex</b>, which perform the same
action as, respectively, <b>setf(ios::dec, ios::basefield)</b>, <b>setf(ios::oct,
ios::basefield)</b>, and <b>setf(ios::hex, ios::basefield)</b>, albeit more
succinctly. The <b>&lt;iostream&gt;</b> header also includes <b>ws</b>, <b>endl</b>, and <b>flush</b> and the additional set shown here:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=461
 style='width:4.8in;margin-left:.4in;border-collapse:collapse;border:none;
 border-collapse:collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=169 valign=top style='width:126.8pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=TableHead>Manipulator</p>
   </td>
   <td width=292 valign=top style='width:218.8pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=TableHead>Effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>showbase</b><b><br>
  noshowbase</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Indicate the numeric base (<b>dec</b>, <b>oct</b>, or <b>hex</b>)
  when printing an integral value.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>showpos</b><b><br>
  noshowpos</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Show plus sign (+) for positive values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>uppercase</b><b><br>
  nouppercase</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Display uppercase A-F for hexadecimal values, and display E
  for scientific values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>showpoint</b><b><br>
  noshowpoint</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Show decimal point and trailing zeros for floating-point
  values.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>skipws</b><b><br>
  noskipws</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Skip white space on input.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>left</b><b><br>
  right</b><b><br>
  internal</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Left-align, pad on right.<br>
  Right-align, pad on left.<br>
  Fill between leading sign or base indicator and value.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=169 valign=top style='width:126.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>scientific</b><b><br>
  fixed</b></p>
  </td>
  <td width=292 valign=top style='width:218.8pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Indicates the display preference for floating-point output (scientific
  notation vs. fixed-point decimal).</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup>&nbsp;</sup></p>

<h3><a href="#_TocRef312373894" name="_Toc312373894">Manipulators with
arguments</a></h3>

<p class=MsoNormal>There are six standard manipulators, such as <b>setw(&nbsp;)</b>,
that take arguments. These are defined in the header file &lt;<b>iomanip&gt;</b>, and are summarized in the following table:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=461
 style='width:4.8in;margin-left:.4in;border-collapse:collapse;border:none;
 border-collapse:collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
   <td width=221 valign=top style='width:2.3in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=TableHead>Manipulator</p>
   </td>
   <td width=240 valign=top style='width:2.5in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm'>
   <p class=TableHead>effect</p>
   </td>
  </tr>
 </thead>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>setiosflags</b><b>(fmtflags n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Equivalent to a call to <b>setf(n)</b>. The setting remains in
  effect until the next change, such as <b>ios::setf(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>resetiosflags</b><b>(fmtflags n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Clears only the format flags specified by <b>n</b>. The
  setting remains in effect until the next change, such as <b>ios::unsetf(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>setbase</b><b>(base n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Changes base to <b>n</b>, where <b>n</b> is 10, 8, or 16.
  (Anything else results in 0.) If <b>n</b> is zero, output is base 10, but
  input uses the C conventions: 10 is 10, 010 is 8, and 0xf is 15. You might as
  well use <b>dec</b>, <b>oct</b>, and <b>hex</b> for output.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>setfill</b><b>(char n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Changes the fill character to <b>n</b>, such as <b>ios::fill(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>setprecision</b><b>(int n)</b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Changes the precision to <b>n</b>, such as <b>ios::precision(&nbsp;)</b>.</p>
  </td>
 </tr>
 <tr style='page-break-inside:avoid' style='page-break-inside:avoid !msorm'>
  <td width=221 valign=top style='width:2.3in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table><b>setw(int n) </b></p>
  </td>
  <td width=240 valign=top style='width:2.5in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm'>
  <p class=Table>Changes the field width to <b>n</b>, such as <b>ios::width(&nbsp;)</b>.</p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:6.0pt'>If you’re doing a lot of
formatting, you can see how using manipulators instead of calling stream member
functions can clean up your code. As an example, here’s the program from the
previous section rewritten to use the manipulators. (The <b>D(&nbsp;)</b> macro
is removed to make it easier to read.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=SV><font color=#dd0000>//: C04:Manips.cpp</span></font></div>
<div class=CC1><span lang=SV><font color=#dd0000>// Format.cpp using manipulators.</span></font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iomanip&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ofstream trc(<font color=#007f00>&quot;trace.out&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> i = 47;</div>
<div class=CC1>  <font color=#ff7700>float</font> f = 2300114.414159;</div>
<div class=CC1>  <font color=#ff7700>char</font>* s = <font color=#007f00>&quot;Is there any more?&quot;</font>;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  trc &lt;&lt; setiosflags(ios::unitbuf</div>
<div class=CC1>           | ios::showbase | ios::uppercase</div>
<div class=CC1>           | ios::showpos);</div>
<div class=CC1>  trc &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>  <span lang=SV>trc &lt;&lt; hex &lt;&lt; i &lt;&lt;
endl</span></div>
<div class=CC1><span lang=SV>      &lt;&lt; oct &lt;&lt; i &lt;&lt;
endl;</span></div>
<div class=CC1><span lang=SV>  </span>trc.setf(ios::left, ios::adjustfield);</div>
<div class=CC1>  trc &lt;&lt; resetiosflags(ios::showbase)</div>
<div class=CC1>      &lt;&lt; dec &lt;&lt; setfill('0');</div>
<div class=CC1>  trc &lt;&lt; <font color=#007f00>&quot;fill char: &quot;</font> &lt;&lt;
trc.fill() &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::right, ios::adjustfield);</div>
<div class=CC1>  trc &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::internal, ios::adjustfield);</div>
<div class=CC1>  trc &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; i &lt;&lt; endl; <font color=#dd0000>// Without setw(10)</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  trc &lt;&lt; resetiosflags(ios::showpos)</div>
<div class=CC1>      &lt;&lt; setiosflags(ios::showpoint)</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot;prec = &quot;</font> &lt;&lt;
trc.precision() &lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::scientific, ios::floatfield);</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; resetiosflags(ios::uppercase)
&lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::fixed, ios::floatfield);</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; setprecision(20);</div>
<div class=CC1>  trc &lt;&lt; <font color=#007f00>&quot;prec = &quot;</font> &lt;&lt;
trc.precision() &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::scientific, ios::floatfield);</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::fixed, ios::floatfield);</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; f &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  trc &lt;&lt; setw(10) &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  trc &lt;&lt; setw(40) &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  trc.setf(ios::left, ios::adjustfield);</div>
<div class=CC1>  trc &lt;&lt; setw(40) &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that a lot of the multiple statements have been
condensed into a single chained insertion. Notice the call to <b>setiosflags(&nbsp;)</b>
in which the bitwise-OR of the flags is passed. This could also have been done
with <b>setf(&nbsp;)</b> and <b>unsetf(&nbsp;)</b> as in the previous example.</p>

<p class=MsoNormal>When using <b>setw(&nbsp;)</b> with an output stream, the
output expression is formatted into a temporary string that is padded with the
current fill character if needed, as determined by comparing the length of the
formatted result to the argument of <b>setw(&nbsp;)</b>. In other words, <b>setw(&nbsp;)</b>
affects the <i>result string</i> of a formatted output operation. Likewise,
using <b>setw(&nbsp;)</b> with input streams only is meaningful when reading <i>strings</i>,
as the following example makes clear:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:InputWidth.cpp</font></div>
<div class=CC1><font color=#dd0000>// Shows limitations of setw with input.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iomanip&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;limits&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  istringstream is(<font color=#007f00>&quot;one 2.34 five&quot;</font>);</div>
<div class=CC1>  string temp;</div>
<div class=CC1>  is &gt;&gt; setw(2) &gt;&gt; temp;</div>
<div class=CC1>  assert(temp == <font color=#007f00>&quot;on&quot;</font>);</div>
<div class=CC1>  is &gt;&gt; setw(2) &gt;&gt; temp;</div>
<div class=CC1>  assert(temp == <font color=#007f00>&quot;e&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>double</font> x;</div>
<div class=CC1>  is &gt;&gt; setw(2) &gt;&gt; x;</div>
<div class=CC1>  <font color=#ff7700>double</font> relerr = fabs(x - 2.34) / x;</div>
<div class=CC1>  assert(relerr &lt;=
numeric_limits&lt;<font color=#ff7700>double</font>&gt;::epsilon());</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you attempt to read a string, <b>setw(&nbsp;)</b>
will control the number of characters extracted quite nicely… up to a point.
The first extraction gets two characters, but the second only gets one, even
though we asked for two. That is because <b>operator&gt;&gt;(&nbsp;)</b> uses
white space as a delimiter (unless you turn off the <b>skipws</b> flag). When
trying to read a number, however, such as <b>x</b>, you cannot use <b>setw(&nbsp;)
</b>to limit the characters read. With input streams, use only <b>setw(&nbsp;)</b>
for extracting strings.</a></p>

<h3><a href="#_TocRef53985695" name="_Toc53985695">Creating manipulators</a></h3>

<p class=MsoNormal>Sometimes you’d like to create your own manipulators, and it
turns out to be remarkably simple. A zero-argument manipulator such as <b>endl </b>is
simply a function that takes as its argument an <b>ostream</b> reference and
returns an <b>ostream</b> reference. The declaration for <b>endl</b> is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>ostream&amp; endl(ostream&amp;);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now, when you say:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout &lt;&lt; <font color=#007f00>&quot;howdy&quot;</font> &lt;&lt; endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>the <b>endl</b> produces the <i>address</i> of that
function. So the compiler asks, “Is there a function that can be applied here
that takes the address of a function as its argument?” Predefined functions in <b>&lt;iostream&gt;
</b>do this; they’re called <i>applicators</i> (because they <i>apply</i> a
function to a stream). The applicator calls its function argument, passing it
the <b>ostream</b> object as its argument. You don’t need to know how
applicators work to create your own manipulator; you only need to know that
they exist. Here’s the (simplified) code for an <b>ostream</b> applicator:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>ostream&amp; ostream::<font color=#ff7700>operator</font>&lt;&lt;(ostream&amp;
(*pf)(ostream&amp;)) {</div>
<div class=CC1>  <font color=#ff7700>return</font> pf(*<font color=#ff7700>this</font>);</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The actual definition is a little more complicated since it
involves templates, but this code illustrates the technique. When a function
such as <b>*pf</b> (that takes a stream parameter and returns a stream
reference) is inserted into a stream, this applicator function is called, which
in turn executes the function to which <b>pf</b> points. Applicators for <b>ios_base</b>,
<b>basic_ios</b>, <b>basic_ostream</b>, and <b>basic_istream</b> are predefined
in the Standard C++ library.</p>

<p class=MsoNormal>To illustrate the process, here’s a trivial example that
creates a manipulator called <b>nl</b> that is equivalent to just inserting a
newline into a stream (i.e., no flushing of the stream occurs, as with <b>endl</b>):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:nl.cpp</font></div>
<div class=CC1><font color=#dd0000>// Creating a manipulator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp; nl(ostream&amp; os) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; '\n';</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;newlines&quot;</font> &lt;&lt; nl
&lt;&lt; <font color=#007f00>&quot;between&quot;</font> &lt;&lt; nl</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot;each&quot;</font> &lt;&lt; nl &lt;&lt;
<font color=#007f00>&quot;word&quot;</font> &lt;&lt; nl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you insert <b>nl</b> into an output stream, such as <b>cout</b>,
the following sequence of calls ensues:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout.<font color=#ff7700>operator</font>&lt;&lt;(nl) <span style='font-family:"Courier New" !msorm'><span
style='font-family:Wingdings'>è</span></span> nl(cout)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The expression</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>os &lt;&lt; '\n';</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>inside <b>nl(&nbsp;)</b> calls <b>ostream::operator(char)</b>,
which returns the stream, which is what is ultimately returned from <b>nl(&nbsp;)</b>.<a href="#_ftn47" name="_ftnref47"><span
class=MsoFootnoteReference>[47]</span></a></p>

<h3><a href="#_TocRef312373896" name="_Toc312373896">Effectors</a></h3>

<p class=MsoNormal>As you’ve seen, zero-argument manipulators are easy to
create. But what if you want to create a manipulator that takes arguments? If
you inspect the <b>&lt;iomanip&gt;</b> header, you’ll see a type called <b>smanip</b>, which is what the manipulators with arguments return. You might be tempted to
somehow use that type to define your own manipulators, but don’t do it. The <b>smanip</b>
type is implementation-dependent and thus not portable. Fortunately, you can
define such manipulators in a straightforward way without any special
machinery, based on a technique introduced by Jerry Schwarz, called an <i>effector</i>.<a href="#_ftn48" name="_ftnref48"><span
class=MsoFootnoteReference>[48]</span></a> An effector is
a simple class whose constructor formats a string representing the desired
operation, along with an overloaded <b>operator&lt;&lt;</b> to insert that
string into a stream. Here’s an example with two effectors. The first outputs a
truncated character string, and the second prints a number in binary.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Effector.cpp</a></font></div>
<div class=CC1><font color=#dd0000>// Jerry Schwarz's &quot;effectors.&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;limits&gt;  </font><font color=#dd0000>// For max()</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Put out a prefix of a string:</font></div>
<div class=CC1><font color=#ff7700>class</font> Fixw {</div>
<div class=CC1>  string str;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Fixw(<font color=#ff7700>const</font> string&amp; s, <font color=#ff7700>int</font> width) : str(s, 0,
width) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Fixw&amp; fw) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; fw.str;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Print a number in binary:</font></div>
<div class=CC1><font color=#ff7700>typedef</font> <font color=#ff7700>unsigned</font> <font color=#ff7700>long</font> ulong;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bin {</div>
<div class=CC1>  ulong n;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Bin(ulong nn) { n = nn; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Bin&amp; b) {</div>
<div class=CC1>    <font color=#ff7700>const</font> ulong ULMAX =
numeric_limits&lt;ulong&gt;::max();</div>
<div class=CC1>    ulong bit = ~(ULMAX &gt;&gt; 1); <font color=#dd0000>// Top bit set</font></div>
<div class=CC1>    <font color=#ff7700>while</font>(bit) {</div>
<div class=CC1>      os &lt;&lt; (b.n &amp; bit ? '1' : '0');</div>
<div class=CC1>      bit &gt;&gt;= 1;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>return</font> os;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string words = <font color=#007f00>&quot;Things that make us happy, make
us wise&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = words.size(); --i &gt;= 0;) {</div>
<div class=CC1>    ostringstream s;</div>
<div class=CC1>    s &lt;&lt; Fixw(words, i);</div>
<div class=CC1>    assert(s.str() == words.substr(0, i));</div>
<div class=CC1>  }</div>
<div class=CC1>  ostringstream xs, ys;</div>
<div class=CC1>  xs &lt;&lt; Bin(0xCAFEBABEUL);</div>
<div class=CC1>  assert(xs.str() ==</div>
<div class=CC1>   
<font color=#007f00>&quot;1100&quot;</font><font color=#007f00>&quot;1010&quot;</font><font color=#007f00>&quot;1111&quot;</font><font color=#007f00>&quot;1110&quot;</font><font color=#007f00>&quot;1011&quot;</font><font color=#007f00>&quot;1010&quot;</font><font color=#007f00>&quot;1011&quot;</font><font color=#007f00>&quot;1110&quot;</font>);</div>
<div class=CC1>  ys &lt;&lt; Bin(0x76543210UL);</div>
<div class=CC1>  assert(ys.str() ==</div>
<div class=CC1>   
<font color=#007f00>&quot;0111&quot;</font><font color=#007f00>&quot;0110&quot;</font><font color=#007f00>&quot;0101&quot;</font><font color=#007f00>&quot;0100&quot;</font><font color=#007f00>&quot;0011&quot;</font><font color=#007f00>&quot;0010&quot;</font><font color=#007f00>&quot;0001&quot;</font><font color=#007f00>&quot;0000&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The constructor for <b>Fixw</b> creates a shortened copy of
its <b>char*</b> argument, and the destructor releases the memory created for
this copy. The overloaded <b>operator&lt;&lt;</b> takes the contents of its
second argument, the <b>Fixw</b> object, inserts it into the first argument,
the <b>ostream</b>, and then returns the <b>ostream</b> so that it can be used
in a chained expression. When you use <b>Fixw</b> in an expression like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout &lt;&lt; Fixw(string, i) &lt;&lt; endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>a <i>temporary object</i> is created by the call to the <b>Fixw</b>
constructor, and that temporary object is passed to <b>operator&lt;&lt;</b>.
The effect is that of a manipulator with arguments. The temporary <b>Fixw</b>
object persists until the end of the statement.</p>

<p class=MsoNormal>The <b>Bin</b> effector relies on the fact that shifting an
unsigned number to the right shifts zeros into the high bits. We use <b>numeric_limits</b><b>&lt;unsigned long&gt;::max(&nbsp;)</b> (the largest <b>unsigned long</b>
value, from the standard header <b>&lt;limits&gt;</b>) to produce a value with the high bit set, and this value is moved across the number in question (by shifting it to
the right), masking each bit in turn. We’ve juxtaposed string literals in the
code for readability; the separate strings are concatenated into a single
string by the compiler.</p>

<p class=MsoNormal>Historically, the problem with this technique was that once
you created a class called <b>Fixw</b> for <b>char*</b> or <b>Bin </b>for <b>unsigned
long</b>,<b> </b>no one else could create a different <b>Fixw</b> or <b>Bin </b>class
for their type. However, with namespaces, this problem is eliminated. Effectors
and manipulators aren’t equivalent, although they can often be used to solve
the same problem. If you find that an effector isn’t enough, you will need to
conquer the complexity of manipulators.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373897" name="_Toc312373897">Iostream examples</a></h2>

<p class=MsoNormal>In this section you’ll see examples that use what you’ve
learned in this chapter. Although many tools exist to manipulate bytes (stream
editors such as <b>sed </b>and <b>awk</b> from UNIX are perhaps the most well
known, but a text editor also fits this category), they generally have some
limitations. Both <b>sed</b> and <b>awk</b> can be slow and can only handle
lines in a forward sequence, and text editors usually require human
interaction, or at least learning a proprietary macro language. The programs
you write with iostreams have none of these limitations: they’re fast,
portable, and flexible.</p>

<h3><a href="#_TocRef53985698" name="_Toc53985698">Maintaining class library source code</a></h3>

<p class=MsoNormal>Generally, when you create a class, you think in library
terms: you make a header file <b>Name.h </b>for the class declaration, and then
create a file called <b>Name.cpp</b> where the member functions are implemented<span
style='text-transform:uppercase'>. T</span>hese files have certain
requirements: a particular coding standard (the program shown here uses the
coding format for this book), and preprocessor statements surrounding the code in
the header file to prevent multiple declarations of classes. (Multiple
declarations confuse the compiler—it doesn’t know which one you want to use.
They could be different, so it throws up its hands and gives an error message.)</p>

<p class=MsoNormal>This example creates a new header/implementation pair of
files or modifies an existing pair. If the files already exist, it checks and
potentially modifies the files, but if they don’t exist, it creates them using
the proper format.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Cppcheck.cpp</font></div>
<div class=CC1><font color=#dd0000>// Configures .h &amp; .cpp files to conform to style</font></div>
<div class=CC1><font color=#dd0000>// standard. Tests existing files for conformance.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> startsWith(<font color=#ff7700>const</font> string&amp; base, <font color=#ff7700>const</font>
string&amp; key) {</div>
<div class=CC1>  <font color=#ff7700>return</font> base.compare(0, key.size(), key) == 0;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> cppCheck(string fileName) {</div>
<div class=CC1>  <font color=#ff7700>enum</font> bufs { BASE, HEADER, IMPLEMENT, HLINE1, GUARD1,</div>
<div class=CC1>    GUARD2, GUARD3, CPPLINE1, INCLUDE, BUFNUM };</div>
<div class=CC1>  string part[BUFNUM];</div>
<div class=CC1>  part[BASE] = fileName;</div>
<div class=CC1>  <font color=#dd0000>// Find any '.' in the string:</font></div>
<div class=CC1>  size_t loc = part[BASE].find('.');</div>
<div class=CC1>  <font color=#ff7700>if</font>(loc != string::npos)</div>
<div class=CC1>    part[BASE].erase(loc); <font color=#dd0000>// Strip extension</font></div>
<div class=CC1>  <font color=#dd0000>// Force to upper case:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; part[BASE].size(); i++)</div>
<div class=CC1>    part[BASE][i] = toupper(part[BASE][i]);</div>
<div class=CC1>  <font color=#dd0000>// Create file names and internal lines:</font></div>
<div class=CC1>  part[HEADER] = part[BASE] + <font color=#007f00>&quot;.h&quot;</font>;</div>
<div class=CC1>  part[IMPLEMENT] = part[BASE] + <font color=#007f00>&quot;.cpp&quot;</font>;</div>
<div class=CC1>  part[HLINE1] = &quot;<font color=#dd0000>//&quot; &quot;: &quot; +
part[HEADER];</font></div>
<div class=CC1>  part[GUARD1] = <font color=#007f00>&quot;#ifndef &quot;</font> + part[BASE] +
<font color=#007f00>&quot;_H&quot;</font>;</div>
<div class=CC1>  part[GUARD2] = <font color=#007f00>&quot;#define &quot;</font> + part[BASE] +
<font color=#007f00>&quot;_H&quot;</font>;</div>
<div class=CC1>  part[GUARD3] = &quot;#endif <font color=#dd0000>// &quot; + part[BASE]
+&quot;_H&quot;;</font></div>
<div class=CC1>  part[CPPLINE1] = string(&quot;<font color=#dd0000>//&quot;) + &quot;:
&quot; + part[IMPLEMENT];</font></div>
<div class=CC1>  part[INCLUDE] = <font color=#007f00>&quot;#include \&quot;&quot;</font> +
part[HEADER] + <font color=#007f00>&quot;\&quot;&quot;</font>;</div>
<div class=CC1>  <font color=#dd0000>// First, try to open existing files:</font></div>
<div class=CC1>  ifstream existh(part[HEADER].c_str()),</div>
<div class=CC1>           existcpp(part[IMPLEMENT].c_str());</div>
<div class=CC1>  <font color=#ff7700>if</font>(!existh) { <font color=#dd0000>// Doesn't exist; create it</font></div>
<div class=CC1>    ofstream newheader(part[HEADER].c_str());</div>
<div class=CC1>    assure(newheader, part[HEADER].c_str());</div>
<div class=CC1>    newheader &lt;&lt; part[HLINE1] &lt;&lt; endl</div>
<div class=CC1>              &lt;&lt; part[GUARD1] &lt;&lt; endl</div>
<div class=CC1>              &lt;&lt; part[GUARD2] &lt;&lt; endl
&lt;&lt; endl</div>
<div class=CC1>              &lt;&lt; part[GUARD3] &lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>else</font> { <font color=#dd0000>// Already exists; verify it</font></div>
<div class=CC1>    stringstream hfile; <font color=#dd0000>// Write &amp; read</font></div>
<div class=CC1>    ostringstream newheader; <font color=#dd0000>// Write</font></div>
<div class=CC1>    hfile &lt;&lt; existh.rdbuf();</div>
<div class=CC1>    <font color=#dd0000>// Check that first three lines conform:</font></div>
<div class=CC1>    <font color=#ff7700>bool</font> changed = <font color=#ff7700>false</font>;</div>
<div class=CC1>    string s;</div>
<div class=CC1>    hfile.seekg(0);</div>
<div class=CC1>    getline(hfile, s);</div>
<div class=CC1>    <font color=#ff7700>bool</font> lineUsed = <font color=#ff7700>false</font>;</div>
<div class=CC1>    <font color=#dd0000>// The call to good() is for Microsoft (later too):</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> line = HLINE1; hfile.good() &amp;&amp; line
&lt;= GUARD2;</div>
<div class=CC1>         ++line) {</div>
<div class=CC1>      <font color=#ff7700>if</font>(startsWith(s, part[line])) {</div>
<div class=CC1>        newheader &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>        lineUsed = <font color=#ff7700>true</font>;</div>
<div class=CC1>        <font color=#ff7700>if</font>(getline(hfile, s))</div>
<div class=CC1>          lineUsed = <font color=#ff7700>false</font>;</div>
<div class=CC1>      } <font color=#ff7700>else</font> {</div>
<div class=CC1>        newheader &lt;&lt; part[line] &lt;&lt; endl;</div>
<div class=CC1>        changed = <font color=#ff7700>true</font>;</div>
<div class=CC1>        lineUsed = <font color=#ff7700>false</font>;</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#dd0000>// Copy rest of file</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(!lineUsed)</div>
<div class=CC1>      newheader &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>    newheader &lt;&lt; hfile.rdbuf();</div>
<div class=CC1>    <font color=#dd0000>// Check for GUARD3</font></div>
<div class=CC1>    string head = hfile.str();</div>
<div class=CC1>    <font color=#ff7700>if</font>(head.find(part[GUARD3]) == string::npos) {</div>
<div class=CC1>      newheader &lt;&lt; part[GUARD3] &lt;&lt; endl;</div>
<div class=CC1>      changed = <font color=#ff7700>true</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#dd0000>// If there were changes, overwrite file:</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(changed) {</div>
<div class=CC1>      existh.close();</div>
<div class=CC1>      ofstream newH(part[HEADER].c_str());</div>
<div class=CC1>      assure(newH, part[HEADER].c_str());</div>
<div class=CC1>      newH &lt;&lt; &quot;<font color=#dd0000>//@//\n&quot;  // Change
marker</font></div>
<div class=CC1>           &lt;&lt; newheader.str();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>if</font>(!existcpp) { <font color=#dd0000>// Create cpp file</font></div>
<div class=CC1>    ofstream newcpp(part[IMPLEMENT].c_str());</div>
<div class=CC1>    assure(newcpp, part[IMPLEMENT].c_str());</div>
<div class=CC1>    newcpp &lt;&lt; part[CPPLINE1] &lt;&lt; endl</div>
<div class=CC1>           &lt;&lt; part[INCLUDE] &lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>else</font> { <font color=#dd0000>// Already exists; verify it</font></div>
<div class=CC1>    stringstream cppfile;</div>
<div class=CC1>    ostringstream newcpp;</div>
<div class=CC1>    cppfile &lt;&lt; existcpp.rdbuf();</div>
<div class=CC1>    <font color=#dd0000>// Check that first two lines conform:</font></div>
<div class=CC1>    <font color=#ff7700>bool</font> changed = <font color=#ff7700>false</font>;</div>
<div class=CC1>    string s;</div>
<div class=CC1>    cppfile.seekg(0);</div>
<div class=CC1>    getline(cppfile, s);</div>
<div class=CC1>    <font color=#ff7700>bool</font> lineUsed = <font color=#ff7700>false</font>;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> line = CPPLINE1;</div>
<div class=CC1>        cppfile.good() &amp;&amp; line &lt;= INCLUDE;
++line) {</div>
<div class=CC1>      <font color=#ff7700>if</font>(startsWith(s, part[line])) {</div>
<div class=CC1>        newcpp &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>        lineUsed = <font color=#ff7700>true</font>;</div>
<div class=CC1>        <font color=#ff7700>if</font>(getline(cppfile, s))</div>
<div class=CC1>          lineUsed = <font color=#ff7700>false</font>;</div>
<div class=CC1>      } <font color=#ff7700>else</font> {</div>
<div class=CC1>        newcpp &lt;&lt; part[line] &lt;&lt; endl;</div>
<div class=CC1>        changed = <font color=#ff7700>true</font>;</div>
<div class=CC1>        lineUsed = <font color=#ff7700>false</font>;</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#dd0000>// Copy rest of file</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(!lineUsed)</div>
<div class=CC1>      newcpp &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>    newcpp &lt;&lt; cppfile.rdbuf();</div>
<div class=CC1>    <font color=#dd0000>// If there were changes, overwrite file:</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(changed) {</div>
<div class=CC1>      existcpp.close();</div>
<div class=CC1>      ofstream newCPP(part[IMPLEMENT].c_str());</div>
<div class=CC1>      assure(newCPP, part[IMPLEMENT].c_str());</div>
<div class=CC1>      newCPP &lt;&lt; &quot;<font color=#dd0000>//@//\n&quot;  // Change
marker</font></div>
<div class=CC1>             &lt;&lt; newcpp.str();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1)</div>
<div class=CC1>    cppCheck(argv[1]);</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    cppCheck(<font color=#007f00>&quot;cppCheckTest.h&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>First notice the useful function <b>startsWith(&nbsp;)</b>,
which does just what its name says—it returns <b>true</b> if the first string
argument starts with the second argument. This is used when looking for the
expected comments and include-related statements. Having the array of strings, <b>part</b>,
allows for easy looping through the series of expected statements in source
code. If the source file doesn’t exist, we merely write the statements to a new
file of the given name. If the file does exist, we search a line at a time,
verifying that the expected lines occur. If they are not present, they are
inserted. Special care must be taken to make sure we don’t drop existing lines
(see where we use the Boolean variable <b>lineUsed</b>). Notice that we use a <b>stringstream</b>
for an existing file, so we can first write the contents of the file to it and
then read from and search it.</p>

<p class=MsoNormal>The names in the enumeration are <b>BASE</b>, the
capitalized base file name without extension; <b>HEADER</b>, the header file
name; <b>IMPLEMENT</b>, the implementation file (<b>cpp</b>) name; <b>HLINE1</b>,
the skeleton first line of the header file; <b>GUARD1</b>, <b>GUARD2</b>, and <b>GUARD3</b>,
the “guard” lines in the header file (to prevent multiple inclusion); <b>CPPLINE1</b>,
the skeleton first line of the <b>cpp</b> file; and <b>INCLUDE</b>, the line in
the <b>cpp</b> file that includes the header file.</p>

<p class=MsoNormal>If you run this program without any arguments, the following
two files are created:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// CPPCHECKTEST.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef CPPCHECKTEST_H</font></div>
<div class=CC1><font color=#7F7F00>#define CPPCHECKTEST_H</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// CPPCHECKTEST_H</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// CPPCHECKTEST.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include
&quot;CPPCHECKTEST.h&quot;</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>(We removed the colon after the double-slash in the first
comment lines so as not to confuse the book’s code extractor. It will appear in
the actual output produced by <b>cppCheck</b>.)</p>

<p class=MsoNormal>You can experiment by removing selected lines from these
files and re-running the program. Each time you will see that the correct lines
are added back in. When a file is modified, the string “<b>//@//</b>” is placed
as the first line of the file to bring the change to your attention. You will
need to remove this line before you process the file again (otherwise <b>cppcheck</b>
will assume the initial comment line is missing).</p>

<h3><a href="#_TocRef53985699" name="_Toc53985699">Detecting compiler errors</a></h3>

<p class=MsoNormal>All the code in this book is designed to compile as shown
without errors. Lines of code that should generate a compile-time error may be
commented out with the special comment sequence “//!”. The following program
will remove these special comments and append a numbered comment to the line.
When you run your compiler, it should generate error messages, and you will see
all the numbers appear when you compile all the files. This program also
appends the modified line to a special file so that you can easily locate any
lines that don’t generate errors.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Showerr.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Un-comment error generators.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>const</font> string USAGE =</div>
<div class=CC1>  <font color=#007f00>&quot;usage: showerr filename chapnum\n&quot;</font></div>
<div class=CC1>  <font color=#007f00>&quot;where filename is a C++ source file\n&quot;</font></div>
<div class=CC1>  <font color=#007f00>&quot;and chapnum is the chapter name it's
in.\n&quot;</font></div>
<div class=CC1>  &quot;Finds lines commented with <font color=#dd0000>//! and
removes\n&quot;</font></div>
<div class=CC1>  &quot;the comment, appending <font color=#dd0000>//(#) where # is
unique\n&quot;</font></div>
<div class=CC1>  <font color=#007f00>&quot;across all files, so you can determine\n&quot;</font></div>
<div class=CC1>  <font color=#007f00>&quot;if your compiler finds the error.\n&quot;</font></div>
<div class=CC1>  <font color=#007f00>&quot;showerr /r\n&quot;</font></div>
<div class=CC1>  <font color=#007f00>&quot;resets the unique counter.&quot;</font>;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Showerr {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> CHAP;</div>
<div class=CC1>  <font color=#ff7700>const</font> string MARKER, FNAME;</div>
<div class=CC1>  <font color=#dd0000>// File containing error number counter:</font></div>
<div class=CC1>  <font color=#ff7700>const</font> string ERRNUM;</div>
<div class=CC1>  <font color=#dd0000>// File containing error lines:</font></div>
<div class=CC1>  <font color=#ff7700>const</font> string ERRFILE;</div>
<div class=CC1>  stringstream edited; <font color=#dd0000>// Edited file</font></div>
<div class=CC1>  <font color=#ff7700>int</font> counter;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Showerr(<font color=#ff7700>const</font> string&amp; f, <font color=#ff7700>const</font> string&amp; en,</div>
<div class=CC1>    <font color=#ff7700>const</font> string&amp; ef, <font color=#ff7700>int</font> c)</div>
<div class=CC1>  : CHAP(c), MARKER(&quot;<font color=#dd0000>//!&quot;), FNAME(f),
ERRNUM(en),</font></div>
<div class=CC1>    ERRFILE(ef), counter(0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> replaceErrors() {</div>
<div class=CC1>    ifstream infile(FNAME.c_str());</div>
<div class=CC1>    assure(infile, FNAME.c_str());</div>
<div class=CC1>    ifstream count(ERRNUM.c_str());</div>
<div class=CC1>    <font color=#ff7700>if</font>(count) count &gt;&gt; counter;</div>
<div class=CC1>    <font color=#ff7700>int</font> linecount = 1;</div>
<div class=CC1>    string buf;</div>
<div class=CC1>    ofstream errlines(ERRFILE.c_str(), ios::app);</div>
<div class=CC1>    assure(errlines, ERRFILE.c_str());</div>
<div class=CC1>    <font color=#ff7700>while</font>(getline(infile, buf)) {</div>
<div class=CC1>      <font color=#dd0000>// Find marker at start of line:</font></div>
<div class=CC1>      size_t pos = buf.find(MARKER);</div>
<div class=CC1>      <font color=#ff7700>if</font>(pos != string::npos) {</div>
<div class=CC1>        <font color=#dd0000>// Erase marker:</font></div>
<div class=CC1>        buf.erase(pos, MARKER.size() + 1);</div>
<div class=CC1>        <font color=#dd0000>// Append counter &amp; error info:</font></div>
<div class=CC1>        ostringstream out;</div>
<div class=CC1>        out &lt;&lt; buf &lt;&lt; &quot; <font color=#dd0000>// (&quot;
&lt;&lt; ++counter &lt;&lt; &quot;) &quot;</font></div>
<div class=CC1>            &lt;&lt; <font color=#007f00>&quot;Chapter &quot;</font> &lt;&lt; CHAP</div>
<div class=CC1>            &lt;&lt; <font color=#007f00>&quot; File: &quot;</font> &lt;&lt; FNAME</div>
<div class=CC1>            &lt;&lt; <font color=#007f00>&quot; Line &quot;</font> &lt;&lt;
linecount &lt;&lt; endl;</div>
<div class=CC1>        edited &lt;&lt; out.str();</div>
<div class=CC1>        errlines &lt;&lt; out.str(); <font color=#dd0000>// Append error
file</font></div>
<div class=CC1>      }</div>
<div class=CC1>      <font color=#ff7700>else</font></div>
<div class=CC1>        edited &lt;&lt; buf &lt;&lt; <font color=#007f00>&quot;\n&quot;</font>; <font color=#dd0000>//
Just copy</font></div>
<div class=CC1>      ++linecount;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> saveFiles() {</div>
<div class=CC1>    ofstream outfile(FNAME.c_str()); <font color=#dd0000>// Overwrites</font></div>
<div class=CC1>    assure(outfile, FNAME.c_str());</div>
<div class=CC1>    outfile &lt;&lt; edited.rdbuf();</div>
<div class=CC1>    ofstream count(ERRNUM.c_str()); <font color=#dd0000>// Overwrites</font></div>
<div class=CC1>    assure(count, ERRNUM.c_str());</div>
<div class=CC1>    count &lt;&lt; counter; <font color=#dd0000>// Save new counter</font></div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>const</font> string ERRCOUNT(<font color=#007f00>&quot;../errnum.txt&quot;</font>),</div>
<div class=CC1>    ERRFILE(<font color=#007f00>&quot;../errlines.txt&quot;</font>);</div>
<div class=CC1>  requireMinArgs(argc, 1, USAGE.c_str());</div>
<div class=CC1>  <font color=#ff7700>if</font>(argv[1][0] == '/' || argv[1][0] == '-') {</div>
<div class=CC1>    <font color=#dd0000>// Allow for other switches:</font></div>
<div class=CC1>    <font color=#ff7700>switch</font>(argv[1][1]) {</div>
<div class=CC1>      <font color=#ff7700>case</font> 'r': <font color=#ff7700>case</font> 'R':</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;reset counter&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>        remove(ERRCOUNT.c_str()); <font color=#dd0000>// Delete files</font></div>
<div class=CC1>        remove(ERRFILE.c_str());</div>
<div class=CC1>        <font color=#ff7700>return</font> EXIT_SUCCESS;</div>
<div class=CC1>      <font color=#ff7700>default</font>:</div>
<div class=CC1>        cerr &lt;&lt; USAGE &lt;&lt; endl;</div>
<div class=CC1>        <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc == 3) {</div>
<div class=CC1>    Showerr s(argv[1], ERRCOUNT, ERRFILE, atoi(argv[2]));</div>
<div class=CC1>    s.replaceErrors();</div>
<div class=CC1>    s.saveFiles();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can replace the marker with one of your choice.</p>

<p class=MsoNormal>Each file is read a line at a time, and each line is
searched for the marker appearing at the head of the line; the line is modified
and put into the error line list and into the string stream, <b>edited</b>.
When the whole file is processed, it is closed (by reaching the end of a
scope), it is reopened as an output file, and <b>edited</b> is poured into the
file. Also notice the counter is saved in an external file. The next time this
program is invoked, it continues to increment the counter.</p>

<h3><a href="#_TocRef312373899" name="_Toc312373899">A simple </a>data logger</h3>

<p class=MsoNormal>This example shows an approach you might take to log data to
disk and later retrieve it for processing. It is meant to produce a temperature-depth
profile of the ocean at various points. The <b>DataPoint</b> class holds the
data:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:DataLogger.h</font></div>
<div class=CC1><font color=#dd0000>// Datalogger record layout.</font></div>
<div class=CC1><span lang=IT>#ifndef DATALOG_H</span></div>
<div class=CC1><span lang=IT>#define DATALOG_H</span></div>
<div class=CC1><span lang=IT>#include &lt;ctime&gt;</span></div>
<div class=CC1><font color=#7F7F00>#include &lt;iosfwd&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::ostream;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> Coord {</div>
<div class=CC1>  <font color=#ff7700>int</font> deg, min, sec;</div>
<div class=CC1>  Coord(<font color=#ff7700>int</font> d = 0, <font color=#ff7700>int</font> m = 0, <font color=#ff7700>int</font> s = 0)</div>
<div class=CC1>  : deg(d), min(m), sec(s) {}</div>
<div class=CC1>  std::string toString() <font color=#ff7700>const</font>;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp;, <font color=#ff7700>const</font>
Coord&amp;);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DataPoint {</div>
<div class=CC1>  std::time_t timestamp; <font color=#dd0000>// Time &amp; day</font></div>
<div class=CC1>  Coord latitude, longitude;</div>
<div class=CC1>  <font color=#ff7700>double</font> depth, temperature;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DataPoint(std::time_t ts, <font color=#ff7700>const</font> Coord&amp; lat,</div>
<div class=CC1>            <font color=#ff7700>const</font> Coord&amp; lon, <font color=#ff7700>double</font> dep, <font color=#ff7700>double</font>
temp)</div>
<div class=CC1>  : timestamp(ts), latitude(lat), longitude(lon),</div>
<div class=CC1>      depth(dep), temperature(temp) {}</div>
<div class=CC1>  DataPoint() : timestamp(0), depth(0), temperature(0)
{}</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp;,
<font color=#ff7700>const</font> DataPoint&amp;);</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DATALOG_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A <b>DataPoint</b> consists of a time stamp, which is stored
as a <b>time</b><b>_t</b> value as defined in <b>&lt;ctime&gt;</b>, longitude and latitude coordinates, and values for depth and temperature. We use inserters for easy formatting.
Here’s the implementation file:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:DataLogger.cpp {O}</font></div>
<div class=CC1><font color=#dd0000>// Datapoint implementations.</font></div>
<div class=CC1><span lang=IT>#include <font color=#007f00>&quot;DataLogger.h&quot;</font></span></div>
<div class=CC1><span lang=IT>#include &lt;iomanip&gt;</span></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
Coord&amp; c) {</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>return</font> os &lt;&lt; c.deg &lt;&lt; '*'
&lt;&lt; c.min &lt;&lt; '\''</span></div>
<div class=CC1><span lang=SV>            </span>&lt;&lt; c.sec
&lt;&lt; '&quot;';</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string Coord::toString() <font color=#ff7700>const</font> {</div>
<div class=CC1>  ostringstream os;</div>
<div class=CC1>  os &lt;&lt; *<font color=#ff7700>this</font>;</div>
<div class=CC1>  <font color=#ff7700>return</font> os.str();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
DataPoint&amp; d) {</div>
<div class=CC1>  os.setf(ios::fixed, ios::floatfield);</div>
<div class=CC1>  <font color=#ff7700>char</font> fillc = os.fill('0'); <font color=#dd0000>// Pad on left with '0'</font></div>
<div class=CC1>  <span lang=IT>tm* tdata =
localtime(&amp;d.timestamp);</span></div>
<div class=CC1><span lang=IT>  </span><span lang=SV>os &lt;&lt;
setw(2) &lt;&lt; tdata-&gt;tm_mon + 1 &lt;&lt; '\\'</span></div>
<div class=CC1><span lang=SV>     &lt;&lt; setw(2) &lt;&lt;
tdata-&gt;tm_mday &lt;&lt; '\\'</span></div>
<div class=CC1><span lang=SV>     </span>&lt;&lt; setw(2) &lt;&lt;
tdata-&gt;tm_year+1900 &lt;&lt; ' '</div>
<div class=CC1>     &lt;&lt; setw(2) &lt;&lt; tdata-&gt;tm_hour
&lt;&lt; ':'</div>
<div class=CC1>     <span lang=SV>&lt;&lt; setw(2) &lt;&lt;
tdata-&gt;tm_min &lt;&lt; ':'</span></div>
<div class=CC1><span lang=SV>     </span>&lt;&lt; setw(2) &lt;&lt;
tdata-&gt;tm_sec;</div>
<div class=CC1>  os.fill(' '); <font color=#dd0000>// Pad on left with ' '</font></div>
<div class=CC1>  streamsize prec = os.precision(4);</div>
<div class=CC1>  os &lt;&lt; <font color=#007f00>&quot; Lat:&quot;</font>    &lt;&lt; setw(9)
&lt;&lt; d.latitude.toString()</div>
<div class=CC1>     &lt;&lt; <font color=#007f00>&quot;, Long:&quot;</font>  &lt;&lt; setw(9)
&lt;&lt; d.longitude.toString()</div>
<div class=CC1>     &lt;&lt; <font color=#007f00>&quot;, depth:&quot;</font> &lt;&lt; setw(9)
&lt;&lt; d.depth</div>
<div class=CC1>     &lt;&lt; <font color=#007f00>&quot;, temp:&quot;</font>  &lt;&lt; setw(9)
&lt;&lt; d.temperature;</div>
<div class=CC1>  os.fill(fillc);</div>
<div class=CC1>  os.precision(prec);</div>
<div class=CC1>  <font color=#ff7700>return</font> os;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Coord::toString(&nbsp;) </b>function is necessary
because the <b>DataPoint</b> inserter calls <b>setw(&nbsp;)</b> before it prints the latitude and longitude. If we used the stream inserter for <b>Coord</b> instead, the width
would only apply to the first insertion (that is, to <b>Coord::deg</b>), since
width changes are always reset immediately. The call to <b>setf(&nbsp;)</b> causes the floating-point output to be fixed-precision, and <b>precision(&nbsp;)</b> sets the number of decimal places to four. Notice how we restore the fill
character and precision to whatever they were before the inserter was called.</p>

<p class=MsoNormal>To get the values from the time encoding stored in <b>DataPoint::timestamp</b>,
we call the function <b>std::localtime(&nbsp;)</b>, which returns a static pointer to a <b>tm</b> object. The <b>tm</b> <b>struct</b> has the following layout:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>struct</font> tm {</div>
<div class=CC1>  <font color=#ff7700>int</font> tm_sec; <font color=#dd0000>// 0-59 seconds</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_min; <font color=#dd0000>// 0-59 minutes</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_hour; <font color=#dd0000>// 0-23 hours</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_mday; <font color=#dd0000>// Day of month</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_mon; <font color=#dd0000>// 0-11 months</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_year; <font color=#dd0000>// Years since 1900</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_wday; <font color=#dd0000>// Sunday == 0, etc.</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_yday; <font color=#dd0000>// 0-365 day of year</font></div>
<div class=CC1>  <font color=#ff7700>int</font> tm_isdst; <font color=#dd0000>// Daylight savings?</font></div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<h4>Generating test data</h4>

<p class=MsoNormal>Here’s a program that creates a file of test data in binary
form (using <b>write(&nbsp;)</b>) and a second file in ASCII form using the <b>DataPoint</b> inserter. You can also print it out to the screen, but it’s easier
to inspect in file form.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Datagen.cpp</font></div>
<div class=CC1><font color=#dd0000>// Test data generator.</font></div>
<div class=CC1><font color=#dd0000>//{L} DataLogger</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DataLogger.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  time_t timer;</div>
<div class=CC1>  srand(time(&amp;timer)); <font color=#dd0000>// Seed the random number
generator</font></div>
<div class=CC1>  ofstream data(<font color=#007f00>&quot;data.txt&quot;</font>);</div>
<div class=CC1>  assure(data, <font color=#007f00>&quot;data.txt&quot;</font>);</div>
<div class=CC1>  ofstream bindata(<font color=#007f00>&quot;data.bin&quot;</font>, ios::binary);</div>
<div class=CC1>  assure(bindata, <font color=#007f00>&quot;data.bin&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++, timer += 55) {</div>
<div class=CC1>    <font color=#dd0000>// Zero to 199 meters:</font></div>
<div class=CC1>    <font color=#ff7700>double</font> newdepth  = rand() % 200;</div>
<div class=CC1>    <font color=#ff7700>double</font> fraction = rand() % 100 + 1;</div>
<div class=CC1>    newdepth += 1.0 / fraction;</div>
<div class=CC1>    <font color=#ff7700>double</font> newtemp = 150 + rand() % 200; <font color=#dd0000>// Kelvin</font></div>
<div class=CC1>    fraction = rand() % 100 + 1;</div>
<div class=CC1>    newtemp += 1.0 / fraction;</div>
<div class=CC1>    <font color=#ff7700>const</font> DataPoint d(timer, Coord(45,20,31),</div>
<div class=CC1>                      Coord(22,34,18), newdepth,</div>
<div class=CC1>                      newtemp);</div>
<div class=CC1>    data &lt;&lt; d &lt;&lt; endl;</div>
<div class=CC1>    bindata.write(<font color=#ff7700>reinterpret_cast</font>&lt;<font color=#ff7700>const</font>
<font color=#ff7700>char</font>*&gt;(&amp;d),</div>
<div class=CC1>                  <font color=#ff7700>sizeof</font>(d));</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The file <b>data.txt </b>is created in the ordinary way as
an ASCII file, but <b>data.bin </b>has the flag <b>ios::binary</b> to tell the constructor to set it up as a binary file. To illustrate the formatting used for the text
file, here is the first line of <b>data.txt</b> (the line wraps because it’s
longer than this page will allow):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>07\28\2003 12:54:40 Lat:45*20'31<font color=#007f00>&quot;, Long:22*34'18&quot;</font>, depth: 
16.0164, temp: 242.0122</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The Standard C library function <b>time(&nbsp;)</b> updates the <b>time_t</b> value its argument points to with an encoding of the
current time, which on most platforms is the number of seconds elapsed since 00:
00: 00 GMT, January 1 1970 (the dawning of the age of Aquarius?). The current
time is also a convenient way to seed the random number generator with the
Standard C library function <b>srand(&nbsp;)</b>, as is done here.</p>

<p class=MsoNormal>After this, the <b>timer</b> is incremented by 55 seconds to
give an interesting interval between readings in this simulation.</p>

<p class=MsoNormal>The latitude and longitude used are fixed values to indicate
a set of readings at a single location. Both the depth and the temperature are
generated with the Standard C library <b>rand(&nbsp;)</b> function, which
returns a pseudorandom number between zero and a platform-dependent constant, <b>RAND_MAX</b>, defined in <b>&lt;cstdlib&gt;</b> (usually the value of the platform’s largest
unsigned integer). To put this in a desired range, use the remainder operator <b>%</b>
and the upper end of the range. These numbers are integral; to add a fractional
part, a second call to <b>rand(&nbsp;)</b> is made, and the value is inverted
after adding one (to prevent divide-by-zero errors).</p>

<p class=MsoNormal>In effect, the <b>data.bin </b>file is being used as a
container for the data in the program, even though the container exists on disk
and not in RAM. <b>write(&nbsp;)</b> sends the data out to the disk in binary
form. The first argument is the starting address of the source block—notice it
must be cast to a<b> char*</b> because that’s what <b>write(&nbsp;)</b> expects
for narrow streams. The second argument is the number of characters to write,
which in this case is the size of the <b>DataPoint</b> object (again, because
we’re using <i>narrow streams</i>). Because no pointers are contained in <b>DataPoint</b>,
there is no problem in writing the object to disk. If the object is more
sophisticated, you must implement a scheme for <i>serialization</i>, which
writes the data referred to by pointers and defines new pointers when read back
in later. (We don’t talk about serialization in this volume—most vendor class libraries
have some sort of serialization structure built into them.)</p>

<h4>Verifying and viewing the data</h4>

<p class=MsoNormal>To check the validity of the data stored in binary format,
you can read it into memory with the <b>read(&nbsp;)</b> member function for
input streams, and compare it to the text file created earlier by <b>Datagen.cpp</b>.
The following example just writes the formatted results to <b>cout</b>, but you
can redirect this to a file and then use a file comparison utility to verify
that it is identical to the original:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=IT><font color=#dd0000>//: C04:Datascan.cpp</span></font></div>
<div class=CC1><span lang=IT><font color=#dd0000>//{L} DataLogger</span></font></div>
<div class=CC1><span lang=IT>#include &lt;fstream&gt;</span></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DataLogger.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream bindata(<font color=#007f00>&quot;data.bin&quot;</font>, ios::binary);</div>
<div class=CC1>  assure(bindata, <font color=#007f00>&quot;data.bin&quot;</font>);</div>
<div class=CC1>  DataPoint d;</div>
<div class=CC1>  <font color=#ff7700>while</font>(bindata.read(<font color=#ff7700>reinterpret_cast</font>&lt;<font color=#ff7700>char</font>*&gt;(&amp;d),</div>
<div class=CC1>         <font color=#ff7700>sizeof</font> d))</div>
<div class=CC1>    cout &lt;&lt; d &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985701" name="_Toc53985701">Internationalization</a></h2>

<p class=MsoNormal>The software industry is now a healthy, worldwide economic
market, with demand for applications that can run in various languages and
cultures. As early as the late 1980s, the C Standards Committee added support
for non-U.S. formatting conventions with their <i>locale</i> mechanism. A
locale is a set of preferences for displaying certain entities such as dates
and monetary quantities. In the 1990s, the C Standards Committee approved an
addendum to Standard C that specified functions to handle <i>wide characters</i> (denoted by the type <b>wchar_t</b>), which allow support for character sets
other than ASCII and its commonly used Western European extensions. Although
the size of a wide character is not specified, some platforms implement them as
32-bit quantities, so they can hold the encodings specified by the Unicode Consortium, as well as mappings to multi-byte characters sets defined by Asian
standards bodies. C++ has integrated support for both wide characters and
locales into the iostreams library.</p>

<h3><a href="#_TocRef53985702" name="_Toc53985702">Wide Streams</a></h3>

<p class=MsoNormal>A <i>wide stream</i> is a stream class that handles wide
characters. All the examples so far (except for the last traits example in
Chapter 3) have used <i>narrow</i> streams that hold instances of <b>char</b>.
Since stream operations are essentially the same no matter the underlying
character type, they are encapsulated generically as templates. So all input
streams, for example, are connected to the <b>basic_istream</b> class template:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, <font color=#ff7700>class</font> traits =
char_traits&lt;charT&gt; &gt;</div>
<div class=CC1><font color=#ff7700>class</font> basic_istream {...};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In fact, all input stream types are specializations of this
template, according to the following type definitions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> basic_istream&lt;<font color=#ff7700>char</font>&gt; istream;</div>
<div class=CC1><font color=#ff7700>typedef</font> basic_istream&lt;<font color=#ff7700>wchar_t</font>&gt; wistream;</div>
<div class=CC1><font color=#ff7700>typedef</font> basic_ifstream&lt;<font color=#ff7700>char</font>&gt; ifstream;</div>
<div class=CC1><font color=#ff7700>typedef</font> basic_ifstream&lt;<font color=#ff7700>wchar_t</font>&gt; wifstream;</div>
<div class=CC1><font color=#ff7700>typedef</font> basic_istringstream&lt;<font color=#ff7700>char</font>&gt; istringstream;</div>
<div class=CC1><font color=#ff7700>typedef</font>
basic_istringstream&lt;<font color=#ff7700>wchar_t</font>&gt; wistringstream;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>All other stream types are defined in similar fashion.</p>

<p class=MsoNormal>In a perfect world, this is all you’d need to create streams
of different character types. But things aren’t that simple. The reason is that
the character-processing functions provided for <b>char</b> and <b>wchar_t</b>
don’t have the same names. To compare two narrow strings, for example, you use
the <b>strcmp(&nbsp;)</b> function. For wide characters, that function is named
<b>wcscmp(&nbsp;)</b>. (Remember these originated in C, which does not have function overloading, hence unique names are required.) For this reason, a generic
stream can’t just call <b>strcmp(&nbsp;)</b> in response to a comparison operator. There needs to be a way for the correct low-level functions to be called automatically.</p>

<p class=MsoNormal>The solution is to factor out the differences into a new
abstraction. The operations you can perform on characters have been abstracted
into the <b>char_traits</b> template, which has predefined specializations for <b>char</b>
and <b>wchar_t</b>, as we discussed at the end of the previous chapter. To
compare two strings, then, <b>basic_string</b> just calls <b>traits::compare(&nbsp;)</b> (remember that <b>traits</b> is the second template parameter), which in
turn calls either <b>strcmp(&nbsp;)</b> or <b>wcscmp(&nbsp;)</b>, depending on
which specialization is being used (transparent to <b>basic_string</b>).</p>

<p class=MsoNormal>You only need to be concerned about <b>char_traits</b> if
you access the low-level character processing functions; most of the time you
don’t care. Consider, however, making your inserters and extractors more robust
by defining them as templates, just in case someone wants to use them on a wide
stream.</p>

<p class=MsoNormal>To illustrate, recall again the <b>Date</b> class inserter
from the beginning of this chapter. We originally declared it as:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp;, <font color=#ff7700>const</font> Date&amp;);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This accommodates only narrow streams. To make it generic,
we simply make it a template based on <b>basic_ostream</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, <font color=#ff7700>class</font> traits&gt;</div>
<div class=CC1>std::basic_ostream&lt;charT, traits&gt;&amp;</div>
<div class=CC1><font color=#ff7700>operator</font>&lt;&lt;(std::basic_ostream&lt;charT,
traits&gt;&amp; os,</div>
<div class=CC1>           <font color=#ff7700>const</font> Date&amp; d) {</div>
<div class=CC1>  charT fillc = os.fill(os.widen('0'));</div>
<div class=CC1>  charT dash = os.widen('-');</div>
<div class=CC1>  os &lt;&lt; setw(2) &lt;&lt; d.month &lt;&lt; dash</div>
<div class=CC1>     &lt;&lt; setw(2) &lt;&lt; d.day &lt;&lt; dash</div>
<div class=CC1>     &lt;&lt; setw(4) &lt;&lt; d.year;</div>
<div class=CC1>  os.fill(fillc);</div>
<div class=CC1>  <font color=#ff7700>return</font> os;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that we also have to replace <b>char</b> with the
template parameter <b>charT</b> in the declaration of <b>fillc</b>, since it
could be either <b>char</b> or <b>wchar_t</b>, depending on the template
instantiation being used.</p>

<p class=MsoNormal>Since you don’t know when you’re writing the template which
type of stream you have, you need a way to automatically convert character
literals to the correct size for the stream. This is the job of the <b>widen(&nbsp;)</b> member function. The expression <b>widen('-')</b>, for example, converts its
argument to <b>L’-’</b> (the literal syntax equivalent to the conversion <b>wchar_t(‘-’)</b>)
if the stream is a wide stream and leaves it alone otherwise. There is also a <b>narrow(&nbsp;)</b> function that converts to a <b>char</b> if needed.</p>

<p class=MsoNormal>We can use <b>widen(&nbsp;)</b> to write a generic version
of the <b>nl</b> manipulator we presented earlier in the chapter.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, <font color=#ff7700>class</font> traits&gt;</div>
<div class=CC1>basic_ostream&lt;charT,traits&gt;&amp;</div>
<div class=CC1>nl(basic_ostream&lt;charT,traits&gt;&amp; os) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; charT(os.widen('\n'));</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef53985703" name="_Toc53985703">Locales</a></h3>

<p class=MsoNormal>Perhaps the most notable difference in typical numeric
computer output from country to country is the punctuator used to separate the
integer and fractional parts of a real number. In the United States, a period
denotes a decimal point, but in much of the world, a comma is expected instead.
It would be quite inconvenient to do all your own formatting for
locale-dependent displays. Once again, creating an abstraction that handles
these differences solves the problem.</p>

<p class=MsoNormal>That abstraction is the <i>locale</i>. All streams have an
associated locale object that they use for guidance on how to display certain
quantities for different cultural environments. A locale manages the categories
of culture-dependent display rules, which are defined as follows:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableHead>Category</p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableHead>Effect</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>collate</b></p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Allows comparing strings according to different, supported
  collating sequences.</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>ctype</b></p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Abstracts the character classification and conversion
  facilities found in &lt;cctype&gt;.</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>monetary</b></p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Supports different displays of monetary quantities.</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>numeric</b></p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Supports different display formats of real numbers,
  including radix (decimal point) and grouping (thousands) separators.</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>time</b></p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Supports various international formats for display of date
  and time.</p>
  </td>
 </tr>
 <tr>
  <td width=127 valign=top style='width:95.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>messages</b></p>
  </td>
  <td width=391 valign=top style='width:293.4pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Scaffolding to implement context-dependent message
  catalogs (such as for error messages in different languages).</p>
  </td>
 </tr>
</table>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The following program illustrates basic locale behavior:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Locale.cpp {-g++}{-bor}{-edg} {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Illustrates effects of locales.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;locale&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  locale def;</div>
<div class=CC1>  cout &lt;&lt; def.name() &lt;&lt; endl;</div>
<div class=CC1>  locale current = cout.getloc();</div>
<div class=CC1>  cout &lt;&lt; current.name() &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>float</font> val = 1234.56;</div>
<div class=CC1>  cout &lt;&lt; val &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Change to French/France</font></div>
<div class=CC1>  cout.imbue(locale(<font color=#007f00>&quot;french&quot;</font>));</div>
<div class=CC1>  current = cout.getloc();</div>
<div class=CC1>  cout &lt;&lt; current.name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; val &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Enter the literal 7890,12:
&quot;</font>;</div>
<div class=CC1>  cin.imbue(cout.getloc());</div>
<div class=CC1>  <span lang=SV>cin &gt;&gt; val;</span></div>
<div class=CC1><span lang=SV>  cout &lt;&lt; val &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span>cout.imbue(def);</div>
<div class=CC1>  cout &lt;&lt; val &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here’s the output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>C</div>
<div class=CC1>C</div>
<div class=CC1>1234.56</div>
<div class=CC1>French_France.1252</div>
<div class=CC1>1234,56</div>
<div class=CC1>Enter the literal 7890,12: <b>7890,12</b></div>
<div class=CC1>7890,12</div>
<div class=CC1>7890.12</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The default locale is the “C” locale, which is what C and
C++ programmers have been used to all these years (basically, English language
and American culture). All streams are initially “imbued” with the “C” locale.
The <b>imbue(&nbsp;)</b> member function changes the locale that a stream uses.
Notice that the full ISO name for the “French” locale is displayed (that is,
French used in France vs. French used in another country). This example shows
that this locale uses a comma for a radix point in numeric display. We have to
change <b>cin</b> to the same locale if we want to do input according to the
rules of this locale.</p>

<p class=MsoNormal>Each locale category is divided into number of <i>facets</i>, which are classes encapsulating the functionality that pertains to
that category. For example, the <b>time</b> category has the facets <b>time_put</b> and <b>time_get</b>, which contain functions for doing time and date <b>input</b>
and <b>output</b> respectively. The <b>monetary</b> category has facets <b>money_get</b>, <b>money_put</b>, and <b>moneypunct</b>. (The latter facet determines the currency symbol.) The following program illustrates the <b>moneypunct</b> facet.
(The <b>time</b> facet requires a sophisticated use of iterators which is
beyond the scope of this chapter.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Facets.cpp {-bor}{-g++}{-mwcc}{-edg}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;locale&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Change to French/France</font></div>
<div class=CC1>  locale loc(<font color=#007f00>&quot;french&quot;</font>);</div>
<div class=CC1>  cout.imbue(loc);</div>
<div class=CC1>  string currency =</div>
<div class=CC1>    use_facet&lt;moneypunct&lt;<font color=#ff7700>char</font>&gt;
&gt;(loc).curr_symbol();</div>
<div class=CC1>  <font color=#ff7700>char</font> point =</div>
<div class=CC1>    use_facet&lt;moneypunct&lt;<font color=#ff7700>char</font>&gt;
&gt;(loc).decimal_point();</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;I made &quot;</font> &lt;&lt; currency
&lt;&lt; 12.34 &lt;&lt; <font color=#007f00>&quot; today!&quot;</font></div>
<div class=CC1>       &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal style='page-break-after:avoid'>The output shows the French
currency symbol and decimal separator:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>I made Ç12,34 today!</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can also define your own facets to construct customized
locales.<a href="#_ftn49" name="_ftnref49"><span
class=MsoFootnoteReference>[49]</span></a> Be aware that
the overhead for locales is considerable. In fact, some library vendors provide
different “flavors” of the Standard C++ library to accommodate environments
that have limited space.<a href="#_ftn50" name="_ftnref50"><span
class=MsoFootnoteReference>[50]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985704" name="_Toc53985704">Summary</a></h2>

<p class=MsoNormal>This chapter has given you a fairly thorough introduction to
the iostream class library. What you’ve seen here is likely to be all you need
to create programs using iostreams. However, be aware that some additional
features in iostreams are not used often, but you can discover them by looking
at the iostream header files and by reading your compiler’s documentation on
iostreams or the references mentioned in this chapter and in the appendices.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312373901" name="_Toc312373901">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Open a file by creating an <b>ifstream</b> object. Make an <b>ostringstream</b>
object and read the entire contents into the <b>ostringstream</b> using the <b>rdbuf(&nbsp;)</b>
member function. Extract a <b>string</b> copy of the underlying buffer and
capitalize every character in the file using the Standard C <b>toupper(&nbsp;)</b>
macro defined in <b>&lt;cctype&gt;</b>. Write the result out to a new file.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a program that opens a file (the first argument on the
command line) and searches it for any one of a set of words (the remaining
arguments on the command line). Read the input a line at a time, and write out
the lines (with line numbers) that match to the new file.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that adds a copyright notice to the beginning of
all source-code files indicated by the program’s command-line arguments.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use your favorite text-searching program (<b>grep</b>, for
example) to output the names (only) of all the files that contain a particular
pattern. Redirect the output into a file. Write a program that uses the
contents of that file to generate a batch file that invokes your editor on each
of the files found by the search program.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>We know that <b>setw(&nbsp;)</b> allows for a minimum of
characters read in, but what if you wanted to read a maximum? Write an effector
that allows the user to specify a maximum number of characters to extract. Have
your effector also work for output, in such a way that output fields are
truncated, if necessary, to stay within width limits.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Demonstrate to yourself that if the fail or bad bit is set, and
you subsequently turn on stream exceptions, that the stream will immediately
throw an exception.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>String streams accommodate easy conversions, but they come with a
price. Write a program that races <b>atoi(&nbsp;)</b> against the <b>stringstream</b>
conversion system to see the effect of the overhead involved with <b>stringstream</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Make a <b>Person</b> struct with fields such as name, age,
address, etc. Make the string fields fixed-size arrays. The social security
number will be the key for each record. Implement the following <b>Database</b>
class:</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'>&nbsp;</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.95in;margin-right:0in'>
<div class=CC1><font color=#ff7700>class</font> DataBase {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// Find where a record is on disk</font></div>
<div class=CC1>  size_t query(size_t ssn);</div>
<div class=CC1>  <font color=#dd0000>// Return the person at rn (record number)</font></div>
<div class=CC1>  Person retrieve(size_t rn);</div>
<div class=CC1>  <font color=#dd0000>// Record a record on disk</font></div>
<div class=CC1>  <font color=#ff7700>void</font> add(<font color=#ff7700>const</font> Person&amp; p);</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>Write some <b>Person</b> records to disk (do not keep them all in memory).
When the user requests a record, read it off the disk and return it. The I/O operations
in the <b>DataBase</b> class use <b>read(&nbsp;)</b> and <b>write(&nbsp;)</b>
to process all <b>Person</b> records.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write an <b>operator&lt;&lt;</b> inserter for the <b>Person</b>
struct that can be used to display records in a format for easy reading. Demonstrate
it by writing data out to a file.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Suppose the database for your <b>Person</b> structs was lost but
that you have the file you wrote from the previous exercise. Recreate your
database using this file. Be sure to use error checking.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write <b>size_t(-1)</b> (the largest <b>unsigned int</b> on your
platform) to a text file 1,000,000 times. Repeat, but write to a binary file.
Compare the size of the two files, and see how much room is saved using the
binary format. (You may first want to calculate how much will be saved on your
platform.)</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>12.&nbsp;&nbsp;&nbsp;&nbsp;</span>Discover the maximum number of digits of precision your
implementation of iostreams will print by repeatedly increasing the value of
the argument to <b>precision(&nbsp;)</b> when printing a transcendental number
such as <b>sqrt(2.0)</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>13.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that reads real numbers from a file and prints
their sum, average, minimum, and maximum.</p>

<p class=ExercisesCharCharCharCharChar style='margin-top:0in;margin-right:0in;
margin-bottom:6.0pt;margin-left:.95in'><span style='font-family:Verdana'>14.&nbsp;&nbsp;&nbsp;&nbsp;</span>Determine the output of the following program before it is
executed:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.95in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C04:Exercise14.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#define d(a) cout &lt;&lt; #a &quot; ==\t&quot;
&lt;&lt; a &lt;&lt; endl;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> tellPointers(fstream&amp; s) {</div>
<div class=CC1>  d(s.tellp());</div>
<div class=CC1>  d(s.tellg());</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> tellPointers(stringstream&amp; s) {</div>
<div class=CC1>  d(s.tellp());</div>
<div class=CC1>  d(s.tellg());</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  fstream in(<font color=#007f00>&quot;Exercise14.cpp&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;Exercise14.cpp&quot;</font>);</div>
<div class=CC1>  in.seekg(10);</div>
<div class=CC1>  tellPointers(in);</div>
<div class=CC1>  in.seekp(20);</div>
<div class=CC1>  tellPointers(in);</div>
<div class=CC1>  stringstream memStream(<font color=#007f00>&quot;Here is a
sentence.&quot;</font>);</div>
<div class=CC1>  memStream.seekg(10);</div>
<div class=CC1>  tellPointers(memStream);</div>
<div class=CC1>  memStream.seekp(5);</div>
<div class=CC1>  tellPointers(memStream);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>15.&nbsp;&nbsp;&nbsp;&nbsp;</span>Suppose you are given line-oriented data in a file formatted as
follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.95in;margin-right:0in'>
<div class=CC1><span lang=IT><font color=#dd0000>//: C04:Exercise15.txt</span></font></div>
<div class=CC1><span lang=IT>Australia</span></div>
<div class=CC1><span lang=IT>5E56,7667230284,Langler,Tyson,31.2147,0.00042117361</span></div>
<div class=CC1>2B97,7586701,Oneill,Zeke,553.429,0.0074673053156065</div>
<div class=CC1>4D75,7907252710,Nickerson,Kelly,761.612,0.010276276</div>
<div class=CC1>9F2,6882945012,Hartenbach,Neil,47.9637,0.0006471644</div>
<div class=CC1>Austria</div>
<div class=CC1>480F,7187262472,Oneill,Dee,264.012,0.00356226040013</div>
<div class=CC1><span lang=IT>1B65,4754732628,Haney,Kim,7.33843,0.000099015948475</span></div>
<div class=CC1><span lang=IT>DA1,1954960784,Pascente,Lester,56.5452,0.0007629529</span></div>
<div class=CC1>3F18,1839715659,Elsea,Chelsy,801.901,0.010819887645</div>
<div class=CC1>Belgium</div>
<div class=CC1>BDF,5993489554,Oneill,Meredith,283.404,0.0038239127</div>
<div class=CC1><span lang=IT>5AC6,6612945602,Parisienne,Biff,557.74,0.0075254727</span></div>
<div class=CC1><span lang=IT>6AD,6477082,Pennington,Lizanne,31.0807,0.0004193544</span></div>
<div class=CC1><span lang=IT>4D0E,7861652688,Sisca,Francis,704.751,0.00950906238</span></div>
<div class=CC1><span lang=SV>Bahamas</span></div>
<div class=CC1><span lang=SV>37D8,6837424208,Parisienne,Samson,396.104,0.0053445</span></div>
<div class=CC1><span lang=SV>5E98,6384069,Willis,Pam,90.4257,0.00122009564059246</span></div>
<div class=CC1><span lang=SV>1462,1288616408,Stover,Hazal,583.939,0.007878970561</span></div>
<div class=CC1><span lang=SV>5FF3,8028775718,Stromstedt,Bunk,39.8712,0.000537974</span></div>
<div class=CC1><span lang=SV>1095,3737212,Stover,Denny,3.05387,0.000041205248883</span></div>
<div class=CC1>7428,2019381883,Parisienne,Shane,363.272,0.00490155</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'>The heading of each section is a region, and every line under that heading
is a seller in that region. Each comma-separated field represents the data
about each seller. The first field in a line is the SELLER_ID which
unfortunately was written out in hexadecimal format. The second is the
PHONE_NUMBER (notice that some are missing area codes). LAST_NAME and
FIRST_NAME then follow. TOTAL_SALES is the second to the last column. The last
column is the decimal amount of the total sales that the seller represents for
the company. You are to format the data on the terminal window so that an
executive can easily interpret the trends. Sample output is given below.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'><span style='font-size:8.0pt;font-family:"Courier New"'>                          Australia</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'><span style='font-size:8.0pt;font-family:"Courier New"'>             
---------------------------------</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'><span style='font-size:8.0pt;font-family:"Courier New"'>&nbsp;</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-size:8.0pt;font-family:"Courier New"'>*Last Name*  *First
Name*   *ID*    *Phone*        *Sales*   *Percent*</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-size:8.0pt;font-family:"Courier New"'>&nbsp;</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span lang=SV style='font-size:8.0pt;font-family:"Courier New"'>Langler      
Tyson          24150   766-723-0284     31.24   4.21E-02</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span lang=SV style='font-size:8.0pt;font-family:"Courier New"'>Oneill       
Zeke           11159   XXX-758-6701    553.43   7.47E-01</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span lang=SV style='font-size:8.0pt;font-family:"Courier New"'>(etc.)</span></p>

<p class=MsoNormal><span lang=SV>&nbsp;</span></p>

</div>

<span lang=SV style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section14>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985706" name="_Toc53985706">5: Templates in Depth</a></h1>

<p class=Intro style='margin-left:.25in'>The C++ template facility goes far
beyond simple “containers of <b>T</b>.” Although the original motivation was to
enable type–safe, generic containers, in modern C++, templates are also used to
generate custom code and to optimize program execution through compile–time
programming constructs.</p>

<p class=MsoNormal>In this chapter we offer a practical look at the power (and
pitfalls) of programming with templates in modern C++. For a more complete
analysis of template-related language issues and pitfalls, we recommend the
superb book by Daveed Vandevoorde and Nico Josuttis.<a href="#_ftn51" name="_ftnref51"><span
class=MsoFootnoteReference>[51]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985707" name="_Toc53985707">Template
parameters</a></h2>

<p class=MsoNormal>As illustrated in Volume 1, templates come in two flavors:
function templates and class templates. Both are wholly characterized by their
parameters. Each template parameter can represent one of the following:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;Types
(either built-in or user-defined).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;Compile-time
constant values (for example, integers, and pointers and references to static
entities; often referred to as non-type parameters).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.&nbsp;&nbsp;Other
templates.</p>

<p class=MsoNormal>The examples in Volume 1 all fall into the first category
and are the most common. The canonical example for simple container-like
templates nowadays seems to be a <b>Stack</b> class. Being a container, a <b>Stack</b>
object is not concerned with the type of object it stores; the logic of holding
objects is independent of the type of objects being held. For this reason you
can use a type parameter to represent the contained type:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Stack {</div>
<div class=CC1>  T* data;</div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; t);</div>
<div class=CC1>  <font color=#dd0000>// Etc.</font></div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The actual type to be used for a particular <b>Stack</b>
instance is determined by the argument for the parameter <b>T</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Stack&lt;<font color=#ff7700>int</font>&gt; myStack;  <font color=#dd0000>// A Stack of ints</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The compiler then provides an <b>int</b>-version of <b>Stack</b>
by substituting <b>int</b> for <b>T</b> and generating the corresponding code.
The name of the class instance generated from the template in this case is <b>Stack&lt;int&gt;</b>.</p>

<h3><a href="#_TocRef53985708" name="_Toc53985708">Non–type template parameters</a></h3>

<p class=MsoNormal>A non-type template parameter must be an integral value that
is known at compile time. You can make a fixed-size <b>Stack</b>, for instance,
by specifying a non-type parameter to be used as the dimension for the
underlying array, as follows.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>class</font> Stack {</div>
<div class=CC1>  T data[N];  <font color=#dd0000>// Fixed capacity is N</font></div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; t);</div>
<div class=CC1>  <font color=#dd0000>// Etc.</font></div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You must provide a compile-time constant value for the
parameter <b>N</b> when you request an instance of this template, such as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Stack&lt;<font color=#ff7700>int</font>, 100&gt; myFixedStack;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because the value of <b>N</b> is known at compile time, the
underlying array (<b>data</b>) can be placed on the runtime stack instead of on the free store. This can improve runtime performance by avoiding the overhead
associated with dynamic memory allocation. Following the pattern mentioned
earlier, the name of the class above is <b>Stack&lt;int, 100&gt;</b>. This
means that each distinct value of <b>N</b> results in a unique class type. For
example, <b>Stack&lt;int, 99&gt;</b> is a distinct class from <b>Stack&lt;int, 100&gt;</b>.</p>

<p class=MsoNormal>The <b>bitset</b> class template, discussed in detail in Chapter
7, is the only class in the Standard C++ library that uses a non-type template
parameter (which specifies the number of bits the <b>bitset</b> object can hold).
The following random number generator example uses a <b>bitset</b> to track
numbers so all the numbers in its range are returned in random order without
repetition before starting over. This example also overloads <b>operator(&nbsp;)</b> to produce a familiar function-call syntax.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Urand.h {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Unique randomizer.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef URAND_H</font></div>
<div class=CC1><font color=#7F7F00>#define URAND_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;bitset&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1><font color=#ff7700>using</font> std::bitset;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;size_t UpperBound&gt; <font color=#ff7700>class</font> Urand {</div>
<div class=CC1>  bitset&lt;UpperBound&gt; used;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Urand() { srand(time(0)); } <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  size_t <font color=#ff7700>operator</font>()(); <font color=#dd0000>// The &quot;generator&quot;
function</font></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;size_t UpperBound&gt;</div>
<div class=CC1><font color=#ff7700>inline</font> size_t Urand&lt;UpperBound&gt;::<font color=#ff7700>operator</font>()() {</div>
<div class=CC1>  <font color=#ff7700>if</font>(used.count() == UpperBound)</div>
<div class=CC1>    used.reset();  <font color=#dd0000>// Start over (clear bitset)</font></div>
<div class=CC1>  size_t newval;</div>
<div class=CC1>  <font color=#ff7700>while</font>(used[newval = rand() % UpperBound])</div>
<div class=CC1>    ; <font color=#dd0000>// Until unique value is found</font></div>
<div class=CC1>  used[newval] = <font color=#ff7700>true</font>;</div>
<div class=CC1>  <font color=#ff7700>return</font> newval;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// URAND_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The numbers generated by <b>Urand</b> are unique because the
<b>bitset</b> <b>used</b> tracks all the possible numbers in the random space
(the upper bound is set with the template argument) and records each used number
by setting the corresponding position bit. When the numbers are all used up, the
<b>bitset</b> is cleared to start over. Here’s a simple driver that illustrates
how to use a <b>Urand</b> object:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:UrandTest.cpp {-bor}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Urand.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Urand&lt;10&gt; u;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 20; ++i)</div>
<div class=CC1>    cout &lt;&lt; u() &lt;&lt; ' ';</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As we explain later in this chapter, non-type template
arguments are also important in the optimization of numeric computations.</p>

<h3><a href="#_TocRef53985709" name="_Toc53985709">Default template arguments</a></h3>

<p class=MsoNormal>You can provide default arguments for template parameters in
class templates, but not function templates. As with default function
arguments, they should only be defined once, the first time a template
declaration or definition is seen by the compiler. Once you introduce a default
argument, all the subsequent template parameters must also have defaults. To
make the fixed-size <b>Stack</b> template shown earlier a little friendlier,
for example, you can add a default argument like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N = 100&gt; <font color=#ff7700>class</font> Stack {</div>
<div class=CC1>  T data[N];  <font color=#dd0000>// Fixed capacity is N</font></div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; t);</div>
<div class=CC1>  <font color=#dd0000>// Etc.</font></div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now, if you omit the second template argument when declaring
a <b>Stack</b> object, the value for <b>N</b> will default to 100.</p>

<p class=MsoNormal>You can choose to provide defaults for all arguments, but
you must use an empty set of brackets when declaring an instance so that the
compiler knows that a class template is involved:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T = <font color=#ff7700>int</font>, size_t N = 100&gt;  <font color=#dd0000>// Both
defaulted</font></div>
<div class=CC1><font color=#ff7700>class</font> Stack {</div>
<div class=CC1>  T data[N];  <font color=#dd0000>// Fixed capacity is N</font></div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; t);</div>
<div class=CC1>  <font color=#dd0000>// Etc.</font></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Stack&lt;&gt; myStack;  <font color=#dd0000>// Same as Stack&lt;int, 100&gt;</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Default arguments are used heavily in the Standard C++
library. The <b>vector</b> class template, for instance, is declared as
follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> Allocator =
allocator&lt;T&gt; &gt;</div>
<div class=CC1><font color=#ff7700>class</font> vector;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note the space between the last two right angle bracket
characters. This prevents the compiler from interpreting those two characters (<b>&gt;&gt;</b>)
as the right-shift operator.</p>

<p class=MsoNormal>This declaration reveals that <b>vector</b> takes two
arguments: the type of the contained objects it holds, and a type that
represents the allocator used by the <b>vector</b>. Whenever you omit the
second argument, the standard <b>allocator</b> template is used, parameterized
by the first template parameter. This declaration also shows that you can use
template parameters in subsequent template parameters, as <b>T</b> is used
here.</p>

<p class=MsoNormal>Although you cannot use default template arguments in
function templates, you can use template parameters as default arguments to
normal functions. The following function template adds the elements in a
sequence:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:FuncDef.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; T sum(T* b, T* e, T init = T())
{</div>
<div class=CC1>  <font color=#ff7700>while</font>(b != e)</div>
<div class=CC1>    init += *b++;</div>
<div class=CC1>  <font color=#ff7700>return</font> init;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 1, 2, 3 };</div>
<div class=CC1>  cout &lt;&lt; sum(a, a + <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0])
&lt;&lt; endl; <font color=#dd0000>// 6</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The third argument to <b>sum(&nbsp;)</b> is the initial
value for the accumulation of the elements. Since we omitted it, this argument
defaults to <b>T(&nbsp;)</b>, which in the case of <b>int</b> and other
built-in types invokes a pseudo-constructor that performs zero-initialization.</p>

<h3><a href="#_TocRef53985710" name="_Toc53985710">Template template parameters</a></h3>

<p class=MsoNormal>The third type of parameter a template can accept is another
class template. If you are going to use a template type parameter itself as a
template in your code, the compiler needs to know that the parameter is a
template in the first place. The following example illustrates a template
template parameter:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:TempTemp.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates a template template parameter.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Array { <font color=#dd0000>// A simple, expandable sequence</font></div>
<div class=CC1>  <font color=#ff7700>enum</font> { INIT = 10 };</div>
<div class=CC1>  T* data;</div>
<div class=CC1>  size_t capacity;</div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Array() {</div>
<div class=CC1>    count = 0;</div>
<div class=CC1>    data = <font color=#ff7700>new</font> T[capacity = INIT];</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Array() { <font color=#ff7700>delete</font> [] data; }</div>
<div class=CC1>  <font color=#ff7700>void</font> push_back(<font color=#ff7700>const</font> T&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count == capacity) {</div>
<div class=CC1>      <font color=#dd0000>// Grow underlying array</font></div>
<div class=CC1>      size_t newCap = 2 * capacity;</div>
<div class=CC1>      T* newData = <font color=#ff7700>new</font> T[newCap];</div>
<div class=CC1>      <font color=#ff7700>for</font>(size_t i = 0; i &lt; count; ++i)</div>
<div class=CC1>        <span lang=IT>newData[i] = data[i];</span></div>
<div class=CC1><span lang=IT>      <font color=#ff7700>delete</font> [] data;</span></div>
<div class=CC1><span lang=IT>      </span>data = newData;</div>
<div class=CC1>      capacity = newCap;</div>
<div class=CC1>    }</div>
<div class=CC1>    data[count++] = t;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop_back() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count &gt; 0)</div>
<div class=CC1>      --count;</div>
<div class=CC1>  }</div>
<div class=CC1>  T* begin() { <font color=#ff7700>return</font> data; }</div>
<div class=CC1>  T* end() { <font color=#ff7700>return</font> data + count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T,
<font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>&gt; <font color=#ff7700>class</font> Seq&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Container {</div>
<div class=CC1>  Seq&lt;T&gt; seq;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> append(<font color=#ff7700>const</font> T&amp; t) { seq.push_back(t); }</div>
<div class=CC1>  T* begin() { <font color=#ff7700>return</font> seq.begin(); }</div>
<div class=CC1>  T* end() { <font color=#ff7700>return</font> seq.end(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Container&lt;<font color=#ff7700>int</font>, Array&gt; container;</div>
<div class=CC1>  container.append(1);</div>
<div class=CC1>  container.append(2);</div>
<div class=CC1>  <font color=#ff7700>int</font>* p = container.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(p != container.end())</div>
<div class=CC1>    cout &lt;&lt; *p++ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Array</b> class template is a trivial sequence
container. The <b>Container</b> template takes two parameters: the type that it
holds, and a sequence data structure to do the holding. The following line in
the implementation of the <b>Container</b> class requires that we inform the
compiler that <b>Seq</b> is a template:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  Seq&lt;T&gt; seq;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If we hadn’t declared <b>Seq</b> to be a template template
parameter, the compiler would complain here that <b>Seq</b> is not a template,
since we’re using it as such. In <b>main(&nbsp;)</b> a <b>Container</b> is
instantiated to use an <b>Array</b> to hold integers, so <b>Seq</b> stands for <b>Array</b>
in this example.</p>

<p class=MsoNormal>Note that it is not necessary in this case to name the
parameter for <b>Seq</b> inside <b>Container</b>’s declaration. The line in
question is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>&gt; <font color=#ff7700>class</font> Seq&gt;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Although we could have written</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> U&gt; <font color=#ff7700>class</font> Seq&gt;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>the parameter <b>U</b> is not needed anywhere. All that
matters is that <b>Seq</b> is a class template that takes a single type
parameter. This is analogous to omitting the names of function parameters when
they’re not needed, such as when you overload the post-increment operator:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>T <font color=#ff7700>operator</font>++(<font color=#ff7700>int</font>);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>int</b> here is merely a placeholder and so needs no
name.</p>

<p class=MsoNormal>The following program uses a fixed-size array, which has an
extra template parameter representing the array length:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=IT><font color=#dd0000>//: C05:TempTemp2.cpp</span></font></div>
<div class=CC1><span lang=IT><font color=#dd0000>// A multi-variate template template
parameter.</span></font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>class</font> Array {</div>
<div class=CC1>  T data[N];</div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Array() { count = 0; }</div>
<div class=CC1>  <font color=#ff7700>void</font> push_back(<font color=#ff7700>const</font> T&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count &lt; N)</div>
<div class=CC1>      data[count++] = t;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop_back() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count &gt; 0)</div>
<div class=CC1>      --count;</div>
<div class=CC1>  }</div>
<div class=CC1>  T* begin() { <font color=#ff7700>return</font> data; }</div>
<div class=CC1>  T* end() { <font color=#ff7700>return</font> data + count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T,size_t
N,template&lt;<font color=#ff7700>class</font>,size_t&gt; <font color=#ff7700>class</font> Seq&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Container {</div>
<div class=CC1>  Seq&lt;T,N&gt; seq;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> append(<font color=#ff7700>const</font> T&amp; t) { seq.push_back(t); }</div>
<div class=CC1>  T* begin() { <font color=#ff7700>return</font> seq.begin(); }</div>
<div class=CC1>  T* end() { <font color=#ff7700>return</font> seq.end(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t N = 10;</div>
<div class=CC1>  Container&lt;<font color=#ff7700>int</font>, N, Array&gt; container;</div>
<div class=CC1>  container.append(1);</div>
<div class=CC1>  container.append(2);</div>
<div class=CC1>  <font color=#ff7700>int</font>* p = container.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(p != container.end())</div>
<div class=CC1>    cout &lt;&lt; *p++ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Once again, parameter names are not needed in the
declaration of <b>Seq</b> inside <b>Container</b>’s declaration, but we need
two parameters to declare the data member <b>seq</b>, hence the appearance of
the non-type parameter <b>N</b> at the top level.</p>

<p class=MsoNormal>Combining default arguments with template template parameters
is slightly more problematic. When the compiler looks at the inner parameters
of a template template parameter, default arguments are not considered, so you
have to repeat the defaults in order to get an exact match. The following
example uses a default argument for the fixed-size <b>Array</b> template and
shows how to accommodate this quirk in the language:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:TempTemp3.cpp {-bor}{-msc}</font></div>
<div class=CC1><font color=#dd0000>// Template template parameters and default arguments.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N = 10&gt;  <font color=#dd0000>// A default
argument</font></div>
<div class=CC1><font color=#ff7700>class</font> Array {</div>
<div class=CC1>  T data[N];</div>
<div class=CC1>  size_t count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Array() { count = 0; }</div>
<div class=CC1>  <font color=#ff7700>void</font> push_back(<font color=#ff7700>const</font> T&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count &lt; N)</div>
<div class=CC1>      data[count++] = t;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop_back() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count &gt; 0)</div>
<div class=CC1>      --count;</div>
<div class=CC1>  }</div>
<div class=CC1>  T* begin() { <font color=#ff7700>return</font> data; }</div>
<div class=CC1>  T* end() { <font color=#ff7700>return</font> data + count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>, size_t = 10&gt;
<font color=#ff7700>class</font> Seq&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Container {</div>
<div class=CC1>  Seq&lt;T&gt; seq;  <font color=#dd0000>// Default used</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> append(<font color=#ff7700>const</font> T&amp; t) { seq.push_back(t); }</div>
<div class=CC1>  T* begin() { <font color=#ff7700>return</font> seq.begin(); }</div>
<div class=CC1>  T* end() { <font color=#ff7700>return</font> seq.end(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Container&lt;<font color=#ff7700>int</font>, Array&gt; container;</div>
<div class=CC1>  container.append(1);</div>
<div class=CC1>  container.append(2);</div>
<div class=CC1>  <font color=#ff7700>int</font>* p = container.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(p != container.end())</div>
<div class=CC1>    cout &lt;&lt; *p++ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The default dimension of 10 is required in the line:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>, size_t = 10&gt; <font color=#ff7700>class</font> Seq&gt;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Both the definition of <b>seq</b> in <b>Container</b> and <b>container</b>
in <b>main(&nbsp;)</b> use the default. The only way to use something other
than the default value was shown in <b>TempTemp2.cpp</b>. This is the only
exception to the rule stated earlier that default arguments should appear only
once in a compilation unit.</p>

<p class=MsoNormal>Since the standard sequence containers (<b>vector</b>, <b>list</b>,
and <b>deque</b>, discussed in depth in Chapter 7) have a default allocator
argument, the technique shown above is helpful should you ever want to pass one
of these sequences as a template parameter. The following program passes a <b>vector</b>
and then a <b>list</b> to two instances of <b>Container</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:TempTemp4.cpp {-bor}{-msc}</font></div>
<div class=CC1><font color=#dd0000>// Passes standard sequences as template arguments.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;memory&gt;  </font><font color=#dd0000>// Declares allocator&lt;T&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T,
<font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> U, <font color=#ff7700>class</font> = allocator&lt;U&gt; &gt;</div>
<div class=CC1>         <font color=#ff7700>class</font> Seq&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Container {</div>
<div class=CC1>  Seq&lt;T&gt; seq; <font color=#dd0000>// Default of allocator&lt;T&gt;
applied implicitly</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> push_back(<font color=#ff7700>const</font> T&amp; t) { seq.push_back(t); }</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq&lt;T&gt;::iterator begin() { <font color=#ff7700>return</font>
seq.begin(); }</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq&lt;T&gt;::iterator end() { <font color=#ff7700>return</font>
seq.end(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Use a vector</font></div>
<div class=CC1>  Container&lt;<font color=#ff7700>int</font>, vector&gt; vContainer;</div>
<div class=CC1>  vContainer.push_back(1);</div>
<div class=CC1>  vContainer.push_back(2);</div>
<div class=CC1>  <font color=#ff7700>for</font>(vector&lt;<font color=#ff7700>int</font>&gt;::iterator p = vContainer.begin();</div>
<div class=CC1>      p != vContainer.end();
++p) {</div>
<div class=CC1>    cout &lt;&lt; *p &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Use a list</font></div>
<div class=CC1>  Container&lt;<font color=#ff7700>int</font>, list&gt; lContainer;</div>
<div class=CC1>  lContainer.push_back(3);</div>
<div class=CC1>  lContainer.push_back(4);</div>
<div class=CC1>  <font color=#ff7700>for</font>(list&lt;<font color=#ff7700>int</font>&gt;::iterator p2 = lContainer.begin();</div>
<div class=CC1>      p2 != lContainer.end(); ++p2) {</div>
<div class=CC1>    cout &lt;&lt; *p2 &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here we name the first parameter of the inner template <b>Seq</b>
(with the name <b>U</b>) because the allocators in the standard sequences must
themselves be parameterized with the same type as the contained objects in the
sequence. Also, since the default <b>allocator</b> parameter is known, we can
omit it in the subsequent references to <b>Seq&lt;T&gt;</b>, as we did in the
previous program. To fully explain this example, however, we have to discuss
the semantics of the <b>typename</b> keyword.</p>

<h3><a href="#_TocRef53985711" name="_Toc53985711">The typename keyword</a></h3>

<p class=MsoNormal>Consider the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:TypenamedID.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Uses 'typename' as a prefix for nested types.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> X {</div>
<div class=CC1>  <font color=#dd0000>// Without typename, you should get an error:</font></div>
<div class=CC1>  <font color=#ff7700>typename</font> T::id i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { i.g(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Y {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>class</font> id {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    <font color=#ff7700>void</font> g() {}</div>
<div class=CC1>  };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  X&lt;Y&gt; xy;</div>
<div class=CC1>  xy.f();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The template definition assumes that the class <b>T</b> that
you hand it must have a nested identifier of some kind called <b>id</b>. Yet <b>id</b>
could also be a static data member of <b>T</b>, in which case you can perform
operations on <b>id </b>directly, but you can’t “create an object” of “the type
<b>id</b>.” In this example, the identifier <b>id </b>is being treated as if it
were a nested type inside <b>T</b>. In the case of class <b>Y</b>, <b>id</b> is
in fact a nested type, but (without the <b>typename </b>keyword) the compiler
can’t know that when it’s compiling <b>X</b>.</p>

<p class=MsoNormal>If the compiler has the option of treating an identifier as
a type or as something other than a type when it sees an identifier in a
template, it will assume that the identifier refers to something other than a
type. That is, it will assume that the identifier refers to an object
(including variables of primitive types), an enumeration, or something similar.
However, it will not—cannot—just assume that it is a type.</p>

<p class=MsoNormal>Because the default behavior of the compiler is to assume that
a name that fits the above two points is not a type, you must use <b>typename</b>
for nested names (except in constructor initializer lists, where it is neither
needed nor allowed). In the above example, when the compiler sees <b>typename</b>
<b>T::id</b>, it knows (because of the <b>typename</b> keyword) that <b>id</b>
refers to a nested type and thus it can create an object of that type.</p>

<p class=MsoNormal>The short version of the rule is: if a type referred to
inside template code is qualified by a template type parameter, you must use
the <b>typename</b> keyword as a prefix, unless it appears in a base class
specification or initializer list in the same scope (in which case you must
not).</p>

<p class=MsoNormal>The above explains the use of the <b>typename</b> keyword in
the program <b>TempTemp4.cpp</b>. Without it, the compiler would assume that
the expression <b>Seq&lt;T&gt;::iterator</b> is not a type, but we were using
it to define the return type of the <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
member functions.</p>

<p class=MsoNormal>The following example, which defines a function template
that can print any Standard C++ sequence, shows a similar use of <b>typename</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:PrintSeq.cpp {-msc}{-mwcc}</font></div>
<div class=CC1><font color=#dd0000>// A print function for Standard C++ sequences.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;memory&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> U, <font color=#ff7700>class</font> =
allocator&lt;U&gt; &gt;</div>
<div class=CC1>         <font color=#ff7700>class</font> Seq&gt;</div>
<div class=CC1><font color=#ff7700>void</font> printSeq(Seq&lt;T&gt;&amp; seq) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>typename</font> Seq&lt;T&gt;::iterator b = seq.begin();</div>
<div class=CC1>       b != seq.end();)</div>
<div class=CC1>    cout &lt;&lt; *b++ &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Process a vector</font></div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v;</div>
<div class=CC1>  v.push_back(1);</div>
<div class=CC1>  v.push_back(2);</div>
<div class=CC1>  printSeq(v);</div>
<div class=CC1>  <font color=#dd0000>// Process a list</font></div>
<div class=CC1>  list&lt;<font color=#ff7700>int</font>&gt; lst;</div>
<div class=CC1>  lst.push_back(3);</div>
<div class=CC1>  lst.push_back(4);</div>
<div class=CC1>  printSeq(lst);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Once again, without the <b>typename</b> keyword the compiler
will interpret <b>iterator</b> as a static data member of <b>Seq&lt;T&gt;</b>,
which is a syntax error, since a type is required.</p>

<h4>Typedefing a typename</h4>

<p class=MsoNormal>It’s important not to assume that the <b>typename</b>
keyword creates a new type name. It doesn’t. Its purpose is to inform the
compiler that the qualified identifier is to be interpreted as a type. A line that
reads:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typename</font> Seq&lt;T&gt;::iterator It;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>causes a variable named <b>It</b> to be declared of type <b>Seq&lt;T&gt;::iterator</b>.
If you mean to create a new type name, you should use <b>typedef</b>, as usual,
as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> <font color=#ff7700>typename</font> Seq&lt;It&gt;::iterator It;</div>

</div>

<div class=CC1>&nbsp;</div>

<h4>Using typename instead of class</h4>

<p class=MsoNormal>Another role of the <b>typename</b> keyword is to provide
you the option of using <b>typename</b> instead of <b>class</b> in the template
argument list of a template definition:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:UsingTypename.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using 'typename' in the template argument list.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>class</font> X {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  X&lt;<font color=#ff7700>int</font>&gt; x;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To some, this produces clearer code.</p>

<h3><a href="#_TocRef53985712" name="_Toc53985712">Using the template keyword as a
hint</a></h3>

<p class=MsoNormal>Just as the <b>typename</b> keyword helps the compiler when
a type identifier is not expected, there is also a potential difficulty with
tokens that are not identifiers, such as the <b>&lt;</b> and <b>&gt;</b>
characters. Sometimes these represent the less-than or greater-than symbols,
and sometimes they delimit template parameter lists. As an example, we’ll once
more use the <b>bitset</b> class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:DotTemplate.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrate the .template construct.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;bitset&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, size_t N&gt;</div>
<div class=CC1>basic_string&lt;charT&gt; bitsetToString(<font color=#ff7700>const</font>
bitset&lt;N&gt;&amp; bs) {</div>
<div class=CC1>  <font color=#ff7700>return</font> bs. <font color=#ff7700>template</font> to_string&lt;charT,
char_traits&lt;charT&gt;,</div>
<div class=CC1>                                allocator&lt;charT&gt;
&gt;();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  bitset&lt;10&gt; bs;</div>
<div class=CC1>  bs.set(1);</div>
<div class=CC1>  bs.set(5);</div>
<div class=CC1>  cout &lt;&lt; bs &lt;&lt; endl; <font color=#dd0000>// 0000100010</font></div>
<div class=CC1>  string s = bitsetToString&lt;<font color=#ff7700>char</font>&gt;(bs);</div>
<div class=CC1>  cout &lt;&lt; s &lt;&lt; endl;  <font color=#dd0000>// 0000100010</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>bitset</b> class supports conversion to string object
via its <b>to_string</b> member function. To support multiple string classes, <b>to_string</b>
is itself a template, following the pattern established by the <b>basic_string</b>
template discussed in Chapter 3. The declaration of <b>to_string</b> inside of <b>bitset</b> looks like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT, <font color=#ff7700>class</font> traits, <font color=#ff7700>class</font>
Allocator&gt;</div>
<div class=CC1>basic_string&lt;charT, traits, Allocator&gt; to_string() <font color=#ff7700>const</font>;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Our <b>bitsetToString(&nbsp;)</b> function template above
requests different types of string representations of a <b>bitset</b>. To get a
wide string, for instance, you change the call to the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  wstring s = bitsetToString&lt;<font color=#ff7700>wchar_t</font>&gt;(bs);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that <b>basic_string</b> uses default template arguments, so we don’t need to repeat the <b>char_traits</b> and <b>allocator</b> arguments in the return value. Unfortunately, <b>bitset::to_string</b> does not use default
arguments. Using <b>bitsetToString&lt;char&gt;(&nbsp;bs)</b> is more convenient
than typing a fully-qualified call to <b>bs.template to_string&lt;char,
char_traits, allocator&lt;char&gt; &gt;(&nbsp;)</b> every time.</p>

<p class=MsoNormal>The return statement in <b>bitsetToString(&nbsp;)</b>
contains the <b>template</b> keyword in an odd place—right after the dot
operator applied to the <b>bitset</b> object <b>bs</b>. This is because when
the template is parsed, the <b>&lt;</b> character after the <b>to_string</b>
token would be interpreted as a less-than operation instead of the beginning of
a template argument list. The <b>template</b> keyword used in this context tells
the compiler that what follows is the name of a template, causing the <b>&lt;</b>
character to be interpreted correctly. The same reasoning applies to the <b>-&gt;</b>
and <b>::</b>operators when applied to templates. As with the <b>typename</b>
keyword, this template disambiguation technique can only be used within
template code.<a href="#_ftn52" name="_ftnref52"><span
class=MsoFootnoteReference>[52]</span></a></p>

<h3><a href="#_TocRef53985713" name="_Toc53985713">Member Templates</a></h3>

<p class=MsoNormal>The <b>bitset::to_string(&nbsp;)</b> function template is an
example of a <i>member template</i>: a template declared within another class
or class template. This allows many combinations of independent template
arguments to be combined. A useful example is found in the <b>complex</b> class
template in the Standard C++ library. The <b>complex</b> template has a type
parameter meant to represent an underlying floating-point type to hold the real
and imaginary parts of a complex number. The following code snippet from the
standard library shows a member-template constructor in the <b>complex</b>
class template:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>class</font>
complex {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> X&gt; complex(<font color=#ff7700>const</font> complex&lt;X&gt;&amp;);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The standard <b>complex</b> template comes ready-made with
specializations that use <b>float</b>, <b>double</b>, and <b>long double</b>
for the parameter <b>T</b>. The member-template constructor above creates a new
complex number that uses a different floating-point type as its base type, as
seen in the code below:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  complex&lt;<font color=#ff7700>float</font>&gt; z(1, 2);</div>
<div class=CC1>  complex&lt;<font color=#ff7700>double</font>&gt; w(z);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In the declaration of <b>w</b>, the <b>complex</b> template
parameter <b>T</b> is <b>double</b> and <b>X</b> is <b>float</b>. Member
templates make this kind of flexible conversion easy.</p>

<p class=MsoNormal>Defining a template within a template is a nesting
operation, so the prefixes that introduce the templates must reflect this
nesting if you define the member template outside the outer class definition.
For example, if you implement the <b>complex</b> class template, and if you
define the member-template constructor outside the <b>complex</b> template
class definition, you do it like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> X&gt;</div>
<div class=CC1>complex&lt;T&gt;::complex(<font color=#ff7700>const</font>
complex&lt;X&gt;&amp; c) {<font color=#7F7F7F>/* Body here… */</font>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Another use of member function templates in the standard
library is in the initialization of containers. Suppose we have a <b>vector</b>
of <b>int</b>s and we want to initialize a new <b>vector</b> of <b>doubles</b>
with it, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <font color=#ff7700>int</font> data[5] = { 1, 2, 3, 4, 5 };</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v1(data, data+5);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>double</font>&gt; v2(v1.begin(), v1.end());</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As long as the elements in <b>v1</b> are
assignment-compatible with the elements in <b>v2</b> (as <b>double</b> and <b>int</b>
are here), all is well. The <b>vector</b> class template has the following
member template constructor:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> InputIterator&gt;</div>
<div class=CC1>vector(InputIterator first, InputIterator last,</div>
<div class=CC1>       <font color=#ff7700>const</font> Allocator&amp; = Allocator());</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This constructor is used twice in the <b>vector</b>
declarations above. When <b>v1</b> is initialized from the array of <b>int</b>s,
the type <b>InputIterator</b> is <b>int*</b>. When <b>v2</b> is initialized
from <b>v1</b>, an instance of the member template constructor is used with <b>InputIterator</b>
representing <b>vector&lt;int&gt;::iterator</b>.</p>

<p class=MsoNormal>Member templates can also be classes. (They don’t need to be
functions.) The following example shows a member class template inside an outer
class template:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MemberClass.cpp</font></div>
<div class=CC1><font color=#dd0000>// A member class template.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Outer {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> R&gt; <font color=#ff7700>class</font> Inner {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    <font color=#ff7700>void</font> f();</div>
<div class=CC1>  };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> R&gt;</div>
<div class=CC1><font color=#ff7700>void</font> Outer&lt;T&gt;::Inner&lt;R&gt;::f() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Outer == &quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(T).name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Inner == &quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(R).name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Full Inner == &quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(*<font color=#ff7700>this</font>).name() &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Outer&lt;<font color=#ff7700>int</font>&gt;::Inner&lt;<font color=#ff7700>bool</font>&gt; inner;</div>
<div class=CC1>  inner.f();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>typeid</b> operator, covered in Chapter 8, takes a
single argument and returns a <b>type_info</b> object whose <b>name(&nbsp;)</b>
function yields a string representing the argument type. For example, <b>typeid(int).name(&nbsp;)</b>
might return the string “<b>int</b>.” (The actual string is
platform-dependent.) The <b>typeid</b> operator can also take an expression and
return a <b>type_info</b> object representing the type of that expression. For
example, with <b>int i</b>, <b>typeid(i).name(&nbsp;)</b> returns something
like “<b>int</b>,” and <b>typeid(&amp;i).name(&nbsp;)</b> returns something
like “<b>int&nbsp;*</b>.”</p>

<p class=MsoNormal>The output of the program above should be something like
this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Outer == <font color=#ff7700>int</font></div>
<div class=CC1>Inner == <font color=#ff7700>bool</font></div>
<div class=CC1>Full Inner == Outer&lt;<font color=#ff7700>int</font>&gt;::Inner&lt;<font color=#ff7700>bool</font>&gt;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The declaration of the variable <b>inner</b> in the main
program instantiates both <b>Inner&lt;bool&gt;</b> and <b>Outer&lt;int&gt;</b>.</p>

<p class=MsoNormal>Member template functions cannot be declared <b>virtual</b>. Current compiler technology expects to be able to determine the size of a
class’s virtual function table when the class is parsed. Allowing virtual
member template functions would require knowing all calls to such member
functions everywhere in the program ahead of time. This is not feasible,
especially for multi-file projects.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985714" name="_Toc53985714">Function
template</a> issues</h2>

<p class=MsoNormal>Just as a class template describes a family of classes, a
function template describes a family of functions. The syntax for creating
either type of template is virtually identical, but they differ somewhat in how
they are used. You must always use angle brackets when instantiating class
templates and you must supply all non-default template arguments. However, with
function templates you can often omit the template arguments, and default
template arguments are not even allowed.<sup> </sup>Consider a typical
implementation of the <b>min(&nbsp;)</b> function template declared in the <b>&lt;algorithm&gt;</b>
header, which looks something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font>
T&amp; a, <font color=#ff7700>const</font> T&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You could invoke this template by providing the type of the
arguments in angle brackets, just like you do with class templates, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=SV><font color=#ff7700>int</font> z = min&lt;<font color=#ff7700>int</font>&gt;(i, j);</span></div>

</div>

<div class=CC1><span lang=SV>&nbsp;</span></div>

<p class=MsoNormal>This syntax tells the compiler that a specialization of the <b>min(&nbsp;)</b>
template is needed with <b>int</b> used in place of the parameter <b>T</b>,
whereupon the compiler generates the corresponding code. Following the pattern
of naming the classes generated from class templates, you can think of the name
of the instantiated function as <b>min&lt;int&gt;(&nbsp;)</b>.</p>

<h3><a href="#_TocRef53985715" name="_Toc53985715">Type deduction of function template arguments</a></h3>

<p class=MsoNormal>You can always use such explicit function template specification as in the example above, but it is often convenient to leave off the template
arguments and let the compiler deduce them from the function arguments, like
this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> z = min(i, j);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If both <b>i</b> and <b>j</b> are <b>int</b>s, the compiler
knows that you need <b>min&lt;int&gt;(&nbsp;)</b>, which it then instantiates
automatically. The types must be identical because the template was originally
specified with only one template type argument used for both function
parameters. No standard conversions are applied for function arguments whose
type is specified by a template parameter. For example, if you wanted to find
the minimum of an <b>int</b> and a <b>double</b>, the following attempt at a
call to <b>min(&nbsp;)</b> would fail:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> z = min(x, j); <font color=#dd0000>// x is a double</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since <b>x</b> and <b>j</b> are distinct types, no single
parameter matches the template parameter <b>T</b> in the definition of <b>min(&nbsp;)</b>,
so the call does not match the template declaration. You can work around this
difficulty by casting one argument to the other’s type or by reverting to the
fully-specified call syntax, as in:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> z = min&lt;<font color=#ff7700>double</font>&gt;(x, j);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This tells the compiler to generate the <b>double</b>
version of <b>min(&nbsp;)</b>, after which <b>j</b> can be promoted to a <b>double</b>
by normal standard conversion rules (because the function <b>min&lt;double&gt;(const
double&amp;, const double&amp;)</b> would then exist).</p>

<p class=MsoNormal>You might be tempted to require two parameters for <b>min(&nbsp;)</b>,
allowing the types of the arguments to be independent, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T, <font color=#ff7700>typename</font>
U&gt;</div>
<div class=CC1><font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font> T&amp; a,
<font color=#ff7700>const</font> U&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This is often a good strategy, but here it is problematic
because <b>min(&nbsp;)</b> must return a value, and there is no satisfactory
way to determine which type it should be (<b>T</b> or <b>U</b>?).</p>

<p class=MsoNormal>If the return type of a function template is an independent
template parameter, you must always specify its type explicitly when you call
it, since there is no argument from which to deduce it. Such is the case with
the <b>fromString</b> template below.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:StringConv.h</a></font></div>
<div class=CC1><font color=#dd0000>// Function templates to convert to and from strings.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef STRINGCONV_H</font></div>
<div class=CC1><font color=#7F7F00>#define STRINGCONV_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; T fromString(<font color=#ff7700>const</font>
std::string&amp; s) {</div>
<div class=CC1>  std::istringstream is(s);</div>
<div class=CC1>  T t;</div>
<div class=CC1>  is &gt;&gt; t;</div>
<div class=CC1>  <font color=#ff7700>return</font> t;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; std::string toString(<font color=#ff7700>const</font>
T&amp; t) {</div>
<div class=CC1>  std::ostringstream s;</div>
<div class=CC1>  s &lt;&lt; t;</div>
<div class=CC1>  <font color=#ff7700>return</font> s.str();</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// STRINGCONV_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>These function templates provide conversions to and from <b>std::string</b>
for any types that provide a stream inserter or extractor, respectively. Here’s
a test program that includes the use of the standard library <b>complex</b>
number type:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:StringConvTest.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;complex&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;StringConv.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>int</font> i = 1234;</span></div>
<div class=CC1><span lang=SV>  cout &lt;&lt; <font color=#007f00>&quot;i == \&quot;&quot;</font>
&lt;&lt; toString(i) &lt;&lt; <font color=#007f00>&quot;\&quot;&quot;</font> &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>float</font> x = 567.89;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;x == \&quot;&quot;</font> &lt;&lt;
toString(x) &lt;&lt; <font color=#007f00>&quot;\&quot;&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  complex&lt;<font color=#ff7700>float</font>&gt; c(1.0, 2.0);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c == \&quot;&quot;</font> &lt;&lt;
toString(c) &lt;&lt; <font color=#007f00>&quot;\&quot;&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <span lang=SV>cout &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>&nbsp;</span></div>
<div class=CC1><span lang=SV>  i =
fromString&lt;<font color=#ff7700>int</font>&gt;(string(<font color=#007f00>&quot;1234&quot;</font>));</span></div>
<div class=CC1><span lang=SV>  </span>cout &lt;&lt; <font color=#007f00>&quot;i == &quot;</font>
&lt;&lt; i &lt;&lt; endl;</div>
<div class=CC1>  x = fromString&lt;<font color=#ff7700>float</font>&gt;(string(<font color=#007f00>&quot;567.89&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;x == &quot;</font> &lt;&lt; x &lt;&lt;
endl;</div>
<div class=CC1>  c = fromString&lt;complex&lt;<font color=#ff7700>float</font>&gt;
&gt;(string(<font color=#007f00>&quot;(1.0,2.0)&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c == &quot;</font> &lt;&lt; c &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The output is what you’d expect:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>i == <font color=#007f00>&quot;1234&quot;</font></div>
<div class=CC1>x == <font color=#007f00>&quot;567.89&quot;</font></div>
<div class=CC1>c == <font color=#007f00>&quot;(1,2)&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1>i == 1234</div>
<div class=CC1>x == 567.89</div>
<div class=CC1>c == (1,2)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that in each of the instantiations of <b>fromString(&nbsp;)</b>,
the template parameter is specified in the call. If you have a function
template with template parameters for the parameter types as well as the return
types, it is important to declare the return type parameter first, otherwise
you won’t be able to omit the type parameters for the function parameters. As
an illustration, consider the following well-known function template:<a href="#_ftn53" name="_ftnref53"><span
class=MsoFootnoteReference>[53]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:ImplicitCast.cpp</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> R, <font color=#ff7700>typename</font>
P&gt;</div>
<div class=CC1>R implicit_cast(<font color=#ff7700>const</font> P&amp; p) {</div>
<div class=CC1>  <font color=#ff7700>return</font> p;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> i = 1;</div>
<div class=CC1>  <font color=#ff7700>float</font> x = implicit_cast&lt;<font color=#ff7700>float</font>&gt;(i);</div>
<div class=CC1>  <font color=#ff7700>int</font> j = implicit_cast&lt;<font color=#ff7700>int</font>&gt;(x);</div>
<div class=CC1>  <font color=#dd0000>//! char* p = implicit_cast&lt;char*&gt;(i);</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you interchange <b>R</b> and <b>P</b> in the template
parameter list near the top of the file, it will be impossible to compile this
program because the return type will remain unspecified (the first template
parameter would be the function’s parameter type). The last line (which is
commented out) is illegal because there is no standard conversion from <b>int</b>
to <b>char*</b>. <b>implicit_cast</b> is for revealing conversions in your code
that are allowed naturally.</p>

<p class=MsoNormal>With a little care you can even deduce array dimensions. This
example has an array-initialization function template (<b>init2</b>) that performs
such a deduction:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:ArraySize.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;size_t R, size_t C, <font color=#ff7700>typename</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> init1(T a[R][C]) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; R; ++i)</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t j = 0; j &lt; C; ++j)</div>
<div class=CC1>      a[i][j] = T();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;size_t R, size_t C, <font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> init2(T (&amp;a)[R][C]) {  <font color=#dd0000>// Reference parameter</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; R; ++i)</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t j = 0; j &lt; C; ++j)</div>
<div class=CC1>      a[i][j] = T();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[10][20];</div>
<div class=CC1>  init1&lt;10,20&gt;(a);  <font color=#dd0000>// Must specify</font></div>
<div class=CC1>  init2(a);         <font color=#dd0000>// Sizes deduced</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Array dimensions are not passed as part of a function
parameter’s type unless that parameter is passed by pointer or reference. The
function template <b>init2</b> declares <b>a</b> to be a reference to a
two-dimensional array, so its dimensions <b>R</b> and <b>C</b> are deduced by
the template facility, making <b>init2</b> a handy way to initialize a
two-dimensional array of any size. The template <b>init1</b> does not pass the
array by reference, so the sizes must be explicitly specified, although the
type parameter can still be deduced.</p>

<h3><a href="#_TocRef53985716" name="_Toc53985716">Function template overloading</a></h3>

<p class=MsoNormal>As with ordinary functions, you can overload function
templates that have the same name. When the compiler processes a function call
in a program, it has to decide which template or ordinary function is the
“best” fit for the call. Along with the <b>min(&nbsp;)</b> function template
introduced earlier, let’s add some ordinary functions to the mix:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MinTest.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::strcmp;</div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1><font color=#ff7700>using</font> std::endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font>
T&amp; a, <font color=#ff7700>const</font> T&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>char</font>* min(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* a, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (strcmp(a, b) &lt; 0) ? a : b;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>double</font> min(<font color=#ff7700>double</font> x, <font color=#ff7700>double</font> y) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (x &lt; y) ? x : y;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font> *s2 = <font color=#007f00>&quot;say \&quot;Ni-!\&quot;&quot;</font>,
*s1 = <font color=#007f00>&quot;knights who&quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; min(1, 2) &lt;&lt; endl;      <font color=#dd0000>// 1: 1
(template)</font></div>
<div class=CC1>  cout &lt;&lt; min(1.0, 2.0) &lt;&lt; endl;  <font color=#dd0000>// 2: 1
(double)</font></div>
<div class=CC1>  cout &lt;&lt; min(1, 2.0) &lt;&lt; endl;    <font color=#dd0000>// 3: 1
(double)</font></div>
<div class=CC1>  cout &lt;&lt; min(s1, s2) &lt;&lt; endl;    <font color=#dd0000>// 4:
knights who (const</font></div>
<div class=CC1>                                  <font color=#dd0000>//                
char*)</font></div>
<div class=CC1>  cout &lt;&lt; min&lt;&gt;(s1, s2) &lt;&lt; endl;  <font color=#dd0000>//
5: say &quot;Ni-!&quot;</font></div>
<div class=CC1>                                  <font color=#dd0000>//    (template)</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In addition to the function template, this program defines
two non-template functions: a C-style string version of <b>min(&nbsp;)</b> and
a <b>double</b> version. If the template doesn’t exist, the call in line 1
above invokes the <b>double</b> version of <b>min(&nbsp;)</b> because of the
standard conversion from <b>int</b> to <b>double</b>. The template can generate
an <b>int</b> version which is considered a better match, so that’s what
happens. The call in line 2 is an exact match for the <b>double</b> version,
and the call in line 3 also invokes the same function, implicitly converting 1
to 1.0. In line 4 the <b>const char*</b> version of <b>min(&nbsp;)</b> is
called directly. In line 5 we force the compiler to use the template facility
by appending empty angle brackets to the function name, whereupon it generates
a <b>const char*</b> version from the template and uses it (which is verified
by the wrong answer—it’s just comparing addresses!<a href="#_ftn54" name="_ftnref54"><span
class=MsoFootnoteReference>[54]</span></a>).
If you’re wondering why we have <b>using</b> declarations in lieu of the <b>using
namespace std </b>directive, it’s because some compilers include headers behind
the scenes that bring in <b>std::min(&nbsp;)</b>, which would conflict with our
declarations of the name <b>min(&nbsp;)</b>.</p>

<p class=MsoNormal>As stated above, you can overload templates of the same
name, as long as they can be distinguished by the compiler. You could, for
example, declare a <b>min(&nbsp;)</b> function template that processes three
arguments:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt;</div>
<div class=CC1><font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font> T&amp; a, <font color=#ff7700>const</font> T&amp; b, <font color=#ff7700>const</font> T&amp; c);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Versions of this template will be generated only for calls
to <b>min(&nbsp;)</b> that have three arguments of the same type.</p>

<h3><a href="#_TocRef53985717" name="_Toc53985717">Taking the address of a generated function template</a></h3>

<p class=MsoNormal>In some situations you need to take the address of a
function. For example, you may have a function that takes an argument of a
pointer to another function. It’s possible that this other function might be
generated from a template function, so you need some way to take that kind of
address:<a href="#_ftn55" name="_ftnref55"><span
class=MsoFootnoteReference>[55]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:TemplateFunctionAddress.cpp {-mwcc}</font></div>
<div class=CC1><font color=#dd0000>// Taking the address of a function generated</font></div>
<div class=CC1><font color=#dd0000>// from a template.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>void</font> f(T*) {}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> h(<font color=#ff7700>void</font> (*pf)(<font color=#ff7700>int</font>*)) {}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>void</font> g(<font color=#ff7700>void</font> (*pf)(T*)) {}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  h(&amp;f&lt;<font color=#ff7700>int</font>&gt;); <font color=#dd0000>// Full type specification</font></div>
<div class=CC1>  h(&amp;f); <font color=#dd0000>// Type deduction</font></div>
<div class=CC1>  g&lt;<font color=#ff7700>int</font>&gt;(&amp;f&lt;<font color=#ff7700>int</font>&gt;); <font color=#dd0000>// Full type
specification</font></div>
<div class=CC1>  g(&amp;f&lt;<font color=#ff7700>int</font>&gt;); <font color=#dd0000>// Type deduction</font></div>
<div class=CC1>  g&lt;<font color=#ff7700>int</font>&gt;(&amp;f); <font color=#dd0000>// Partial (but sufficient)
specification</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example demonstrates a number of issues. First, even
though you’re using templates, the signatures must match. The function <b>h(&nbsp;)</b>
takes a pointer to a function that takes an <b>int*</b> and returns <b>void</b>,
and that’s what the template <b>f(&nbsp;)</b> produces. Second, the function
that wants the function pointer as an argument can itself be a template, as in
the case of the template <b>g(&nbsp;)</b>.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b> you can see that type deduction works
here, too. The first call to <b>h(&nbsp;)</b> explicitly gives the template
argument for <b>f(&nbsp;)</b>, but since <b>h(&nbsp;)</b> says that it will
only take the address of a function that takes an <b>int*</b>, that part can be
deduced by the compiler. With <b>g(&nbsp;)</b> the situation is even more
interesting because two templates are involved. The compiler cannot deduce the
type with nothing to go on, but if either <b>f(&nbsp;)</b> or <b>g(&nbsp;)</b>
is given <b>int</b>, the rest can be deduced.</p>

<p class=MsoNormal>An obscure issue arises when trying to pass the functions <b>tolower</b> or <b>toupper</b>, declared in <b>&lt;cctype&gt;</b>, as parameters. It is possible to use these, for example, with the <b>transform</b> algorithm (which is covered in detail in the next chapter) to convert a string to lower or upper case. You must be careful because
there are multiple declarations for these functions. A naive approach would be
something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// The variable <b>s</b> is a std::string</font></div>
<div class=CC1>transform(s.begin(), s.end(), s.begin(), tolower);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>transform</b> algorithm applies its fourth parameter
(<b>tolower(&nbsp;) </b>in this case) to each character in the string <b>s</b>
and places the result in <b>s</b> itself, thus overwriting each character in <b>s</b>
with its lower-case equivalent. As it is written, this statement may or may not
work! It fails in the following context:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:FailedTransform.cpp {-xo}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;LOWER&quot;</font>);</div>
<div class=CC1>  transform(s.begin(), s.end(), s.begin(), tolower);</div>
<div class=CC1>  cout &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Even if your compiler lets you get away with this, it is
illegal. The reason is that the <b>&lt;iostream&gt;</b> header also makes
available a two-argument version of <b>tolower(&nbsp;)</b> and <b>toupper(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT&gt; charT toupper(charT c,</div>
<div class=CC1>                                    <font color=#ff7700>const</font> locale&amp;
loc);</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT&gt; charT tolower(charT c,</div>
<div class=CC1>                                    <font color=#ff7700>const</font> locale&amp; loc);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>These function templates take a second argument of type <b>locale</b>.
The compiler has no way of knowing whether it should use the one-argument
version of <b>tolower(&nbsp;) </b>defined in <b>&lt;cctype&gt;</b> or the one
mentioned above. You can solve this problem (almost!) with a cast in the call
to <b>transform</b>, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  transform(s.begin(),s.end(),s.begin()</div>
<div class=CC1>            <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>int</font> (*)(<font color=#ff7700>int</font>)&gt;(tolower));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>(Recall that <b>tolower(&nbsp;) </b>and <b>toupper(&nbsp;) </b>work
with <b>int</b> instead of <b>char</b>.) The cast above makes clear that the
single-argument version of <b>tolower(&nbsp;) </b>is desired. This works with
some compilers, but it is not required to. The reason, albeit obscure, is that
a library implementation is allowed to give “C linkage” (meaning that the
function name does not contain all the auxiliary information<a href="#_ftn56" name="_ftnref56"><span
class=MsoFootnoteReference>[56]</span></a> that
normal C++ functions do) to functions inherited from the C language. If this is
the case, the cast fails because <b>transform</b> is a C++ function template
and expects its fourth argument to have C++ linkage—and a cast is not allowed
to change the linkage. What a predicament!</p>

<p class=MsoNormal>The solution is to place <b>tolower(&nbsp;) </b>calls in an
unambiguous context. For example, you could write a function named <b>strTolower(&nbsp;)</b>
and place it in its own file without including <b>&lt;iostream&gt;</b>, like
this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:StrTolower.cpp {O} {-mwcc}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string strTolower(string s) {</div>
<div class=CC1>  transform(s.begin(), s.end(), s.begin(), tolower);</div>
<div class=CC1>  <font color=#ff7700>return</font> s;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The header <b>&lt;iostream&gt;</b> is not involved here, and
the compilers we use do not introduce the two-argument version of <b>tolower(&nbsp;)
</b>in this context,<a href="#_ftn57" name="_ftnref57"><span
class=MsoFootnoteReference>[57]</span></a> so
there’s no problem. You can then use this function normally:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Tolower.cpp {-mwcc}</font></div>
<div class=CC1><font color=#dd0000>//{L} StrTolower</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>string strTolower(string);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;LOWER&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; strTolower(s) &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Another solution is to write a wrapper function template
that calls the correct version of <b>tolower(&nbsp;)</b> explicitly:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:ToLower2.cpp {-mwcc}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT&gt; charT strTolower(charT c) {</div>
<div class=CC1>  <font color=#ff7700>return</font> tolower(c);  <font color=#dd0000>// One-arg version called</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string s(<font color=#007f00>&quot;LOWER&quot;</font>);</div>
<div class=CC1> 
transform(s.begin(),s.end(),s.begin(),&amp;strTolower&lt;<font color=#ff7700>char</font>&gt;);</div>
<div class=CC1>  cout &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This version has the advantage that it can process both wide
and narrow strings since the underlying character type is a template parameter.
The C++ Standards Committee is working on modifying the language so that the
first example (without the cast) will work, and some day these workarounds can
be ignored.<a href="#_ftn58" name="_ftnref58"><span
class=MsoFootnoteReference>[58]</span></a></p>

<h3><a href="#_TocRef312374091" name="_Toc312374091">Applying a function to a</a>n
STL sequence</h3>

<p class=MsoNormal>Suppose you want to take an STL sequence container (which
you’ll learn more about in subsequent chapters; for now we can just use the
familiar <b>vector</b>) and apply a member function to all the objects it contains.
Because a <b>vector</b> can contain any type of object, you need a function
that works with any type of <b>vector</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:ApplySequence.h</font></div>
<div class=CC1><font color=#dd0000>// Apply a function to an STL sequence container.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// const, 0 arguments, any type of return value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq, <font color=#ff7700>class</font> T, <font color=#ff7700>class</font> R&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Seq&amp; sq, R (T::*f)() <font color=#ff7700>const</font>) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator it = sq.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != sq.end())</div>
<div class=CC1>    ((*it++)-&gt;*f)();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// const, 1 argument, any type of return value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq, <font color=#ff7700>class</font> T, <font color=#ff7700>class</font> R, <font color=#ff7700>class</font> A&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Seq&amp; sq, R(T::*f)(A) <font color=#ff7700>const</font>, A a) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator it = sq.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != sq.end())</div>
<div class=CC1>    ((*it++)-&gt;*f)(a);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// const, 2 arguments, any type of return value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq, <font color=#ff7700>class</font> T, <font color=#ff7700>class</font> R,</div>
<div class=CC1>         <font color=#ff7700>class</font> A1, <font color=#ff7700>class</font> A2&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Seq&amp; sq, R(T::*f)(A1, A2) <font color=#ff7700>const</font>,</div>
<div class=CC1>    A1 a1, A2 a2) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator it = sq.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != sq.end())</div>
<div class=CC1>    ((*it++)-&gt;*f)(a1, a2);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Non-const, 0 arguments, any type of return value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq, <font color=#ff7700>class</font> T, <font color=#ff7700>class</font> R&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Seq&amp; sq, R (T::*f)()) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator it = sq.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != sq.end())</div>
<div class=CC1>    ((*it++)-&gt;*f)();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Non-const, 1 argument, any type of return value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq, <font color=#ff7700>class</font> T, <font color=#ff7700>class</font> R, <font color=#ff7700>class</font> A&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Seq&amp; sq, R(T::*f)(A), A a) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator it = sq.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != sq.end())</div>
<div class=CC1>    ((*it++)-&gt;*f)(a);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Non-const, 2 arguments, any type of return value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq, <font color=#ff7700>class</font> T, <font color=#ff7700>class</font> R,</div>
<div class=CC1>         <font color=#ff7700>class</font> A1, <font color=#ff7700>class</font> A2&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Seq&amp; sq, R(T::*f)(A1, A2),</div>
<div class=CC1>    A1 a1, A2 a2) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator it = sq.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != sq.end())</div>
<div class=CC1>    ((*it++)-&gt;*f)(a1, a2);</div>
<div class=CC1>}</div>
<div class=CC1><font color=#dd0000>// Etc., to handle maximum
likely arguments ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>apply(&nbsp;) </b>function template above takes a
reference to the container class and a pointer-to-member for a member function
of the objects contained in the class. It uses an iterator to move through the
sequence and apply the function to every object. We have overloaded on the <b>const</b>-ness
of the function so you can use it with both <b>const</b> and non-<b>const</b>
functions.</p>

<p class=MsoNormal>Notice that there are no STL header files (or any header
files, for that matter) included in <b>applySequence.h</b>, so it is not
limited to use with an STL container. However, it does make assumptions
(primarily, the name and behavior of the <b>iterator</b>) that apply to STL
sequences, and it also assumes that the elements of the container be of pointer
type.</p>

<p class=MsoNormal>You can see there is more than one version of <b>apply(&nbsp;)</b>,
further illustrating overloading of function templates. Although these
templates allow any type of return value (which is ignored, but the type
information is required to match the pointer-to-member), each version takes a
different number of arguments, and because it’s a template, those arguments can
be of any type. The only limitation here is that there’s no “super template” to
create templates for you; you must decide how many arguments will ever be
required and make the appropriate definitions.</p>

<p class=MsoNormal>To test the various overloaded versions of <b>apply(&nbsp;)</b>,
the class <b>Gromit</b><a href="#_ftn59" name="_ftnref59"><span
class=MsoFootnoteReference>[59]</span></a> is
created containing functions with different numbers of arguments, and both <b>const</b>
and non-<b>const</b> member functions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Gromit.h</font></div>
<div class=CC1><font color=#dd0000>// The techno-dog. Has member functions</font></div>
<div class=CC1><font color=#dd0000>// with various numbers of arguments.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Gromit {</div>
<div class=CC1>  <font color=#ff7700>int</font> arf;</div>
<div class=CC1>  <font color=#ff7700>int</font> totalBarks;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Gromit(<font color=#ff7700>int</font> arf = 1) : arf(arf + 1), totalBarks(0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> speak(<font color=#ff7700>int</font>) {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; arf; i++) {</div>
<div class=CC1>      std::cout &lt;&lt; <font color=#007f00>&quot;arf! &quot;</font>;</div>
<div class=CC1>      ++totalBarks;</div>
<div class=CC1>    }</div>
<div class=CC1>    std::cout &lt;&lt; std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>char</font> eat(<font color=#ff7700>float</font>) <font color=#ff7700>const</font> {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;chomp!&quot;</font> &lt;&lt;
std::endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> 'z';</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> sleep(<font color=#ff7700>char</font>, <font color=#ff7700>double</font>) <font color=#ff7700>const</font> {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;zzz...&quot;</font> &lt;&lt;
std::endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> sit() <font color=#ff7700>const</font> {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;Sitting...&quot;</font> &lt;&lt;
std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>}; <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now you can use the <b>apply(&nbsp;)</b> template functions to
apply the <b>Gromit</b> member functions to a <b>vector&lt;Gromit*&gt;</b>,
like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:ApplyGromit.cpp</font></div>
<div class=CC1><font color=#dd0000>// Test ApplySequence.h.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;ApplySequence.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Gromit.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Gromit*&gt; dogs;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; 5; i++)</div>
<div class=CC1>    dogs.push_back(<font color=#ff7700>new</font> Gromit(i));</div>
<div class=CC1>  apply(dogs, &amp;Gromit::speak, 1);</div>
<div class=CC1>  apply(dogs, &amp;Gromit::eat, 2.0f);</div>
<div class=CC1>  apply(dogs, &amp;Gromit::sleep, 'z', 3.0);</div>
<div class=CC1>  apply(dogs, &amp;Gromit::sit);</div>
<div class=CC1>  purge(dogs);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>purge(&nbsp;)</b> function is a small utility that
calls <b>delete</b> on every element of sequence. You’ll find it defined in
Chapter 7, and used various places in this book.</p>

<p class=MsoNormal>Although the definition of <b>apply(&nbsp;)</b> is somewhat
complex and not something you’d ever expect a novice to understand, its use is
remarkably clean and simple, and a novice could use it knowing only<i> what</i>
it is intended to accomplish, not <i>how</i>. This is the type of division you
should strive for in all your program components. The tough details are all
isolated on the designer’s side of the wall. Users are concerned only with
accomplishing their goals and don’t see, know about, or depend on details of
the underlying implementation. We’ll explore even more flexible ways to apply
functions to sequences in the next chapter.</p>

<h3><a href="#_TocRef53985719" name="_Toc53985719">Partial ordering of
function templates</a></h3>

<p class=MsoNormal>We mentioned earlier that an ordinary function overload of <b>min(&nbsp;)</b> is preferable to using the template. If a function already exists
to match a function call, why generate another? In the absence of ordinary
functions, however, it is possible that overloaded function templates can lead
to ambiguities. To minimize the chances of this, an ordering is defined for
function templates, which chooses the <i>most specialized</i> template, if such
exists. A function template is considered more specialized than another if
every possible list of arguments that matches it also matches the other, but
not the other way around. Consider the following function template
declarations, taken from an example in the C++ Standard document:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(T);</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(T*);</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(<font color=#ff7700>const</font> T*);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first template can be matched with any type. The second
template is more specialized than the first because only pointer types match
it. In other words, you can look upon the set of possible calls that match the
second template as a subset of the first. A similar relationship exists between
the second and third template declarations above: the third can only be called
for pointers to <b>const</b>, but the second accommodates any pointer type. The
following program illustrates these rules:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:PartialOrder.cpp</font></div>
<div class=CC1><font color=#dd0000>// Reveals ordering of function templates.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(T) {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;T&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(T*) {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;T*&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(<font color=#ff7700>const</font> T*) {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;const T*&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  f(0);            <font color=#dd0000>// T</font></div>
<div class=CC1>  <font color=#ff7700>int</font> i = 0;</div>
<div class=CC1>  f(&amp;i);           <font color=#dd0000>// T*</font></div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> j = 0;</div>
<div class=CC1>  f(&amp;j);           <font color=#dd0000>// const T*</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The call <b>f(&amp;i)</b> certainly matches the first
template, but since the second is more specialized, it is called. The third
can’t be called here since the pointer is not a pointer to <b>const</b>. The
call <b>f(&amp;j)</b> matches all three templates (for example, <b>T</b> would
be <b>const int</b> in the second template), but again, the third template is
more specialized, so it is used instead.</p>

<p class=MsoNormal>If there is no “most specialized” template among a set of
overloaded function templates, an ambiguity remains, and the compiler will
report an error. That is why this feature is called a “partial ordering”—it may
not be able to resolve all possibilities. Similar rules exist for class
templates (see the section “Partial specialization” below).</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985720" name="_Toc53985720">Template
specialization</a></h2>

<p class=MsoNormal>The term <i>specialization</i> has a specific,
template-related meaning in C++. A template definition is, by its very nature,
a <i>generalization</i>, because it describes a family of functions or classes
in general terms. When template arguments are supplied, the result is a
specialization of the template because it determines a unique instance out of
the many possible instances of the family of functions or classes. The <b>min(&nbsp;)</b>
function template seen at the beginning of this chapter is a generalization of
a minimum-finding function because the type of its parameters is not specified.
When you supply the type for the template parameter, whether explicitly or
implicitly via argument deduction, the resultant code generated by the compiler
(for example, <b>min&lt;int&gt;(&nbsp;)</b>) is a specialization of the
template. The code generated is also considered an <i>instantiation</i> of the template, as are all code bodies generated by the template facility.</p>

<h3><a href="#_TocRef53985721" name="_Toc53985721">Explicit specialization</a></h3>

<p class=MsoNormal>You can also provide the code yourself for a given template
specialization, should the need arise. Providing your own template
specializations is often needed with class templates, but we will begin with
the <b>min(&nbsp;)</b> function template to introduce the syntax.</p>

<p class=MsoNormal>Recall that in <b>MinTest.cpp</b> earlier in this chapter we
introduced the following ordinary function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>char</font>* min(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* a, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (strcmp(a, b) &lt; 0) ? a : b;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This was so that a call to <b>min(&nbsp;)</b> would compare
strings and not addresses. Although it would provide no advantage here, we
could instead define a <b>const char*</b> specialization for <b>min(&nbsp;)</b>,
as in the following program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MinTest2.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::strcmp;</div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1><font color=#ff7700>using</font> std::endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font> T&amp;
a, <font color=#ff7700>const</font> T&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// An explicit specialization of the min template</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>char</font>* <font color=#ff7700>const</font>&amp; min&lt;<font color=#ff7700>const</font> <font color=#ff7700>char</font>*&gt;(<font color=#ff7700>const</font>
<font color=#ff7700>char</font>* <font color=#ff7700>const</font>&amp; a,</div>
<div class=CC1>                                    <font color=#ff7700>const</font> <font color=#ff7700>char</font>*
<font color=#ff7700>const</font>&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (strcmp(a, b) &lt; 0) ? a : b;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font> *s2 = <font color=#007f00>&quot;say \&quot;Ni-!\&quot;&quot;</font>,
*s1 = <font color=#007f00>&quot;knights who&quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; min(s1, s2) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; min&lt;&gt;(s1, s2) &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The “<b>template&lt;&gt;</b>” prefix tells the compiler that
what follows is a specialization of a template. The type for the specialization
must appear in angle brackets immediately following the function name, as it normally
would in an explicitly specified call. Note that we <i>carefully</i> substitute
<b>const char*</b> for <b>T</b> in the explicit specialization. Whenever the
original template specifies <b>const T</b>, that <b>const</b> modifies the <i>whole</i>
type <b>T</b>. It is the pointer to a <b>const char*</b> that is <b>const</b>. So
we must write <b>const char* const</b> in place of <b>const T</b> in the specialization.
When the compiler sees a call to <b>min(&nbsp;)</b> with <b>const</b> <b>char*</b>
arguments in the program, it will instantiate our <b>const char*</b> version of
<b>min(&nbsp;)</b> so it can be called. The two calls to <b>min(&nbsp;)</b> in
this program call the same specialization of <b>min(&nbsp;)</b>.</p>

<p class=MsoNormal>Explicit specializations tend to be more useful for class
templates than for function templates. When you provide a full specialization
for a class template, though, you may need to implement all the member
functions. This is because you are providing a separate class, and client code
may expect the complete interface to be implemented.</p>

<p class=MsoNormal>The standard library has an explicit specialization for <b>vector</b>
when it holds objects of type <b>bool</b>. The purpose for <b>vector&lt;bool&gt;</b>
is to allow library implementations to save space by packing bits into
integers.<a href="#_ftn60" name="_ftnref60"><span
class=MsoFootnoteReference>[60]</span></a></p>

<p class=MsoNormal>As you saw earlier in this chapter, the declaration for the
primary <b>vector</b> class template is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> Allocator =
allocator&lt;T&gt; &gt;</div>
<div class=CC1><font color=#ff7700>class</font> vector {...};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To specialize for objects of type <b>bool</b>, you could
declare an explicit specialization as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>class</font>
vector&lt;<font color=#ff7700>bool</font>, allocator&lt;<font color=#ff7700>bool</font>&gt; &gt; {...};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Again, this is quickly recognized as a full, explicit
specialization because of the <b>template&lt;&gt;</b> prefix and because all
the primary template’s parameters are satisfied by the argument list appended
to the class name.</p>

<p class=MsoNormal>It turns out that <b>vector&lt;bool&gt;</b> is a little more
flexible than we have described, as seen in the next section.</p>

<h3><a href="#_TocRef53985722" name="_Toc53985722">Partial Specialization</a></h3>

<p class=MsoNormal>Class templates can also be partially specialized, meaning
that at least one of the template parameters is left “open” in some way in the
specialization. <b>vector&lt;bool&gt;</b> specifies the object type (<b>bool</b>),
but leaves the allocator type unspecified. Here is the actual declaration of <b>vector&lt;bool&gt;</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Allocator&gt; <font color=#ff7700>class</font> vector&lt;<font color=#ff7700>bool</font>,
Allocator&gt;;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can recognize a partial specialization because non-empty
parameter lists appear in angle brackets both after the template keyword (the
unspecified parameters) and after the class (the specified arguments). Because
of the way <b>vector&lt;bool&gt;</b> is defined, a user can provide a custom
allocator type, even though the contained type of <b>bool</b> is fixed. In
other words, specialization, and partial specialization in particular,
constitute a sort of “overloading” for class templates.</p>

<h4>Partial ordering of class templates</h4>

<p class=MsoNormal>The rules that determine which template is selected for instantiation are similar to the partial ordering for function templates—the “most
specialized” template is selected. The string in each <b>f(&nbsp;)</b> member
function in the illustration below explains the role of each template
definition:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:PartialOrder2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Reveals partial ordering of class templates.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> U&gt; <font color=#ff7700>class</font> C {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; <font color=#007f00>&quot;Primary Template\n&quot;</font>;
}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> U&gt; <font color=#ff7700>class</font> C&lt;<font color=#ff7700>int</font>, U&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; <font color=#007f00>&quot;T == int\n&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> C&lt;T, <font color=#ff7700>double</font>&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; &quot;U == double\n”; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> U&gt; <font color=#ff7700>class</font> C&lt;T*, U&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; &quot;T* used\n”; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> U&gt; <font color=#ff7700>class</font> C&lt;T, U*&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; &quot;U* used\n”; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> U&gt; <font color=#ff7700>class</font> C&lt;T*, U*&gt;
{</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; &quot;T* <font color=#ff7700>and</font> U* used\n”; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> C&lt;T, T&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; &quot;T == U\n”; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  C&lt;<font color=#ff7700>float</font>, <font color=#ff7700>int</font>&gt;().f();    <font color=#dd0000>// 1: Primary template</font></div>
<div class=CC1>  C&lt;<font color=#ff7700>int</font>, <font color=#ff7700>float</font>&gt;().f();    <font color=#dd0000>// 2: T == int</font></div>
<div class=CC1>  C&lt;<font color=#ff7700>float</font>, <font color=#ff7700>double</font>&gt;().f(); <font color=#dd0000>// 3: U == double</font></div>
<div class=CC1>  C&lt;<font color=#ff7700>float</font>, <font color=#ff7700>float</font>&gt;().f();  <font color=#dd0000>// 4: T == U</font></div>
<div class=CC1>  C&lt;<font color=#ff7700>float</font>*, <font color=#ff7700>float</font>&gt;().f(); <font color=#dd0000>// 5: T* used [T is
float]</font></div>
<div class=CC1>  C&lt;<font color=#ff7700>float</font>, <font color=#ff7700>float</font>*&gt;().f(); <font color=#dd0000>// 6: U* used [U is
float]</font></div>
<div class=CC1>  C&lt;<font color=#ff7700>float</font>*, <font color=#ff7700>int</font>*&gt;().f();  <font color=#dd0000>// 7: T* and U* used
[float,int]</font></div>
<div class=CC1>  <font color=#dd0000>// The following are ambiguous:</font></div>
<div class=CC1><font color=#dd0000>//   8: C&lt;int, int&gt;().f();</font></div>
<div class=CC1><font color=#dd0000>//   9: C&lt;double, double&gt;().f();</font></div>
<div class=CC1><font color=#dd0000>//  10: C&lt;float*, float*&gt;().f();</font></div>
<div class=CC1><font color=#dd0000>//  11: C&lt;int, int*&gt;().f();</font></div>
<div class=CC1><font color=#dd0000>//  12: C&lt;int*, int*&gt;().f();</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As you can see, you can partially specify template
parameters according to whether they are pointer types, or whether they are
equal. When the <b>T*</b> specialization is used, such as is the case in line
5, <b>T</b> itself is not the top-level pointer type that was passed—it is the
type that the pointer refers to (<b>float</b>, in this case). The <b>T*</b>
specification is a pattern to allow matching against pointer types. If you use <b>int**</b>
as the first template argument, <b>T</b> becomes <b>int*</b>. Line 8 is
ambiguous because having the first parameter as an <b>int</b> versus having the
two parameters equal are independent issues—one is not more specialized than
the other. Similar logic applies to lines 9 through 12.</p>

<h3><a href="#_TocRef53985723" name="_Toc53985723">A practical example</a></h3>

<p class=MsoNormal>You can easily derive from a class template, and you can
create a new template that instantiates and inherits from an existing template.
If the <b>vector </b>template does most everything you want, for example, but in
a certain application you’d also like a version that can sort itself, you can
easily reuse the <b>vector</b> code. The following example derives from <b>vector&lt;T&gt;</b>
and adds sorting. Note that deriving from <b>vector</b>, which doesn’t have a
virtual destructor, would be dangerous if we needed to perform cleanup in our
destructor.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Sortable.h</font></div>
<div class=CC1><font color=#dd0000>// Template specialization.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef SORTABLE_H</font></div>
<div class=CC1><font color=#7F7F00>#define SORTABLE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Sortable : <font color=#ff7700>public</font> std::vector&lt;T&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> sort();</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> Sortable&lt;T&gt;::sort() { <font color=#dd0000>// A simple sort</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = <font color=#ff7700>this</font>-&gt;size(); i &gt; 0; --i)</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t j = 1; j &lt; i; ++j)</div>
<div class=CC1>      <font color=#ff7700>if</font>(<font color=#ff7700>this</font>-&gt;at(j-1) &gt; <font color=#ff7700>this</font>-&gt;at(j)) {</div>
<div class=CC1>        T t = <font color=#ff7700>this</font>-&gt;at(j-1);</div>
<div class=CC1>        <font color=#ff7700>this</font>-&gt;at(j-1) = <font color=#ff7700>this</font>-&gt;at(j);</div>
<div class=CC1>        <font color=#ff7700>this</font>-&gt;at(j) = t;</div>
<div class=CC1>      }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Partial specialization for
pointers:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Sortable&lt;T*&gt; :
<font color=#ff7700>public</font> std::vector&lt;T*&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> sort();</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> Sortable&lt;T*&gt;::sort() {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = <font color=#ff7700>this</font>-&gt;size(); i &gt; 0; --i)</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t j = 1; j &lt; i; ++j)</div>
<div class=CC1>      <font color=#ff7700>if</font>(*<font color=#ff7700>this</font>-&gt;at(j-1) &gt; *<font color=#ff7700>this</font>-&gt;at(j)) {</div>
<div class=CC1>        T* t = <font color=#ff7700>this</font>-&gt;at(j-1);</div>
<div class=CC1>        <font color=#ff7700>this</font>-&gt;at(j-1) = <font color=#ff7700>this</font>-&gt;at(j);</div>
<div class=CC1>        <font color=#ff7700>this</font>-&gt;at(j) = t;</div>
<div class=CC1>      }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Full specialization for char*</font></div>
<div class=CC1><font color=#dd0000>// (Made inline here for
convenience -- normally you would</font></div>
<div class=CC1><font color=#dd0000>// place the function body in a separate
file and only</font></div>
<div class=CC1><font color=#dd0000>// leave the declaration here).</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>inline</font> <font color=#ff7700>void</font> Sortable&lt;<font color=#ff7700>char</font>*&gt;::sort()
{</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = <font color=#ff7700>this</font>-&gt;size(); i &gt; 0; --i)</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t j = 1; j &lt; i; ++j)</div>
<div class=CC1>      <font color=#ff7700>if</font>(std::strcmp(<font color=#ff7700>this</font>-&gt;at(j-1), <font color=#ff7700>this</font>-&gt;at(j))
&gt; 0) {</div>
<div class=CC1>        <font color=#ff7700>char</font>* t = <font color=#ff7700>this</font>-&gt;at(j-1);</div>
<div class=CC1>        <font color=#ff7700>this</font>-&gt;at(j-1) = <font color=#ff7700>this</font>-&gt;at(j);</div>
<div class=CC1>        <font color=#ff7700>this</font>-&gt;at(j) = t;</div>
<div class=CC1>      }</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// SORTABLE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Sortable</b> template imposes a restriction on all
but one of the classes for which it is instantiated: they must contain a <b>&gt;</b>
operator. It works correctly only with non-pointer objects (including objects
of built-in types). The full specialization compares the elements using <b>strcmp(&nbsp;)</b>
to sort <b>vector</b>s of <b>char*</b> according to the null-terminated strings
to which they refer. The use of “<b>this-</b>&gt;” above is mandatory<a href="#_ftn61" name="_ftnref61"><span
class=MsoFootnoteReference>[61]</span></a> and is
explained in the section entitled “Name lookup issues” later in this chapter.<a href="#_ftn62" name="_ftnref62"><span
class=MsoFootnoteReference>[62]</span></a></p>

<p class=MsoNormal>Here’s a driver for <b>Sortable.h</b> that uses the randomizer
introduced earlier in the chapter:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Sortable.cpp</font></div>
<div class=CC1><font color=#dd0000>//{-bor} (Because of bitset in Urand.h)</font></div>
<div class=CC1><font color=#dd0000>// Testing template specialization.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Sortable.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Urand.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#define asz(a) (sizeof a / sizeof a[0])</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>char</font>* words[] = { <font color=#007f00>&quot;is&quot;</font>, <font color=#007f00>&quot;running&quot;</font>,
<font color=#007f00>&quot;big&quot;</font>, <font color=#007f00>&quot;dog&quot;</font>, <font color=#007f00>&quot;a&quot;</font>, };</div>
<div class=CC1><font color=#ff7700>char</font>* words2[] = { <font color=#007f00>&quot;this&quot;</font>, <font color=#007f00>&quot;that&quot;</font>,
<font color=#007f00>&quot;theother&quot;</font>, };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Sortable&lt;<font color=#ff7700>int</font>&gt; is;</div>
<div class=CC1>  Urand&lt;47&gt; rnd;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; 15; ++i)</div>
<div class=CC1>    is.push_back(rnd());</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; is.size(); ++i)</div>
<div class=CC1>    cout &lt;&lt; is[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  is.sort();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; is.size(); ++i)</div>
<div class=CC1>    cout &lt;&lt; is[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Uses the template partial specialization:</font></div>
<div class=CC1>  Sortable&lt;string*&gt; ss;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; asz(words); ++i)</div>
<div class=CC1>    ss.push_back(<font color=#ff7700>new</font> string(words[i]));</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; ss.size(); ++i)</div>
<div class=CC1>    cout &lt;&lt; *ss[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  ss.sort();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; ss.size(); ++i) {</div>
<div class=CC1>    <span lang=SV>cout &lt;&lt; *ss[i] &lt;&lt; ' ';</span></div>
<div class=CC1><span lang=SV>    <font color=#ff7700>delete</font> ss[i];</span></div>
<div class=CC1><span lang=SV>  </span>}</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Uses the full char* specialization:</font></div>
<div class=CC1>  Sortable&lt;<font color=#ff7700>char</font>*&gt; scp;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; asz(words2); ++i)</div>
<div class=CC1>    scp.push_back(words2[i]);</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; scp.size(); ++i)</div>
<div class=CC1>    cout &lt;&lt; scp[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  scp.sort();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; scp.size(); ++i)</div>
<div class=CC1>    cout &lt;&lt; scp[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each of the template instantiations above uses a different
version of the template. <b>Sortable&lt;int&gt;</b> uses the primary template. <b>Sortable&lt;string*&gt;</b>
uses the partial specialization for pointers. Last, <b>Sortable&lt;char*&gt;</b>
uses the full specialization for <b>char*</b>. Without this full
specialization, you could be fooled into thinking that things were working
correctly because the <b>words</b> array would still sort out to “a big dog is
running” since the partial specialization would end up comparing the first
character of each array. However, <b>words2</b> would not sort correctly.</p>

<h3><a href="#_TocRef312374086" name="_Toc312374086">Preventing template code
bloat</a></h3>

<p class=MsoNormal>Whenever a class template is instantiated, the code from the
class definition for the particular specialization is generated, along with all
the member functions that are called in the program. Only the member functions
that are called are generated. This is good, as you can see in the following
program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:DelayedInstantiation.cpp</font></div>
<div class=CC1><font color=#dd0000>// Member functions of class templates are not</font></div>
<div class=CC1><font color=#dd0000>// instantiated until they're needed.</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> X {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Y {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> g() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>class</font> Z {</div>
<div class=CC1>  T t;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> a() { t.f(); }</div>
<div class=CC1>  <font color=#ff7700>void</font> b() { t.g(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Z&lt;X&gt; zx;</div>
<div class=CC1>  zx.a(); <font color=#dd0000>// Doesn't create Z&lt;X&gt;::b()</font></div>
<div class=CC1>  Z&lt;Y&gt; zy;</div>
<div class=CC1>  zy.b(); <font color=#dd0000>// Doesn't create Z&lt;Y&gt;::a()</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here, even though the template <b>Z</b> purports to use both
<b>f(&nbsp;)</b> and <b>g(&nbsp;)</b> member functions of <b>T</b>, the fact
that the program compiles shows you that it only generates <b>Z&lt;X&gt;::a(&nbsp;)</b>
when it is explicitly called for <b>zx</b>. (If <b>Z&lt;X&gt;::b(&nbsp;)</b>
were also generated at the same time, a compile-time error message would be
generated because it would attempt to call <b>X::g(&nbsp;)</b>, which doesn’t
exist.) Similarly, the call to <b>zy.b(&nbsp;)</b> doesn’t generate <b>Z&lt;Y&gt;::a(&nbsp;)</b>.
As a result, the <b>Z</b> template can be used with <b>X</b> and <b>Y</b>,
whereas if all the member functions were generated when the class was first instantiated
the use of many templates would become significantly limited.</p>

<p class=MsoNormal>Suppose you have a templatized <b>Stack</b> container and
you use specializations for <b>int</b>, <b>int*</b>, and <b>char*</b>. Three
versions of <b>Stack</b> code will be generated and linked as part of your
program. One of the reasons for using a template in the first place is so you don’t
need to replicate code by hand; but code still gets replicated—it’s just the
compiler that does it instead of you. You can factor the bulk of the
implementation for storing pointer types into a single class by using a combination
of full and partial specialization. The key is to fully specialize for <b>void*</b>
and then derive all other pointer types from the <b>void*</b> implementation so
the common code can be shared. The program below illustrates this technique:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Nobloat.h</font></div>
<div class=CC1><font color=#dd0000>// Shares code for storing pointers in a Stack.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef NOBLOAT_H</font></div>
<div class=CC1><font color=#7F7F00>#define NOBLOAT_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The primary template</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Stack {</div>
<div class=CC1>  T* data;</div>
<div class=CC1>  std::size_t count;</div>
<div class=CC1>  std::size_t capacity;</div>
<div class=CC1>  <font color=#ff7700>enum</font> { INIT = 5 };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Stack() {</div>
<div class=CC1>    count = 0;</div>
<div class=CC1>    capacity = INIT;</div>
<div class=CC1>    data = <font color=#ff7700>new</font> T[INIT];</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count == capacity) {</div>
<div class=CC1>      <font color=#dd0000>// Grow array store</font></div>
<div class=CC1>      std::size_t newCapacity = 2 * capacity;</div>
<div class=CC1>      T* newData = <font color=#ff7700>new</font> T[newCapacity];</div>
<div class=CC1>      <font color=#ff7700>for</font>(size_t i = 0; i &lt; count; ++i)</div>
<div class=CC1>        <span lang=IT>newData[i] = data[i];</span></div>
<div class=CC1><span lang=IT>      <font color=#ff7700>delete</font> [] data;</span></div>
<div class=CC1><span lang=IT>      </span>data = newData;</div>
<div class=CC1>      capacity = newCapacity;</div>
<div class=CC1>    }</div>
<div class=CC1>    assert(count &lt; capacity);</div>
<div class=CC1>    data[count++] = t;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop() {</div>
<div class=CC1>    assert(count &gt; 0);</div>
<div class=CC1>    --count;</div>
<div class=CC1>  }</div>
<div class=CC1>  T top() <font color=#ff7700>const</font> {</div>
<div class=CC1>    assert(count &gt; 0);</div>
<div class=CC1>    <font color=#ff7700>return</font> data[count-1];</div>
<div class=CC1>  }</div>
<div class=CC1>  std::size_t size() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Full specialization for void*</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>class</font> Stack&lt;<font color=#ff7700>void</font> *&gt; {</div>
<div class=CC1>  <font color=#ff7700>void</font>** data;</div>
<div class=CC1>  std::size_t count;</div>
<div class=CC1>  std::size_t capacity;</div>
<div class=CC1>  <font color=#ff7700>enum</font> { INIT = 5 };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Stack() {</div>
<div class=CC1>    count = 0;</div>
<div class=CC1>    capacity = INIT;</div>
<div class=CC1>    data = <font color=#ff7700>new</font> <font color=#ff7700>void</font>*[INIT];</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>void</font>* <font color=#ff7700>const</font> &amp; t) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(count == capacity) {</div>
<div class=CC1>      std::size_t newCapacity = 2*capacity;</div>
<div class=CC1>      <font color=#ff7700>void</font>** newData = <font color=#ff7700>new</font> <font color=#ff7700>void</font>*[newCapacity];</div>
<div class=CC1>      std::memcpy(newData, data, count*<font color=#ff7700>sizeof</font>(<font color=#ff7700>void</font>*));</div>
<div class=CC1>      <span lang=IT><font color=#ff7700>delete</font> [] data;</span></div>
<div class=CC1><span lang=IT>      data = newData;</span></div>
<div class=CC1><span lang=IT>      capacity = newCapacity;</span></div>
<div class=CC1><span lang=IT>    </span>}</div>
<div class=CC1>    assert(count &lt; capacity);</div>
<div class=CC1>    data[count++] = t;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop() {</div>
<div class=CC1>    assert(count &gt; 0);</div>
<div class=CC1>    --count;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font>* top() <font color=#ff7700>const</font> {</div>
<div class=CC1>    assert(count &gt; 0);</div>
<div class=CC1>    <font color=#ff7700>return</font> data[count-1];</div>
<div class=CC1>  }</div>
<div class=CC1>  std::size_t size() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Partial specialization for
other pointer types</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font>
Stack&lt;T*&gt; : <font color=#ff7700>private</font> Stack&lt;<font color=#ff7700>void</font> *&gt; {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Stack&lt;<font color=#ff7700>void</font> *&gt;
Base;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> push(T* <font color=#ff7700>const</font> &amp; t) { Base::push(t); }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop() {Base::pop();}</div>
<div class=CC1>  T* top() <font color=#ff7700>const</font> { <font color=#ff7700>return</font>
<font color=#ff7700>static_cast</font>&lt;T*&gt;(Base::top()); }</div>
<div class=CC1>  std::size_t size() { <font color=#ff7700>return</font> Base::size(); }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// NOBLOAT_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This simple stack expands as it fills its capacity. The <b>void*</b>
specialization stands out as a full specialization by virtue of the <b>template&lt;&gt;</b>
prefix (that is, the template parameter list is empty). As mentioned earlier,
it is necessary to implement all member functions in a class template
specialization. The savings occurs with all other pointer types. The partial
specialization for other pointer types derives from <b>Stack&lt;void*&gt;</b>
privately, since we are merely using <b>Stack&lt;void*&gt;</b> for
implementation purposes, and do not wish to expose any of its interface
directly to the user. The member functions for each pointer instantiation are
small forwarding functions to the corresponding functions in <b>Stack&lt;void*&gt;</b>.
Hence, whenever a pointer type other than <b>void*</b> is instantiated, it is a
fraction of the size it would have been had the primary template alone been
used.<a href="#_ftn63" name="_ftnref63"><span
class=MsoFootnoteReference>[63]</span></a> Here is a driver
program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:NobloatTest.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Nobloat.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> StackType&gt;</div>
<div class=CC1><font color=#ff7700>void</font> emptyTheStack(StackType&amp; stk) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(stk.size() &gt; 0) {</div>
<div class=CC1>    cout &lt;&lt; stk.top() &lt;&lt; endl;</div>
<div class=CC1>    stk.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// An overload for emptyTheStack (not a
specialization!)</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> emptyTheStack(Stack&lt;T*&gt;&amp; stk) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(stk.size() &gt; 0) {</div>
<div class=CC1>    cout &lt;&lt; *stk.top() &lt;&lt; endl;</div>
<div class=CC1>    stk.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Stack&lt;<font color=#ff7700>int</font>&gt; s1;</div>
<div class=CC1>  s1.push(1);</div>
<div class=CC1>  s1.push(2);</div>
<div class=CC1>  emptyTheStack(s1);</div>
<div class=CC1>  Stack&lt;<font color=#ff7700>int</font> *&gt; s2;</div>
<div class=CC1>  <font color=#ff7700>int</font> i = 3;</div>
<div class=CC1>  <font color=#ff7700>int</font> j = 4;</div>
<div class=CC1>  s2.push(&amp;i);</div>
<div class=CC1>  s2.push(&amp;j);</div>
<div class=CC1>  emptyTheStack(s2);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>For convenience we include two <b>emptyStack</b> function templates.
Since function templates don’t support partial specialization, we provide
overloaded templates. The second version of <b>emptyStack</b> is more
specialized than the first, so it is chosen whenever pointer types are used. Three
class templates are instantiated in this program: <b>Stack&lt;int&gt;</b>, <b>Stack&lt;void*&gt;</b>,
and <b>Stack&lt;int*&gt;</b>. <b>Stack&lt;void*&gt;</b> is implicitly
instantiated because <b>Stack&lt;int*&gt;</b> derives from it. A program using
instantiations for many pointer types can produce substantial savings in code
size over just using a single <b>Stack</b> template.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985725" name="_Toc53985725">Name
lookup issues</a></h2>

<p class=MsoNormal>When the compiler encounters an identifier it must determine
the type and scope (and in the case of variables, the lifetime) of the entity
the identifier represents. Templates add complexity to the situation. Because the
compiler doesn’t know everything about a template when it first sees the
definition, it can’t tell whether the template is being used properly until it
sees the template instantiation. This predicament leads to a two-phase process
for template compilation.</p>

<h3><a href="#_TocRef53985726" name="_Toc53985726">Names in templates</a></h3>

<p class=MsoNormal>In the first phase, the compiler parses the template
definition looking for obvious syntax errors and resolving all the names it
can. It can resolve names that do not depend on template parameters using
normal name lookup, and if necessary through argument-dependent lookup (discussed
below). The names it can’t resolve are the so-called <i>dependent name</i><i>s</i>, which depend on template parameters in some way. These can’t be resolved
until the template is instantiated with its actual arguments. So instantiation is
the second phase of template compilation. Here, the compiler determines whether to use an explicit specialization of the template instead of the primary
template.</p>

<p class=MsoNormal>Before you see an example, you must understand two more
terms. A <i>qualified name</i> is a name with a class-name prefix, a name with
an object name and a dot operator, or a name with a pointer to an object and an
arrow operator. Examples of qualified names are:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>MyClass::f();</div>
<div class=CC1>x.f();</div>
<div class=CC1>p-&gt;f();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We use qualified names many times in this book, and most
recently in connection with the <b>typename</b> keyword. These are called
qualified names because the target names (like <b>f</b> above) are explicitly
associated with a class or namespace, which tells the compiler where to look
for the declarations of those names.</p>

<p class=MsoNormal>The other term is <i>argument-dependent lookup</i><a href="#_ftn64" name="_ftnref64"><span
class=MsoFootnoteReference>[64]</span></a> (ADL), a mechanism
originally designed to simplify non-member function calls (including operators)
declared in namespaces. Consider the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#dd0000>// ...</font></div>
<div class=CC1>  std::string s(<font color=#007f00>&quot;hello&quot;</font>);</div>
<div class=CC1>  std::cout &lt;&lt; s &lt;&lt; std::endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that, following the typical practice in header files,
there is no <b>using namespace std</b> directive. Without such a directive, you
must use the “<b>std::</b>”<b> </b>qualifier on the items that are in the <b>std</b>
namespace. We have, however, not qualified everything from <b>std</b> that we
are using. Can you see what is unqualified?</p>

<p class=MsoNormal>We have not specified which operator functions to use. We
want the following to happen, but we don’t want to have to type it!</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>std::<font color=#ff7700>operator</font>&lt;&lt;(std::<font color=#ff7700>operator</font>&lt;&lt;(std::cout,s),std::endl);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To make the original output statement work as desired, ADL
specifies that when an unqualified function call appears and its declaration is
not in (normal) scope, the namespaces of each of its arguments are searched for
a matching function declaration. In the original statement, the first function
call is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>operator</font>&lt;&lt;(std::cout, s);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since there is no such function in scope in our original
excerpt, the compiler notes that this function’s first argument (<b>std::cout</b>)
is in the namespace <b>std;</b> so it adds that namespace to the list of scopes
to search for a unique function that best matches the signature <b>operator&lt;&lt;(std::ostream&amp;,
std::string)</b>. It finds this function declared in the <b>std</b> namespace
via the <b>&lt;string&gt;</b> header.</p>

<p class=MsoNormal>Namespaces would be very inconvenient without ADL. Note that
ADL generally brings in <i>all</i> declarations of the name in question from
all eligible namespaces—if there is no single best match, an ambiguity will
result.</p>

<p class=MsoNormal>To turn off ADL, you can enclose the function name in
parentheses:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>(f)(x, y);  <font color=#dd0000>// ADL suppressed</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now consider the following program:<a href="#_ftn65" name="_ftnref65"><span
class=MsoFootnoteReference>[65]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Lookup.cpp</font></div>
<div class=CC1><font color=#dd0000>// Only produces correct behavior with EDG,</font></div>
<div class=CC1><font color=#dd0000>// and Metrowerks using a special option.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1><font color=#ff7700>using</font> std::endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f(<font color=#ff7700>double</font>) { cout &lt;&lt; <font color=#007f00>&quot;f(double)&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> X {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> g() { f(1); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f(<font color=#ff7700>int</font>) { cout &lt;&lt; <font color=#007f00>&quot;f(int)&quot;</font> &lt;&lt;
endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  X&lt;<font color=#ff7700>int</font>&gt;().g();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The only compiler we have that produces correct behavior
without modification is the Edison Design Group front end,<a href="#_ftn66" name="_ftnref66"><span
class=MsoFootnoteReference>[66]</span></a> although
some compilers, such as Metrowerks, have an option to enable the correct lookup
behavior. The output should be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>f(<font color=#ff7700>double</font>)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>because <b>f</b> is a non-dependent name that can be
resolved early by looking in the context where the template is defined, when
only <b>f(double)</b> is in scope. Unfortunately, there is a lot of existing code
in the industry that depends on the non-standard behavior of binding the call
to <b>f(1)</b> inside <b>g(&nbsp;)</b> to the latter <b>f(int)</b>, so compiler
writers have been reluctant to make the change.</p>

<p class=MsoNormal>Here is a more detailed example:<a href="#_ftn67" name="_ftnref67"><span
class=MsoFootnoteReference>[67]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Lookup2.cpp {-bor}{-g++}{-dmc}</font></div>
<div class=CC1><font color=#dd0000>// Microsoft: use option –Za (ANSI mode)</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1><font color=#ff7700>using</font> std::endl;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> g() { cout &lt;&lt; &quot;global g()” &lt;&lt;
endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Y {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> g() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Y&lt;&quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(T).name() &lt;&lt; &quot;&gt;::g()” &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> h() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Y&lt;&quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(T).name() &lt;&lt; &quot;&gt;::h()” &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>int</font> E;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> <font color=#ff7700>double</font> E;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> swap(T&amp; t1, T&amp; t2)
{</div>
<div class=CC1>  cout &lt;&lt; &quot;global swap” &lt;&lt; endl;</div>
<div class=CC1>  T temp = t1;</div>
<div class=CC1>  t1 = t2;</div>
<div class=CC1>  t2 = temp;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> X : <font color=#ff7700>public</font> Y&lt;T&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  E f() {</div>
<div class=CC1>    g();</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;h();</div>
<div class=CC1>    T t1 = T(), t2 = T(1);</div>
<div class=CC1>    cout &lt;&lt; t1 &lt;&lt; endl;</div>
<div class=CC1>    swap(t1, t2);</div>
<div class=CC1>    std::swap(t1, t2);</div>
<div class=CC1>    cout &lt;&lt; <font color=#ff7700>typeid</font>(E).name() &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> E(t2);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  X&lt;<font color=#ff7700>int</font>&gt; x;</div>
<div class=CC1>  cout &lt;&lt; x.f() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The output from this program should be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>global g()</div>
<div class=CC1>Y&lt;<font color=#ff7700>int</font>&gt;::h()</div>
<div class=CC1>0</div>
<div class=CC1>global swap</div>
<div class=CC1><font color=#ff7700>double</font></div>
<div class=CC1>1</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Looking at the declarations inside of <b>X::f(&nbsp;)</b>:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>E</b>, the return type of <b>X::f(&nbsp;)</b>, is not a
dependent name, so it is looked up when the template is parsed, and the <b>typedef</b>
naming <b>E</b> as a <b>double</b> is found. This may seem strange, since with
non-template classes the declaration of <b>E</b> in the base class would be
found first, but those are the rules. (The base class, <b>Y</b>, is a <i>dependent
base class</i>, so it can’t be searched at template definition time).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The call to <b>g(&nbsp;)</b> is also non-dependent, since there
is no mention of <b>T</b>. If <b>g</b> had parameters that were of class type
of defined in another namespace, ADL would take over, since there is no <b>g</b>
with parameters in scope. As it is, this call matches the global declaration of
<b>g(&nbsp;)</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The call <b>this-&gt;h(&nbsp;)</b> is a qualified name, and the object that qualifies it (<b>this</b>) refers to the current object, which is of type <b>X</b>,
which in turn depends on the name <b>Y&lt;T&gt;</b> by inheritance. There is no
function <b>h(&nbsp;)</b> inside of <b>X</b>, so the lookup will search the
scope of <b>X</b>’s base class, <b>Y&lt;T&gt;</b>. Since this is a dependent
name, it is looked up at instantiation time, when <b>Y&lt;T&gt;</b> are
reliably known (including any potential specializations that might have been
written after the definition of <b>X</b>), so it calls <b>Y&lt;int&gt;::h(&nbsp;)</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The declarations of <b>t1</b> and <b>t2</b> are dependent.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The call to <b>operator&lt;&lt;(cout, t1)</b> is dependent, since
<b>t1</b> is of type <b>T</b>. This is looked up later when <b>T</b> is <b>int</b>,
and the inserter for <b>int</b> is found in <b>std</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The unqualified call to <b>swap(&nbsp;)</b> is dependent because
its arguments are of type <b>T</b>. This ultimately causes a global <b>swap(int&amp;,
int&amp;)</b> to be instantiated.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The qualified call to <b>std::swap(&nbsp;)</b> is <i>not</i>
dependent, because <b>std</b> is a fixed namespace. The compiler knows to look in
<b>std</b> for the proper declaration. (The qualifier on the left of the “<b>::</b>”
must mention a template parameter for a qualified name to be considered
dependent.) The <b>std::swap(&nbsp;)</b> function template later generates <b>std::swap(int&amp;,
int&amp;)</b>, at instantiation time. No more dependent names remain in <b>X&lt;T&gt;::f(&nbsp;)</b>.</p>

<p class=MsoNormal>To clarify and summarize: name lookup is done at the point
of instantiation if the name is dependent, except that for unqualified
dependent names the normal name lookup is also attempted early, at the point of
definition. All non-dependent names in templates are looked up early, at the
time the template definition is parsed. (If necessary, another lookup occurs at
instantiation time, when the type of the actual argument is known.)</p>

<p class=MsoNormal>If you have studied this example to the point that you
understand it, prepare yourself for yet another surprise in the following
section on <b>friend</b> declarations.</p>

<h3><a href="#_TocRef53985727" name="_Toc53985727">Templates and friends</a></h3>

<p class=MsoNormal>A friend function declaration inside a class allows a
non-member function to access non-public members of that class. If the friend
function name is qualified, it will be found in the namespace or class that
qualifies it. If it is unqualified, however, the compiler must make an
assumption about where the definition of the friend function will be, since all
identifiers must have a unique scope. The expectation is that the function will
be defined in the nearest enclosing namespace (non-class) scope that contains
the class granting friendship. Often this is just the global scope. The
following non-template example clarifies this issue:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:FriendScope.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Friendly {</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Friendly(<font color=#ff7700>int</font> theInt) { i = theInt; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>void</font> f(<font color=#ff7700>const</font> Friendly&amp;); <font color=#dd0000>// Needs global
def.</font></div>
<div class=CC1>  <font color=#ff7700>void</font> g() { f(*<font color=#ff7700>this</font>); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> h() {</div>
<div class=CC1>  f(Friendly(1));  <font color=#dd0000>// Uses ADL</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> f(<font color=#ff7700>const</font> Friendly&amp; fo) {  <font color=#dd0000>// Definition of
friend</font></div>
<div class=CC1>  cout &lt;&lt; fo.i &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  h(); <font color=#dd0000>// Prints 1</font></div>
<div class=CC1>  Friendly(2).g(); <font color=#dd0000>// Prints 2</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The declaration of <b>f(&nbsp;)</b> inside the <b>Friendly</b>
class is unqualified, so the compiler will expect to be able to eventually link
that declaration to a definition at file scope (the namespace scope that
contains <b>Friendly</b> in this case). That definition appears after the
definition of the function <b>h(&nbsp;)</b>. The linking of the call to <b>f(&nbsp;)</b>
inside <b>h(&nbsp;)</b> to the same function is a separate matter, however.
This is resolved by ADL. Since the argument of <b>f(&nbsp;)</b> inside <b>h(&nbsp;)</b>
is a <b>Friendly</b> object, the <b>Friendly</b> class is searched for a
declaration of <b>f(&nbsp;)</b>, which succeeds. If the call were <b>f(1)</b>
instead (which makes some sense since 1 can be implicitly converted to <b>Friendly(1)</b>),
the call should fail, since there is no hint of where the compiler should look
for the declaration of <b>f(&nbsp;)</b>. The EDG compiler correctly complains
that <b>f</b> is undefined in that case.</p>

<p class=MsoNormal>Now suppose that <b>Friendly</b> and <b>f</b> are both
templates, as in the following program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:FriendScope2.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Necessary forward declarations:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Friendly;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(<font color=#ff7700>const</font>
Friendly&lt;T&gt;&amp;);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Friendly {</div>
<div class=CC1>  T t;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Friendly(<font color=#ff7700>const</font> T&amp; theT) : t(theT) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>void</font> f&lt;&gt;(<font color=#ff7700>const</font> Friendly&lt;T&gt;&amp;);</div>
<div class=CC1>  <font color=#ff7700>void</font> g() { f(*<font color=#ff7700>this</font>); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> h() {</div>
<div class=CC1>  f(Friendly&lt;<font color=#ff7700>int</font>&gt;(1));</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> f(<font color=#ff7700>const</font>
Friendly&lt;T&gt;&amp; fo) {</div>
<div class=CC1>  cout &lt;&lt; fo.t &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  h();</div>
<div class=CC1>  Friendly&lt;<font color=#ff7700>int</font>&gt;(2).g();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>First notice that angle brackets in the declaration of <b>f</b>
inside <b>Friendly</b>. This is necessary to tell the compiler that <b>f</b> is
a template. Otherwise, the compiler will look for an ordinary function named <b>f</b>
and not find it. We could have inserted the template parameter (<b>&lt;T&gt;</b>)
in the brackets, but it is easily deduced from the declaration.</p>

<p class=MsoNormal>The forward declaration of the function template <b>f</b>
before the class definition is necessary, even though it wasn’t in the previous
example when <b>f</b> was a not a template; the language specifies that friend
function templates must be previously declared. To properly declare <b>f</b>, <b>Friendly</b>
must also have been declared, since <b>f</b> takes a <b>Friendly</b> argument,
hence the forward declaration of <b>Friendly</b> in the beginning. We could
have placed the full definition of <b>f</b> right after the initial declaration
of <b>Friendly</b> instead of separating its definition and declaration, but we
chose instead to leave it in a form that more closely resembles the previous
example.</p>

<p class=MsoNormal>One last option remains for using friends inside templates:
fully define them inside the host class template definition itself. Here is how
the previous example would appear with that change:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:FriendScope3.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Microsoft: use the -Za (ANSI-compliant) option</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Friendly {</div>
<div class=CC1>  T t;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Friendly(<font color=#ff7700>const</font> T&amp; theT) : t(theT) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>void</font> f(<font color=#ff7700>const</font> Friendly&lt;T&gt;&amp; fo) {</div>
<div class=CC1>    cout &lt;&lt; fo.t &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> g() { f(*<font color=#ff7700>this</font>); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> h() {</div>
<div class=CC1>  f(Friendly&lt;<font color=#ff7700>int</font>&gt;(1));</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  h();</div>
<div class=CC1>  Friendly&lt;<font color=#ff7700>int</font>&gt;(2).g();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>There is an important difference between this and the
previous example: <b>f</b> is not a template here, but is an ordinary function.
(Remember that angle brackets were necessary before to imply that <b>f(&nbsp;)</b>
was a template.) Every time the <b>Friendly</b> class template is instantiated,
a new, ordinary function overload is created that takes an argument of the
current <b>Friendly</b> specialization. This is what Dan Saks has called
“making new friends.”<a href="#_ftn68" name="_ftnref68"><span
class=MsoFootnoteReference>[68]</span></a> This
is the most convenient way to define friend functions for templates.</p>

<p class=MsoNormal>To clarify, suppose you want to add non-member friend
operators to a class template. Here is a class template that simply holds a
generic value:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Box {</div>
<div class=CC1>  T t;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Box(<font color=#ff7700>const</font> T&amp; theT) : t(theT) {}</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Without understanding the previous examples in this section,
novices find themselves frustrated because they can’t get a simple stream
output inserter to work. If you don’t define your operators inside the
definition of <b>Box</b>, you must provide the forward declarations we showed
earlier:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Box1.cpp</font></div>
<div class=CC1><font color=#dd0000>// Defines template operators.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Forward declarations</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Box;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>Box&lt;T&gt; <font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> Box&lt;T&gt;&amp;, <font color=#ff7700>const</font>
Box&lt;T&gt;&amp;);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp;, <font color=#ff7700>const</font>
Box&lt;T&gt;&amp;);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Box {</div>
<div class=CC1>  T t;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Box(<font color=#ff7700>const</font> T&amp; theT) : t(theT) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> Box <font color=#ff7700>operator</font>+&lt;&gt;(<font color=#ff7700>const</font> Box&lt;T&gt;&amp;,
<font color=#ff7700>const</font> Box&lt;T&gt;&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt; &lt;&gt;(ostream&amp;,
<font color=#ff7700>const</font> Box&lt;T&gt;&amp;);</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>Box&lt;T&gt; <font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> Box&lt;T&gt;&amp; b1,
<font color=#ff7700>const</font> Box&lt;T&gt;&amp; b2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> Box&lt;T&gt;(b1.t + b2.t);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
Box&lt;T&gt;&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; '[' &lt;&lt; b.t &lt;&lt; ']';</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Box&lt;<font color=#ff7700>int</font>&gt; b1(1), b2(2);</div>
<div class=CC1>  cout &lt;&lt; b1 + b2 &lt;&lt; endl;  <font color=#dd0000>// [3]</font></div>
<div class=CC1><font color=#dd0000>//  cout &lt;&lt; b1 + 2 &lt;&lt; endl; // No implicit
conversions!</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here we are defining both an addition operator and an output
stream operator. The main program reveals a disadvantage of this approach: you
can’t depend on implicit conversions (the expression <b>b1 + 2</b>) because
templates do not provide them. Using the in-class, non-template approach is
shorter and more robust:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Box2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Defines non-template operators.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Box {</div>
<div class=CC1>  T t;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Box(<font color=#ff7700>const</font> T&amp; theT) : t(theT) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> Box&lt;T&gt; <font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> Box&lt;T&gt;&amp;
b1,</div>
<div class=CC1>                          <font color=#ff7700>const</font> Box&lt;T&gt;&amp; b2) {</div>
<div class=CC1>    <font color=#ff7700>return</font> Box&lt;T&gt;(b1.t + b2.t);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
Box&lt;T&gt;&amp; b) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; '[' &lt;&lt; b.t &lt;&lt; ']';</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Box&lt;<font color=#ff7700>int</font>&gt; b1(1), b2(2);</div>
<div class=CC1>  cout &lt;&lt; b1 + b2 &lt;&lt; endl; <font color=#dd0000>// [3]</font></div>
<div class=CC1>  cout &lt;&lt; b1 + 2 &lt;&lt; endl; <font color=#dd0000>// [3]</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because the operators are normal functions (overloaded for
each specialization of <b>Box</b>—just <b>int</b> in this case), implicit
conversions are applied as normal; so the expression <b>b1 + 2</b> is valid.</p>

<p class=MsoNormal>Note that there’s one type in particular that cannot be made
a friend of <b>Box</b>, or any other class template for that matter, and that
type is <b>T</b>—or rather, the type that the class template is parameterized
upon. To the best of our knowledge, there are really no good reasons why this
shouldn’t be allowed, but as is, the declaration <b>friend class T</b> is
illegal, and should not compile.</p>

<h4>Friend templates</h4>

<p class=MsoNormal>You can be precise as to which specializations of a template
are friends of a class. In the examples in the previous section, only the
specialization of the function template <b>f</b> with the same type that
specialized <b>Friendly</b> was a friend. For example, only the specialization <b>f&lt;int&gt;(const
Friendly&lt;int&gt;&amp;)</b> is a friend of the class <b>Friendly&lt;int&gt;</b>.
This was accomplished by using the template parameter for <b>Friendly</b> to
specialize <b>f</b> in its friend declaration. If we had wanted to, we could
have made a particular, fixed specialization of <b>f</b> a friend to all
instances of <b>Friendly</b>, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <font color=#dd0000>// Inside Friendly:</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>void</font> f&lt;&gt;(<font color=#ff7700>const</font> Friendly&lt;<font color=#ff7700>double</font>&gt;&amp;);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>By using <b>double</b> instead of <b>T</b>, the <b>double</b>
specialization of <b>f</b> has access to the non-public members of any <b>Friendly</b>
specialization. The specialization <b>f&lt;double&gt;(&nbsp;)</b> still isn’t
instantiated unless it is explicitly called.</p>

<p class=MsoNormal>Likewise, if you declare a non-template function with no
parameters dependent on <b>T</b>, that single function is a friend to all
instances of <b>Friendly</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <font color=#dd0000>// Inside Friendly:</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>void</font> g(<font color=#ff7700>int</font>);  <font color=#dd0000>// g(int) befriends all Friendlys</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As always, since <b>g(int)</b> is unqualified, it must be
defined at file scope (the namespace scope containing <b>Friendly</b>).</p>

<p class=MsoNormal>It is also possible to arrange for all specializations of <b>f</b>
to be friends for all specializations of <b>Friendly</b>, with a so-called <i>friend
template</i>, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Friendly {</div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> U&gt; <font color=#ff7700>friend</font> <font color=#ff7700>void</font> f&lt;&gt;(<font color=#ff7700>const</font> Friendly&lt;U&gt;&amp;);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since the template argument for the friend declaration is
independent of <b>T</b>, any combination of <b>T</b> and <b>U</b> is allowed,
achieving the friendship objective. Like member templates, friend templates can
appear within non-template classes as well.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985728" name="_Toc53985728">Template
programming idioms</a></h2>

<p class=MsoNormal>Since language is a tool of thought, new language features
tend to spawn new programming techniques. In this section we cover some
commonly used template programming idioms that have emerged in the years since
templates were added to the C++ language.<a href="#_ftn69" name="_ftnref69"><span
class=MsoFootnoteReference>[69]</span></a></p>

<h3><a href="#_TocRef53985729" name="_Toc53985729">Traits</a></h3>

<p class=MsoNormal>The traits template technique, pioneered by Nathan Myers, is a means of bundling type-dependent declarations together. In essence, using
traits you can “mix and match” certain types and values with contexts that use
them in a flexible manner, while keeping your code readable and maintainable.</p>

<p class=MsoNormal>The simplest example of a traits template is the <b>numeric_limits</b> class template defined in <b>&lt;limits&gt;</b>. The primary template is defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> numeric_limits {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_specialized = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> T min() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> T max() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> digits = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> digits10 = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_signed = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_integer = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_exact = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> radix = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> T epsilon() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> T round_error() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> min_exponent = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> min_exponent10 = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> max_exponent = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> max_exponent10 = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> has_infinity = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> has_quiet_NaN = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> has_signaling_NaN = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> float_denorm_style has_denorm =</div>
<div class=CC1>                                  denorm_absent;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> has_denorm_loss = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> T infinity() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> T quiet_NaN() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> T signaling_NaN() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> T denorm_min() <font color=#ff7700>throw</font>();</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_iec559 = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_bounded = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> is_modulo = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> traps = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>bool</font> tinyness_before = <font color=#ff7700>false</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> float_round_style round_style =</div>
<div class=CC1>                                 round_toward_zero;</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>&lt;limits&gt;</b> header defines specializations for
all fundamental, numeric types (when the member <b>is_specialized</b> is set to
<b>true</b>). To obtain the base for the <b>double</b> version of your floating-point
number system, for example, you can use the expression <b>numeric_limits&lt;double&gt;::radix</b>.
To find the smallest integer value available, you can use <b>numeric_limits&lt;int&gt;::min(&nbsp;)</b>.
Not all members of <b>numeric_limits</b> apply to all fundamental types. (For
example, <b>epsilon(&nbsp;)</b> is only meaningful for floating-point types.)</p>

<p class=MsoNormal>The values that will always be integral are static data
members of <b>numeric_limits</b>. Those that may not be integral, such as the
minimum value for <b>float</b>, are implemented as static inline member
functions. This is because C++ allows only <i>integral</i> static data member
constants to be initialized inside a class definition.</p>

<p class=MsoNormal>In Chapter 3 you saw how traits are used to control the
character-processing functionality used by the string classes. The classes <b>std::string</b>
and <b>std::wstring</b> are specializations of the <b>std::basic_string</b>
template, which is defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> charT,</div>
<div class=CC1>  <font color=#ff7700>class</font> traits = char_traits&lt;charT&gt;,</div>
<div class=CC1>  <font color=#ff7700>class</font> allocator = allocator&lt;charT&gt; &gt;</div>
<div class=CC1>  <font color=#ff7700>class</font>
basic_string;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The template parameter <b>charT</b> represents the
underlying character type, which is usually either <b>char</b> or <b>wchar_t</b>.
The primary <b>char_traits</b> template is typically empty, and specializations
for <b>char</b> and <b>wchar_t</b> are provided by the standard library. Here
is the specification of the specialization <b>char_traits&lt;char&gt;</b>
according to the C++ Standard:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>struct</font> char_traits&lt;<font color=#ff7700>char</font>&gt; {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>char</font> char_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>int</font> int_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> streamoff off_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> streampos pos_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> mbstate_t state_type;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> assign(char_type&amp; c1, <font color=#ff7700>const</font>
char_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> eq(<font color=#ff7700>const</font> char_type&amp; c1, <font color=#ff7700>const</font>
char_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> lt(<font color=#ff7700>const</font> char_type&amp; c1, <font color=#ff7700>const</font>
char_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> compare(<font color=#ff7700>const</font> char_type* s1,</div>
<div class=CC1>                     <font color=#ff7700>const</font> char_type* s2, size_t n);</div>
<div class=CC1>  <font color=#ff7700>static</font> size_t length(<font color=#ff7700>const</font> char_type* s);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> char_type* find(<font color=#ff7700>const</font> char_type* s,</div>
<div class=CC1>                               size_t n,</div>
<div class=CC1>                               <font color=#ff7700>const</font> char_type&amp; a);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type* move(char_type* s1,</div>
<div class=CC1>                         <font color=#ff7700>const</font> char_type* s2, size_t
n);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type* copy(char_type* s1,</div>
<div class=CC1>                         <font color=#ff7700>const</font> char_type* s2, size_t
n);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type* assign(char_type* s, size_t n,</div>
<div class=CC1>                           char_type a);</div>
<div class=CC1>  <font color=#ff7700>static</font> int_type not_eof(<font color=#ff7700>const</font> int_type&amp; c);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type to_char_type(<font color=#ff7700>const</font> int_type&amp; c);</div>
<div class=CC1>  <font color=#ff7700>static</font> int_type to_int_type(<font color=#ff7700>const</font> char_type&amp; c);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> eq_int_type(<font color=#ff7700>const</font> int_type&amp; c1,</div>
<div class=CC1>                          <font color=#ff7700>const</font> int_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> int_type eof();</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>These functions are used by the <b>basic_string</b> class
template for character-based operations common to string processing. When you
declare a <b>string</b> variable, such as:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>std::string
s;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>you are actually declaring <b>s</b> as follows (because of
the default template arguments in the specification of <b>basic_string</b>):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>std::basic_string&lt;<font color=#ff7700>char</font>,
std::char_traits&lt;<font color=#ff7700>char</font>&gt;,</div>
<div class=CC1>                  std::allocator&lt;<font color=#ff7700>char</font>&gt; &gt; s;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because the character traits have been separated from the <b>basic_string</b>
class template, you can supply a custom traits class to replace <b>std::char_traits</b>.
The following example illustrates this flexibility:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:BearCorner.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef BEARCORNER_H</font></div>
<div class=CC1><font color=#7F7F00>#define BEARCORNER_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::ostream;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Item classes (traits of guests):</font></div>
<div class=CC1><font color=#ff7700>class</font> Milk {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Milk&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Milk&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> CondensedMilk {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> CondensedMilk
&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Condensed Milk&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Honey {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Honey&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Honey&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Cookies {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Cookies&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Cookies&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Guest classes:</font></div>
<div class=CC1><font color=#ff7700>class</font> Bear {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Bear&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Theodore&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Boy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Boy&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Patrick&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Primary traits template (empty-could hold common
types)</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Guest&gt; <font color=#ff7700>class</font> GuestTraits;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Traits specializations for Guest types</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>class</font> GuestTraits&lt;Bear&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>typedef</font> CondensedMilk beverage_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Honey snack_type;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>class</font> GuestTraits&lt;Boy&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Milk beverage_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Cookies snack_type;</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// BEARCORNER_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:BearCorner.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates traits classes.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;BearCorner.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A custom traits class</font></div>
<div class=CC1><font color=#ff7700>class</font> MixedUpTraits {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Milk beverage_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Honey snack_type;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The Guest template (uses a traits class)</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Guest, <font color=#ff7700>class</font> traits =
GuestTraits&lt;Guest&gt; &gt;</div>
<div class=CC1><font color=#ff7700>class</font> BearCorner {</div>
<div class=CC1>  Guest theGuest;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>typename</font> traits::beverage_type beverage_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>typename</font> traits::snack_type snack_type;</div>
<div class=CC1>  <span lang=SV>beverage_type bev;</span></div>
<div class=CC1><span lang=SV>  snack_type snack;</span></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BearCorner(<font color=#ff7700>const</font> Guest&amp; g) : theGuest(g) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> entertain() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Entertaining &quot;</font> &lt;&lt;
theGuest</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot; serving &quot;</font> &lt;&lt; bev</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot; and &quot;</font> &lt;&lt; snack
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Boy cr;</div>
<div class=CC1>  BearCorner&lt;Boy&gt; pc1(cr);</div>
<div class=CC1>  pc1.entertain();</div>
<div class=CC1>  Bear pb;</div>
<div class=CC1>  BearCorner&lt;Bear&gt; pc2(pb);</div>
<div class=CC1>  pc2.entertain();</div>
<div class=CC1>  BearCorner&lt;Bear, MixedUpTraits&gt; pc3(pb);</div>
<div class=CC1>  pc3.entertain();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this program, instances of the guest classes <b>Boy</b>
and <b>Bear</b> are served items appropriate to their tastes. <b>Boy</b>s like
milk and cookies, and <b>Bear</b>s like condensed milk and honey. This
association of guests to items is done via specializations of a primary (empty)
traits class template. The default arguments to <b>BearCorner</b> ensure that
guests get their proper items, but you can override this by simply providing a
class that meets the requirements of the traits class, as we do with the <b>MixedUpTraits</b>
class above. The output of this program is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Entertaining Patrick serving Milk <font color=#ff7700>and</font> Cookies</div>
<div class=CC1>Entertaining Theodore serving Condensed Milk <font color=#ff7700>and</font> Honey</div>
<div class=CC1>Entertaining Theodore serving
Milk <font color=#ff7700>and</font> Honey</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Using traits provides two key advantages: (1) it allows
flexibility and extensibility in pairing objects with associated attributes or
functionality, and (2) it keeps template parameter lists small and readable. If
30 types were associated with a guest, it would be inconvenient to have to
specify all 30 arguments directly in each <b>BearCorner</b> declaration.
Factoring the types into a separate traits class simplifies things
considerably.</p>

<p class=MsoNormal>The traits technique is also used in implementing streams
and locales, as we showed in Chapter 4. An example of iterator traits is found
in the header file <b>PrintSequence.h</b> in Chapter 6.</p>

<h3><a href="#_TocRef53985730" name="_Toc53985730">Policies</a></h3>

<p class=MsoNormal>If you inspect the <b>char_traits</b> specialization for <b>wchar_t</b>,
you’ll see that it is practically identical to its <b>char</b> counterpart:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>struct</font> char_traits&lt;<font color=#ff7700>wchar_t</font>&gt; {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>wchar_t</font> char_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> wint_t int_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> streamoff off_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> wstreampos pos_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> mbstate_t state_type;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> assign(char_type&amp; c1, <font color=#ff7700>const</font>
char_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> eq(<font color=#ff7700>const</font> char_type&amp; c1, <font color=#ff7700>const</font>
char_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> lt(<font color=#ff7700>const</font> char_type&amp; c1, <font color=#ff7700>const</font>
char_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> compare(<font color=#ff7700>const</font> char_type* s1,</div>
<div class=CC1>                     <font color=#ff7700>const</font> char_type*  s2, size_t n);</div>
<div class=CC1>  <font color=#ff7700>static</font> size_t length(<font color=#ff7700>const</font> char_type* s);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> char_type* find(<font color=#ff7700>const</font> char_type* s,</div>
<div class=CC1>                               size_t n,</div>
<div class=CC1>                               <font color=#ff7700>const</font> char_type&amp; a);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type* move(char_type* s1,</div>
<div class=CC1>                         <font color=#ff7700>const</font> char_type* s2, size_t
n);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type* copy(char_type* s1,</div>
<div class=CC1>                         <font color=#ff7700>const</font> char_type* s2, size_t
n);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type* assign(char_type* s, size_t n,</div>
<div class=CC1>                           char_type a);</div>
<div class=CC1>  <font color=#ff7700>static</font> int_type not_eof(<font color=#ff7700>const</font> int_type&amp; c);</div>
<div class=CC1>  <font color=#ff7700>static</font> char_type to_char_type(<font color=#ff7700>const</font> int_type&amp; c);</div>
<div class=CC1>  <font color=#ff7700>static</font> int_type to_int_type(<font color=#ff7700>const</font> char_type&amp; c);</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>bool</font> eq_int_type(<font color=#ff7700>const</font> int_type&amp; c1,</div>
<div class=CC1>                          <font color=#ff7700>const</font> int_type&amp; c2);</div>
<div class=CC1>  <font color=#ff7700>static</font> int_type eof();</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The only real difference between the two versions is the set
of types involved (<b>char</b> and <b>int</b> vs. <b>wchar_t</b> and <b>wint_t</b>).
The functionality provided is the same.<a href="#_ftn70" name="_ftnref70"><span
class=MsoFootnoteReference>[70]</span></a> This
highlights the fact that traits classes are indeed for <i>traits</i>, and the
things that change between related traits classes are usually types and
constant values, or fixed algorithms that use type-related template parameters.
Traits classes tend to be templates themselves, since the types and constants
they contain are seen as characteristics of the primary template parameter(s) (for
example, <b>char</b> and <b>wchar_t</b>).</p>

<p class=MsoNormal>It is also useful to be able to associate <i>functionality</i>
with template arguments, so that client programmers can easily customize
behavior when they code. The following version of the <b>BearCorner</b> program,
for instance, supports different types of entertainment:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:BearCorner2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates policy classes.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;BearCorner.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Policy classes (require a static doAction()
function):</font></div>
<div class=CC1><font color=#ff7700>class</font> Feed {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>char</font>* doAction() { <font color=#ff7700>return</font>
<font color=#007f00>&quot;Feeding&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Stuff {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>char</font>* doAction() { <font color=#ff7700>return</font>
<font color=#007f00>&quot;Stuffing&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The Guest template (uses a policy and a traits
class)</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Guest, <font color=#ff7700>class</font> Action,</div>
<div class=CC1>         <font color=#ff7700>class</font> traits = GuestTraits&lt;Guest&gt; &gt;</div>
<div class=CC1><font color=#ff7700>class</font> BearCorner {</div>
<div class=CC1>  Guest theGuest;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>typename</font> traits::beverage_type beverage_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>typename</font> traits::snack_type snack_type;</div>
<div class=CC1>  <span lang=SV>beverage_type bev;</span></div>
<div class=CC1><span lang=SV>  snack_type snack;</span></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BearCorner(<font color=#ff7700>const</font> Guest&amp; g) : theGuest(g) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> entertain() {</div>
<div class=CC1>    cout &lt;&lt; Action::doAction() &lt;&lt; <font color=#007f00>&quot;
&quot;</font> &lt;&lt; theGuest</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot; with &quot;</font> &lt;&lt; bev</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot; and &quot;</font> &lt;&lt; snack
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Boy cr;</div>
<div class=CC1>  BearCorner&lt;Boy, Feed&gt; pc1(cr);</div>
<div class=CC1>  pc1.entertain();</div>
<div class=CC1>  Bear pb;</div>
<div class=CC1>  BearCorner&lt;Bear, Stuff&gt; pc2(pb);</div>
<div class=CC1>  pc2.entertain();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Action</b> template parameter in the <b>BearCorner</b>
class expects to have a static member function named <b>doAction(&nbsp;)</b>,
which is used in <b>BearCorner&lt;&gt;::entertain(&nbsp;)</b>. Users can choose
<b>Feed</b> or <b>Stuff</b> at will, both of which provide the required
function. Classes that encapsulate functionality in this way are referred to as
<i>policy classes</i>. The entertainment “policies” are provided above through <b>Feed::doAction(&nbsp;)</b>
and <b>Stuff::doAction(&nbsp;)</b>. These policy classes happen to be ordinary
classes, but they can be templates, and can be combined with inheritance to
great advantage. For more in-depth information on policy-based design, see
Andrei Alexandrescu’s book,<a href="#_ftn71" name="_ftnref71"><span
class=MsoFootnoteReference>[71]</span></a> the
definitive source on the subject.</p>

<h3><a href="#_TocRef53985731" name="_Toc53985731">The curiously recurring template pattern</a></h3>

<p class=MsoNormal>Any novice C++ programmer can figure out how to modify a class to keep track of the number of objects of that class that currently exist. All
you have to do is to add static members, and modify constructor and destructor
logic, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:CountedClass.cpp</font></div>
<div class=CC1><font color=#dd0000>// Object counting via static members.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> CountedClass {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  CountedClass() { ++count; }</div>
<div class=CC1>  CountedClass(<font color=#ff7700>const</font> CountedClass&amp;) { ++count; }</div>
<div class=CC1>  ~CountedClass() { --count; }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> getCount() { <font color=#ff7700>return</font> count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> CountedClass::count = 0;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CountedClass a;</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;   <font color=#dd0000>// 1</font></div>
<div class=CC1>  CountedClass b;</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;   <font color=#dd0000>// 2</font></div>
<div class=CC1>  { <font color=#dd0000>// An arbitrary scope:</font></div>
<div class=CC1>    CountedClass c(b);</div>
<div class=CC1>    cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl; <font color=#dd0000>// 3</font></div>
<div class=CC1>    a = c;</div>
<div class=CC1>    cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl; <font color=#dd0000>// 3</font></div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;   <font color=#dd0000>// 2</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>All constructors of <b>CountedClass</b> increment the static
data member <b>count</b>, and the destructor decrements it. The static member
function <b>getCount(&nbsp;)</b> yields the current number of objects.</p>

<p class=MsoNormal>It would be tedious to manually add these members every time
you wanted to add object counting to a class. The usual object-oriented device used
to repeat or share code is inheritance, which is only half a solution in this
case. Observe what happens when we collect the counting logic into a base
class.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:CountedClass2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Erroneous attempt to count objects.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Counted {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Counted() { ++count; }</div>
<div class=CC1>  Counted(<font color=#ff7700>const</font> Counted&amp;) { ++count; }</div>
<div class=CC1>  ~Counted() { --count; }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> getCount() { <font color=#ff7700>return</font> count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Counted::count = 0;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> CountedClass : <font color=#ff7700>public</font> Counted {};</div>
<div class=CC1><font color=#ff7700>class</font> CountedClass2 : <font color=#ff7700>public</font> Counted {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CountedClass a;</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;    <font color=#dd0000>// 1</font></div>
<div class=CC1>  CountedClass b;</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;    <font color=#dd0000>// 2</font></div>
<div class=CC1>  CountedClass2 c;</div>
<div class=CC1>  cout &lt;&lt; CountedClass2::getCount() &lt;&lt;
endl;   <font color=#dd0000>// 3 (Error)</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>All classes that derive from <b>Counted</b> share the same,
single static data member, so the number of objects is tracked collectively
across all classes in the <b>Counted</b> hierarchy. What is needed is a way to
automatically generate a <i>different</i> base class for each derived class.
This is accomplished by the curious template construct illustrated below:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:CountedClass3.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Counted {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Counted() { ++count; }</div>
<div class=CC1>  Counted(<font color=#ff7700>const</font> Counted&lt;T&gt;&amp;) { ++count; }</div>
<div class=CC1>  ~Counted() { --count; }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> getCount() { <font color=#ff7700>return</font> count; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>int</font> Counted&lt;T&gt;::count =
0;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Curious class definitions</font></div>
<div class=CC1><font color=#ff7700>class</font> CountedClass : <font color=#ff7700>public</font> Counted&lt;CountedClass&gt;
{};</div>
<div class=CC1><font color=#ff7700>class</font> CountedClass2 : <font color=#ff7700>public</font>
Counted&lt;CountedClass2&gt; {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CountedClass a;</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;    <font color=#dd0000>// 1</font></div>
<div class=CC1>  CountedClass b;</div>
<div class=CC1>  cout &lt;&lt; CountedClass::getCount() &lt;&lt;
endl;    <font color=#dd0000>// 2</font></div>
<div class=CC1>  CountedClass2 c;</div>
<div class=CC1>  cout &lt;&lt; CountedClass2::getCount() &lt;&lt;
endl;   <font color=#dd0000>// 1 (!)</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each derived class derives from a unique base class that is
determined by using itself (the derived class) as a template parameter! This
may seem like a circular definition, and it would be, had any base class
members used the template argument in a computation. Since no data members of <b>Counted</b>
are dependent on <b>T</b>, the size of <b>Counted</b> (which is zero!) is known
when the template is parsed. So it doesn’t matter which argument is used to
instantiate <b>Counted</b> because the size is always the same. Any derivation
from an instance of <b>Counted</b> can be completed when it is parsed, and
there is no recursion. Since each base class is unique, it has its own static
data, thus constituting a handy technique for adding counting to any class
whatsoever. Jim Coplien was the first to mention this interesting derivation
idiom in print, which he cited in an article, entitled “Curiously Recurring
Template Patterns.”<span style='position:relative;top:-3.0pt;vertical-align:
baseline !msorm'><span class=MsoFootnoteReference><sup><span style='font-size:
8.0pt;position:relative;top:0pt'> </span></sup></span></span><a href="#_ftn72" name="_ftnref72"><span
class=MsoFootnoteReference>[72]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985732" name="_Toc53985732">Template
metaprogramming</a></h2>

<p class=MsoNormal>In 1993 compilers were beginning to support simple template
constructs so that users could define generic containers and functions. About
the same time that the STL was being considered for adoption into Standard C++,
clever and surprising examples such as the following were passed around among
members of the C++ Standards Committee:<a href="#_ftn73" name="_ftnref73"><span
class=MsoFootnoteReference>[73]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Factorial.cpp</font></div>
<div class=CC1><font color=#dd0000>// Compile-time computation using templates.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n&gt; <font color=#ff7700>struct</font> Factorial {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = Factorial&lt;n-1&gt;::val * n };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>struct</font> Factorial&lt;0&gt; {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = 1 };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; Factorial&lt;12&gt;::val &lt;&lt; endl;
<font color=#dd0000>// 479001600</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>That this program prints the correct value of <b>12!</b> is
not alarming. What is alarming is that the computation is complete before the
program even runs!</p>

<p class=MsoNormal>When the compiler attempts to instantiate <b>Factorial&lt;12&gt;</b>,
it finds it must also instantiate <b>Factorial&lt;11&gt;</b>, which requires <b>Factorial&lt;10&gt;</b>,
and so on. Eventually the recursion ends with the specialization <b>Factorial&lt;1&gt;</b>,
and the computation unwinds. Eventually, <b>Factorial&lt;12&gt;::val</b> is
replaced by the integral constant 479001600, and compilation ends. Since all
the computation is done by the compiler, the values involved must be
compile-time constants, hence the use of <b>enum</b>. When the program runs,
the only work left to do is print that constant followed by a newline. To
convince yourself that a specialization of <b>Factorial</b> results in the
correct compile-time value, you could use it as an array dimension, such as:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>double</font> nums[Factorial&lt;5&gt;::val];</div>
<div class=CC1>assert(<font color=#ff7700>sizeof</font>
nums == <font color=#ff7700>sizeof</font>(<font color=#ff7700>double</font>)*120);</div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef53985733" name="_Toc53985733">Compile–time programming</a></h3>

<p class=MsoNormal>So what was meant to be a convenient way to perform type
parameter substitution turned out to be a mechanism to support compile-time
programming. Such a program is called a <b>template</b> <b>metaprogram</b>
(since you’re in effect “programming a program”), and it turns out that you can
do quite a lot with it. In fact, template metaprogramming is <i>Turing complete</i> because it supports selection (if-else) and looping (through recursion). Theoretically,
then, you can perform any computation with it.<a href="#_ftn74" name="_ftnref74"><span
class=MsoFootnoteReference>[74]</span></a> The
factorial example above shows how to implement repetition: write a recursive
template and provide a stopping criterion via a specialization. The following
example shows how to compute Fibonacci numbers at compile time by the same
technique:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Fibonacci.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n&gt; <font color=#ff7700>struct</font> Fib {</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>enum</font> { val = Fib&lt;n-1&gt;::val +
Fib&lt;n-2&gt;::val };</span></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>struct</font> Fib&lt;1&gt; { <font color=#ff7700>enum</font> { val = 1 };
};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>struct</font>
Fib&lt;0&gt; { <font color=#ff7700>enum</font> { val = 0 }; };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; Fib&lt;5&gt;::val &lt;&lt; endl;   <font color=#dd0000>// 6</font></div>
<div class=CC1>  cout &lt;&lt; Fib&lt;20&gt;::val &lt;&lt; endl;  <font color=#dd0000>//
6765</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Fibonacci numbers are defined mathematically as:</p>

<p class=MsoNormal style='margin-left:1.0in'><span style='position:relative;
top:25.0pt;vertical-align:baseline !msorm'><sub><img width=159 height=75
src="TicV2_files/image011.gif"></sub></span></p>

<p class=MsoNormal>The first two cases lead to the template specializations
above, and the rule in the third line becomes the primary template.</p>

<h4>Compile–time looping</h4>

<p class=MsoNormal>To compute any loop in a template metaprogram, it must first
be reformulated recursively. For example, to raise the integer <b>n</b> to the
power <b>p</b>, instead of using a loop such as in the following lines:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> val = 1;</div>
<div class=CC1><font color=#ff7700>while</font>(p--)</div>
<div class=CC1>  val *=
n;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>you cast it as a recursive procedure:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font> power(<font color=#ff7700>int</font> n, <font color=#ff7700>int</font> p) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (p == 0) ? 1 : n*power(n, p - 1);</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This can now be easily rendered as a template metaprogram:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Power.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> N, <font color=#ff7700>int</font> P&gt; <font color=#ff7700>struct</font> Power {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = N * Power&lt;N, P-1&gt;::val };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> N&gt; <font color=#ff7700>struct</font> Power&lt;N, 0&gt; {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = 1 };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; Power&lt;2, 5&gt;::val &lt;&lt; endl; 
<font color=#dd0000>// 32</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We need to use a partial specialization for the stopping
condition, since the value <b>N</b> is still a free template parameter. Note
that this program only works for non-negative powers.</p>

<p class=MsoNormal>The following metaprogram adapted from Czarnecki and Eisenecker<a href="#_ftn75" name="_ftnref75"><span
class=MsoFootnoteReference>[75]</span></a> is interesting
in that it uses a template template parameter, and simulates passing a function
as a parameter to another function, which “loops through” the numbers <b>0..n</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Accumulate.cpp</font></div>
<div class=CC1><font color=#dd0000>// Passes a &quot;function&quot; as a parameter at
compile time.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Accumulates the results of F(0)..F(n)</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n, <font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font>&gt; <font color=#ff7700>class</font> F&gt; <font color=#ff7700>struct</font>
Accumulate {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = Accumulate&lt;n-1, F&gt;::val +
F&lt;n&gt;::val };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The stopping criterion (returns the value F(0))</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font>&gt; <font color=#ff7700>class</font> F&gt; <font color=#ff7700>struct</font>
Accumulate&lt;0, F&gt; {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = F&lt;0&gt;::val };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Various &quot;functions&quot;:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n&gt; <font color=#ff7700>struct</font>
Identity {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = n };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n&gt; <font color=#ff7700>struct</font> Square {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = n*n };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n&gt; <font color=#ff7700>struct</font> Cube {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = n*n*n };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; Accumulate&lt;4, Identity&gt;::val
&lt;&lt; endl; <font color=#dd0000>// 10</font></div>
<div class=CC1>  cout &lt;&lt; Accumulate&lt;4, Square&gt;::val
&lt;&lt; endl;   <font color=#dd0000>// 30</font></div>
<div class=CC1>  cout &lt;&lt; Accumulate&lt;4, Cube&gt;::val &lt;&lt;
endl;     <font color=#dd0000>// 100</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The primary <b>Accumulate</b> template attempts to compute
the sum <b>F(n)+F(n&#8209;1)…F(0)</b>. The stopping criterion is obtained by a
partial specialization, which “returns” <b>F(0)</b>. The parameter <b>F</b> is
itself a template, and acts like a function as in the previous examples in this
section. The templates <b>Identity</b>, <b>Square</b>, and <b>Cube</b> compute
the corresponding functions of their template parameter that their names
suggest. The first instantiation of <b>Accumulate</b> in <b>main(&nbsp;)</b>
computes the sum 4+3+2+1+0, because the <b>Identity</b> function simply
“returns” its template parameter. The second line in <b>main(&nbsp;)</b> adds
the squares of those numbers (16+9+4+1+0), and the last computes the sum of the
cubes (64+27+8+1+0).</p>

<h4>Loop unrolling</h4>

<p class=MsoNormal>Algorithm designers have always endeavored to optimize their
programs. One time-honored optimization, especially for numeric programming, is
loop unrolling, a technique that minimizes loop overhead. The quintessential
loop-unrolling example is matrix multiplication. The following function
multiplies a matrix and a vector. (Assume that the constants <b>ROWS</b> and <b>COLS</b>
have been previously defined.):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> mult(<font color=#ff7700>int</font> a[ROWS][COLS], <font color=#ff7700>int</font> x[COLS], <font color=#ff7700>int</font> y[COLS])
{</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; ROWS; ++i) {</div>
<div class=CC1>      y[i] = 0;</div>
<div class=CC1>      <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; COLS; ++j)</div>
<div class=CC1>        y[i] += a[i][j]*x[j];</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If <b>COLS</b> is an even number, the overhead of
incrementing and comparing the loop control variable <b>j</b> can be cut in
half by “unrolling” the computation into pairs in the inner loop:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> mult(<font color=#ff7700>int</font> a[ROWS][COLS], <font color=#ff7700>int</font> x[COLS], <font color=#ff7700>int</font> y[COLS])
{</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; ROWS; ++i) {</div>
<div class=CC1>      y[i] = 0;</div>
<div class=CC1>      <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; COLS; j += 2)</div>
<div class=CC1>        y[i] += a[i][j]*x[j] + a[i][j+1]*x[j+1];</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In general, if <b>COLS</b> is a factor of <b>k</b>, <b>k</b>
operations can be performed each time the inner loop iterates, greatly reducing
the overhead. The savings is only noticeable on large arrays, but that is
precisely the case with industrial-strength mathematical computations.</p>

<p class=MsoNormal>Function inlining also constitutes a form of loop unrolling.
Consider the following approach to computing powers of integers:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Unroll.cpp</font></div>
<div class=CC1><font color=#dd0000>// Unrolls an implicit loop via inlining.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n&gt; <font color=#ff7700>inline</font> <font color=#ff7700>int</font> power(<font color=#ff7700>int</font> m) {</div>
<div class=CC1>  <font color=#ff7700>return</font> power&lt;n-1&gt;(m) * m;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>inline</font> <font color=#ff7700>int</font> power&lt;1&gt;(<font color=#ff7700>int</font> m) {</div>
<div class=CC1>  <font color=#ff7700>return</font> m;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>inline</font> <font color=#ff7700>int</font> power&lt;0&gt;(<font color=#ff7700>int</font> m) {</div>
<div class=CC1>  <font color=#ff7700>return</font> 1;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> m = 4;</div>
<div class=CC1>  cout &lt;&lt; power&lt;3&gt;(m) &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Conceptually, the compiler must generate three
specializations of <b>power&lt;&gt;</b>, one each for the template parameters
3, 2, and 1. Because the code for each of these functions can be inlined, the
actual code that is inserted into <b>main(&nbsp;)</b> is the single expression <b>m*m*m</b>.
Thus, a simple template specialization coupled with inlining provides a way to
totally avoid loop control overhead.<a href="#_ftn76" name="_ftnref76"><span
class=MsoFootnoteReference>[76]</span></a> This
approach to loop unrolling is limited by your compiler’s inlining depth.</p>

<h4>Compile–time selection</h4>

<p class=MsoNormal>To simulate conditionals at compile time, you can use the
conditional ternary operator in an <b>enum</b> declaration. The following
program uses this technique to calculate the maximum of two integers at compile
time:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Max.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> n1, <font color=#ff7700>int</font> n2&gt; <font color=#ff7700>struct</font> Max {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { val = n1 &gt; n2 ? n1 : n2 };</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; Max&lt;10, 20&gt;::val &lt;&lt; endl; 
<font color=#dd0000>// 20</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you want to use compile-time conditions to govern custom
code generation, you can use specializations of the values <b>true</b> and <b>false</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Conditionals.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses compile-time conditions to choose code.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>bool</font> cond&gt; <font color=#ff7700>struct</font> Select {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>class</font> Select&lt;<font color=#ff7700>true</font>&gt; {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> statement1() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;This is statement1 executing\n&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> f() { statement1(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>class</font> Select&lt;<font color=#ff7700>false</font>&gt; {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> statement2() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;This is statement2
executing\n&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> f() { statement2(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>bool</font> cond&gt; <font color=#ff7700>void</font> execute() {</div>
<div class=CC1>  Select&lt;cond&gt;::f();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  execute&lt;<font color=#ff7700>sizeof</font>(<font color=#ff7700>int</font>) == 4&gt;();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This program is equivalent to the expression:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(cond)</div>
<div class=CC1>  statement1();</div>
<div class=CC1><font color=#ff7700>else</font></div>
<div class=CC1> 
statement2();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>except that the condition <b>cond</b> is evaluated at
compile time, and the appropriate versions of <b>execute&lt;&gt;(&nbsp;)</b> and
<b>Select&lt;&gt;</b> are instantiated<b> </b>by the compiler. The function <b>Select&lt;&gt;::f(&nbsp;)</b>
executes at runtime. A <b>switch</b> statement can be emulated in similar
fashion, but specializing on each case value instead of the values <b>true</b>
and <b>false</b>.</p>

<h4>Compile–time assertions</h4>

<p class=MsoNormal>In Chapter 2 we touted the virtues of using assertions as
part of an overall defensive programming strategy. An assertion is basically an
evaluation of a Boolean expression followed by a suitable action: do nothing if
the condition is true, or halt with a diagnostic message otherwise. It’s best to
discover assertion failures as soon as possible. If you can evaluate an
expression at compile time, use a compile-time assertion. The following example
uses a technique that maps a Boolean expression to an array declaration:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:StaticAssert1.cpp {-xo}</font></div>
<div class=CC1><font color=#dd0000>// A simple, compile-time assertion facility</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F00>#define STATIC_ASSERT(x) \</font></div>
<div class=CC1>  <font color=#ff7700>do</font> { <font color=#ff7700>typedef</font> <font color=#ff7700>int</font> a[(x) ? 1 : -1]; } <font color=#ff7700>while</font>(0)</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  STATIC_ASSERT(<font color=#ff7700>sizeof</font>(<font color=#ff7700>int</font>) &lt;= <font color=#ff7700>sizeof</font>(<font color=#ff7700>long</font>)); <font color=#dd0000>//
Passes</font></div>
<div class=CC1>  STATIC_ASSERT(<font color=#ff7700>sizeof</font>(<font color=#ff7700>double</font>) &lt;= <font color=#ff7700>sizeof</font>(<font color=#ff7700>int</font>)); <font color=#dd0000>//
Fails</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>do</b> loop creates a temporary scope for the
definition of an array, <b>a</b>, whose size is determined by the condition in
question. It is illegal to define an array of size -1, so when the condition is
false the statement should fail.</p>

<p class=MsoNormal>The previous section showed how to evaluate compile-time Boolean
expressions. The remaining challenge in emulating assertions at compile time is
to print a meaningful error message and halt. All that is required to halt the
compiler is a compile error; the trick is to insert helpful text in the error
message. The following example from Alexandrescu<a href="#_ftn77" name="_ftnref77"><span
class=MsoFootnoteReference>[77]</span></a> uses template
specialization, a local class, and a little macro magic to do the job:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:StaticAssert2.cpp {-g++}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A template and a specialization</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>bool</font>&gt; <font color=#ff7700>struct</font> StaticCheck {</div>
<div class=CC1>  StaticCheck(...);</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;&gt; <font color=#ff7700>struct</font> StaticCheck&lt;<font color=#ff7700>false</font>&gt; {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The macro (generates a local class)</font></div>
<div class=CC1><font color=#7F7F00>#define STATIC_CHECK(expr, msg) {             \</font></div>
<div class=CC1>  <font color=#ff7700>class</font> Error_##msg {};                       \</div>
<div class=CC1>  <font color=#ff7700>sizeof</font>((StaticCheck&lt;expr&gt;(Error_##msg()))); \</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Detects narrowing conversions</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> To, <font color=#ff7700>class</font> From&gt; To safe_cast(From
from) {</div>
<div class=CC1>  STATIC_CHECK(<font color=#ff7700>sizeof</font>(From) &lt;= <font color=#ff7700>sizeof</font>(To),</div>
<div class=CC1>               NarrowingConversion);</div>
<div class=CC1>  <font color=#ff7700>return</font> <font color=#ff7700>reinterpret_cast</font>&lt;To&gt;(from);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>void</font>* p = 0;</div>
<div class=CC1>  <font color=#ff7700>int</font> i = safe_cast&lt;<font color=#ff7700>int</font>&gt;(p);</div>
<div class=CC1>  cout &lt;&lt; &quot;int cast okay” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>//! char c = safe_cast&lt;char&gt;(p);</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example defines a function template, <b>safe_cast&lt;&gt;(&nbsp;)</b>,
that checks to see if the object it is casting from is no larger than the type
of object it casts to. If the size of the target object type is smaller, then
the user will be notified at compile time that a narrowing conversion was
attempted. Notice that the <b>StaticCheck</b> class template has the curious
feature that <i>anything</i> can be converted to an instance of <b>StaticCheck&lt;true&gt;</b>
(because of the ellipsis in its constructor<a href="#_ftn78" name="_ftnref78"><span
class=MsoFootnoteReference>[78]</span></a>),
and <i>nothing</i> can be converted to a <b>StaticCheck&lt;false&gt;</b>
because no conversions are supplied for that specialization. The idea is to
attempt to create an instance of a new class and attempt to convert it to <b>StaticCheck&lt;true&gt;</b>
<i>at compile time</i> whenever the condition of interest is true, or to a <b>StaticCheck&lt;false&gt;</b>
object when the condition being tested is false. Since the <b>sizeof</b>
operator does its work at compile time, it is used to attempt the conversion.
If the condition is false, the compiler will complain that it doesn’t know how
to convert from the new class type to <b>StaticCheck&lt;false&gt;</b>. (The
extra parentheses inside the <b>sizeof</b> invocation in <b>STATIC_CHECK(&nbsp;)</b>
are to prevent the compiler from thinking that we’re trying to invoke <b>sizeof</b>
on a function, which is illegal.) To get some meaningful information inserted
into the error message, the new class name carries key text in its name.</p>

<p class=MsoNormal>The best way to understand this technique is to walk through
a specific case. Consider the line in <b>main(&nbsp;)</b> above which reads:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>   <font color=#ff7700>int</font> i =
safe_cast&lt;<font color=#ff7700>int</font>&gt;(p);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The call to <b>safe_cast&lt;int&gt;(p)</b> contains the
following macro expansion replacing its first line of code:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>{                                                   \</div>
<div class=CC1>   <font color=#ff7700>class</font> Error_NarrowingConversion {};              \</div>
<div class=CC1>   <font color=#ff7700>sizeof</font>(StaticCheck&lt;<font color=#ff7700>sizeof</font>(<font color=#ff7700>void</font>*) &lt;= <font color=#ff7700>sizeof</font>(<font color=#ff7700>int</font>)&gt;
\</div>
<div class=CC1>           (Error_NarrowingConversion()));          \</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>(Recall that the token-pasting preprocessing operator, <b>##</b>,
concatenates its operand into a single token, so <b>Error_##NarrowingConversion</b>
becomes the token <b>Error_NarrowingConversion</b> after preprocessing). The
class <b>Error_NarrowingConversion</b> is a <i>local class</i> (meaning that it
is declared inside a non-namespace scope) because it is not needed elsewhere in
the program. The application of the <b>sizeof</b> operator here attempts to
determine the size of an instance of <b>StaticCheck&lt;true&gt;</b> (because <b>sizeof(void*)
&lt;= sizeof(int)</b> is true on our platforms), created implicitly from the
temporary object returned by the call <b>Error_NarrowingConversion(&nbsp;)</b>.
The compiler knows the size of the new class <b>Error_NarrowingConversion</b> (it’s
empty), and so the compile-time use of <b>sizeof</b> at the outer level in <b>STATIC_CHECK(&nbsp;)</b>
is valid. Since the conversion from the <b>Error_NarrowingConversion</b>
temporary to <b>StaticCheck&lt;true&gt;</b> succeeds, so does this outer
application of <b>sizeof</b>, and execution continues.</p>

<p class=MsoNormal>Now consider what would happen if the comment were removed
from the last line of <b>main(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>   <font color=#ff7700>char</font> c
= safe_cast&lt;<font color=#ff7700>char</font>&gt;(p);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here the <b>STATIC_CHECK(&nbsp;)</b> macro inside <b>safe_cast&lt;char&gt;(p)</b>
expands to:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>{                                                    \</div>
<div class=CC1>   <font color=#ff7700>class</font> Error_NarrowingConversion {};               \</div>
<div class=CC1>   <font color=#ff7700>sizeof</font>(StaticCheck&lt;<font color=#ff7700>sizeof</font>(<font color=#ff7700>void</font>*) &lt;=
<font color=#ff7700>sizeof</font>(<font color=#ff7700>char</font>)&gt; \</div>
<div class=CC1>           (Error_NarrowingConversion()));           \</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since the expression <b>sizeof(void*) &lt;= sizeof(char)</b>
is false, a conversion from an <b>Error_NarrowingConversion</b> temporary to <b>StaticCheck&lt;false&gt;</b>
is attempted, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>sizeof</font>(StaticCheck&lt;<font color=#ff7700>false</font>&gt;(Error_NarrowingConversion()));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which fails, so the compiler halts with a message something
like the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Cannot cast from
'Error_NarrowingConversion' to 'StaticCheck&lt;0&gt;' in function</div>
<div class=CC1><font color=#ff7700>char</font> safe_cast&lt;<font color=#ff7700>char</font>,void *&gt;(<font color=#ff7700>void</font> *)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class name <b>Error_NarrowingConversion</b> is the
meaningful message judiciously arranged by the coder. In general, to perform a
static assertion with this technique, you just invoke the <b>STATIC_CHECK</b>
macro with the compile-time condition to check and with a meaningful name to
describe the error.</p>

<h3><a href="#_TocRef53985734" name="_Toc53985734">Expression templates</a></h3>

<p class=MsoNormal>Perhaps the most powerful application of templates is a
technique discovered independently in 1994 by Todd Veldhuizen<a href="#_ftn79" name="_ftnref79"><span
class=MsoFootnoteReference>[79]</span></a> and Daveed
Vandevoorde:<a href="#_ftn80" name="_ftnref80"><span
class=MsoFootnoteReference>[80]</span></a> <i>expression
templates</i>. Expression templates enable extensive compile-time optimization
of certain computations that result in code that is at least as fast as
hand-optimized Fortran, and yet preserves the natural notation of mathematics
via operator overloading. Although you wouldn’t be likely to use this technique
in everyday programming, it is the basis for a number of sophisticated,
high-performance mathematical libraries written in C++.<a href="#_ftn81" name="_ftnref81"><span
class=MsoFootnoteReference>[81]</span></a></p>

<p class=MsoNormal>To motivate the need for expression templates, consider typical
numerical linear algebra operations, such as adding together two matrices or
vectors,<a href="#_ftn82" name="_ftnref82"><span
class=MsoFootnoteReference>[82]</span></a> such as in the
following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>D = A + B
+ C;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In naive implementations, this expression would result in a
number of temporaries—one for <b>A+B</b>, and one for (<b>A+B)+C</b>. When
these variables represent immense matrices or vectors, the coincident drain on
resources is unacceptable. Expression templates allow you to use the same
expression without temporaries.</p>

<p class=MsoNormal>The following program defines a <b>MyVector</b> class to
simulate mathematical vectors of any size. We use a non-type template argument
for the length of the vector. We also define a <b>MyVectorSum</b> class to act
as a proxy class for a sum of <b>MyVector</b> objects. This allows us to use
lazy evaluation, so the addition of vector components is performed on demand
without the need for temporaries.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MyVector.cpp</font></div>
<div class=CC1><font color=#dd0000>// Optimizes away temporaries via templates.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A proxy class for sums of vectors</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>, size_t&gt; <font color=#ff7700>class</font> MyVectorSum;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>class</font> MyVector {</div>
<div class=CC1>  T data[N];</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MyVector&lt;T,N&gt;&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font>
MyVector&lt;T,N&gt;&amp; right) {</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>      <span lang=IT>data[i] = right.data[i];</span></div>
<div class=CC1><span lang=IT>    </span><font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  MyVector&lt;T,N&gt;&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font>
MyVectorSum&lt;T,N&gt;&amp; right);</div>
<div class=CC1>  <font color=#ff7700>const</font> T&amp; <font color=#ff7700>operator</font>[](size_t i) <font color=#ff7700>const</font> { <font color=#ff7700>return</font>
data[i]; }</div>
<div class=CC1>  T&amp; <font color=#ff7700>operator</font>[](size_t i) { <font color=#ff7700>return</font> data[i]; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Proxy class hold references; uses lazy addition</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>class</font> MyVectorSum {</div>
<div class=CC1>  <font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; left;</div>
<div class=CC1>  <font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; right;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MyVectorSum(<font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; lhs,</div>
<div class=CC1>              <font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; rhs)</div>
<div class=CC1>  : left(lhs), right(rhs) {}</div>
<div class=CC1>  T <font color=#ff7700>operator</font>[](size_t i) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>return</font> left[i] + right[i];</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Operator to support v3 = v1 + v2</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; MyVector&lt;T,N&gt;&amp;</div>
<div class=CC1>MyVector&lt;T,N&gt;::<font color=#ff7700>operator</font>=(<font color=#ff7700>const</font>
MyVectorSum&lt;T,N&gt;&amp; right) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>    data[i] = right[i];</div>
<div class=CC1>  <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// operator+ just stores references</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>inline</font>
MyVectorSum&lt;T,N&gt;</div>
<div class=CC1><font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; left,</div>
<div class=CC1>          <font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; right) {</div>
<div class=CC1>  <font color=#ff7700>return</font> MyVectorSum&lt;T,N&gt;(left, right);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Convenience functions for the test program below</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>void</font>
init(MyVector&lt;T,N&gt;&amp; v) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>    v[i] = rand() % 100;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>void</font>
print(MyVector&lt;T,N&gt;&amp; v) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>    cout &lt;&lt; v[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v1;</div>
<div class=CC1>  init(v1);</div>
<div class=CC1>  print(v1);</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v2;</div>
<div class=CC1>  init(v2);</div>
<div class=CC1>  print(v2);</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v3;</div>
<div class=CC1>  v3 = v1 + v2;</div>
<div class=CC1>  print(v3);</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v4;</div>
<div class=CC1>  <font color=#dd0000>// Not yet supported:</font></div>
<div class=CC1><font color=#dd0000>//!  v4 = v1 + v2 + v3;</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>MyVectorSum</b> class does no computation when it is
created; it merely holds references to the two vectors to be added. Calculations
happen only when you access a component of a vector sum (see its <b>operator[&nbsp;](&nbsp;)</b>).
The overload of the assignment operator for <b>MyVector</b> that takes a <b>MyVectorSum</b>
argument is for an expression such as:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>v1 = v2 + v3; 
<font color=#dd0000>// Add two vectors</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When the expression <b>v1+v2</b> is evaluated, a <b>MyVectorSum</b>
object is returned (or actually, inserted inline, since that <b>operator+(&nbsp;)</b>
is declared <b>inline</b>). This is a small, fixed-size object (it holds only
two references). Then the assignment operator mentioned above is invoked:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>v3.<font color=#ff7700>operator</font>=&lt;<font color=#ff7700>int</font>,5&gt;(MyVectorSum&lt;<font color=#ff7700>int</font>,5&gt;(v2,
v3));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This assigns to each element of <b>v3</b> the sum of the
corresponding elements of <b>v1</b> and <b>v2</b>, computed in real time. No
temporary <b>MyVector</b> objects are created.</p>

<p class=MsoNormal>This program does not support an expression that has more
than two operands, however, such as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>v4 = v1 +
v2 + v3;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The reason is that, after the first addition, a second
addition is attempted:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>(v1 + v2) <b>+</b>
v3;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which would require an <b>operator+(&nbsp;)</b> with a first
argument of <b>MyVectorSum</b> and a second argument of type <b>MyVector</b>.
We could attempt to provide a number of overloads to meet all situations, but
it is better to let templates do the work, as in the following version of the
program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MyVector2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Handles sums of any length with expression templates.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A proxy class for sums of vectors</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>, size_t, <font color=#ff7700>class</font>, <font color=#ff7700>class</font>&gt; <font color=#ff7700>class</font>
MyVectorSum;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>class</font> MyVector {</div>
<div class=CC1>  T data[N];</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MyVector&lt;T,N&gt;&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font>
MyVector&lt;T,N&gt;&amp; right) {</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>      <span lang=IT>data[i] = right.data[i];</span></div>
<div class=CC1><span lang=IT>    </span><font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Left, <font color=#ff7700>class</font>
Right&gt; MyVector&lt;T,N&gt;&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font>
MyVectorSum&lt;T,N,Left,Right&gt;&amp; right);</div>
<div class=CC1>  <font color=#ff7700>const</font> T&amp; <font color=#ff7700>operator</font>[](size_t i) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>return</font> data[i];</div>
<div class=CC1>  }</div>
<div class=CC1>  T&amp; <font color=#ff7700>operator</font>[](size_t i) {</div>
<div class=CC1>    <font color=#ff7700>return</font> data[i];</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Allows mixing MyVector and MyVectorSum</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N, <font color=#ff7700>class</font> Left, <font color=#ff7700>class</font>
Right&gt;</div>
<div class=CC1><font color=#ff7700>class</font> MyVectorSum {</div>
<div class=CC1>  <font color=#ff7700>const</font> Left&amp; left;</div>
<div class=CC1>  <font color=#ff7700>const</font> Right&amp; right;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MyVectorSum(<font color=#ff7700>const</font> Left&amp; lhs, <font color=#ff7700>const</font> Right&amp;
rhs)</div>
<div class=CC1>  : left(lhs), right(rhs) {}</div>
<div class=CC1>  T <font color=#ff7700>operator</font>[](size_t i) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>return</font> left[i] + right[i];</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Left, <font color=#ff7700>class</font> Right&gt;</div>
<div class=CC1>MyVector&lt;T,N&gt;&amp;</div>
<div class=CC1>MyVector&lt;T,N&gt;::</div>
<div class=CC1><font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> MyVectorSum&lt;T,N,Left,Right&gt;&amp;
right) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>    data[i] = right[i];</div>
<div class=CC1>  <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#dd0000>// operator+ just stores references</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt;</div>
<div class=CC1><font color=#ff7700>inline</font>
MyVectorSum&lt;T,N,MyVector&lt;T,N&gt;,MyVector&lt;T,N&gt; &gt;</div>
<div class=CC1><font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; left,</div>
<div class=CC1>          <font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; right) {</div>
<div class=CC1>  <font color=#ff7700>return</font>
MyVectorSum&lt;T,N,MyVector&lt;T,N&gt;,MyVector&lt;T,N&gt; &gt;</div>
<div class=CC1>      (left,right);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N, <font color=#ff7700>class</font> Left, <font color=#ff7700>class</font>
Right&gt;</div>
<div class=CC1><font color=#ff7700>inline</font> MyVectorSum&lt;T, N,
MyVectorSum&lt;T,N,Left,Right&gt;,</div>
<div class=CC1>            MyVector&lt;T,N&gt; &gt;</div>
<div class=CC1><font color=#ff7700>operator</font>+(<font color=#ff7700>const</font> MyVectorSum&lt;T,N,Left,Right&gt;&amp;
left,</div>
<div class=CC1>          <font color=#ff7700>const</font> MyVector&lt;T,N&gt;&amp; right) {</div>
<div class=CC1>  <font color=#ff7700>return</font>
MyVectorSum&lt;T,N,MyVectorSum&lt;T,N,Left,Right&gt;,</div>
<div class=CC1>                         MyVector&lt;T,N&gt; &gt;</div>
<div class=CC1>    (left, right);</div>
<div class=CC1>}</div>
<div class=CC1><font color=#dd0000>// Convenience functions for the test program below</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>void</font>
init(MyVector&lt;T,N&gt;&amp; v) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>    v[i] = rand() % 100;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, size_t N&gt; <font color=#ff7700>void</font>
print(MyVector&lt;T,N&gt;&amp; v) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; N; ++i)</div>
<div class=CC1>    cout &lt;&lt; v[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v1;</div>
<div class=CC1>  init(v1);</div>
<div class=CC1>  print(v1);</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v2;</div>
<div class=CC1>  init(v2);</div>
<div class=CC1>  print(v2);</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v3;</div>
<div class=CC1>  v3 = v1 + v2;</div>
<div class=CC1>  print(v3);</div>
<div class=CC1>  <font color=#dd0000>// Now supported:</font></div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v4;</div>
<div class=CC1>  v4 = v1 + v2 + v3;</div>
<div class=CC1>  print(v4);</div>
<div class=CC1>  MyVector&lt;<font color=#ff7700>int</font>, 5&gt; v5;</div>
<div class=CC1>  v5 = v1 + v2 + v3 + v4;</div>
<div class=CC1>  print(v5);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The template facility deduces the argument types of a sum
using the template arguments, <b>Left</b> and <b>Right</b>, instead of
committing to those types ahead of time. The <b>MyVectorSum</b> template takes
these extra two parameters so it can represent a sum of any combination of
pairs of <b>MyVector</b> and <b>MyVectorSum</b>.</p>

<p class=MsoNormal>The assignment operator is now a member function template.
This allows any &lt;<b>T,</b> <b>N&gt;</b> pair to be coupled with any &lt;<b>Left,</b>
<b>Right&gt;</b> pair, so a <b>MyVector</b> object can be assigned from a <b>MyVectorSum</b>
holding references to any possible pair of the types <b>MyVector</b> and <b>MyVectorSum</b>.</p>

<p class=MsoNormal>As we did before, let’s trace through a sample assignment to
understand exactly what takes place, beginning with the expression</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>v4 = v1 +
v2 + v3;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since the resulting expressions become quite unwieldy, in
the explanation that follows, we will use <b>MVS</b> as shorthand for <b>MyVectorSum</b>,
and will omit the template arguments.</p>

<p class=MsoNormal>The first operation is <b>v1+v2</b>, which invokes the
inline <b>operator+(&nbsp;)</b>, which in turn inserts <b>MVS(v1, v2)</b> into
the compilation stream. This is then added to <b>v3</b>, which results in a
temporary object according to the expression <b>MVS(MVS(v1, v2), v3)</b>. The
final representation of the entire statement is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>v4.<font color=#ff7700>operator</font>+(MVS(MVS(v1,
v2), v3));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This transformation is all arranged by the compiler and
explains why this technique carries the moniker “expression templates.” The template
<b>MyVectorSum</b> represents an expression (an addition, in this case), and
the nested calls above are reminiscent of the parse tree of the left-associative
expression <b>v1+v2+v3</b>.</p>

<p class=MsoNormal>An excellent article by Angelika Langer and Klaus Kreft explains how this technique can be extended to more complex computations.<a href="#_ftn83" name="_ftnref83"><span
class=MsoFootnoteReference>[83]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985735" name="_Toc53985735">Template
compilation models</a></h2>

<p class=MsoNormal>You may have noticed that all our template examples place
fully-defined templates within each compilation unit. (For example, we place
them completely within single-file programs, or in header files for multi-file
programs.) This runs counter to the conventional practice of separating ordinary
function definitions from their declarations by placing the latter in header
files and the function implementations in separate (that is, <b>.cpp</b>)
files.</p>

<p class=MsoNormal>The reasons for this traditional separation are:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.75in;text-indent:-.25in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Non-inline function bodies in header files lead to multiple
function definitions, resulting in linker errors.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.75in;text-indent:-.25in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Hiding the implementation from clients helps reduce compile-time
coupling.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.75in;text-indent:-.25in'><span style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Vendors can distribute pre-compiled code (for a particular
compiler) along with headers so that users cannot see the function
implementations.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Compile times are shorter since header files are smaller.</p>

<h3><a href="#_TocRef53985736" name="_Toc53985736">The inclusion model</a></h3>

<p class=MsoNormal>Templates, on the other hand, are not code per se, but
instructions for code generation. Only template instantiations are real code.
When a compiler has seen a complete template definition during a compilation
and then encounters a point of instantiation for that template in the same
translation unit, it must deal with the fact that an equivalent point of
instantiation may be present in another translation unit. The most common
approach consists of generating the code for the instantiation in every
translation unit and letting the linker weed out duplicates. That particular
approach also works well with inline functions that cannot be inlined and with
virtual function tables, which is one of the reasons for its popularity. Nonetheless,
several compilers prefer instead to rely on more complex schemes to avoid
generating a particular instantiation more than once. Either way, it is the
responsibility of the C++ translation system to avoid errors due to multiple
equivalent points of instantiation.</p>

<p class=MsoNormal>A drawback of this approach is that all template source code
is visible to the client, so there is little opportunity for library vendors to
hide their implementation strategies. Another disadvantage of the inclusion
model is that header files are much larger than they would be if function
bodies were compiled separately. This can increase compile times dramatically
over traditional compilation models.</p>

<p class=MsoNormal>To help reduce the large headers required by the inclusion
model, C++ offers two (non-exclusive) alternative code organization mechanisms:
you can manually instantiate each specialization using <i>explicit instantiation</i>
or you can use <i>exported templates</i>, which support a large degree of
separate compilation.</p>

<h3><a href="#_TocRef312374093" name="_Toc312374093">Explicit instantiation</a></h3>

<p class=MsoNormal>You can manually direct the compiler to instantiate any
template specializations of your choice. When you use this technique, there
must be one and only one such directive for each such specialization; otherwise
you might<i> </i>get multiple definition errors, just as you would with
ordinary, non-inline functions with identical signatures. To illustrate, we
first (erroneously) separate the declaration of the <b>min(&nbsp;)</b> template
from earlier in this chapter from its definition, following the normal pattern
for ordinary, non-inline functions. The following example consists of five
files:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>OurMin.h</b>: contains the declaration of the <b>min(&nbsp;)</b>
function template.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>OurMin</b><b>.cpp</b>: contains the definition of the <b>min(&nbsp;)</b>
function template.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>UseMin1.cpp</b>: attempts to use an <b>int</b>-instantiation
of <b>min(&nbsp;)</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>UseMin2.cpp</b>: attempts to use a <b>double</b>-instantiation
of <b>min(&nbsp;)</b>.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>MinMain.cpp</b>: calls <b>usemin1(&nbsp;)</b> and <b>usemin2(&nbsp;)</b>.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:OurMin.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef OURMIN_H</font></div>
<div class=CC1><font color=#7F7F00>#define OURMIN_H</font></div>
<div class=CC1><font color=#dd0000>// The declaration of min()</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font>
T&amp;, <font color=#ff7700>const</font> T&amp;);</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>//
OURMIN_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// OurMin.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;OurMin.h&quot;</font></div>
<div class=CC1><font color=#dd0000>// The definition of min()</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font>
T&amp; a, <font color=#ff7700>const</font> T&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:UseMin1.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;OurMin.h&quot;</font></div>
<div class=CC1><font color=#ff7700>void</font> usemin1() {</div>
<div class=CC1>  <span lang=SV>std::cout &lt;&lt; min(1,2) &lt;&lt;
std::endl;</span></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:UseMin2.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;OurMin.h&quot;</font></div>
<div class=CC1><font color=#ff7700>void</font> usemin2() {</div>
<div class=CC1>  <span lang=SV>std::cout &lt;&lt; min(3.1,4.2)
&lt;&lt; std::endl;</span></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MinMain.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} UseMin1 UseMin2 MinInstances</font></div>
<div class=CC1><font color=#ff7700>void</font> usemin1();</div>
<div class=CC1><font color=#ff7700>void</font> usemin2();</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  usemin1();</div>
<div class=CC1>  usemin2();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When we attempt to build this program, the linker reports
unresolved external references for <b>min&lt;int&gt;(&nbsp;)</b> and <b>min&lt;double&gt;(&nbsp;)</b>.
The reason is that when the compiler encounters the calls to specializations of
<b>min(&nbsp;)</b> in <b>UseMin1</b> and <b>UseMin2</b>, only the declaration
of <b>min(&nbsp;)</b> is visible. Since the definition is not available, the
compiler assumes it will come from some other translation unit, and the needed
specializations are thus not instantiated at that point, leaving the linker to eventually
complain that it cannot find them.</p>

<p class=MsoNormal>To solve this problem, we will introduce a new file, <b>MinInstances.cpp</b>,
that explicitly instantiates the needed specializations of <b>min(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:MinInstances.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;OurMin.cpp&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Explicit Instantiations for int and double</font></div>
<div class=CC1><font color=#ff7700>template</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font>&amp; min&lt;<font color=#ff7700>int</font>&gt;(<font color=#ff7700>const</font> <font color=#ff7700>int</font>&amp;,
<font color=#ff7700>const</font> <font color=#ff7700>int</font>&amp;);</div>
<div class=CC1><font color=#ff7700>template</font> <font color=#ff7700>const</font> <font color=#ff7700>double</font>&amp; min&lt;<font color=#ff7700>double</font>&gt;(<font color=#ff7700>const</font>
<font color=#ff7700>double</font>&amp;,</div>
<div class=CC1>                     
             <font color=#ff7700>const</font> <font color=#ff7700>double</font>&amp;);</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To manually instantiate a particular template
specialization, you precede the specialization’s declaration with the <b>template</b>
keyword. Note that we must include <b>OurMin.cpp</b>, not <b>OurMin.h</b>,
here, because the compiler needs the template definition to perform the
instantiation. This is the only place where we have to do this in this program,<a href="#_ftn84" name="_ftnref84"><span
class=MsoFootnoteReference>[84]</span></a> however, since
it gives us the unique instantiations of <b>min(&nbsp;)</b> that we need—the declarations
alone suffice for the other files. Since we are including <b>OurMin.cpp</b>
with the macro preprocessor, we add include guards:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:OurMin.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#ifndef OURMIN_CPP</font></div>
<div class=CC1><font color=#7F7F00>#define OURMIN_CPP</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;OurMin.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font>
T&amp; a, <font color=#ff7700>const</font> T&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>//
OURMIN_CPP ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now when we compile all the files together into a complete
program, the unique instances of <b>min(&nbsp;)</b> are found, and the program
executes correctly, giving the output:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>1</div>
<div class=CC1>3.1</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can also manually instantiate classes and static data
members. When explicitly instantiating a class, all member functions for the
requested specialization are instantiated, except any that may have been explicitly
instantiated previously. This is important, as it will render many templates
useless when using this mechanism—specifically, templates that implement
different functionality depending on their parameterization type. Implicit
instantiation has the advantage here: only member functions that get called are
instantiated.</p>

<p class=MsoNormal>Explicit instantiation is intended for large projects where
a hefty chunk of compilation time can be avoided. Whether you use implicit or
explicit instantiation is independent of which template compilation you use. You
can use manual instantiation with either the inclusion model or the separation
model (discussed in the next section).</p>

<h3><a href="#_TocRef53985738" name="_Toc53985738">The separation model</a></h3>

<p class=MsoNormal>The separation model of template compilation separates function template definitions or static data member definitions from their
declarations across translation units, just like you do with ordinary functions
and data, by <i>exporting</i> templates. After reading the preceding two
sections, this must sound strange. Why bother to have the inclusion model in
the first place if you can just adhere to the status quo? The reasons are both
historical and technical.</p>

<p class=MsoNormal>Historically, the inclusion model was the first to experience
widespread commercial use—all C++ compilers support the inclusion model. Part
of the reason for that was that the separation model was not well specified
until late in the standardization process, but also that the inclusion model is
easier to implement. A lot of working code was in existence long before the
semantics of the separation model were finalized.</p>

<p class=MsoNormal>The separation model is so difficult to implement that, as
of Summer 2003, only one compiler front end (EDG) supports the separation
model, and at the moment it still requires that template source code be
available at compile time to perform instantiation on demand. Plans are in
place to use some form of intermediate code instead of requiring that the
original source be at hand, at which point you will be able to ship
“pre-compiled” templates without shipping source code. Because of the lookup
complexities explained earlier in this chapter (about dependent names being
looked up in the template definition context), a full template definition still
has to be available in some form when you compile a program that instantiates
it.</p>

<p class=MsoNormal>The syntax to separate the source code of a template
definition from its declaration is easy enough. You use the <b>export</b> keyword:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// C05:OurMin2.h</font></div>
<div class=CC1><font color=#dd0000>// Declares min as an exported template</font></div>
<div class=CC1><font color=#dd0000>// (Only works with EDG-based compilers)</font></div>
<div class=CC1><font color=#7F7F00>#ifndef OURMIN2_H</font></div>
<div class=CC1><font color=#7F7F00>#define OURMIN2_H</font></div>
<div class=CC1><font color=#ff7700>export</font> <font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp;
min(<font color=#ff7700>const</font> T&amp;,</div>
<div class=CC1>                                         <font color=#ff7700>const</font> T&amp;);</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>//
OURMIN2_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Similar to <b>inline</b> or <b>virtual</b>, the <b>export</b>
keyword need only be mentioned once in a compilation stream, where an exported
template is introduced. For this reason, we need not repeat it in the
implementation file, but it is considered good practice to do so:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// C05:OurMin2.cpp</font></div>
<div class=CC1><font color=#dd0000>// The definition of the exported min template</font></div>
<div class=CC1><font color=#dd0000>// (Only works with EDG-based compilers)</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;OurMin2.h&quot;</font></div>
<div class=CC1><font color=#ff7700>export</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>const</font> T&amp; min(<font color=#ff7700>const</font>
T&amp; a, <font color=#ff7700>const</font> T&amp; b) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (a &lt; b) ? a : b;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>UseMin</b> files used previously only need to include
the correct header file (<b>OurMin2.h</b>), and the main program doesn’t
change. Although this appears to give true separation, the file with the
template definition (<b>OurMin2.cpp</b>) must still be shipped to users (because
it must be processed for each instantiation of <b>min(&nbsp;)</b>) until such
time as some form of intermediate code representation of template definitions
is supported. So while the standard does provide for a true separation model,
not all of its benefits can be reaped today. Only one family of compilers
currently supports <b>export</b> (those based on the EDG front end), and these
compilers currently do not exploit the potential ability to distribute template
definitions in compiled form.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985739" name="_Toc53985739">Summary</a></h2>

<p class=MsoNormal>Templates go far beyond simple type parameterization. When
you combine argument type deduction, custom specialization, and template
metaprogramming, C++ templates emerge as a powerful code generation mechanism.</p>

<p class=MsoNormal>One of the weaknesses of C++ templates that we did not
mention is the difficulty in interpreting compile-time error messages. The quantity
of inscrutable text spewed out by the compiler can be quite overwhelming. C++
compilers have improved their template error messages, and Leor Zolman has written a tool called <b>STLFilt</b> that renders these error messages much
more readable by extracting the useful information and throwing away the rest.<a href="#_ftn85" name="_ftnref85"><span
class=MsoFootnoteReference>[85]</span></a></p>

<p class=MsoNormal>Another important idea to take away from this chapter is
that <i>a template implies an interface</i>. That is, even though the <b>template</b>
keyword says “I’ll take any type,” the code in a template definition requires
that certain operators and member functions be supported—that’s the interface.
So in reality, a template definition is saying, “I’ll take any type that
supports this interface.” Things would be much nicer if the compiler could
simply say, “Hey, this type that you’re trying to instantiate the template with
doesn’t support that interface—can’t do it.” Using templates constitutes a sort
of “latent type checking” that is more flexible than the pure object-oriented
practice of requiring all types to derive from certain base classes.</p>

<p class=MsoNormal>In Chapters 6 and 7 we explore in depth the most famous
application of templates, the subset of the Standard C++ library commonly known
as the Standard Template Library (STL). Chapters 9 and 10 also use template
techniques not found in this chapter.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985740" name="_Toc53985740">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a unary function template that takes a single type template
parameter. Create a full specialization for the type <b>int</b>. Also create a
non-template overload for this function that takes a single <b>int</b>
parameter. Have your main program invoke three function variations.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a class template that uses a <b>vector</b> to implement a
stack data structure.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify your solution to the previous exercise so that the type of
the container used to implement the stack is a template template parameter.</p>

<p class=ExercisesCharCharCharCharChar style='margin-top:0in;margin-right:0in;
margin-bottom:6.0pt;margin-left:.95in'><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>In the following code, the class <b>NonComparable</b> does not
have an <b>operator=(&nbsp;)</b>. Why would the presence of the class <b>HardLogic</b>
cause a compile error, but <b>SoftLogic</b> would not?</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Exercise4.cpp {-xo}</font></div>
<div class=CC1><font color=#ff7700>class</font> Noncomparable {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> HardLogic {</div>
<div class=CC1>  Noncomparable nc1, nc2;</div>
<div class=CC1>  <font color=#ff7700>void</font> compare() {</div>
<div class=CC1>    <font color=#ff7700>return</font> nc1 == nc2; <font color=#dd0000>// Compiler error</font></div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>struct</font> SoftLogic {</div>
<div class=CC1>  Noncomparable nc1, nc2;</div>
<div class=CC1>  <font color=#ff7700>void</font> noOp() {}</div>
<div class=CC1>  <font color=#ff7700>void</font> compare() {</div>
<div class=CC1>    nc1 == nc2;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  SoftLogic&lt;Noncomparable&gt; l;</div>
<div class=CC1>  l.noOp();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<p class=ExercisesCharCharCharCharChar style='margin-top:6.0pt;margin-right:
0in;margin-bottom:0in;margin-left:.95in;margin-bottom:.0001pt'><span
style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a function template that takes a single type parameter (<b>T</b>)
and accepts four function arguments: an array of <b>T</b>, a start index, a
stop index (inclusive), and an optional initial value. The function returns the
sum of all the array elements in the specified range and the initial value. Use
the default constructor of <b>T</b> for the default initial value.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Repeat the previous exercise but use explicit instantiation to
manually create specializations for <b>int</b> and <b>double</b>, following the
technique explained in this chapter.</p>

<p class=ExercisesCharCharCharCharChar style='margin-top:0in;margin-right:0in;
margin-bottom:6.0pt;margin-left:.95in'><span style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Why does the following code not compile? (Hint: what do class
member functions have access to?)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Exercise7.cpp {-xo}</font></div>
<div class=CC1><font color=#ff7700>class</font> Buddy {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> My {</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> play(My&lt;Buddy&gt;&amp; s) {</div>
<div class=CC1>    s.i = 3;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  My&lt;<font color=#ff7700>int</font>&gt; h;</div>
<div class=CC1>  My&lt;Buddy&gt; me, bud;</div>
<div class=CC1>  h.play(bud);</div>
<div class=CC1>  me.play(bud);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<p class=ExercisesCharCharCharCharChar style='margin-top:6.0pt;margin-right:
0in;margin-bottom:6.0pt;margin-left:.95in'><span style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Why does the following code not compile?</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.75in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C05:Exercise8.cpp {-xo}</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>double</font> pythag(T a, T b, T c) {</div>
<div class=CC1>  <font color=#ff7700>return</font> (-b + sqrt(<font color=#ff7700>double</font>(b*b - 4*a*c))) / 2*a;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  pythag(1, 2, 3);</div>
<div class=CC1>  pythag(1.0, 2.0, 3.0);</div>
<div class=CC1>  pythag(1, 2.0, 3.0);</div>
<div class=CC1>  pythag&lt;<font color=#ff7700>double</font>&gt;(1, 2.0, 3.0);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<p class=ExercisesCharCharCharCharChar style='margin-top:6.0pt;margin-right:
0in;margin-bottom:0in;margin-left:.95in;margin-bottom:.0001pt'><span
style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write templates that take non-type parameters of the following
variety: an <b>int</b>, a pointer to an <b>int</b>, a pointer to a static class
member of type <b>int</b>, and a pointer to a static member function.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a class template that takes two type parameters. Define a
partial specialization for the first parameter, and another partial
specialization that specifies the second parameter. In each specialization,
introduce members that are not in the primary template.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Define a class template named <b>Bob</b> that takes a single type
parameter. Make <b>Bob</b> a friend of all instances of a template class named <b>Friendly</b>,
and a friend of a class template named <b>Picky</b> only when the type
parameter of <b>Bob</b> and <b>Picky</b> are identical. Give <b>Bob</b> member
functions that demonstrate its friendship.</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section15>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985741" name="_Toc53985741">6: Generic Algorithms</a></h1>

<p class=Intro style='margin-left:.25in'>Algorithms are at the core of
computing. To be able to write an algorithm that works with any type of
sequence makes your programs both simpler and safer. The ability to customize
algorithms at runtime has revolutionized software development.</p>

<p class=MsoNormal>The subset of the Standard C++ library known as the Standard
Template Library (STL) was originally designed around <i>generic algorithms</i>—code that processes sequences of any type of values in a type-safe manner. The
goal was to use predefined algorithms for almost every task, instead of
hand-coding loops every time you need to process a collection of data. This
power comes with a bit of a learning curve, however. By the time you get to the
end of this chapter, you should be able to decide for yourself whether you find
the algorithms addictive or too confusing to remember. If you’re like most
people, you’ll resist them at first but then tend to use them more and more as
time goes on.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef22433867" name="_Toc22433867">A first look</a></h2>

<p class=MsoNormal>Among other things, the generic algorithms in the standard
library provide a vocabulary with which to describe solutions. Once you become
familiar with the algorithms, you’ll have a new set of words with which to
discuss what you’re doing, and these words are at a higher level than what you
had before. You don’t need to say, “This loop moves through and assigns from
here to there … oh, I see, it’s copying!” Instead, you just say <b>copy(&nbsp;)</b>.
This is what we’ve been doing in computer programming from the
beginning—creating high-level abstractions to express <i>what</i> you’re doing
and spending less time saying <i>how</i> you’re doing it. The <i>how</i> has
been solved once and for all and is hidden in the algorithm’s code, ready to be
reused on demand.</p>

<p class=MsoNormal>Here’s an example of how to use the <b>copy</b> algorithm:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyInts.cpp</font></div>
<div class=CC1><font color=#dd0000>// Copies ints without an explicit loop.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;  </font><font color=#dd0000>// For size_t</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  <font color=#ff7700>int</font> b[SIZE];</div>
<div class=CC1>  copy(a, a + SIZE, b);</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; SIZE; ++i)</div>
<div class=CC1>    <span lang=IT>assert(a[i] == b[i]);</span></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>copy(&nbsp;)</b> algorithm’s first two parameters represent the <i>range</i> of the input sequence—in this case the array <b>a</b>.
Ranges are denoted by a pair of pointers. The first points to the first element
of the sequence, and the second points one position <i>past the end</i> of the
array (right after the last element). This may seem strange at first, but it is
an old C idiom that comes in quite handy. For example, the difference of these
two pointers yields the number of elements in the sequence. More important, in
implementing <b>copy</b>, the second pointer can act as a sentinel to stop the
iteration through the sequence. The third argument refers to the beginning of
the output sequence, which is the array <b>b</b> in this example. It is assumed
that the array that <b>b</b> represents has enough space to receive the copied
elements.</p>

<p class=MsoNormal>The <b>copy(&nbsp;)</b> algorithm wouldn’t be very exciting
if it could only process integers. It can copy any kind of sequence. The
following example copies <b>string</b> objects:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=SV><font color=#dd0000>//: C06:CopyStrings.cpp</span></font></div>
<div class=CC1><span lang=SV><font color=#dd0000>// Copies strings.</span></font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string a[] = {<font color=#007f00>&quot;read&quot;</font>, <font color=#007f00>&quot;my&quot;</font>,
<font color=#007f00>&quot;lips&quot;</font>};</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  string b[SIZE];</div>
<div class=CC1>  copy(a, a + SIZE, b);</div>
<div class=CC1>  assert(equal(a, a + SIZE, b));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example introduces another algorithm, <b>equal(&nbsp;)</b>, which returns <b>true</b> only if each element in the first sequence is equal
(using its <b>operator==(&nbsp;)</b>) to the corresponding element in the
second sequence. This example traverses each sequence twice, once for the copy,
and once for the comparison, without a single explicit loop!</p>

<p class=MsoNormal>Generic algorithms achieve this flexibility because they are
function templates. If you think that the implementation of <b>copy(&nbsp;)</b>
looks like the following, you’re almost right:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>void</font> copy(T* begin, T* end,
T* dest) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(begin != end)</div>
<div class=CC1>    *dest++ = *begin++;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We say “almost” because <b>copy(&nbsp;)</b> can process
sequences delimited by anything that acts like a pointer, such as an iterator.
In this way, <b>copy(&nbsp;)</b> can be used to duplicate a <b>vector</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyVector.cpp</font></div>
<div class=CC1><font color=#dd0000>// Copies the contents of a vector.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v1(a, a + SIZE);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v2(SIZE);</div>
<div class=CC1>  copy(v1.begin(), v1.end(), v2.begin());</div>
<div class=CC1>  assert(equal(v1.begin(), v1.end(), v2.begin()));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first <b>vector</b>, <b>v1</b>, is initialized from the
sequence of integers in the array <b>a</b>. The definition of the <b>vector</b>
<b>v2</b> uses a different <b>vector</b> constructor that makes room for <b>SIZE</b>
elements, initialized to zero (the default value for integers).</p>

<p class=MsoNormal>As with the array example earlier, it’s important that <b>v2</b>
have enough space to receive a copy of the contents of <b>v1</b>. For
convenience, a special library function, <b>back_inserter(&nbsp;)</b>, returns a special type of iterator that <i>inserts</i> elements instead of <i>overwriting</i> them, so memory is expanded
automatically by the container as needed. The following example uses <b>back_inserter(&nbsp;)</b>,
so it doesn’t have to establish the size of the output <b>vector</b>, <b>v2</b>,
ahead of time:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:InsertVector.cpp</font></div>
<div class=CC1><font color=#dd0000>// Appends the contents of a vector to another.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v1(a, a + SIZE);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v2;  <font color=#dd0000>// v2 is empty here</font></div>
<div class=CC1>  copy(v1.begin(), v1.end(), back_inserter(v2));</div>
<div class=CC1>  assert(equal(v1.begin(), v1.end(), v2.begin()));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>back_inserter(&nbsp;)</b> function is defined in the <b>&lt;iterator&gt;</b>
header. We’ll explain how insert iterators work in depth in the next chapter.</p>

<p class=MsoNormal>Since iterators are identical to pointers in all essential
ways, you can write the algorithms in the standard library in such a way as to
allow both pointer and iterator arguments. For this reason, the implementation
of <b>copy(&nbsp;)</b> looks more like the following code:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> Iterator&gt;</div>
<div class=CC1><font color=#ff7700>void</font> copy(Iterator begin, Iterator end, Iterator dest)
{</div>
<div class=CC1>  <font color=#ff7700>while</font>(begin != end)</div>
<div class=CC1>    *begin++ = *dest++;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Whichever argument type you use in the call, <b>copy(&nbsp;)</b>
assumes it properly implements the indirection and increment operators. If it
doesn’t, you’ll get a compile-time error.</p>

<h3><a href="#_TocRef22433868" name="_Toc22433868">Predicates</a></h3>

<p class=MsoNormal>At times, you might want to copy only a well-defined subset
of one sequence to another, such as only those elements that satisfy a particular
condition. To achieve this flexibility, many algorithms have alternate calling
sequences that allow you to supply a <i>predicate</i>, which is simply a function that returns a Boolean value based on some criterion. Suppose, for example, that you
only want to extract from a sequence of integers those numbers that are less
than or equal to 15. A version of <b>copy(&nbsp;)</b> called <b>remove_copy_if(&nbsp;)</b> can do the job, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyInts2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Ignores ints that satisfy a predicate.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// You supply this predicate</font></div>
<div class=CC1><font color=#ff7700>bool</font> gt15(<font color=#ff7700>int</font> x) { <font color=#ff7700>return</font> 15 &lt; x; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  <font color=#ff7700>int</font> b[SIZE];</div>
<div class=CC1>  <font color=#ff7700>int</font>* endb = remove_copy_if(a, a+SIZE, b, gt15);</div>
<div class=CC1>  <font color=#ff7700>int</font>* beginb = b;</div>
<div class=CC1>  <font color=#ff7700>while</font>(beginb != endb)</div>
<div class=CC1>    cout &lt;&lt; *beginb++ &lt;&lt; endl; <font color=#dd0000>// Prints 10
only</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>remove_copy_if(&nbsp;)</b> function template takes
the usual range-delimiting pointers, followed by a predicate of your choosing.
The predicate must be a pointer to a function<a href="#_ftn86" name="_ftnref86"><span
class=MsoFootnoteReference>[86]</span></a> that
takes a single argument of the same type as the elements in the sequence, and
it must return a <b>bool</b>. Here, the function <b>gt15</b> returns <b>true</b>
if its argument is greater than 15. The <b>remove_copy_if(&nbsp;)</b> algorithm
applies <b>gt15(&nbsp;)</b> to each element in the input sequence and ignores
those elements where the predicate yields true when writing to the output
sequence.</p>

<p class=MsoNormal>The following program illustrates yet another variation of
the <b>copy</b> algorithm:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyStrings2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Replaces strings that satisfy a predicate.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The predicate</font></div>
<div class=CC1><font color=#ff7700>bool</font> contains_e(<font color=#ff7700>const</font> string&amp; s) {</div>
<div class=CC1>  <font color=#ff7700>return</font> s.find('e') != string::npos;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string a[] = {<font color=#007f00>&quot;read&quot;</font>, <font color=#007f00>&quot;my&quot;</font>,
<font color=#007f00>&quot;lips&quot;</font>};</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  string b[SIZE];</div>
<div class=CC1>  string* endb = replace_copy_if(a, a + SIZE, b,</div>
<div class=CC1>    contains_e, string(<font color=#007f00>&quot;kiss&quot;</font>));</div>
<div class=CC1>  string* beginb = b;</div>
<div class=CC1>  <font color=#ff7700>while</font>(beginb != endb)</div>
<div class=CC1>    cout &lt;&lt; *beginb++ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Instead of just ignoring elements that don’t satisfy the
predicate, <b>replace_copy_if(&nbsp;)</b> substitutes a fixed value for such elements when populating the output sequence. The output is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>kiss</div>
<div class=CC1>my</div>
<div class=CC1>lips</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>because the original occurrence of “read,” the only input
string containing the letter <i>e</i>, is replaced by the word “kiss,” as
specified in the last argument in the call to <b>replace_copy_if(&nbsp;)</b>.</p>

<p class=MsoNormal>The <b>replace_if(&nbsp;)</b> algorithm changes the original sequence in place, instead of writing to a separate output sequence, as the
following program shows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:ReplaceStrings.cpp</font></div>
<div class=CC1><font color=#dd0000>// Replaces strings in-place.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> contains_e(<font color=#ff7700>const</font> string&amp; s) {</div>
<div class=CC1>  <font color=#ff7700>return</font> s.find('e') != string::npos;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string a[] = {<font color=#007f00>&quot;read&quot;</font>, <font color=#007f00>&quot;my&quot;</font>,
<font color=#007f00>&quot;lips&quot;</font>};</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  replace_if(a, a + SIZE, contains_e,
string(<font color=#007f00>&quot;kiss&quot;</font>));</div>
<div class=CC1>  string* p = a;</div>
<div class=CC1>  <font color=#ff7700>while</font>(p != a + SIZE)</div>
<div class=CC1>    cout &lt;&lt; *p++ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef22433869" name="_Toc22433869">Stream iterators</a></h3>

<p class=MsoNormal>Like any good software library, the Standard C++ Library
attempts to provide convenient ways to automate common tasks. We mentioned in
the beginning of this chapter that you can use generic algorithms in place of
looping constructs. So far, however, our examples have still used an explicit
loop to print their output. Since printing output is one of the most common
tasks, you would hope for a way to automate that too.</p>

<p class=MsoNormal>That’s where <i>stream iterators</i> come in. A stream iterator uses a stream as either an input or an output sequence. To eliminate the output loop
in the <b>CopyInts2.cpp</b> program, for instance, you can do something like
the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyInts3.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses an output stream iterator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> gt15(<font color=#ff7700>int</font> x) { <font color=#ff7700>return</font> 15 &lt; x; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  remove_copy_if(a, a + SIZE,</div>
<div class=CC1>                 ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>), gt15);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this example we’ve replaced the output sequence <b>b</b>
in the third argument of <b>remove_copy_if(&nbsp;)</b> with an <i>output</i>
stream iterator, which is an instance of the <b>ostream_iterator</b> class template declared in the <b>&lt;iterator&gt;</b> header. Output stream iterators overload their copy-assignment
operators to write to their stream. This particular instance of <b>ostream_iterator</b>
is attached to the output stream <b>cout</b>. Every time <b>remove_copy_if(&nbsp;)</b>
assigns an integer from the sequence <b>a</b> to <b>cout</b> through this
iterator, the iterator writes the integer to <b>cout</b> and also automatically
writes an instance of the separator string found in its second argument, which
in this case contains the newline character.</p>

<p class=MsoNormal>It is just as easy to write to a file by providing an output
file stream, instead of <b>cout</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyIntsToFile.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses an output file stream iterator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> gt15(<font color=#ff7700>int</font> x) { <font color=#ff7700>return</font> 15 &lt; x; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  ofstream outf(<font color=#007f00>&quot;ints.out&quot;</font>);</div>
<div class=CC1>  remove_copy_if(a, a + SIZE,</div>
<div class=CC1>                 ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(outf,
<font color=#007f00>&quot;\n&quot;</font>), gt15);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>An <i>input</i> stream iterator allows an algorithm to get
its input sequence from an input stream. This is accomplished by having both
the constructor and <b>operator++(&nbsp;)</b> read the next element from the
underlying stream and by overloading <b>operator*(&nbsp;)</b> to yield the
value previously read. Since algorithms require two pointers to delimit an
input sequence, you can construct an <b>istream_iterator</b><b> </b>in two ways, as you can see in the program that follows.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyIntsFromFile.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses an input stream iterator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> gt15(<font color=#ff7700>int</font> x) { <font color=#ff7700>return</font> 15 &lt; x; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ofstream ints(<font color=#007f00>&quot;someInts.dat&quot;</font>);</div>
<div class=CC1>  ints &lt;&lt; <font color=#007f00>&quot;1 3 47 5 84 9&quot;</font>;</div>
<div class=CC1>  ints.close();</div>
<div class=CC1>  ifstream inf(<font color=#007f00>&quot;someInts.dat&quot;</font>);</div>
<div class=CC1>  assure(inf, <font color=#007f00>&quot;someInts.dat&quot;</font>);</div>
<div class=CC1>  remove_copy_if(istream_iterator&lt;<font color=#ff7700>int</font>&gt;(inf),</div>
<div class=CC1>                 istream_iterator&lt;<font color=#ff7700>int</font>&gt;(),</div>
<div class=CC1>                 ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>), gt15);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first argument to <b>replace_copy_if(&nbsp;)</b> in this
program attaches an <b>istream_iterator</b> object to the input file stream
containing <b>int</b>s. The second argument uses the default constructor of the
<b>istream_iterator</b> class. This call constructs a special value of <b>istream_iterator</b>
that indicates end-of-file, so that when the first iterator finally encounters
the end of the physical file, it compares equal to the value <b>istream_iterator&lt;int&gt;(&nbsp;)</b>,
allowing the algorithm to terminate correctly. Note that this example avoids
using an explicit array altogether.</p>

<h3><a href="#_TocRef22433870" name="_Toc22433870">Algorithm complexity</a></h3>

<p class=MsoNormal>Using a software library is a matter of trust. You trust the
implementers to not only provide correct functionality, but you also hope that
the functions execute as efficiently as possible. It’s better to write your own
loops than to use algorithms that degrade performance.</p>

<p class=MsoNormal>To guarantee quality library implementations, the C++
Standard not only specifies what an algorithm should do, but how fast it should
do it and sometimes how much space it should use. Any algorithm that does not
meet the performance requirements does not conform to the standard. The measure
of an algorithm’s operational efficiency is called its <i>complexity</i>.</p>

<p class=MsoNormal>When possible, the standard specifies the exact number of
operation counts an algorithm should use. The <b>count_if</b><b>(&nbsp;)</b> algorithm, for example, returns the number of elements in a sequence satisfying a given
predicate. The following call to <b>count_if(&nbsp;)</b>, if applied to a
sequence of integers similar to the examples earlier in this chapter, yields
the number of integer elements that are greater than 15:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>size_t n = count_if(a, a + SIZE, gt15);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since <b>count_if(&nbsp;)</b> must look at every element
exactly once, it is specified to make a number of comparisons exactly equal to
the number of elements in the sequence. The <b>copy(&nbsp;)</b> algorithm has
the same specification.</p>

<p class=MsoNormal>Other algorithms can be specified to take <i>at most</i> a
certain number of operations. The <b>find</b><b>(&nbsp;)</b> algorithm searches through a sequence in order until it encounters an element equal to its third
argument:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>int</font>* p = find(a, a + SIZE, 20);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>It stops as soon as the element is found and returns a pointer
to that first occurrence. If it doesn’t find one, it returns a pointer one
position past the end of the sequence (<b>a+SIZE</b> in this example). So <b>find()</b>
makes at most a number of comparisons equal to the number of elements in the
sequence.</p>

<p class=MsoNormal>Sometimes the number of operations an algorithm takes cannot
be measured with such precision. In such cases, the standard specifies the
algorithm’s <i>asymptotic complexity</i>, which is a measure of how the
algorithm behaves with large sequences compared to well-known formulas. A good
example is the <b>sort(&nbsp;)</b> algorithm, which the standard says takes
“approximately <b>n log n</b> comparisons on average” (<b>n</b> is the number
of elements in the sequence).<a href="#_ftn87" name="_ftnref87"><span
class=MsoFootnoteReference>[87]</span></a> Such
complexity measures give a “feel” for the cost of an algorithm and at least
give a meaningful basis for comparing algorithms. As you’ll see in the next
chapter, the <b>find(&nbsp;)</b> member function for the <b>set</b> container
has logarithmic complexity, which means that the cost of searching for an
element in a <b>set</b> will, for large sets, be proportional to the logarithm
of the number of elements. This is much smaller than the number of elements for
large <b>n</b>, so it is always better to search a <b>set</b> by using its <b>find(&nbsp;)</b>
member function rather than by using the generic <b>find(&nbsp;)</b> algorithm.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef22433871" name="_Toc22433871">Function objects</a></h2>

<p class=MsoNormal>As you study some of the examples earlier in this chapter,
you will probably notice the limited utility of the function <b>gt15(&nbsp;)</b>.
What if you want to use a number other than 15 as a comparison threshold? You
may need a <b>gt20(&nbsp;)</b> or <b>gt25(&nbsp;)</b> or others as well. Having
to write a separate function is time consuming, but also unreasonable because you
must know all required values when you write your application code.</p>

<p class=MsoNormal>The latter limitation means that you can’t use runtime
values<a href="#_ftn88" name="_ftnref88"><span
class=MsoFootnoteReference>[88]</span></a> to govern your
searches, which is unacceptable. Overcoming this difficulty requires a way to
pass information to predicates at runtime. For example, you would need a
greater-than function that you can initialize with an arbitrary comparison
value. Unfortunately, you can’t pass that value as a function parameter because
unary predicates, such as our <b>gt15(&nbsp;)</b>, are applied to each value in
a sequence individually and must therefore take only one parameter.</p>

<p class=MsoNormal>The way out of this dilemma is, as always, to create an
abstraction. Here, we need an abstraction that can act like a function as well
as store state, without disturbing the number of function parameters it accepts
when used. This abstraction is called a <i>function object</i>.<a href="#_ftn89" name="_ftnref89"><span
class=MsoFootnoteReference>[89]</span></a></p>

<p class=MsoNormal>A function object is an instance of a class that overloads <b>operator(&nbsp;)</b>, the function call operator. This operator allows an object to be used with
function call syntax. As with any other object, you can initialize it via its
constructors. Here is a function object that can be used in place of <b>gt15(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:GreaterThanN.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> gt_n {</div>
<div class=CC1>  <font color=#ff7700>int</font> value;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  gt_n(<font color=#ff7700>int</font> val) : value(val) {}</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>int</font> n) { <font color=#ff7700>return</font> n &gt; value; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  gt_n f(4);</div>
<div class=CC1>  cout &lt;&lt; f(3) &lt;&lt; endl;  <font color=#dd0000>// Prints 0 (for
false)</font></div>
<div class=CC1>  cout &lt;&lt; f(5) &lt;&lt; endl;  <font color=#dd0000>// Prints 1 (for
true)</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The fixed value to compare against (4) is passed when the
function object <b>f</b> is created. The expression <b>f(3)</b> is then evaluated
by the compiler as the following function call:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>f.<font color=#ff7700>operator</font>()(3);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which returns the value of the expression <b>3 &gt; value</b>,
which is false when <b>value</b> is 4, as it is in this example.</p>

<p class=MsoNormal>Since such comparisons apply to types other than <b>int</b>,
it would make sense to define <b>gt_n(&nbsp;)</b> as a class template. It turns
out you don’t need to do it yourself, though—the standard library has already
done it for you. The following descriptions of function objects should not only
make that topic clear, but also give you a better understanding of how the
generic algorithms work.</p>

<h3><a href="#_TocRef22433872" name="_Toc22433872">Classification of
function objects</a></h3>

<p class=MsoNormal>The Standard C++ library classifies a function object based
on the number of arguments its <b>operator(&nbsp;)</b> takes and the kind of value
it returns. This classification is based on whether a function object’s <b>operator(&nbsp;)</b>
takes zero, one, or two arguments:</p>

<p class=MsoNormal><b>Generator</b>: A type of function object that takes no
arguments and returns a value of an arbitrary type. A random number generator
is an example of a generator. The standard library provides one generator, the
function <b>rand(&nbsp;)</b> declared in <b>&lt;cstdlib&gt;</b>, and has some
algorithms, such as <b>generate_n(&nbsp;)</b>, which apply generators to a
sequence.</p>

<p class=MsoNormal><b>Unary Function</b>: A type of function object that takes
a single argument of any type and returns a value that may be of a different
type (which may be <b>void</b>).</p>

<p class=MsoNormal><b>Binary Function</b>: A type of function object that takes
two arguments of any two (possibly distinct) types and returns a value of any
type (including <b>void</b>).</p>

<p class=MsoNormal><b>Unary Predicate</b>: A Unary Function that returns a <b>bool</b>.</p>

<p class=MsoNormal><b>Binary Predicate</b>: A Binary Function that returns a <b>bool</b>.</p>

<p class=MsoNormal><b>Strict Weak Ordering</b>: A binary predicate that allows for a more general interpretation of “equality.” Some of the standard containers
consider two elements equivalent if neither is less than the other (using <b>operator&lt;(&nbsp;)</b>).
This is important when comparing floating-point values, and objects of other
types where <b>operator==(&nbsp;)</b> is unreliable or unavailable. This notion
also applies if you want to sort a sequence of data records (<b>struct</b>s) on
a subset of the <b>struct</b>’s fields. That comparison scheme is considered a
strict weak ordering because two records with equal keys are not really “equal”
as total objects, but they are equal as far as the comparison you’re using is
concerned. The importance of this concept will become clearer in the next
chapter.</p>

<p class=MsoNormal>In addition, certain algorithms make assumptions about the
operations available for the types of objects they process. We will use the
following terms to indicate these assumptions:</p>

<p class=MsoNormal><b>LessThanComparable</b>: A class that has a less-than <b>operator&lt;</b>.</p>

<p class=MsoNormal><b>Assignable</b>: A class that has a copy-assignment <b>operator=</b>
for its own type.</p>

<p class=MsoNormal><b>EqualityComparable</b>: A class that has an equivalence <b>operator==</b> for its own type.</p>

<p class=MsoNormal>We will use these terms later in this chapter to describe
the generic algorithms in the standard library.</p>

<h3><a href="#_TocRef22433873" name="_Toc22433873">Automatic creation of
function objects</a></h3>

<p class=MsoNormal>The <b>&lt;functional&gt;</b> header defines a number of useful generic function objects. They are admittedly simple, but you can use them to compose
more complicated function objects. Consequently, in many instances, you can
construct complicated predicates without writing a single function. You do so
by using <i>function object adaptors</i><a href="#_ftn90" name="_ftnref90"><span
class=MsoFootnoteReference>[90]</span></a><i> </i> to take the simple function objects and adapt them for use with other function
objects in a chain of operations.</p>

<p class=MsoNormal>To illustrate, let’s use only standard function objects to
accomplish what <b>gt15(&nbsp;)</b> did earlier. The standard function object, <b>greater</b>, is a <i>binary</i> function object that returns <b>true</b> if its first
argument is greater than its second argument. We cannot apply this directly to
a sequence of integers through an algorithm such as <b>remove_copy_if(&nbsp;)</b>
because <b>remove_copy_if(&nbsp;)</b> expects a <i>unary</i> predicate. We can
construct a unary predicate on the fly that uses <b>greater</b> to compare its
first argument to a <i>fixed value</i>. We fix the value of the second
parameter at 15 using the function object adaptor <b>bind2nd</b>, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CopyInts4.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses a standard function object and adaptor.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  remove_copy_if(a, a + SIZE,</div>
<div class=CC1>                 ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>),</div>
<div class=CC1>                 bind2nd(greater&lt;<font color=#ff7700>int</font>&gt;(), 15));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This program produces the same result as <b>CopyInts3.cpp</b>,
but without writing our own predicate function <b>gt15(&nbsp;)</b>. The
function object adaptor <b>bind2nd(&nbsp;)</b> is a template function that
creates a function object of type <b>binder2nd</b>, which simply stores the two arguments passed to <b>bind2nd(&nbsp;)</b>, the first of which must be a
binary function or function object (that is, anything that can be called with
two arguments). The <b>operator(&nbsp;)</b> function in <b>binder2nd</b>, which is itself a unary function, calls the binary function it stored, passing it its
incoming parameter and the fixed value it stored.</p>

<p class=MsoNormal>To make the explanation concrete for this example, let’s
call the instance of <b>binder2nd</b> created by <b>bind2nd(&nbsp;)</b> by the
name <b>b</b>. When <b>b</b> is created, it receives two parameters (<b>greater&lt;int&gt;(&nbsp;)</b>
and 15) and stores them. Let’s call the instance of <b>greater&lt;int&gt;</b>
by the name <b>g</b>, and call the instance of the output stream iterator by
the name <b>o</b>. Then the call to <b>remove_copy_if(&nbsp;)</b> earlier conceptually
becomes the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>remove_copy_if(a, a + SIZE, o, b(g, 15).<font color=#ff7700>operator</font>());</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As <b>remove_copy_if</b><b>(&nbsp;)</b> iterates through the sequence, it calls <b>b</b> on each element, to determine whether to ignore
the element when copying to the destination. If we denote the current element
by the name <b>e</b>, that call inside <b>remove_copy_if(&nbsp;)</b> is
equivalent to</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(b(e))</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>but <b>binder2nd</b>’s function call operator just turns
around and calls <b>g(e,15)</b>, so the earlier call is the same as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(greater&lt;<font color=#ff7700>int</font>&gt;(e, 15))</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which is the comparison we were seeking. There is also a <b>bind1st</b><b>(&nbsp;)</b> adaptor that creates a <b>binder1st</b> object, which fixes the <i>first</i> argument of the associated input binary function.</p>

<p class=MsoNormal>As another example, let’s count the number of elements in
the sequence not equal to 20. This time we’ll use the algorithm <b>count_if(&nbsp;)</b>,
introduced earlier. There is a standard binary function object, <b>equal_to</b>, and also a function object adaptor, <b>not1</b><b>(&nbsp;)</b>, that takes a unary function object as a parameter and invert its truth value. The following
program will do the job:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CountNotEqual.cpp</font></div>
<div class=CC1><font color=#dd0000>// Count elements not equal to 20.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 10, 20, 30 };</div>
<div class=CC1>  <font color=#ff7700>const</font> size_t SIZE = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  cout &lt;&lt; count_if(a, a + SIZE,</div>
<div class=CC1>                   not1(bind1st(equal_to&lt;<font color=#ff7700>int</font>&gt;(),
20)));<font color=#dd0000>// 2</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As <b>remove_copy_if(&nbsp;)</b> did in the previous
example, <b>count_if(&nbsp;)</b> calls the predicate in its third argument (let’s
call it <b>n</b>) for each element of its sequence and increments its internal
counter each time <b>true</b> is returned. If, as before, we call the current
element of the sequence by the name <b>e</b>, the statement</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(n(e))</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>in the implementation of <b>count_if </b>is interpreted as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(!bind1st(equal_to&lt;<font color=#ff7700>int</font>&gt;, 20)(e))</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which ends up as</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(!equal_to&lt;<font color=#ff7700>int</font>&gt;(20, e))</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>because <b>not1(&nbsp;)</b> returns the logical negation of
the result of calling its unary function argument. The first argument to <b>equal_to</b>
is 20 because we used <b>bind1st(&nbsp;)</b> instead of <b>bind2nd(&nbsp;)</b>.
Since testing for equality is symmetric in its arguments, we could have used
either <b>bind1st(&nbsp;)</b> or <b>bind2nd(&nbsp;)</b> in this example.</p>

<p class=MsoNormal>The following table shows the templates that generate the
standard function objects, along with the kinds of expressions to which they
apply:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:23.4pt;border-collapse:collapse;border:none;border-collapse:
 collapse !msorm;border:none !msorm'>
 <thead>
  <tr style='height:18.05pt' style='height:18.05pt !msorm'>
   <td width=120 valign=top style='width:1.25in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
   <p class=tablehead0>Name</p>
   </td>
   <td width=132 valign=top style='width:99.0pt;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
   <p class=tablehead0>Type</p>
   </td>
   <td width=216 valign=top style='width:2.25in;border-top:solid windowtext 1.0pt;
   border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
   padding:0in 5.4pt 0in 5.4pt;border-top:solid windowtext 1.0pt !msorm;
   border-left:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
   border-right:none !msorm;padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
   <p class=tablehead0>Result produced </p>
   </td>
  </tr>
 </thead>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>plus</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 + arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>minus</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 - arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>multiplies</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 * arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>divides</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 / arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>modulus</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryFunction</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 % arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>negate</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>UnaryFunction</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>- arg1</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>equal_to</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 == arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>not_equal_to</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 != arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>greater</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 &gt; arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>less</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 &lt; arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>greater_equal</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 &gt;= arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>less_equal</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 &lt;= arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>logical_and</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 &amp;&amp; arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>Logical_or</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>BinaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>arg1 || arg2</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>logical_not</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>UnaryPredicate</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>!arg1</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>unary_negate</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>Unary Logical</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>!(UnaryPredicate(arg1))</p>
  </td>
 </tr>
 <tr style='height:18.05pt' style='height:18.05pt !msorm'>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext><b>binary_negate</b></p>
  </td>
  <td width=132 valign=top style='width:99.0pt;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>Binary Logical</p>
  </td>
  <td width=216 valign=top style='width:2.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border:none !msorm;border-bottom:solid windowtext 1.0pt !msorm;
  padding:0in 5.4pt 0in 5.4pt !msorm;height:18.05pt'>
  <p class=tabletext>!(BinaryPredicate(arg1, arg2))</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><sup>&nbsp;</sup></p>

<h3><a href="#_TocRef22433874" name="_Toc22433874">Adaptable function
objects</a></h3>

<p class=MsoNormal>Standard function adaptors such as <b>bind1st(&nbsp;)</b>
and <b>bind2nd(&nbsp;)</b> make some assumptions about the function objects
they process. Consider the following expression from the last line of the
earlier <b>CountNotEqual.cpp</b> program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>not1(bind1st(equal_to&lt;<font color=#ff7700>int</font>&gt;(), 20))</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>bind1st(&nbsp;)</b> adaptor creates a unary function
object of type <b>binder1st</b>, which simply stores an instance of <b>equal_to&lt;int&gt;</b>
and the value 20. The <b>binder1st::operator(&nbsp;)</b> function needs to know
its argument type and its return type; otherwise, it will not have a valid
declaration. The convention to solve this problem is to expect all function
objects to provide nested type definitions for these types. For unary
functions, the type names are <b>argument_type</b> and <b>result_type</b>; for binary function objects they are <b>first_argument_type</b>, <b>second_argument_type</b>, and <b>result_type</b>. Looking at the implementation of <b>bind1st(&nbsp;)</b> and <b>binder1st</b>
in the <b>&lt;functional&gt;</b> header reveals these expectations. First
inspect <b>bind1st(&nbsp;)</b>, as it might appear in a typical library
implementation:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Op, <font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>binder1st&lt;Op&gt; bind1st(<font color=#ff7700>const</font> Op&amp; f, <font color=#ff7700>const</font>
T&amp; val) {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> <font color=#ff7700>typename</font> Op::first_argument_type Arg1_t;</div>
<div class=CC1>  <font color=#ff7700>return</font> binder1st&lt;Op&gt;(f, Arg1_t(val));</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that the template parameter, <b>Op</b>, which
represents the type of the binary function being adapted by <b>bind1st(&nbsp;)</b>,
must have a nested type named <b>first_argument_type</b>. (Note also the use of
<b>typename</b> to inform the compiler that it is a member <i>type</i> name, as
explained in Chapter 5.) Now see how <b>binder1st</b> uses the type names in <b>Op</b>
in its declaration of its function call operator:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// Inside the implementation for binder1st&lt;Op&gt;</font></div>
<div class=CC1><font color=#ff7700>typename</font> Op::result_type</div>
<div class=CC1><font color=#ff7700>operator</font>()(<font color=#ff7700>const</font> <font color=#ff7700>typename</font> Op::second_argument_type&amp;
x)</div>
<div class=CC1>  <font color=#ff7700>const</font>;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Function objects whose classes provide these type names are
called <i>adaptable function objects</i>.</p>

<p class=MsoNormal>Since these names are expected of all standard function
objects as well as of any function objects you create to use with function
object adaptors, the <b>&lt;functional&gt;</b> header provides two templates
that define these types for you: <b>unary_function</b> and <b>binary_function</b>. You simply derive from these classes while filling in the argument types as template
parameters. Suppose, for example, that we want to make the function object <b>gt_n</b>,
defined earlier in this chapter, adaptable. All we need to do is the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>class</font> gt_n : <font color=#ff7700>public</font> unary_function&lt;<font color=#ff7700>int</font>, <font color=#ff7700>bool</font>&gt; {</div>
<div class=CC1>  <font color=#ff7700>int</font> value;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  gt_n(<font color=#ff7700>int</font> val) : value(val) {}</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>int</font> n) {</div>
<div class=CC1>    <font color=#ff7700>return</font> n &gt; value;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>All <b>unary_function</b> does is to provide the appropriate
type definitions, which it infers from its template parameters as you can see
in its definition:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Arg, <font color=#ff7700>class</font> Result&gt; <font color=#ff7700>struct</font>
unary_function {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Arg argument_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Result result_type;</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>These types become accessible through <b>gt_n</b> because it
derives publicly from <b>unary_function</b>. The <b>binary_function</b>
template behaves in a similar manner.</p>

<h3><a href="#_TocRef22433875" name="_Toc22433875">More function object
examples</a></h3>

<p class=MsoNormal>The following <b>FunctionObjects.cpp</b> example provides
simple tests for most of the built-in basic function object templates. This
way, you can see how to use each template, along with the resulting behavior.
This example uses one of the following generators for convenience:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Generators.h</font></div>
<div class=CC1><font color=#dd0000>// Different ways to fill sequences.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef GENERATORS_H</font></div>
<div class=CC1><font color=#7F7F00>#define GENERATORS_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A generator that can skip over numbers:</font></div>
<div class=CC1><span lang=SV><font color=#ff7700>class</font> SkipGen {</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>int</font> i;</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>int</font> skp;</span></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  SkipGen(<font color=#ff7700>int</font> start = 0, <font color=#ff7700>int</font> skip = 1)</div>
<div class=CC1>  : i(start), skp(skip) {}</div>
<div class=CC1>  <font color=#ff7700>int</font> <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>int</font> r = i;</div>
<div class=CC1>    i += skp;</div>
<div class=CC1>    <font color=#ff7700>return</font> r;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Generate unique random numbers from 0 to mod:</font></div>
<div class=CC1><font color=#ff7700>class</font> URandGen {</div>
<div class=CC1>  std::set&lt;<font color=#ff7700>int</font>&gt; used;</div>
<div class=CC1>  <font color=#ff7700>int</font> limit;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  URandGen(<font color=#ff7700>int</font> lim) : limit(lim) {}</div>
<div class=CC1>  <font color=#ff7700>int</font> <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(<font color=#ff7700>true</font>) {</div>
<div class=CC1>      <font color=#ff7700>int</font> i = <font color=#ff7700>int</font>(std::rand()) % limit;</div>
<div class=CC1>      <font color=#ff7700>if</font>(used.find(i) == used.end()) {</div>
<div class=CC1>        used.insert(i);</div>
<div class=CC1>        <font color=#ff7700>return</font> i;</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Produces random characters:</font></div>
<div class=CC1><font color=#ff7700>class</font> CharGen {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>char</font>* source;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> <font color=#ff7700>int</font> len;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>char</font> <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>return</font> source[std::rand() % len];</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// GENERATORS_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Generators.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>char</font>* CharGen::source = <font color=#007f00>&quot;ABCDEFGHIJK&quot;</font></div>
<div class=CC1> 
<font color=#007f00>&quot;LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</font>;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>int</font> CharGen::len = std::strlen(source);</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We’ll be using these generating functions in various
examples throughout this chapter. The <b>SkipGen</b> function object returns
the next number of an arithmetic sequence whose common difference is held in
its <b>skp</b> data member. A <b>URandGen</b> object generates a unique random
number in a specified range. (It uses a <b>set</b> container, which we’ll
discuss in the next chapter.) A <b>CharGen</b> object returns a random
alphabetic character. Here is a sample program using <b>UrandGen</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:FunctionObjects.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Illustrates selected predefined function object</font></div>
<div class=CC1><font color=#dd0000>// templates from the Standard C++ library.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> Contain, <font color=#ff7700>typename</font> UnaryFunc&gt;</div>
<div class=CC1><font color=#ff7700>void</font> testUnary(Contain&amp; source, Contain&amp; dest,</div>
<div class=CC1>  UnaryFunc f) {</div>
<div class=CC1>  transform(source.begin(), source.end(), dest.begin(),
f);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> Contain1, <font color=#ff7700>typename</font> Contain2,</div>
<div class=CC1>  <font color=#ff7700>typename</font> BinaryFunc&gt;</div>
<div class=CC1><font color=#ff7700>void</font> testBinary(Contain1&amp; src1, Contain1&amp; src2,</div>
<div class=CC1>  Contain2&amp; dest, BinaryFunc f) {</div>
<div class=CC1>  transform(src1.begin(), src1.end(),</div>
<div class=CC1>    src2.begin(), dest.begin(), f);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Executes the expression, then stringizes the</font></div>
<div class=CC1><font color=#dd0000>// expression into the print statement:</font></div>
<div class=CC1><font color=#7F7F00>#define T(EXPR) EXPR; print(r.begin(), r.end(), \</font></div>
<div class=CC1>  <font color=#007f00>&quot;After &quot;</font> #EXPR);</div>
<div class=CC1><font color=#dd0000>// For Boolean tests:</font></div>
<div class=CC1><font color=#7F7F00>#define B(EXPR) EXPR; print(br.begin(), br.end(), \</font></div>
<div class=CC1>  <font color=#007f00>&quot;After &quot;</font> #EXPR);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Boolean random generator:</font></div>
<div class=CC1><font color=#ff7700>struct</font> BRand {</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()() { <font color=#ff7700>return</font> rand() % 2 == 0; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 10;</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> MAX = 50;</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; x(SZ), y(SZ), r(SZ);</div>
<div class=CC1>  <font color=#dd0000>// An integer random number generator:</font></div>
<div class=CC1>  URandGen urg(MAX);</div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate_n(x.begin(), SZ, urg);</div>
<div class=CC1>  generate_n(y.begin(), SZ, urg);</div>
<div class=CC1>  <font color=#dd0000>// Add one to each to guarantee nonzero divide:</font></div>
<div class=CC1>  transform(y.begin(), y.end(), y.begin(),</div>
<div class=CC1>    bind2nd(plus&lt;<font color=#ff7700>int</font>&gt;(), 1));</div>
<div class=CC1>  <font color=#dd0000>// Guarantee one pair of elements is ==:</font></div>
<div class=CC1>  x[0] = y[0];</div>
<div class=CC1>  print(x.begin(), x.end(), <font color=#007f00>&quot;x&quot;</font>);</div>
<div class=CC1>  print(y.begin(), y.end(), <font color=#007f00>&quot;y&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Operate on each element pair of x &amp; y,</font></div>
<div class=CC1>  <font color=#dd0000>// putting the result into r:</font></div>
<div class=CC1>  T(testBinary(x, y, r, plus&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  T(testBinary(x, y, r, minus&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  T(testBinary(x, y, r, multiplies&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  T(testBinary(x, y, r, divides&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  T(testBinary(x, y, r, modulus&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  T(testUnary(x, r, negate&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  vector&lt;<font color=#ff7700>bool</font>&gt; br(SZ); <font color=#dd0000>// For Boolean results</font></div>
<div class=CC1>  B(testBinary(x, y, br, equal_to&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(x, y, br, not_equal_to&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(x, y, br, greater&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(x, y, br, less&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(x, y, br, greater_equal&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(x, y, br, less_equal&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(x, y, br,
not2(greater_equal&lt;<font color=#ff7700>int</font>&gt;())));</div>
<div class=CC1>  B(testBinary(x,y,br,not2(less_equal&lt;<font color=#ff7700>int</font>&gt;())));</div>
<div class=CC1>  vector&lt;<font color=#ff7700>bool</font>&gt; b1(SZ), b2(SZ);</div>
<div class=CC1>  generate_n(b1.begin(), SZ, BRand());</div>
<div class=CC1>  generate_n(b2.begin(), SZ, BRand());</div>
<div class=CC1>  print(b1.begin(), b1.end(), <font color=#007f00>&quot;b1&quot;</font>);</div>
<div class=CC1>  print(b2.begin(), b2.end(), <font color=#007f00>&quot;b2&quot;</font>);</div>
<div class=CC1>  B(testBinary(b1, b2, br, logical_and&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testBinary(b1, b2, br, logical_or&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testUnary(b1, br, logical_not&lt;<font color=#ff7700>int</font>&gt;()));</div>
<div class=CC1>  B(testUnary(b1, br, not1(logical_not&lt;<font color=#ff7700>int</font>&gt;())));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example uses a handy function template, <b>print(&nbsp;)</b>,
which is capable of printing a sequence of any type along with an optional
message. This template appears in the header file <b>PrintSequence.h</b>, and
is explained later in this chapter. </p>

<p class=MsoNormal>The two template functions automate the process of testing
the various function object templates. There are two because the function
objects are either unary or binary. The <b>testUnary(&nbsp;)</b> function takes
a source <b>vector</b>, a destination <b>vector</b>, and a unary function
object to apply to the source <b>vector</b> to produce the destination <b>vector</b>.
In <b>testBinary(&nbsp;)</b>, two source <b>vector</b>s are fed to a binary
function to produce the destination <b>vector</b>. In both cases, the template
functions simply turn around and call the <b>transform(&nbsp;)</b> algorithm,
which applies the unary function or function object found in its fourth
parameter to each sequence element, writing the result to the sequence indicated
by its third parameter, which in this case is the same as the input sequence.</p>

<p class=MsoNormal>For each test, you want to see a string describing the test,
followed by the results of the test. To automate this, the preprocessor comes
in handy; the <b>T(&nbsp;)</b> and <b>B(&nbsp;)</b> macros each take the
expression you want to execute. After evaluating the expression, they pass the
appropriate range to <b>print(&nbsp;)</b>. To produce the message the
expression is “stringized” using the preprocessor. That way you see the code of
the expression that is executed followed by the result <b>vector</b>.</p>

<p class=MsoNormal>The last little tool, <b>BRand</b>, is a generator object
that creates random <b>bool</b> values. To do this, it gets a random number
from <b>rand(&nbsp;)</b> and tests to see if it’s greater than <b>(RAND_MAX+1)/2</b>.
If the random numbers are evenly distributed, this should happen half the time.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, three <b>vector</b>s of <b>int</b>
are created: <b>x</b> and <b>y</b> for source values, and <b>r</b> for results.
To initialize <b>x</b> and <b>y</b> with random values no greater than 50, a
generator of type <b>URandGen</b> from <b>Generators.h</b> is used. The
standard <b>generate_n(&nbsp;)</b> algorithm populates the sequence specified
in its first argument by invoking its third argument (which must be a
generator) a given number of times (specified in its second argument). Since
there is one operation where elements of <b>x</b> are divided by elements of <b>y</b>,
we must ensure that there are no zero values of <b>y</b>. This is accomplished
by once again using the <b>transform</b><b>(&nbsp;)</b> algorithm, taking the source values from <b>y</b> and putting the results back into <b>y</b>. The function
object for this is created with the expression:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>bind2nd(plus&lt;<font color=#ff7700>int</font>&gt;(), 1)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This expression uses the <b>plus</b> function object to add
1 to its first argument. As we did earlier in this chapter, we use a binder adaptor
to make this a unary function so it can applied to the sequence by a single
call to <b>transform(&nbsp;)</b>.</p>

<p class=MsoNormal>Another test in the program compares the elements in the two
<b>vector</b>s for equality, so it is interesting to guarantee that at least
one pair of elements is equivalent; here element zero is chosen.</p>

<p class=MsoNormal>Once the two <b>vector</b>s are printed, <b>T(&nbsp;)</b>
tests each of the function objects that produces a numeric value, and then <b>B(&nbsp;)</b>
tests each function object that produces a Boolean result. The result is placed
into a <b>vector&lt;bool&gt;</b>, and when this <b>vector</b> is printed, it
produces a ‘<b>1</b>’ for a true value and a ‘<b>0</b>’ for a false value. Here
is the output from an execution of <b>FunctionObjects.cpp</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>x:</div>
<div class=CC1>4 8 18 36 22 6 29 19 25 47</div>
<div class=CC1>y:</div>
<div class=CC1>4 14 23 9 11 32 13 15 44 30</div>
<div class=CC1>After testBinary(x, y, r, plus&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>8 22 41 45 33 38 42 34 69 77</div>
<div class=CC1>After testBinary(x, y, r, minus&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 -6 -5 27 11 -26 16 4 -19 17</div>
<div class=CC1>After testBinary(x, y, r, multiplies&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>16 112 414 324 242 192 377 285 1100 1410</div>
<div class=CC1>After testBinary(x, y, r, divides&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>1 0 0 4 2 0 2 1 0 1</div>
<div class=CC1>After testBinary(x, y, r, limit&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 8 18 0 0 6 3 4 25 17</div>
<div class=CC1>After testUnary(x, r, negate&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>-4 -8 -18 -36 -22 -6 -29 -19 -25 -47</div>
<div class=CC1>After testBinary(x, y, br, equal_to&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>1 0 0 0 0 0 0 0 0 0</div>
<div class=CC1>After testBinary(x, y, br, not_equal_to&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 1 1 1 1 1 1 1 1 1</div>
<div class=CC1>After testBinary(x, y, br, greater&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 0 0 1 1 0 1 1 0 1</div>
<div class=CC1>After testBinary(x, y, br, less&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 1 1 0 0 1 0 0 1 0</div>
<div class=CC1>After testBinary(x, y, br, greater_equal&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>1 0 0 1 1 0 1 1 0 1</div>
<div class=CC1>After testBinary(x, y, br, less_equal&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>1 1 1 0 0 1 0 0 1 0</div>
<div class=CC1>After testBinary(x, y, br,
not2(greater_equal&lt;<font color=#ff7700>int</font>&gt;())):</div>
<div class=CC1>0 1 1 0 0 1 0 0 1 0</div>
<div class=CC1>After testBinary(x,y,br,not2(less_equal&lt;<font color=#ff7700>int</font>&gt;())):</div>
<div class=CC1>0 0 0 1 1 0 1 1 0 1</div>
<div class=CC1>b1:</div>
<div class=CC1>0 1 1 0 0 0 1 0 1 1</div>
<div class=CC1>b2:</div>
<div class=CC1>0 1 1 0 0 0 1 0 1 1</div>
<div class=CC1>After testBinary(b1, b2, br, logical_and&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 1 1 0 0 0 1 0 1 1</div>
<div class=CC1>After testBinary(b1, b2, br, logical_or&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>0 1 1 0 0 0 1 0 1 1</div>
<div class=CC1>After testUnary(b1, br, logical_not&lt;<font color=#ff7700>int</font>&gt;()):</div>
<div class=CC1>1 0 0 1 1 1 0 1 0 0</div>
<div class=CC1>After testUnary(b1, br,
not1(logical_not&lt;<font color=#ff7700>int</font>&gt;())):</div>
<div class=CC1>0 1 1 0 0 0 1 0 1 1</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you want the Boolean values to display as “true” and
“false” instead of 1 and 0, call <b>cout.setf(ios::boolalpha)</b>.</p>

<p class=MsoNormal>A binder doesn’t have to produce a unary <i>predicate</i>;
it can also create any unary <i>function</i> (that is, a function that returns
something other than <b>bool</b>). For example, you can to multiply every
element in a <b>vector</b> by 10 using a binder with the <b>transform(&nbsp;)</b>
algorithm:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:FBinder.cpp</font></div>
<div class=CC1><font color=#dd0000>// Binders aren't limited to producing predicates.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ostream_iterator&lt;<font color=#ff7700>int</font>&gt; out(cout,<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v(15);</div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate(v.begin(), v.end(), URandGen(20));</div>
<div class=CC1>  copy(v.begin(), v.end(), out);</div>
<div class=CC1>  transform(v.begin(), v.end(),
v.begin(),</div>
<div class=CC1>           
bind2nd(multiplies&lt;<font color=#ff7700>int</font>&gt;(), 10));</div>
<div class=CC1>  copy(v.begin(), v.end(), out);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since the third argument to <b>transform(&nbsp;) </b>is the
same as the first, the resulting elements are copied back into the source <b>vector</b>.
The function object created by <b>bind2nd</b><b>(&nbsp;)</b> in this case produces an <b>int</b> result.</p>

<p class=MsoNormal>The “bound” argument to a binder cannot be a function
object, but it does not have to be a compile-time constant. For example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:BinderValue.cpp</font></div>
<div class=CC1><font color=#dd0000>// The bound argument can vary.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> boundedRand() { <font color=#ff7700>return</font> rand() % 100; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 20;</div>
<div class=CC1>  <font color=#ff7700>int</font> a[SZ], b[SZ] = {0};</div>
<div class=CC1>  generate(a, a + SZ, boundedRand);</div>
<div class=CC1>  <font color=#ff7700>int</font> val = boundedRand();</div>
<div class=CC1>  <font color=#ff7700>int</font>* end = remove_copy_if(a, a + SZ, b,</div>
<div class=CC1>                           
bind2nd(greater&lt;<font color=#ff7700>int</font>&gt;(), val));</div>
<div class=CC1>  <font color=#dd0000>// Sort for easier viewing:</font></div>
<div class=CC1>  sort(a, a + SZ);</div>
<div class=CC1>  sort(b, end);</div>
<div class=CC1>  ostream_iterator&lt;<font color=#ff7700>int</font>&gt; out(cout, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; &quot;Original Sequence:” &lt;&lt; endl;</div>
<div class=CC1>  copy(a, a + SZ, out); cout &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Values &lt;= &quot;</font> &lt;&lt; val
&lt;&lt; endl;</div>
<div class=CC1>  copy(b, end, out); cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here, an array is filled with 20 random numbers between 0
and 100, and the user provides a value on the command line. In the <b>remove_copy_if</b><b>(&nbsp;)</b> call, you can see that the bound argument to <b>bind2nd(&nbsp;)</b>
is random number in the same range as the sequence. Here is the output from one
run:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Original Sequence:</div>
<div class=CC1>4 12 15 17 19 21 26 30 47 48 56 58 60 63 71 79 82 90 92
95</div>
<div class=CC1>Values &lt;= 41</div>
<div class=CC1>4 12 15 17 19 21 26 30</div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef22433876" name="_Toc22433876">Function pointer adaptors</a></h3>

<p class=MsoNormal>Wherever a function-like entity is expected by an algorithm,
you can supply either a pointer to an ordinary function or a function object.
When the algorithm issues a call, if it is through a function pointer, than the
native function-call mechanism is used. If it is through a function object,
then that object’s <b>operator(&nbsp;)</b> member executes. In <b>CopyInts2.cpp</b>,
we passed the raw function <b>gt15(&nbsp;)</b> as a predicate to <b>remove_copy_if(&nbsp;)</b>.
We also passed pointers to functions returning random numbers to <b>generate(&nbsp;)</b>
and <b>generate_n(&nbsp;)</b>.</p>

<p class=MsoNormal>You cannot use raw functions with function object adaptors
such as <b>bind2nd(&nbsp;)</b> because they assume the existence of type
definitions for the argument and result types. Instead of manually converting
your native functions into function objects yourself, the standard library
provides a family of adaptors to do the work for you. The <b>ptr_fun</b><b>(&nbsp;) </b>adaptors take a pointer to a function and turn it into a function
object. They are not designed for a function that takes no arguments—they must
only be used with unary functions or binary functions.</p>

<p class=MsoNormal>The following program uses <b>ptr_fun(&nbsp;)</b> to wrap a
unary function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:PtrFun1.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using ptr_fun() with a unary function.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> d[] = { 123, 94, 10, 314, 315 };</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>int</font> DSZ = <font color=#ff7700>sizeof</font> d / <font color=#ff7700>sizeof</font> *d;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> isEven(<font color=#ff7700>int</font> x) { <font color=#ff7700>return</font> x % 2 == 0; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;<font color=#ff7700>bool</font>&gt; vb;</div>
<div class=CC1>  transform(d, d + DSZ, back_inserter(vb),</div>
<div class=CC1>    not1(ptr_fun(isEven)));</div>
<div class=CC1>  copy(vb.begin(), vb.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>bool</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Output: 1 0 0 0 1</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We can’t simply pass <b>isEven</b> to <b>not1</b>, because <b>not1</b> needs to know the actual argument type and return type its argument uses. The <b>ptr_fun(&nbsp;)</b>
adaptor deduces those types through template argument deduction. The definition
of the unary version of <b>ptr_fun(&nbsp;)</b> looks something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Arg, <font color=#ff7700>class</font> Result&gt;</div>
<div class=CC1>pointer_to_unary_function&lt;Arg, Result&gt;</div>
<div class=CC1><span lang=SV>ptr_fun(Result (*fptr)(Arg)) {</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>return</font>
pointer_to_unary_function&lt;Arg, Result&gt;(fptr);</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As you can see, this version of <b>ptr_fun(&nbsp;)</b>
deduces the argument and result types from <b>fptr</b> and uses them to
initialize a <b>pointer_to_unary_function</b> object that stores <b>fptr</b>. The function call operator for <b>pointer_to_unary_function</b> just calls <b>fptr</b>, as
you can see by the last line of its code:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Arg, <font color=#ff7700>class</font> Result&gt;</div>
<div class=CC1><font color=#ff7700>class</font> pointer_to_unary_function</div>
<div class=CC1>: <font color=#ff7700>public</font> unary_function&lt;Arg, Result&gt; {</div>
<div class=CC1>  Result (*fptr)(Arg); <font color=#dd0000>// Stores the f-ptr</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  pointer_to_unary_function(Result (*x)(Arg)) : fptr(x)
{}</div>
<div class=CC1>  Result <font color=#ff7700>operator</font>()(Arg x) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> fptr(x); }</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since <b>pointer_to_unary_function</b> derives from <b>unary_function</b>, the appropriate type definitions come along for the ride and are available to <b>not1</b>.</p>

<p class=MsoNormal>There is also a binary version of <b>ptr_fun(&nbsp;)</b>,
which returns a <b>pointer_to_binary_function</b> object (which derives from <b>binary_function</b>) that behaves analogously to the unary case. The following program uses
the binary version of <b>ptr_fun(&nbsp;)</b> to raise numbers in a sequence to
a power. It also reveals a pitfall when passing overloaded functions to <b>ptr_fun(&nbsp;)</b>.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:PtrFun2.cpp {-edg}</font></div>
<div class=CC1><font color=#dd0000>// Using ptr_fun() for a binary function.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>double</font> d[] = { 01.23, 91.370, 56.661,</div>
<div class=CC1>  023.230, 19.959, 1.0, 3.14159 };</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>int</font> DSZ = <font color=#ff7700>sizeof</font> d / <font color=#ff7700>sizeof</font> *d;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;<font color=#ff7700>double</font>&gt; vd;</div>
<div class=CC1>  transform(d, d + DSZ, back_inserter(vd),</div>
<div class=CC1>    bind2nd(ptr_fun&lt;<font color=#ff7700>double</font>, <font color=#ff7700>double</font>, <font color=#ff7700>double</font>&gt;(pow),
2.0));</div>
<div class=CC1>  copy(vd.begin(), vd.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>double</font>&gt;(cout, <font color=#007f00>&quot;
&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>pow(&nbsp;)</b> function is overloaded in the Standard
C++ header <b>&lt;cmath&gt;</b> for each of the floating-point data types, as
follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>float</font> pow(<font color=#ff7700>float</font>, <font color=#ff7700>int</font>);  <font color=#dd0000>// Efficient int power versions
...</font></div>
<div class=CC1><font color=#ff7700>double</font> pow(<font color=#ff7700>double</font>, <font color=#ff7700>int</font>);</div>
<div class=CC1><font color=#ff7700>long</font> <font color=#ff7700>double</font> pow(<font color=#ff7700>long</font> <font color=#ff7700>double</font>, <font color=#ff7700>int</font>);</div>
<div class=CC1><font color=#ff7700>float</font> pow(<font color=#ff7700>float</font>, <font color=#ff7700>float</font>);</div>
<div class=CC1><font color=#ff7700>double</font> pow(<font color=#ff7700>double</font>, <font color=#ff7700>double</font>);</div>
<div class=CC1><font color=#ff7700>long</font> <font color=#ff7700>double</font> pow(<font color=#ff7700>long</font> <font color=#ff7700>double</font>, <font color=#ff7700>long</font> <font color=#ff7700>double</font>);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since there are multiple versions of <b>pow(&nbsp;)</b>, the
compiler has no way of knowing which to choose. Here, we have to help the
compiler by using explicit function template specialization, as explained in
the previous chapter.<a href="#_ftn91" name="_ftnref91"><span
class=MsoFootnoteReference>[91]</span></a></p>

<p class=MsoNormal>It’s even trickier to convert a member function into a
function object suitable for using with the generic algorithms. As a simple
example, suppose we have the classical “shape” problem and want to apply the <b>draw(&nbsp;)</b>
member function to each pointer in a container of <b>Shape</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:MemFun1.cpp</font></div>
<div class=CC1><font color=#dd0000>// Applying pointers to member functions.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Shape() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Circle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() { cout &lt;&lt;
<font color=#007f00>&quot;Circle::Draw()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  ~Circle() { cout &lt;&lt;
<font color=#007f00>&quot;Circle::~Circle()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Square : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() { cout &lt;&lt; <font color=#007f00>&quot;Square::Draw()&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>  ~Square() { cout &lt;&lt;
<font color=#007f00>&quot;Square::~Square()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Shape*&gt; vs;</div>
<div class=CC1>  vs.push_back(<font color=#ff7700>new</font> Circle);</div>
<div class=CC1>  vs.push_back(<font color=#ff7700>new</font> Square);</div>
<div class=CC1>  for_each(vs.begin(), vs.end(),
mem_fun(&amp;Shape::draw));</div>
<div class=CC1>  purge(vs);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>for_each(&nbsp;)</b> algorithm passes each element in a sequence to the function object denoted by its third argument. Here, we want the
function object to wrap one of the member functions of the class itself, and so
the function object’s “argument” becomes the pointer to the object for the
member function call. To produce such a function object, the <b>mem_fun</b><b>(&nbsp;)</b> template takes a pointer to a member as its argument.</p>

<p class=MsoNormal>The <b>mem_fun(&nbsp;)</b> functions are for producing
function objects that are called using a pointer to the object that the member
function is called for, while <b>mem_fun_ref</b><b>(&nbsp;)</b> calls the member function directly for an object. One set of overloads of both <b>mem_fun(&nbsp;)</b>
and <b>mem_fun_ref(&nbsp;)</b> is for member functions that take zero arguments
and one argument, and this is multiplied by two to handle <b>const</b> vs. non-<b>const</b>
member functions. However, templates and overloading take care of sorting all
that out—all you need to remember is when to use <b>mem_fun(&nbsp;)</b> vs. <b>mem_fun_ref(&nbsp;)</b>.</p>

<p class=MsoNormal>Suppose you have a container of objects (not pointers), and
you want to call a member function that takes an argument. The argument you
pass should come from a second container of objects. To accomplish this, use
the second overloaded form of the <b>transform(&nbsp;)</b> algorithm:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:MemFun2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Calling member functions through an object reference.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Angle {</div>
<div class=CC1>  <font color=#ff7700>int</font> degrees;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Angle(<font color=#ff7700>int</font> deg) : degrees(deg) {}</div>
<div class=CC1>  <font color=#ff7700>int</font> mul(<font color=#ff7700>int</font> times) { <font color=#ff7700>return</font> degrees *= times; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Angle&gt; va;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 50; i += 10)</div>
<div class=CC1>    va.push_back(Angle(i));</div>
<div class=CC1>  <font color=#ff7700>int</font> x[] = { 1, 2, 3, 4, 5 };</div>
<div class=CC1>  transform(va.begin(), va.end(), x,</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>),</div>
<div class=CC1>    mem_fun_ref(&amp;Angle::mul));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Output: 0 20 60 120 200</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Because the container is holding objects, <b>mem_fun_ref(&nbsp;)</b>
must be used with the pointer-to-member function. This version of <b>transform(&nbsp;)</b>
takes the start and end point of the first range (where the objects live); the
starting point of the second range, which holds the arguments to the member
function; the destination iterator, which in this case is standard output; and
the function object to call for each object. This function object is created
with <b>mem_fun_ref(&nbsp;)</b> and the desired pointer to member. Notice that
the <b>transform(&nbsp;)</b> and <b>for_each(&nbsp;)</b> template functions are
incomplete; <b>transform(&nbsp;)</b> requires that the function it calls return
a value, and there is no <b>for_each(&nbsp;)</b> that passes two arguments to
the function it calls. Thus, you cannot call a member function that returns <b>void</b>
and takes an argument using <b>transform(&nbsp;)</b> or <b>for_each(&nbsp;)</b>.</p>

<p class=MsoNormal>Most any member function works with <b>mem_fun_ref(&nbsp;)</b>.
You can also use standard library member functions, if your compiler doesn’t
add any default arguments beyond the normal arguments specified in the standard.<a href="#_ftn92" name="_ftnref92"><span
class=MsoFootnoteReference>[92]</span></a> For example,
suppose you’d like to read a file and search for blank lines. Your compiler may
allow you to use the <b>string::empty(&nbsp;)</b> member function like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:FindBlanks.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstrates mem_fun_ref() with string::empty().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> vector&lt;string&gt;::iterator LSI;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;FindBlanks.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  vector&lt;string&gt; vs;</div>
<div class=CC1>  string s;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, s))</div>
<div class=CC1>    vs.push_back(s);</div>
<div class=CC1>  vector&lt;string&gt; cpy = vs; <font color=#dd0000>// For testing</font></div>
<div class=CC1>  LSI lsi = find_if(vs.begin(), vs.end(),</div>
<div class=CC1>     mem_fun_ref(&amp;string::empty));</div>
<div class=CC1>  <font color=#ff7700>while</font>(lsi != vs.end()) {</div>
<div class=CC1>    *lsi = <font color=#007f00>&quot;A BLANK LINE&quot;</font>;</div>
<div class=CC1>    lsi = find_if(vs.begin(), vs.end(),</div>
<div class=CC1>      mem_fun_ref(&amp;string::empty));</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; cpy.size(); i++)</div>
<div class=CC1>    <font color=#ff7700>if</font>(cpy[i].size() == 0)</div>
<div class=CC1>      assert(vs[i] == <font color=#007f00>&quot;A BLANK LINE&quot;</font>);</div>
<div class=CC1>    <font color=#ff7700>else</font></div>
<div class=CC1>      assert(vs[i] != <font color=#007f00>&quot;A BLANK LINE&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example uses <b>find_if(&nbsp;)</b> to locate the first
blank line in the given range using <b>mem_fun_ref(&nbsp;)</b> with <b>string::empty(&nbsp;)</b>.
After the file is opened and read into the <b>vector</b>, the process is
repeated to find every blank line in the file. Each time a blank line is found,
it is replaced with the characters “A BLANK LINE.” All you have to do to
accomplish this is dereference the iterator to select the current string.</p>

<h3><a href="#_TocRef22433877" name="_Toc22433877">Writing your own function
object adaptors</a></h3>

<p class=MsoNormal>Consider how to write a program that converts strings
representing floating-point numbers to their actual numeric values. To get
things started, here’s a generator that creates the strings:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:NumStringGen.h</font></div>
<div class=CC1><font color=#dd0000>// A random number generator that produces</font></div>
<div class=CC1><font color=#dd0000>// strings representing floating-point numbers.</font></div>
<div class=CC1><span lang=SV>#ifndef NUMSTRINGGEN_H</span></div>
<div class=CC1><span lang=SV>#define NUMSTRINGGEN_H</span></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> NumStringGen {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> sz; <font color=#dd0000>// Number of digits to make</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  NumStringGen(<font color=#ff7700>int</font> ssz = 5) : sz(ssz) {}</div>
<div class=CC1>  std::string <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    std::string digits(<font color=#007f00>&quot;0123456789&quot;</font>);</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>int</font> ndigits = digits.size();</div>
<div class=CC1>    std::string r(sz, ' ');</div>
<div class=CC1>    <font color=#dd0000>// Don't want a zero as the first digit</font></div>
<div class=CC1>    r[0] = digits[std::rand() % (ndigits - 1)] + 1;</div>
<div class=CC1>    <font color=#dd0000>// Now assign the rest</font></div>
<div class=CC1>    <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 1; i &lt; sz; ++i)</span></div>
<div class=CC1><span lang=SV>      </span><font color=#ff7700>if</font>(sz &gt;= 3 &amp;&amp; i
== sz/2)</div>
<div class=CC1>        r[i] = '.'; <font color=#dd0000>// Insert a decimal point</font></div>
<div class=CC1>      <font color=#ff7700>else</font></div>
<div class=CC1>        r[i] = digits[std::rand() % ndigits];</div>
<div class=CC1>    <font color=#ff7700>return</font> r;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// NUMSTRINGGEN_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You tell it how big the strings should be when you create
the <b>NumStringGen</b> object. The random number generator selects digits, and
a decimal point is placed in the middle.</p>

<p class=MsoNormal>The following program uses <b>NumStringGen</b> to fill a <b>vector&lt;string&gt;</b>.
However, to use the standard C library function <b>atof(&nbsp;)</b> to convert
the strings to floating-point numbers, the <b>string</b> objects must first be
turned into <b>char</b> pointers, since there is no automatic type conversion
from <b>string</b> to <b>char*</b>. The <b>transform(&nbsp;)</b> algorithm can
be used with <b>mem_fun_ref(&nbsp;)</b> and <b>string::c_str(&nbsp;)</b> to
convert all the <b>string</b>s to <b>char*</b>, and then these can be
transformed using <b>atof</b>.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:MemFun3.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using mem_fun().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;NumStringGen.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 9;</div>
<div class=CC1>  vector&lt;string&gt; vs(SZ);</div>
<div class=CC1>  <font color=#dd0000>// Fill it with random number strings:</font></div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate(vs.begin(), vs.end(), NumStringGen());</div>
<div class=CC1>  copy(vs.begin(), vs.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(cout,
<font color=#007f00>&quot;\t&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* vcp[SZ];</div>
<div class=CC1>  transform(vs.begin(), vs.end(), vcp,</div>
<div class=CC1>    mem_fun_ref(&amp;string::c_str));</div>
<div class=CC1>  vector&lt;<font color=#ff7700>double</font>&gt; vd;</div>
<div class=CC1>  transform(vcp, vcp + SZ, back_inserter(vd),</div>
<div class=CC1>    std::atof);</div>
<div class=CC1>  cout.precision(4);</div>
<div class=CC1>  cout.setf(ios::showpoint);</div>
<div class=CC1>  copy(vd.begin(), vd.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>double</font>&gt;(cout,
<font color=#007f00>&quot;\t&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This program does two transformations: one to convert
strings to C-style strings (arrays of characters), and one to convert the
C-style strings to numbers via <b>atof(&nbsp;)</b>. It would be nice to combine
these two operations into one. After all, we can compose functions in
mathematics, so why not C++?</p>

<p class=MsoNormal>The obvious approach takes the two functions as arguments
and applies them in the proper order:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:ComposeTry.cpp</font></div>
<div class=CC1><font color=#dd0000>// A first attempt at implementing function composition.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> R, <font color=#ff7700>typename</font> E, <font color=#ff7700>typename</font> F1,
<font color=#ff7700>typename</font> F2&gt;</div>
<div class=CC1><font color=#ff7700>class</font> unary_composer {</div>
<div class=CC1>  F1 f1;</div>
<div class=CC1>  F2 f2;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  unary_composer(F1 fone, F2 ftwo) : f1(fone), f2(ftwo)
{}</div>
<div class=CC1>  R <font color=#ff7700>operator</font>()(E x) { <font color=#ff7700>return</font> f1(f2(x)); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> R, <font color=#ff7700>typename</font> E, <font color=#ff7700>typename</font> F1,
<font color=#ff7700>typename</font> F2&gt;</div>
<div class=CC1>unary_composer&lt;R, E, F1, F2&gt; compose(F1 f1, F2
f2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> unary_composer&lt;R, E, F1, F2&gt;(f1, f2);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>double</font> x = compose&lt;<font color=#ff7700>double</font>, <font color=#ff7700>const</font> string&amp;&gt;(</div>
<div class=CC1>    atof,
mem_fun_ref(&amp;string::c_str))(<font color=#007f00>&quot;12.34&quot;</font>);</div>
<div class=CC1>  assert(x == 12.34);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>unary_composer</b> object in this example stores the function pointers <b>atof</b> and <b>string::c_str</b> such that the latter
function is applied first when its <b>operator(&nbsp;)</b> is called. The <b>compose</b><b>(&nbsp;)</b> function adaptor is a convenience, so we don’t need to supply all
four template arguments explicitly—<b>F1</b> and <b>F2</b> are deduced from the
call.</p>

<p class=MsoNormal>It would be much better if we didn’t need to supply any
template arguments. This is achieved by adhering to the convention for type
definitions for adaptable function objects. In other words, we will assume that
the functions to be composed are adaptable. This requires that we use <b>ptr_fun(&nbsp;)</b>
for <b>atof(&nbsp;)</b>. For maximum flexibility, we also make <b>unary_composer</b>
adaptable in case it gets passed to a function adaptor. The following program
does so and easily solves the original problem:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:ComposeFinal.cpp {-edg}</font></div>
<div class=CC1><font color=#dd0000>// An adaptable composer.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;NumStringGen.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> F1, <font color=#ff7700>typename</font> F2&gt; <font color=#ff7700>class</font>
unary_composer</div>
<div class=CC1>: <font color=#ff7700>public</font> unary_function&lt;<font color=#ff7700>typename</font> F2::argument_type,</div>
<div class=CC1>                        <font color=#ff7700>typename</font> F1::result_type&gt; {</div>
<div class=CC1>  F1 f1;</div>
<div class=CC1>  F2 f2;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  unary_composer(F1 f1, F2 f2) : f1(f1), f2(f2) {}</div>
<div class=CC1>  <font color=#ff7700>typename</font> F1::result_type</div>
<div class=CC1>  <font color=#ff7700>operator</font>()(<font color=#ff7700>typename</font> F2::argument_type x) {</div>
<div class=CC1>    <font color=#ff7700>return</font> f1(f2(x));</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> F1, <font color=#ff7700>typename</font> F2&gt;</div>
<div class=CC1>unary_composer&lt;F1, F2&gt; compose(F1 f1, F2 f2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> unary_composer&lt;F1, F2&gt;(f1, f2);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 9;</div>
<div class=CC1>  vector&lt;string&gt; vs(SZ);</div>
<div class=CC1>  <font color=#dd0000>// Fill it with random number strings:</font></div>
<div class=CC1>  generate(vs.begin(), vs.end(), NumStringGen());</div>
<div class=CC1>  copy(vs.begin(), vs.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(cout,
<font color=#007f00>&quot;\t&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  vector&lt;<font color=#ff7700>double</font>&gt; vd;</div>
<div class=CC1>  transform(vs.begin(), vs.end(), back_inserter(vd),</div>
<div class=CC1>    compose(ptr_fun(atof),
mem_fun_ref(&amp;string::c_str)));</div>
<div class=CC1>  copy(vd.begin(), vd.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>double</font>&gt;(cout,
<font color=#007f00>&quot;\t&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Once again we must use <b>typename</b> to let the compiler
know that the member we are referring to is a nested type.</p>

<p class=MsoNormal>Some implementations<a href="#_ftn93" name="_ftnref93"><span
class=MsoFootnoteReference>[93]</span></a> support
composition of function objects as an extension, and the C++ Standards Committee
is likely to add these capabilities to the next version of Standard C++.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef22433878" name="_Toc22433878">A catalog of STL algorithms</a></h2>

<p class=MsoNormal>This section provides a quick reference when you’re
searching for the appropriate algorithm. We leave the full exploration of all
the STL algorithms to other references (see the end of this chapter, and
Appendix A), along with the more intimate details of issues like performance.
Our goal here is for you to rapidly become comfortable with the algorithms, and
we’ll assume you will look into the more specialized references if you need
more detail.</p>

<p class=MsoNormal>Although you will often see the algorithms described using
their full template declaration syntax, we’re not doing that here because you
already know they are templates, and it’s quite easy to see what the template
arguments are from the function declarations. The type names for the arguments
provide descriptions for the types of iterators required. We think you’ll find
this form is easier to read, and you can quickly find the full declaration in
the template header file if you need it.</p>

<p class=MsoNormal>The reason for all the fuss about iterators is to
accommodate any type of container that meets the requirements in the standard
library. So far we have illustrated the generic algorithms with only arrays and
<b>vector</b>s as sequences, but in the next chapter you’ll see a broad range
of data structures that support less robust iteration. For this reason, the
algorithms are categorized in part by the types of iteration facilities they
require.</p>

<p class=MsoNormal>The names of the iterator classes describe the iterator type
to which they must conform. There are no interface base classes to enforce
these iteration operations—they are just expected to be there. If they are not,
your compiler will complain. The various flavors of iterators are described
briefly as follows.</p>

<p class=MsoNormal><b>InputIterator</b>.<b> </b>An input iterator only allows <i>reading</i>
elements of its sequence in a single, forward pass using <b>operator++</b> and <b>operator*</b>.
Input iterators<b> </b>can also be tested with <b>operator==</b> and <b>operator!=</b>.
That’s the extent of the constraints.</p>

<p class=MsoNormal><b>OutputIterator</b>.<b> </b>An output iterator only allows
<i>writing</i> elements to a sequence in a single, forward pass using <b>operator++</b>
and <b>operator*</b>. <b>OutputIterator</b>s cannot be tested with <b>operator==</b>
and <b>operator!=</b>, however, because you assume that you can just keep
sending elements to the destination and that you don’t need to see if the destination’s
end marker was reached. That is, the container that an <b>OutputIterator</b>
references can take an infinite number of objects, so no end-checking is
necessary. This requirement is important so that an <b>OutputIterator</b> can
be used with <b>ostream</b>s (via <b>ostream_iterator</b>), but you’ll also
commonly use the “insert” iterators such as are the type of iterator returned
by <b>back_inserter(&nbsp;)</b>).</p>

<p class=MsoNormal>There is no way to determine whether multiple <b>InputIterators</b>
or <b>OutputIterators</b> point within the same range, so there is no way to use
such iterators together. Just think in terms of iterators to support <b>istream</b>s
and <b>ostream</b>s, and <b>InputIterator</b> and <b>OutputIterator</b> will
make perfect sense. Also note that algorithms that use <b>InputIterators</b> or
<b>OutputIterators</b> put the weakest restrictions on the types of iterators
they will accept, which means that you can use any “more sophisticated” type of
iterator when you see <b>InputIterator</b> or <b>OutputIterator</b> used as STL
algorithm template arguments.</p>

<p class=MsoNormal><b>ForwardIterator</b>. Because you can only read from an <b>InputIterator</b> and write to an <b>OutputIterator</b>, you can’t use either of
them to simultaneously read and modify a range, and you can’t dereference such
an iterator more than once. With a <b>ForwardIterator</b> these restrictions
are relaxed; you can still only move forward using <b>operator++</b>, but you
can both write and read, and you can compare such iterators in the same range
for equality. Since forward iterators can both read and write, they can be used
in place of an <b>InputIterator</b> or <b>OutputIterator</b>.</p>

<p class=MsoNormal><b>BidirectionalIterator</b>.<b> </b>Effectively, this is a <b>ForwardIterator</b> that can also go backward. That is, a <b>BidirectionalIterator</b>
supports all the operations that a <b>ForwardIterator</b> does, but in addition
it has an <b>operator--</b>.</p>

<p class=MsoNormal><b>RandomAccessIterator</b>. This type of iterator supports all the operations that a regular pointer does: you can add and subtract integral values to
move it forward and backward by jumps (rather than just one element at a time),
you can subscript it with <b>operator[&nbsp;]</b>, you can subtract one
iterator from another, and you can compare iterators to see which is greater
using <b>operator&lt;</b>, <b>operator&gt;</b>, and so on. If you’re
implementing a sorting routine or something similar, random access iterators
are necessary to be able to create an efficient algorithm.</p>

<p class=MsoNormal>The names used for the template parameter types in the
algorithm descriptions later in this chapter consist of the listed iterator
types (sometimes with a ‘1’ or ‘2’ appended to distinguish different template
arguments) and can also include other arguments, often function objects.</p>

<p class=MsoNormal>When describing the group of elements passed to an
operation, mathematical “range” notation is often used. In this, the square
bracket means “includes the end point,” and the parenthesis means “does not
include the end point.” When using iterators, a range is determined by the
iterator pointing to the initial element and by the “past-the-end” iterator,
pointing past the last element. Since the past-the-end element is never used,
the range determined by a pair of iterators can be expressed as <b>[first,
last)</b>, where <b>first</b> is the iterator pointing to the initial element,
and <b>last</b> is the past-the-end iterator.</p>

<p class=MsoNormal>Most books and discussions of the STL algorithms arrange
them according to side-effects: <i>non-mutating</i> algorithms don’t change the
elements in the range, <i>mutating</i> algorithms do change the elements, and
so on. These descriptions are based primarily on the underlying behavior or
implementation of the algorithm—that is, on the designer’s perspective. In
practice, we don’t find this a useful categorization, so instead we’ll organize
them according to the problem you want to solve: Are you searching for an
element or set of elements, performing an operation on each element, counting
elements, replacing elements, and so on? This should help you find the
algorithm you want more easily.</p>

<p class=MsoNormal>If you do not see a different header such as <b>&lt;utility&gt;</b>
or <b>&lt;numeric&gt;</b> above the function declarations, it appears in <b>&lt;algorithm&gt;</b>.
Also, all the algorithms are in the namespace<b> std</b>.</p>

<h3><a href="#_TocRef22433879" name="_Toc22433879">Support tools for example
creation</a></h3>

<p class=MsoNormal>It’s useful to create some basic tools to test the
algorithms. In the examples that follow we’ll use the generators mentioned
earlier in <b>Generators.h</b>, as well as what appears below.</p>

<p class=MsoNormal>Displaying a range is a frequent task, so here is a function
template to print any sequence, regardless of the type contained in that
sequence:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//:
C06:PrintSequence.h</font></div>
<div class=CC1><font color=#dd0000>// Prints
the contents of any sequence.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef
PRINTSEQUENCE_H</font></div>
<div class=CC1><font color=#7F7F00>#define
PRINTSEQUENCE_H</font></div>
<div class=CC1><font color=#7F7F00>#include
&lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include
&lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include
&lt;iterator&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font>
Iter&gt;</div>
<div class=CC1><font color=#ff7700>void</font>
print(Iter first, Iter last, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* nm = <font color=#007f00>&quot;&quot;</font>,</div>
<div class=CC1>          
<font color=#ff7700>const</font> <font color=#ff7700>char</font>* sep = <font color=#007f00>&quot;\n&quot;</font>,</div>
<div class=CC1>          
std::ostream&amp; os = std::cout) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(nm != 0
&amp;&amp; *nm != '\0')</div>
<div class=CC1>    os
&lt;&lt; nm &lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; sep;</div>
<div class=CC1>  <font color=#ff7700>typedef</font>
<font color=#ff7700>typename</font> </div>
<div class=CC1>   
std::iterator_traits&lt;Iter&gt;::value_type T;</div>
<div class=CC1> 
std::copy(first, last, </div>
<div class=CC1>           
std::ostream_iterator&lt;T&gt;(std::cout, sep));</div>
<div class=CC1>  os
&lt;&lt; std::endl;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>//
PRINTSEQUENCE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>By default this function template prints to <b>cout</b> with
newlines as separators, but you can change that by modifying the default
argument. You can also provide a message to print at the head of the output.
Since <b>print(&nbsp;)</b> uses the <b>copy(&nbsp;)</b> algorithm to send objects to <b>cout</b> via an <b>ostream_iterator</b>, the <b>ostream_iterator</b> must know
the type of object it is printing, which we infer from the <b>value_type</b>
member of the iterator passed.</p>

<p class=MsoNormal>The <b>std::iterator_traits</b> template enables the <b>print(&nbsp;)</b>
function template to process sequences delimited by any type of iterator. The
iterator types returned by the standard containers such as <b>vector</b> define
a nested type, <b>value_type</b>, which represents the element type, but when
using arrays, the iterators are just pointers, which can have no nested types.
To supply the conventional types associated with iterators in the standard
library, <b>std::iterator_traits</b> provides the following partial
specialization for pointer types:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>  <font color=#ff7700>struct</font> iterator_traits&lt;T*&gt; {</div>
<div class=CC1>    <font color=#ff7700>typedef</font> random_access_iterator_tag
iterator_category;</div>
<div class=CC1>    <font color=#ff7700>typedef</font> T value_type;</div>
<div class=CC1>    <font color=#ff7700>typedef</font> ptrdiff_t difference_type;</div>
<div class=CC1>    <font color=#ff7700>typedef</font> T* pointer;</div>
<div class=CC1>    <font color=#ff7700>typedef</font> T&amp; reference;</div>
<div class=CC1>  };</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This makes the type of the elements pointed at (namely, <b>T</b>)
available via the type name <b>value_type</b>.</p>

<h4>Stable vs. unstable reordering</h4>

<p class=MsoNormal>A number of the STL algorithms that move elements of a sequence
around distinguish between <i>stable</i> and <i>unstable</i> reordering of a sequence. A stable sort preserves the original relative order of
the elements that are equivalent as far as the comparison function is
concerned. For example, consider a sequence <b>{ c(1), b(1), c(2), a(1), b(2),
a(2) }</b>. These elements are tested for equivalence based on their letters,
but their numbers indicate how they first appeared in the sequence. If you sort
(for example) this sequence using an unstable sort, there’s no guarantee of any
particular order among equivalent letters, so you could end up with <b>{ a(2),
a(1), b(1), b(2), c(2), c(1) }</b>. However, if you use a stable sort, you will
get <b>{ a(1), a(2), b(1), b(2), c(1), c(2) }</b>. The STL <b>sort(&nbsp;)</b>
algorithm uses a variation of <i>quicksort</i> and is thus unstable, but a <b>stable_sort</b><b>(&nbsp;)</b> is also provided.<a href="#_ftn94" name="_ftnref94"><span
class=MsoFootnoteReference>[94]</span></a></p>

<p class=MsoNormal>To demonstrate the stability versus instability of
algorithms that reorder a sequence, we need some way to keep track of how the
elements originally appeared. The following is a kind of <b>string</b> object
that keeps track of the order in which that particular object originally
appeared, using a <b>static map</b> that maps <b>NString</b>s to <b>Counter</b>s.
Each <b>NString</b> then contains an <b>occurrence</b> field that indicates the
order in which this <b>NString</b> was discovered.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:NString.h</font></div>
<div class=CC1><font color=#dd0000>// A &quot;numbered string&quot; that keeps track of
the</font></div>
<div class=CC1><font color=#dd0000>// number of occurrences of the word it contains.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef NSTRING_H</font></div>
<div class=CC1><font color=#7F7F00>#define NSTRING_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;utility&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> std::pair&lt;std::string, <font color=#ff7700>int</font>&gt; psi;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Only compare on the first element</font></div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> psi&amp; l, <font color=#ff7700>const</font> psi&amp; r) {</div>
<div class=CC1>  <font color=#ff7700>return</font> l.first == r.first;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> NString {</div>
<div class=CC1>  std::string s;</div>
<div class=CC1>  <font color=#ff7700>int</font> thisOccurrence;</div>
<div class=CC1>  <font color=#dd0000>// Keep track of the number of occurrences:</font></div>
<div class=CC1>  <font color=#ff7700>typedef</font> std::vector&lt;psi&gt; vp;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> vp::iterator vpit;</div>
<div class=CC1>  <font color=#ff7700>static</font> vp words;</div>
<div class=CC1>  <font color=#ff7700>void</font> addString(<font color=#ff7700>const</font> std::string&amp; x) {</div>
<div class=CC1>    psi p(x, 0);</div>
<div class=CC1>    vpit it = std::find(words.begin(), words.end(), p);</div>
<div class=CC1>    <font color=#ff7700>if</font>(it != words.end())</div>
<div class=CC1>      thisOccurrence = ++it-&gt;second;</div>
<div class=CC1>    <font color=#ff7700>else</font> {</div>
<div class=CC1>      thisOccurrence = 0;</div>
<div class=CC1>      words.push_back(p);</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  NString() : thisOccurrence(0) {}</div>
<div class=CC1>  NString(<font color=#ff7700>const</font> std::string&amp; x) : s(x) {
addString(x); }</div>
<div class=CC1>  NString(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* x) : s(x) { addString(x); }</div>
<div class=CC1>  <font color=#dd0000>// Implicit operator= and copy-constructor are OK
here.</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(</div>
<div class=CC1>    std::ostream&amp; os, <font color=#ff7700>const</font> NString&amp; ns) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; ns.s &lt;&lt; <font color=#007f00>&quot; [&quot;</font>
&lt;&lt; ns.thisOccurrence &lt;&lt; <font color=#007f00>&quot;]&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Need this for sorting. Notice it only</font></div>
<div class=CC1>  <font color=#dd0000>// compares strings, not occurrences:</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font></div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> NString&amp; l, <font color=#ff7700>const</font> NString&amp;
r) {</div>
<div class=CC1>    <font color=#ff7700>return</font> l.s &lt; r.s;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font></div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> NString&amp; l, <font color=#ff7700>const</font>
NString&amp; r) {</div>
<div class=CC1>    <font color=#ff7700>return</font> l.s == r.s;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// For sorting with greater&lt;NString&gt;:</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font></div>
<div class=CC1>  <font color=#ff7700>operator</font>&gt;(<font color=#ff7700>const</font> NString&amp; l, <font color=#ff7700>const</font> NString&amp;
r) {</div>
<div class=CC1>    <font color=#ff7700>return</font> l.s &gt; r.s;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// To get at the string directly:</font></div>
<div class=CC1>  <font color=#ff7700>operator</font> <font color=#ff7700>const</font> std::string&amp;() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> s; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Because NString::vp is a template and we are using
the</font></div>
<div class=CC1><font color=#dd0000>// inclusion model, it must be defined in this header
file:</font></div>
<div class=CC1>NString::vp NString::words;</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// NSTRING_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We would normally use a <b>map</b> container to associate a string
with its number of occurrences, but maps don’t appear until the next chapter,
so we use a <b>vector</b> of pairs instead. You’ll see plenty of similar
examples in Chapter 7.</p>

<p class=MsoNormal>The only operator necessary to perform an ordinary ascending
sort is <b>NString::operator&lt;(&nbsp;)</b>. To sort in reverse order, the <b>operator&gt;(&nbsp;)</b>
is also provided so that the <b>greater</b> template can call it.</p>

<h3><a href="#_TocRef22433880" name="_Toc22433880">Filling and generating</a></h3>

<p class=MsoNormal>These algorithms let you automatically fill a range with a
particular value or generate a set of values for a particular range. The “fill”
functions insert a single value multiple times into the container. The “generate”
functions use generators such as those described earlier to produce values to
insert into the container.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>fill</b>(ForwardIterator
first, ForwardIterator last,<br>
  const T&amp; value);<br>
void <b>fill_n</b>(OutputIterator first, Size n, const T&amp; value);</p>

</div>

<p class=MsoNormal><b>fill</b><b>(&nbsp;)</b> assigns <b>value</b> to every
element in the range <b>[first, last)</b>. <b>fill_n(&nbsp;)</b> assigns <b>value</b>
to <b>n</b> elements starting at <b>first</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>generate</b>(ForwardIterator
first, ForwardIterator last,<br>
  Generator gen);<br>
void <b>generate_n</b>(OutputIterator first, Size n, Generator<br>
  gen);</p>

</div>

<p class=MsoNormal><b>generate</b><b>(&nbsp;)</b> makes a call to <b>gen(&nbsp;)</b>
for each element in the range <b>[first, last)</b>, presumably<b> </b>to
produce a different value for each element. <b>generate_n(&nbsp;)</b> calls <b>gen(&nbsp;)</b>
<b>n</b> times and assigns each result to <b>n</b> elements starting at <b>first</b>.</p>

<h4>Example</h4>

<p class=MsoNormal>The following example fills and generates into <b>vector</b>s.
It also shows the use of <b>print(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:FillGenerateTest.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstrates &quot;fill&quot; and &quot;generate.&quot;</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;string&gt; v1(5);</div>
<div class=CC1>  fill(v1.begin(), v1.end(), <font color=#007f00>&quot;howdy&quot;</font>);</div>
<div class=CC1>  print(v1.begin(), v1.end(), <font color=#007f00>&quot;v1&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  vector&lt;string&gt; v2;</div>
<div class=CC1>  fill_n(back_inserter(v2), 7, <font color=#007f00>&quot;bye&quot;</font>);</div>
<div class=CC1>  print(v2.begin(), v2.end(), <font color=#007f00>&quot;v2&quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v3(10);</div>
<div class=CC1>  generate(v3.begin(), v3.end(), SkipGen(4,5));</div>
<div class=CC1>  print(v3.begin(), v3.end(), <font color=#007f00>&quot;v3&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v4;</div>
<div class=CC1>  generate_n(back_inserter(v4),15, URandGen(30));</div>
<div class=CC1>  print(v4.begin(), v4.end(), <font color=#007f00>&quot;v4&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A <b>vector&lt;string&gt;</b> is created with a predefined
size. Since storage has already been created for all the <b>string</b> objects
in the <b>vector</b>, <b>fill(&nbsp;)</b> can use its assignment operator to
assign a copy of “howdy” to each space in the <b>vector</b>. Also, the default
newline separator is replaced with a space.</p>

<p class=MsoNormal>The second <b>vector&lt;string&gt; v2</b> is not given an
initial size, so <b>back_inserter(&nbsp;)</b> must be used to force new elements in instead of trying to assign to existing locations.</p>

<p class=MsoNormal>The <b>generate(&nbsp;)</b> and <b>generate_n(&nbsp;)</b>
functions have the same form as the “fill” functions except that they use a
generator instead of a constant value. Here, both generators are demonstrated.</p>

<h3><a href="#_TocRef22433881" name="_Toc22433881">Counting</a></h3>

<p class=MsoNormal>All containers have a member function <b>size(&nbsp;)</b>
that tells you how many elements they hold. The return type of <b>size(&nbsp;)</b>
is the iterator’s <b>difference_type</b><a href="#_ftn95" name="_ftnref95"><span
class=MsoFootnoteReference>[95]</span></a> (usually
<b>ptrdiff_t</b>), which we denote by <b>IntegralValue</b> in the following.
The following two algorithms count objects that satisfy certain criteria.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>IntegralValue <b>count</b>(InputIterator
first, InputIterator<br>
  last, const EqualityComparable&amp; value);</p>

</div>

<p class=MsoNormal>Produces the number of elements in <b>[first, last)</b> that
are equivalent to <b>value</b> (when tested using <b>operator==</b>).</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>IntegralValue <b>count_if</b>(InputIterator
first, InputIterator<br>
  last, Predicate pred);</p>

</div>

<p class=MsoNormal>Produces the number of elements<b> </b>in <b>[first, last)</b>
that each cause <b>pred</b> to return <b>true</b>.</p>

<h4>Example</h4>

<p class=MsoNormal>Here, a <b>vector&lt;char&gt; v</b> is<b> </b>filled with
random characters (including some duplicates). A <b>set&lt;char&gt;</b> is
initialized from <b>v</b>, so it holds only one of each letter represented in <b>v</b>.
This <b>set</b> counts all the instances of all the characters, which are then
displayed:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Counting.cpp</font></div>
<div class=CC1><font color=#dd0000>// The counting algorithms.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;<font color=#ff7700>char</font>&gt; v;</div>
<div class=CC1>  generate_n(back_inserter(v), 50, CharGen());</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;v&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Create a set of the characters in v:</font></div>
<div class=CC1>  set&lt;<font color=#ff7700>char</font>&gt; cs(v.begin(), v.end());</div>
<div class=CC1>  <font color=#ff7700>typedef</font> set&lt;<font color=#ff7700>char</font>&gt;::iterator sci;</div>
<div class=CC1>  <font color=#ff7700>for</font>(sci it = cs.begin(); it != cs.end(); it++) {</div>
<div class=CC1>    <font color=#ff7700>int</font> n = count(v.begin(), v.end(), *it);</div>
<div class=CC1>    cout &lt;&lt; *it &lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt;
n &lt;&lt; <font color=#007f00>&quot;, &quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> lc = count_if(v.begin(), v.end(),</div>
<div class=CC1>    bind2nd(greater&lt;<font color=#ff7700>char</font>&gt;(), 'a'));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\nLowercase letters: &quot;</font>
&lt;&lt; lc &lt;&lt; endl;</div>
<div class=CC1>  sort(v.begin(), v.end());</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;sorted&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>count_if(&nbsp;)</b> algorithm is demonstrated by
counting all the lowercase letters; the predicate is created using the <b>bind2nd</b><b>(&nbsp;)</b> and <b>greater</b> function object templates.</p>

<h3><a href="#_TocRef22433882" name="_Toc22433882">Manipulating sequences</a></h3>

<p class=MsoNormal>These algorithms let you move sequences around.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>copy</b>(InputIterator
first, InputIterator<br>
  last, OutputIterator destination);</p>

</div>

<p class=MsoNormal>Using assignment, copies from <b>[first, last)</b> to <b>destination</b>,
incrementing <b>destination</b> after each assignment. This is essentially a
“shuffle-left” operation, and so the source sequence must not contain the
destination. Because assignment is used, you cannot directly insert elements
into an empty container or at the end of a container, but instead you must wrap
the <b>destination</b> iterator in an <b>insert_iterator</b> (typically by using <b>back_inserter(&nbsp;)</b> or by using <b>inserter(&nbsp;)</b> in the case of an associative container).</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>BidirectionalIterator2 <b>copy_backward</b>(BidirectionalIterator1<br>
  first, BidirectionalIterator1 last,<br>
  BidirectionalIterator2 destinationEnd);</p>

</div>

<p class=MsoNormal>Like <b>copy(&nbsp;)</b>, but copies the elements in reverse
order. This is essentially a “shuffle-right” operation, and, like <b>copy(&nbsp;)</b>,
the source sequence must not contain the destination. The source range <b>[first,
last)</b> is copied to the destination, but the first destination element is <b>destinationEnd
- 1</b>. This iterator is then decremented after each assignment. The space in
the destination range must already exist (to allow assignment), and the
destination range cannot be within the source range.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>reverse</b>(BidirectionalIterator
first,<br>
  BidirectionalIterator last);<br>
OutputIterator <b>reverse_copy</b>(BidirectionalIterator first,<br>
  BidirectionalIterator last, OutputIterator destination);</p>

</div>

<p class=MsoNormal>Both forms of this function reverse the range <b>[first,
last)</b>. <b>reverse(&nbsp;)</b> reverses the range in place, and <b>reverse_copy</b><b>(&nbsp;)</b> leaves the original range alone and copies the reversed elements
into <b>destination</b>, returning the past-the-end iterator of the resulting
range.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator2 <b>swap_ranges</b>(ForwardIterator1
first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2);</p>

</div>

<p class=MsoNormal>Exchanges the contents of two ranges of equal size by
swapping corresponding elements.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>rotate</b>(ForwardIterator
first, ForwardIterator middle,<br>
  ForwardIterator last);<br>
OutputIterator <b>rotate_copy</b>(ForwardIterator first,<br>
  ForwardIterator middle, ForwardIterator last,<br>
  OutputIterator destination);</p>

</div>

<p class=MsoNormal>Moves the contents of <b>[first, middle)</b> to the end of
the sequence, and the contents of <b>[middle, last)</b> to the beginning. With <b>rotate(&nbsp;)</b>,
the swap is performed in place; and with <b>rotate_copy</b><b>(&nbsp;)</b> the original range is untouched, and the rotated version is copied into <b>destination</b>,
returning the past-the-end iterator of the resulting range. Note that while <b>swap_ranges(&nbsp;)</b>
requires that the two ranges be exactly the same size, the “rotate” functions do
not.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>next_permutation</b>(BidirectionalIterator
first,<br>
  BidirectionalIterator last);<br>
bool <b>next_permutation</b>(BidirectionalIterator first,<br>
  BidirectionalIterator last, StrictWeakOrdering<br>
  binary_pred);<br>
bool <b>prev_permutation</b>(BidirectionalIterator first,<br>
  BidirectionalIterator last);<br>
bool <b>prev_permutation</b>(BidirectionalIterator first,<br>
  BidirectionalIterator last, StrictWeakOrdering<br>
  binary_pred);</p>

</div>

<p class=MsoNormal>A <i>permutation</i> is one unique ordering of a set of
elements. If you have <b>n</b> unique elements, there are <b>n!</b> (<b>n</b>
factorial) distinct possible combinations of those elements. All these
combinations can be conceptually sorted into a sequence using a lexicographical
(dictionary-like) ordering and thus produce a concept of a “next” and
“previous” permutation. So whatever the current ordering of elements in the
range, there is a distinct “next” and “previous” permutation in the sequence of
permutations.</p>

<p class=MsoNormal>The <b>next_permutation</b><b>(&nbsp;)</b> and <b>prev_permutation(&nbsp;)</b> functions rearrange the elements into their next or previous
permutation and, if successful, return <b>true</b>. If there are no more “next”
permutations, the elements are in sorted order so <b>next_permutation(&nbsp;)</b>
returns <b>false</b>. If there are no more “previous” permutations, the
elements are in descending sorted order so <b>previous_permutation(&nbsp;)</b>
returns <b>false</b>.</p>

<p class=MsoNormal>The versions of the functions that have a <b>StrictWeakOrdering</b> argument perform the comparisons using <b>binary_pred</b> instead of <b>operator&lt;</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>random_shuffle</b>(RandomAccessIterator
first,<br>
  RandomAccessIterator last);<br>
void <b>random_shuffle</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last RandomNumberGenerator&amp; rand);</p>

</div>

<p class=MsoNormal>This function randomly rearranges the elements in the range.
It yields uniformly distributed results if the random-number generator does.
The first form uses an internal random number generator, and the second uses a
user-supplied random-number generator. The generator must return a value in the
range <b>[0, n)</b> for some positive <b>n</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>BidirectionalIterator <b>partition</b>(BidirectionalIterator<br>
  first, BidirectionalIterator last, Predicate pred);<br>
BidirectionalIterator <b>stable_partition</b>(BidirectionalIterator first,<br>
  BidirectionalIterator last, Predicate pred);</p>

</div>

<p class=MsoNormal>The “partition” functions move elements that satisfy <b>pred</b>
to the beginning of the sequence. An iterator pointing one past the last of
those elements is returned (which is, in effect, an “end” iterator” for the
initial subsequence of elements that satisfy <b>pred</b>). This location is
often called the “partition point.”</p>

<p class=MsoNormal>With <b>partition</b><b>(&nbsp;)</b>, the order of the elements in each resulting subsequence after the function call is not specified, but with
<b>stable_partition</b><b>(&nbsp;)</b>, the relative order of the elements
before and after the partition point will be the same as before the
partitioning process.</p>

<h4>Example</h4>

<p class=MsoNormal>This gives a basic demonstration of sequence manipulation:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Manipulations.cpp</font></div>
<div class=CC1><font color=#dd0000>// Shows basic manipulations.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#dd0000>// NString</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;NString.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v1(10);</div>
<div class=CC1>  <font color=#dd0000>// Simple counting:</font></div>
<div class=CC1>  generate(v1.begin(), v1.end(), SkipGen());</div>
<div class=CC1>  print(v1.begin(), v1.end(), <font color=#007f00>&quot;v1&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v2(v1.size());</div>
<div class=CC1>  copy_backward(v1.begin(), v1.end(), v2.end());</div>
<div class=CC1>  print(v2.begin(), v2.end(),
<font color=#007f00>&quot;copy_backward&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  reverse_copy(v1.begin(), v1.end(), v2.begin());</div>
<div class=CC1>  print(v2.begin(), v2.end(), <font color=#007f00>&quot;reverse_copy&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  reverse(v1.begin(), v1.end());</div>
<div class=CC1>  print(v1.begin(), v1.end(), <font color=#007f00>&quot;reverse&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> half = v1.size() / 2;</div>
<div class=CC1>  <font color=#dd0000>// Ranges must be exactly the same size:</font></div>
<div class=CC1>  swap_ranges(v1.begin(), v1.begin() + half,</div>
<div class=CC1>    v1.begin() + half);</div>
<div class=CC1>  print(v1.begin(), v1.end(), <font color=#007f00>&quot;swap_ranges&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Start with a fresh sequence:</font></div>
<div class=CC1>  generate(v1.begin(), v1.end(), SkipGen());</div>
<div class=CC1>  print(v1.begin(), v1.end(), <font color=#007f00>&quot;v1&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> third = v1.size() / 3;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 10; i++) {</div>
<div class=CC1>    rotate(v1.begin(), v1.begin() + third, v1.end());</div>
<div class=CC1>    print(v1.begin(), v1.end(), <font color=#007f00>&quot;rotate&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Second rotate example:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>char</font> c[] = <font color=#007f00>&quot;aabbccddeeffgghhiijj&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font> CSZ = strlen(c);</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 10; i++) {</div>
<div class=CC1>    rotate(c, c + 2, c + CSZ);</div>
<div class=CC1>    print(c, c + CSZ, <font color=#007f00>&quot;&quot;</font>, <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;All n! permutations of abcd:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>int</font> nf = 4 * 3 * 2 * 1;</div>
<div class=CC1>  <font color=#ff7700>char</font> p[] = <font color=#007f00>&quot;abcd&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; nf; i++) {</div>
<div class=CC1>    next_permutation(p, p + 4);</div>
<div class=CC1>    print(p, p + 4, <font color=#007f00>&quot;&quot;</font>, <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Using prev_permutation:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; nf; i++) {</div>
<div class=CC1>    prev_permutation(p, p + 4);</div>
<div class=CC1>    print(p, p + 4, <font color=#007f00>&quot;&quot;</font>, <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;random_shuffling a word:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  string s(<font color=#007f00>&quot;hello&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++) {</div>
<div class=CC1>    random_shuffle(s.begin(), s.end());</div>
<div class=CC1>    cout &lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  NString sa[] = { <font color=#007f00>&quot;a&quot;</font>, <font color=#007f00>&quot;b&quot;</font>,
<font color=#007f00>&quot;c&quot;</font>, <font color=#007f00>&quot;d&quot;</font>, <font color=#007f00>&quot;a&quot;</font>, <font color=#007f00>&quot;b&quot;</font>,</div>
<div class=CC1>    <font color=#007f00>&quot;c&quot;</font>, <font color=#007f00>&quot;d&quot;</font>, <font color=#007f00>&quot;a&quot;</font>,
<font color=#007f00>&quot;b&quot;</font>, <font color=#007f00>&quot;c&quot;</font>, <font color=#007f00>&quot;d&quot;</font>, <font color=#007f00>&quot;a&quot;</font>, <font color=#007f00>&quot;b&quot;</font>,
<font color=#007f00>&quot;c&quot;</font>};</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SASZ = <font color=#ff7700>sizeof</font> sa / <font color=#ff7700>sizeof</font> *sa;</div>
<div class=CC1>  <span lang=SV>vector&lt;NString&gt; ns(sa, sa + SASZ);</span></div>
<div class=CC1><span lang=SV>  </span>print(ns.begin(), ns.end(),
<font color=#007f00>&quot;ns&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  vector&lt;NString&gt;::iterator it =</div>
<div class=CC1>    partition(ns.begin(), ns.end(),</div>
<div class=CC1>      bind2nd(greater&lt;NString&gt;(),
<font color=#007f00>&quot;b&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Partition point: &quot;</font> &lt;&lt;
*it &lt;&lt; endl;</div>
<div class=CC1>  print(ns.begin(), ns.end(), <font color=#007f00>&quot;&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Reload vector:</font></div>
<div class=CC1>  copy(sa, sa + SASZ, ns.begin());</div>
<div class=CC1>  it = stable_partition(ns.begin(), ns.end(),</div>
<div class=CC1>    bind2nd(greater&lt;NString&gt;(), <font color=#007f00>&quot;b&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Stable partition&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Partition point: &quot;</font> &lt;&lt;
*it &lt;&lt; endl;</div>
<div class=CC1>  print(ns.begin(), ns.end(), <font color=#007f00>&quot;&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The best way to see the results of this program is to run
it. (You’ll probably want to redirect the output to a file.)</p>

<p class=MsoNormal>The <b>vector&lt;int&gt; v1</b> is initially loaded with a
simple ascending sequence and printed. You’ll see that the effect of <b>copy_backward(&nbsp;)</b>
(which copies into <b>v2</b>, which is the same size as <b>v1</b>) is the same
as an ordinary copy. Again, <b>copy_backward(&nbsp;)</b> does the same thing as
<b>copy(&nbsp;)</b>—it just performs the operations in reverse order.</p>

<p class=MsoNormal><b>reverse_copy(&nbsp;)</b> actually does create a reversed
copy, and <b>reverse(&nbsp;)</b> performs the reversal in place. Next, <b>swap_ranges(&nbsp;)</b>
swaps the upper half of the reversed sequence with the lower half. The ranges
could be smaller subsets of the entire <b>vector</b>, as long as they are of
equivalent size.</p>

<p class=MsoNormal>After re-creating the ascending sequence, <b>rotate(&nbsp;)</b>
is demonstrated by rotating one third of <b>v1</b> multiple times. A second <b>rotate(&nbsp;)</b>
example uses characters and just rotates two characters at a time. This also
demonstrates the flexibility of both the STL algorithms and the <b>print(&nbsp;)</b>
template, since they can both be used with arrays of <b>char</b> as easily as
with anything else.</p>

<p class=MsoNormal>To demonstrate <b>next_permutation(&nbsp;)</b> and <b>prev_permutation(&nbsp;)</b>,
a set of four characters “abcd” is permuted through all <b>n!</b> (<b>n</b>
factorial) possible combinations. You’ll see from the output that the
permutations move through a strictly defined order (that is, permuting is a
deterministic process).</p>

<p class=MsoNormal>A quick-and-dirty demonstration of <b>random_shuffle(&nbsp;)</b>
is to apply it to a <b>string</b> and see what words result. Because a <b>string</b>
object has <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> member functions that
return the appropriate iterators, it too can be easily used with many of the
STL algorithms. An array of <b>char</b> could also have been used.</p>

<p class=MsoNormal>Finally, the <b>partition(&nbsp;)</b> and <b>stable_partition(&nbsp;)</b>
are demonstrated, using an array of <b>NString</b>. You’ll note that the
aggregate initialization expression uses <b>char</b> arrays, but <b>NString</b>
has a <b>char*</b> constructor that is automatically used.</p>

<p class=MsoNormal>You’ll see from the output that with the unstable partition,
the objects are correctly above and below the partition point, but in no
particular order; whereas with the stable partition, their original order is maintained.</p>

<h3><a href="#_TocRef22433883" name="_Toc22433883">Searching and replacing</a></h3>

<p class=MsoNormal>All these algorithms are used for searching for one or more
objects within a range defined by the first two iterator arguments.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>InputIterator <b>find</b>(InputIterator
first, InputIterator last,<br>
  const EqualityComparable&amp; value);</p>

</div>

<p class=MsoNormal>Searches for <b>value </b>within a range of elements.
Returns an iterator in the range <b>[first, last)</b> that points to the first
occurrence of <b>value</b>. If <b>value</b> isn’t in the range, <b>find</b><b>(&nbsp;)</b> returns <b>last</b>. This is a <i>linear search</i>; that is, it starts at the beginning and looks at each sequential element without making any
assumptions about the way the elements are ordered. In contrast, a <b>binary_search(&nbsp;)</b>
(defined later) works on a sorted sequence and can thus be much faster.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>InputIterator <b>find_if</b>(InputIterator
first, InputIterator<br>
  last, Predicate pred);</p>

</div>

<p class=MsoNormal>Just like <b>find(&nbsp;)</b>, <b>find_if</b><b>(&nbsp;)</b> performs a linear search through the range. However, instead of searching for <b>value</b>,
<b>find_if(&nbsp;)</b> looks for an element such that the <b>Predicate pred</b>
returns <b>true</b> when applied to that element. Returns <b>last</b> if no
such element can be found.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>adjacent_find</b>(ForwardIterator first,<br>
  ForwardIterator last);<br>
ForwardIterator <b>adjacent_find</b>(ForwardIterator first,<br>
  ForwardIterator last, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Like <b>find(&nbsp;)</b>, performs a linear search through
the range, but instead of looking for only one element, it searches for two
adjacent elements that are equivalent. The first form of the function looks for
two elements that are equivalent (via <b>operator==</b>). The second form looks
for two adjacent elements that, when passed together to <b>binary_pred</b>,
produce a <b>true</b> result. An iterator to the first of the two elements is
returned if a pair is found; otherwise, <b>last</b> is returned.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator1 <b>find_first_of</b>(ForwardIterator1 first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2,<br>
  ForwardIterator2 last2);<br>
ForwardIterator1 <b>find_first_of</b>(ForwardIterator1 first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2,<br>
  ForwardIterator2 last2, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Like <b>find(&nbsp;)</b>, performs a linear search through
the range. Both forms search for an element in the second range that’s
equivalent to one in the first, the first form using <b>operator==</b>, and the
second using the supplied predicate. In the second form, the current element
from the first range becomes the first argument to <b>binary_pred</b>, and the
element from the second range becomes the second argument.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator1 <b>search</b>(ForwardIterator1 first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2,<br>
  ForwardIterator2 last2);<br>
ForwardIterator1 <b>search</b>(ForwardIterator1 first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2,<br>
  ForwardIterator2 last2 BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Checks to see if the second range occurs (in the exact order
of the second range) within the first range, and if so returns an iterator
pointing to the place in the first range where the second range begins. Returns
<b>last1</b> if no subset can be found. The first form performs its test using <b>operator==</b>,
and the second checks to see if each pair of objects being compared causes <b>binary_pred</b>
to return <b>true</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator1 <b>find_end</b>(ForwardIterator1 first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2,<br>
  ForwardIterator2 last2);<br>
ForwardIterator1 <b>find_end</b>(ForwardIterator1 first1,<br>
  ForwardIterator1 last1, ForwardIterator2 first2,<br>
  ForwardIterator2 last2, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>The forms and arguments are just like <b>search(&nbsp;)</b>
in that they look for the second range appearing as a subset of the first
range, but while <b>search(&nbsp;)</b> looks for the first occurrence of the
subset, <b>find_end(&nbsp;)</b> looks for the <i>last</i> occurrence and
returns an iterator to its first element.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>search_n</b>(ForwardIterator first,<br>
  ForwardIterator last, Size count, const T&amp; value);<br>
ForwardIterator <b>search_n</b>(ForwardIterator first,<br>
  ForwardIterator last, Size count, const T&amp; value,<br>
  BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Looks for a group of <b>count</b> consecutive values in <b>[first,
last)</b> that are all equal to <b>value</b> (in the first form) or that all
cause a return value of <b>true</b> when passed into <b>binary_pred</b> along
with <b>value</b> (in the second form). Returns <b>last</b> if such a group
cannot be found.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>min_element</b>(ForwardIterator first,<br>
  ForwardIterator last);<br>
ForwardIterator <b>min_element</b>(ForwardIterator first,<br>
  ForwardIterator last, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Returns an iterator pointing to the first occurrence of the
“smallest” value in the range (as explained below—there may be multiple
occurrences of this value.) Returns <b>last</b> if the range is empty. The first
version performs comparisons with <b>operator&lt;</b>, and the value <b>r </b>returned
is such that *<b>e &lt; *r</b> is false for every element <b>e</b> in the range
<b>[first, r)</b>. The second version compares using <b>binary_pred</b>, and
the value <b>r</b> returned is such that <b>binary_pred(*e, *r)</b> is false
for every element <b>e</b> in the range <b>[first, r)</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>max_element</b>(ForwardIterator first,<br>
  ForwardIterator last);<br>
ForwardIterator <b>max_element</b>(ForwardIterator first,<br>
  ForwardIterator last, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Returns an iterator pointing to the first occurrence of the
largest value in the range. (There may be multiple occurrences of the largest
value.) Returns <b>last</b> if the range is empty. The first version performs
comparisons with <b>operator&lt;</b>, and the value <b>r </b>returned is such
that *<b>r &lt; *e</b> is false for every element <b>e</b> in the range <b>[first,
r)</b>. The second version compares using <b>binary_pred</b>, and the value <b>r</b>
returned is such that <b>binary_pred(*r, *e)</b> is false for every element <b>e</b>
in the range <b>[first, r)</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>replace</b>(ForwardIterator first, ForwardIterator last,<br>
  const T&amp; old_value, const T&amp; new_value);<br>
void <b>replace_if</b>(ForwardIterator first, ForwardIterator<br>
  last, Predicate pred, const T&amp; new_value);<br>
OutputIterator <b>replace_copy</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result, const T&amp;<br>
  old_value, const T&amp; new_value);<br>
OutputIterator <b>replace_copy_if</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result, Predicate<br>
  pred, const T&amp; new_value);</p>

</div>

<p class=MsoNormal>Each of the “replace” forms moves through the range <b>[first,
last)</b>, finding values that match a criterion and replacing them with <b>new_value</b>.
Both <b>replace(&nbsp;)</b> and <b>replace_copy(&nbsp;)</b> simply look for <b>old_value</b>
to replace; <b>replace_if(&nbsp;)</b> and <b>replace_copy_if(&nbsp;)</b> look
for values that satisfy the predicate <b>pred</b>. The “copy” versions of the
functions do not modify the original range but instead make a copy with the
replacements into <b>result</b> (incrementing <b>result</b> after each
assignment).</p>

<h4>Example</h4>

<p class=MsoNormal>To provide easy viewing of the results, this example manipulates
<b>vector</b>s of <b>int</b>. Again, not every possible version of each
algorithm is shown. (Some that should be obvious have been omitted.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:SearchReplace.cpp</font></div>
<div class=CC1><font color=#dd0000>// The STL search and replace algorithms.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> PlusOne {</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>int</font> i, <font color=#ff7700>int</font> j) { <font color=#ff7700>return</font> j == i + 1; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MulMoreThan {</div>
<div class=CC1>  <font color=#ff7700>int</font> value;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MulMoreThan(<font color=#ff7700>int</font> val) : value(val) {}</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>int</font> v, <font color=#ff7700>int</font> m) { <font color=#ff7700>return</font> v * m &gt;
value; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 1, 2, 3, 4, 5, 6, 6, 7, 7, 7,</div>
<div class=CC1>    8, 8, 8, 8, 11, 11, 11, 11, 11 };</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> ASZ = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> *a;</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v(a, a + ASZ);</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;v&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt;::iterator it = find(v.begin(),
v.end(), 4);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;find: &quot;</font> &lt;&lt; *it
&lt;&lt; endl;</div>
<div class=CC1>  it = find_if(v.begin(), v.end(),</div>
<div class=CC1>    bind2nd(greater&lt;<font color=#ff7700>int</font>&gt;(), 8));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;find_if: &quot;</font> &lt;&lt; *it
&lt;&lt; endl;</div>
<div class=CC1>  it = adjacent_find(v.begin(), v.end());</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != v.end()) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;adjacent_find: &quot;</font> &lt;&lt;
*it</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;, &quot;</font> &lt;&lt; *(it + 1)
&lt;&lt; endl;</div>
<div class=CC1>    it = adjacent_find(it + 1, v.end());</div>
<div class=CC1>  }</div>
<div class=CC1>  it = adjacent_find(v.begin(), v.end(), PlusOne());</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != v.end()) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;adjacent_find PlusOne: &quot;</font>
&lt;&lt; *it</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;, &quot;</font> &lt;&lt; *(it + 1)
&lt;&lt; endl;</div>
<div class=CC1>    it = adjacent_find(it + 1, v.end(), PlusOne());</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> b[] = { 8, 11 };</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> BSZ = <font color=#ff7700>sizeof</font> b / <font color=#ff7700>sizeof</font> *b;</div>
<div class=CC1>  print(b, b + BSZ, <font color=#007f00>&quot;b&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  it = find_first_of(v.begin(), v.end(), b, b + BSZ);</div>
<div class=CC1>  print(it, it + BSZ, <font color=#007f00>&quot;find_first_of&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  it = find_first_of(v.begin(), v.end(),</div>
<div class=CC1>    b, b + BSZ, PlusOne());</div>
<div class=CC1>  print(it,it + BSZ,<font color=#007f00>&quot;find_first_of
PlusOne&quot;</font>,<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  it = search(v.begin(), v.end(), b, b + BSZ);</div>
<div class=CC1>  print(it, it + BSZ, <font color=#007f00>&quot;search&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> c[] = { 5, 6, 7 };</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> CSZ = <font color=#ff7700>sizeof</font> c / <font color=#ff7700>sizeof</font> *c;</div>
<div class=CC1>  print(c, c + CSZ, <font color=#007f00>&quot;c&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  it = search(v.begin(), v.end(), c, c + CSZ,
PlusOne());</div>
<div class=CC1>  print(it, it + CSZ,<font color=#007f00>&quot;search PlusOne&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> d[] = { 11, 11, 11 };</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> DSZ = <font color=#ff7700>sizeof</font> d / <font color=#ff7700>sizeof</font> *d;</div>
<div class=CC1>  print(d, d + DSZ, <font color=#007f00>&quot;d&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  it = find_end(v.begin(), v.end(), d, d + DSZ);</div>
<div class=CC1>  print(it, v.end(),<font color=#007f00>&quot;find_end&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <span lang=IT><font color=#ff7700>int</font> e[] = { 9, 9 };</span></div>
<div class=CC1><span lang=IT>  print(e, e + 2, <font color=#007f00>&quot;e&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</span></div>
<div class=CC1><span lang=IT>  </span>it = find_end(v.begin(),
v.end(), e, e + 2, PlusOne());</div>
<div class=CC1>  print(it, v.end(),<font color=#007f00>&quot;find_end PlusOne&quot;</font>,<font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  it = search_n(v.begin(), v.end(), 3, 7);</div>
<div class=CC1>  print(it, it + 3, <font color=#007f00>&quot;search_n 3, 7&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  it = search_n(v.begin(), v.end(),</div>
<div class=CC1>    6, 15, MulMoreThan(100));</div>
<div class=CC1>  print(it, it + 6,</div>
<div class=CC1>    <font color=#007f00>&quot;search_n 6, 15, MulMoreThan(100)&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;min_element: &quot;</font></div>
<div class=CC1>       &lt;&lt; *min_element(v.begin(), v.end())
&lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;max_element: &quot;</font></div>
<div class=CC1>       &lt;&lt; *max_element(v.begin(), v.end())
&lt;&lt; endl;</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; v2;</div>
<div class=CC1>  replace_copy(v.begin(), v.end(),</div>
<div class=CC1>    back_inserter(v2), 8, 47);</div>
<div class=CC1>  print(v2.begin(), v2.end(), <font color=#007f00>&quot;replace_copy 8
-&gt; 47&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  replace_if(v.begin(), v.end(),</div>
<div class=CC1>    bind2nd(greater_equal&lt;<font color=#ff7700>int</font>&gt;(), 7), -1);</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;replace_if &gt;= 7
-&gt; -1&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The example begins with two predicates: <b>PlusOne</b>,
which is a binary predicate that returns <b>true</b> if the second argument is
equivalent to one plus the first argument; and <b>MulMoreThan</b>, which
returns <b>true</b> if the first argument times the second argument is greater
than a value stored in the object. These binary predicates are used as tests in
the example.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, an array <b>a</b> is created and fed
to the constructor for <b>vector&lt;int&gt; v</b>. This <b>vector</b> is the
target for the search and replace activities, and you’ll note that there are
duplicate elements—these are discovered by some of the search/replace routines.</p>

<p class=MsoNormal>The first test demonstrates <b>find(&nbsp;)</b>, discovering
the value 4 in <b>v</b>. The return value is the iterator pointing to the first
instance of 4, or the end of the input range (<b>v.end(&nbsp;)</b>) if the
search value is not found.</p>

<p class=MsoNormal>The<b> find_if(&nbsp;)</b> algorithm uses a predicate to
determine if it has discovered the correct element. In this example, this
predicate is created on the fly using <b>greater&lt;int&gt;</b> (that is, “see
if the first <b>int </b>argument is greater than the second”) and <b>bind2nd(&nbsp;)</b>
to fix the second argument to 8. Thus, it returns true if the value in <b>v</b>
is greater than 8.</p>

<p class=MsoNormal>Since two identical objects appear next to each other in a
number of cases in <b>v</b>, the test of <b>adjacent_find(&nbsp;)</b> is
designed to find them all. It starts looking from the beginning and then drops
into a <b>while</b> loop, making sure that the iterator <b>it</b> has not
reached the end of the input sequence (which would mean that no more matches
can be found). For each match it finds, the loop prints the matches and then
performs the next <b>adjacent_find(&nbsp;)</b>, this time using <b>it + 1</b>
as the first argument (this way, it will still find two pairs in a triple).</p>

<p class=MsoNormal>You might look at the <b>while</b> loop and think that you
can do it a bit more cleverly, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <font color=#ff7700>while</font>(it != v.end()) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;adjacent_find: &quot;</font> &lt;&lt;
*it++</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;, &quot;</font> &lt;&lt; *it++
&lt;&lt; endl;</div>
<div class=CC1>    it = adjacent_find(it, v.end());</div>
<div class=CC1>  }</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This is exactly what we tried first. However, we did not get
the output we expected, on any compiler. This is because there is no guarantee
about when the increments occur in this expression.</p>

<p class=MsoNormal>The next test uses <b>adjacent_find(&nbsp;)</b> with the <b>PlusOne</b>
predicate, which discovers all the places where the next number in the sequence
<b>v</b> changes from the previous by one. The same <b>while</b> approach finds
all the cases.</p>

<p class=MsoNormal>The<b> find_first_of(&nbsp;)</b> algorithm requires a second
range of objects for which to hunt; this is provided in the array <b>b</b>. Because
the first range and the second range in <b>find_first_of(&nbsp;)</b> are
controlled by separate template arguments, those ranges can refer to two
different types of containers, as seen here. The second form of <b>find_first_of(&nbsp;)</b>
is also tested, using <b>PlusOne</b>.</p>

<p class=MsoNormal>The<b> search(&nbsp;)</b> algorithm finds exactly the second
range inside the first one, with the elements in the same order. The second
form of <b>search(&nbsp;)</b> uses a predicate, which is typically just
something that defines equivalence, but it also presents some interesting
possibilities—here, the <b>PlusOne</b> predicate causes the range <b>{ 4, 5, 6
}</b> to be found.</p>

<p class=MsoNormal>The <b>find_end(&nbsp;)</b> test discovers the <i>last</i>
occurrence of the entire sequence <b>{ 11, 11, 11 }</b>. To show that it has in
fact found the last occurrence, the rest of <b>v</b> starting from <b>it</b> is
printed.</p>

<p class=MsoNormal>The first <b>search_n(&nbsp;)</b> test looks for 3 copies of
the value 7, which it finds and prints. When using the second version of <b>search_n(&nbsp;)</b>,
the predicate is ordinarily meant to be used to determine equivalence between
two elements, but we’ve taken some liberties and used a function object that
multiplies the value in the sequence by (in this case) 15 and checks to see if
it’s greater than 100. That is, the <b>search_n(&nbsp;)</b> test says “find me
6 consecutive values that, when multiplied by 15, each produce a number greater
than 100.” Not exactly what you normally expect to do, but it might give you
some ideas the next time you have an odd searching problem.</p>

<p class=MsoNormal>The<b> min_element(&nbsp;)</b> and <b>max_element(&nbsp;)</b>
algorithms are straightforward, but they look odd, as if the function is being
dereferenced with a ‘<b>*</b>’. Actually, the returned iterator is being
dereferenced to produce the value for printing.</p>

<p class=MsoNormal>To test replacements, <b>replace_copy(&nbsp;)</b> is used
first (so it doesn’t modify the original <b>vector</b>) to replace all values
of 8 with the value 47. Notice the use of <b>back_inserter(&nbsp;)</b> with the
empty <b>vector</b> <b>v2</b>. To demonstrate <b>replace_if(&nbsp;)</b>, a
function object is created using the standard template <b>greater_equal</b>
along with <b>bind2nd</b> to replace all the values that are greater than or
equal to 7 with the value -1.</p>

<h3><a href="#_TocRef22433884" name="_Toc22433884">Comparing ranges</a></h3>

<p class=MsoNormal>These algorithms provide ways to compare two ranges. At
first glance, the operations they perform seem similar to the <b>search(&nbsp;)</b>
function. However, <b>search(&nbsp;)</b> tells you where the second sequence
appears within the first, and <b>equal(&nbsp;)</b> and <b>lexicographical_compare(&nbsp;)
</b>simply tell you how two sequences compare. On the other hand, <b>mismatch(&nbsp;)</b>
does tell you where the two sequences go out of sync, but those sequences must
be exactly the same length.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>equal</b>(InputIterator first1, InputIterator last1,<br>
  InputIterator first2);<br>
bool <b>equal</b>(InputIterator first1, InputIterator last1,<br>
  InputIterator first2 BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>In both these functions, the first range is the typical one,
<b>[first1, last1)</b>. The second range starts at <b>first2</b>, but there is
no “last2” because its length is determined by the length of the first range.
The <b>equal(&nbsp;)</b> function returns true if both ranges are exactly the
same (the same elements in the same order). In the first case, the <b>operator==</b>
performs the comparison, and in the second case <b>binary_pred</b> decides if
two elements are the same.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>lexicographical_compare</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2);<br>
bool <b>lexicographical_compare</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>These two functions determine if the first range is
“lexicographically less” than the second. (They return <b>true</b> if range 1
is less than range 2, and false otherwise.) <i>Lexicographical comparison</i>,
or “dictionary” comparison, means that the comparison is done in the same way that
we establish the order of strings in a dictionary: one element at a time. The
first elements determine the result if these elements are different, but if
they’re equal, the algorithm moves on to the next elements and looks at those,
and so on until it finds a mismatch. At that point, it looks at the elements,
and if the element from range 1 is less than the element from range two, <b>lexicographical_compare(&nbsp;)</b>
returns <b>true</b>; otherwise, it returns <b>false</b>. If it gets all the way
through one range or the other (the ranges may be different lengths for this
algorithm) without finding an inequality, range 1 is <i>not </i>less than range
2, so the function returns <b>false</b>.</p>

<p class=MsoNormal>If the two ranges are different lengths, a missing element
in one range acts as one that “precedes” an element that exists in the other
range, so “abc” precedes “abcd.” If the algorithm reaches the end of one of the
ranges without a mismatch, then the shorter range comes first. In that case, if
the shorter range is the first range, the result is <b>true</b>, otherwise it
is <b>false</b>.</p>

<p class=MsoNormal>In the first version of the function, <b>operator&lt;</b>
performs the comparisons, and in the second version, <b>binary_pred</b> is used.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>pair&lt;InputIterator1,
InputIterator2&gt;<br>
<b>mismatch</b>(InputIterator1 first1, InputIterator1 last1,<br>
  InputIterator2 first2);<br>
pair&lt;InputIterator1, InputIterator2&gt;<br>
<b>mismatch</b>(InputIterator1 first1, InputIterator1 last1,<br>
  InputIterator2 first2, BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>As in <b>equal(&nbsp;)</b>, the length of both ranges is
exactly the same, so only the first iterator in the second range is necessary,
and the length of the first range is used as the length of the second range.
Whereas <b>equal(&nbsp;)</b> just tells you whether the two ranges are the
same, <b>mismatch(&nbsp;)</b> tells you where they begin to differ. To
accomplish this, you must be told (1) the element in the first range where the
mismatch occurred and (2) the element in the second range where the mismatch
occurred. These two iterators are packaged together into a <b>pair</b> object
and returned. If no mismatch occurs, the return value is <b>last1</b> combined
with the past-the-end iterator of the second range. The <b>pair</b> template
class is a <b>struct</b> with two elements denoted by the member names <b>first</b>
and <b>second</b> and is defined in the <b>&lt;utility&gt;</b> header.</p>

<p class=MsoNormal>As in <b>equal(&nbsp;)</b>, the first function tests for
equality using <b>operator==</b> while the second one uses <b>binary_pred</b>.</p>

<h4>Example</h4>

<p class=MsoNormal>Because the Standard C++ <b>string</b> class is built like a
container (it has <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> member functions
that produce objects of type <b>string::iterator</b>), it can be used to
conveniently create ranges of characters to test with the STL comparison
algorithms. However, note that <b>string </b>has a fairly complete set of
native operations, so look at the <b>string</b> class before using the STL
algorithms to perform operations.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Comparison.cpp</font></div>
<div class=CC1><font color=#dd0000>// The STL range comparison algorithms.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Strings provide a convenient way to create</font></div>
<div class=CC1>  <font color=#dd0000>// ranges of characters, but you should</font></div>
<div class=CC1>  <font color=#dd0000>// normally look for native string operations:</font></div>
<div class=CC1>  string s1(<font color=#007f00>&quot;This is a test&quot;</font>);</div>
<div class=CC1>  string s2(<font color=#007f00>&quot;This is a Test&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;s1: &quot;</font> &lt;&lt; s1 &lt;&lt;
endl &lt;&lt; <font color=#007f00>&quot;s2: &quot;</font> &lt;&lt; s2 &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;compare s1 &amp; s1: &quot;</font></div>
<div class=CC1>       &lt;&lt; equal(s1.begin(), s1.end(), s1.begin())
&lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;compare s1 &amp; s2: &quot;</font></div>
<div class=CC1>       &lt;&lt; equal(s1.begin(), s1.end(), s2.begin())
&lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;lexicographical_compare s1 &amp;
s1: &quot;</font></div>
<div class=CC1>       &lt;&lt; lexicographical_compare(s1.begin(),
s1.end(),</div>
<div class=CC1>          s1.begin(), s1.end()) &lt;&lt;  endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;lexicographical_compare s1 &amp;
s2: &quot;</font></div>
<div class=CC1>       &lt;&lt; lexicographical_compare(s1.begin(),
s1.end(),</div>
<div class=CC1>          s2.begin(), s2.end()) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;lexicographical_compare s2 &amp;
s1: &quot;</font></div>
<div class=CC1>       &lt;&lt; lexicographical_compare(s2.begin(),
s2.end(),</div>
<div class=CC1>          s1.begin(), s1.end()) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;lexicographical_compare shortened
&quot;</font></div>
<div class=CC1>          <font color=#007f00>&quot;s1 &amp; full-length s2: &quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  string s3(s1);</div>
<div class=CC1>  <font color=#ff7700>while</font>(s3.length() != 0) {</div>
<div class=CC1>    <font color=#ff7700>bool</font> result = lexicographical_compare(</div>
<div class=CC1>      s3.begin(), s3.end(), s2.begin(),s2.end());</div>
<div class=CC1>    cout &lt;&lt; s3 &lt;&lt; endl &lt;&lt; s2 &lt;&lt;
<font color=#007f00>&quot;, result = &quot;</font></div>
<div class=CC1>         &lt;&lt; result &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>if</font>(result == <font color=#ff7700>true</font>) <font color=#ff7700>break</font>;</div>
<div class=CC1>    s3 = s3.substr(0, s3.length() - 1);</div>
<div class=CC1>  }</div>
<div class=CC1>  pair&lt;string::iterator, string::iterator&gt; p =</div>
<div class=CC1>    mismatch(s1.begin(), s1.end(), s2.begin());</div>
<div class=CC1>  print(p.first, s1.end(), <font color=#007f00>&quot;p.first&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  print(p.second, s2.end(),
<font color=#007f00>&quot;p.second&quot;</font>,<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that the only difference between <b>s1</b> and <b>s2</b>
is the capital ‘T’ in <b>s2</b>’s “Test.” Comparing <b>s1</b> and <b>s1</b> for
equality yields <b>true</b>, as expected, while <b>s1</b> and <b>s2</b> are not
equal because of the capital ‘T’.</p>

<p class=MsoNormal>To understand the output of the <b>lexicographical_compare(&nbsp;)</b>
tests, remember two things: first, the comparison is performed
character-by-character, and second, on our platform capital letters “precede”
lowercase letters. In the first test, <b>s1</b> is compared to <b>s1</b>. These
are exactly equivalent. One is <i>not</i> lexicographically less than the other
(which is what the comparison is looking for), and thus the result is <b>false</b>.
The second test is asking “does <b>s1</b> precede <b>s2</b>?” When the
comparison gets to the ‘t’ in “test”, it discovers that the lowercase ‘t’ in <b>s1</b>
is “greater” than the uppercase ‘T’ in <b>s2</b>, so the answer is again <b>false</b>.
However, if we test to see whether <b>s2</b> precedes <b>s1</b>, the answer is <b>true</b>.</p>

<p class=MsoNormal>To further examine lexicographical comparison, the next test
in this example compares <b>s1</b> with <b>s2</b> again (which returned <b>false</b>
before). But this time it repeats the comparison, trimming one character off
the end of <b>s1</b> (which is first copied into <b>s3</b>) each time through
the loop until the test evaluates to <b>true</b>. What you’ll see is that, as
soon as the uppercase ‘T’ is trimmed off <b>s3</b> (the copy of <b>s1</b>), the
characters, which are exactly equal up to that point, no longer count. Because <b>s3</b>
is shorter than <b>s2</b>, it lexicographically precedes <b>s2</b>.</p>

<p class=MsoNormal>The final test uses<b> mismatch(&nbsp;)</b>. To capture the
return value, create the appropriate <b>pair p</b>, constructing the template
using the iterator type from the first range and the iterator type from the
second range (in this case, both <b>string::iterator</b>s). To print the
results, the iterator for the mismatch in the first range is <b>p.first</b>,
and for the second range is <b>p.second</b>. In both cases, the range is
printed from the mismatch iterator to the end of the range so you can see
exactly where the iterator points.</p>

<h3><a href="#_TocRef22433885" name="_Toc22433885">Removing elements</a></h3>

<p class=MsoNormal>Because of the genericity of the STL, the concept of removal
is a bit constrained. Since elements can only be “removed” via iterators, and
iterators can point to arrays, <b>vector</b>s, <b>list</b>s, and so on, it is
not safe or reasonable to try to destroy the elements that are being removed
and to change the size of the input range <b>[first, last)</b>. (An array, for
example, cannot have its size changed.) So instead, what the STL “remove”
functions do is rearrange the sequence so that the “removed” elements are at
the end of the sequence, and the “un-removed” elements are at the beginning of
the sequence (in the same order that they were before, minus the removed
elements—that is, this is a <i>stable</i> operation). Then the function will
return an iterator to the “new last” element of the sequence, which is the end
of the sequence without the removed elements and the beginning of the sequence
of the removed elements. In other words, if <b>new_last</b> is the iterator
that is returned from the “remove” function, <b>[first, new_last)</b> is the
sequence without any of the removed elements, and <b>[new_last, last)</b> is
the sequence of removed elements.</p>

<p class=MsoNormal>If you are simply using your sequence, including the removed
elements, with more STL algorithms, you can just use <b>new_last</b> as the new
past-the-end iterator. However, if you’re using a resizable container <b>c </b>(not
an array) and you want to eliminate the removed elements from the container,
you can use <b>erase(&nbsp;)</b> to do so, for example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>c.erase(remove(c.begin(), c.end(), value), c.end());</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can also use the <b>resize(&nbsp;)</b> member function
that belongs to all standard sequences (more on this in the next chapter).</p>

<p class=MsoNormal>The return value of <b>remove(&nbsp;)</b> is the <b>new_last</b>
iterator, so <b>erase(&nbsp;)</b> deletes all the removed elements from <b>c</b>.</p>

<p class=MsoNormal>The iterators in <b>[new_last, last)</b> are
dereferenceable, but the element values are unspecified and should not be used.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>remove</b>(ForwardIterator first,<br>
  ForwardIterator last, const T&amp; value);<br>
ForwardIterator <b>remove_if</b>(ForwardIterator first,<br>
  ForwardIterator last, Predicate pred);<br>
OutputIterator <b>remove_copy</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result, const T&amp;<br>
  value);<br>
OutputIterator <b>remove_copy_if</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result, Predicate<br>
  pred);</p>

</div>

<p class=MsoNormal>Each of the “remove” forms moves through the range <b>[first,
last)</b>, finding values that match a removal criterion and copying the
unremoved elements over the removed elements (thus effectively removing them).
The original order of the unremoved elements is maintained. The return value is
an iterator pointing past the end of the range that contains none of the
removed elements. The values that this iterator points to are unspecified.</p>

<p class=MsoNormal>The “if” versions pass each element to <b>pred(&nbsp;)</b>
to determine whether it should be removed. (If <b>pred(&nbsp;)</b> returns <b>true</b>,
the element is removed.) The “copy” versions do not modify the original
sequence, but instead copy the unremoved values into a range beginning at <b>result</b>
and return an iterator indicating the past-the-end value of this new range.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>unique</b>(ForwardIterator first,<br>
  ForwardIterator last);<br>
ForwardIterator <b>unique</b>(ForwardIterator first,<br>
  ForwardIterator last, BinaryPredicate binary_pred);<br>
OutputIterator <b>unique_copy</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result);<br>
OutputIterator <b>unique_copy</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result,<br>
  BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Each of the “unique” functions moves through the range <b>[first,
last)</b>, finding adjacent values that are equivalent (that is, duplicates)
and “removing” the duplicate elements by copying over them. The original order
of the unremoved elements is maintained. The return value is an iterator
pointing past the end of the range that has the adjacent duplicates removed.</p>

<p class=MsoNormal>Because only duplicates that are adjacent are removed, it’s
likely that you’ll want to call <b>sort(&nbsp;)</b> before calling a “unique”
algorithm, since that will guarantee that <i>all</i> the duplicates are removed.</p>

<p class=MsoNormal>For each iterator value <b>i</b> in the input range, the
versions containing <b>binary_pred</b> call:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>binary_pred(*i, *(i-1));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>and if the result is <b>true</b>, <b>*i</b> is considered a
duplicate.</p>

<p class=MsoNormal>The “copy” versions do not modify the original sequence, but
instead copy the unremoved values into a range beginning at <b>result</b> and
return an iterator indicating the past-the-end value of this new range.</p>

<h4>Example</h4>

<p class=MsoNormal>This example gives a visual demonstration of the way the
“remove” and “unique” functions work.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Removing.cpp</font></div>
<div class=CC1><font color=#dd0000>// The removing algorithms.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> IsUpper {</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>char</font> c) { <font color=#ff7700>return</font> isupper(c); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  string v;</div>
<div class=CC1>  v.resize(25);</div>
<div class=CC1>  generate(v.begin(), v.end(), CharGen());</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;v original&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Create a set of the characters in v:</font></div>
<div class=CC1>  string us(v.begin(), v.end());</div>
<div class=CC1>  sort(us.begin(), us.end());</div>
<div class=CC1>  string::iterator it = us.begin(), cit = v.end(),</div>
<div class=CC1>    uend = unique(us.begin(), us.end());</div>
<div class=CC1>  <font color=#dd0000>// Step through and remove everything:</font></div>
<div class=CC1>  <font color=#ff7700>while</font>(it != uend) {</div>
<div class=CC1>    cit = remove(v.begin(), cit, *it);</div>
<div class=CC1>    print(v.begin(), v.end(), <font color=#007f00>&quot;Complete v&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>    print(v.begin(), cit, <font color=#007f00>&quot;Pseudo v &quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Removed element:\t&quot;</font>
&lt;&lt; *it</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;\nPsuedo Last Element:\t&quot;</font></div>
<div class=CC1>         &lt;&lt; *cit &lt;&lt; endl &lt;&lt; endl;</div>
<div class=CC1>    ++it;</div>
<div class=CC1>  }</div>
<div class=CC1>  generate(v.begin(), v.end(), CharGen());</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;v&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  cit = remove_if(v.begin(), v.end(), IsUpper());</div>
<div class=CC1>  print(v.begin(), cit, <font color=#007f00>&quot;v after remove_if
IsUpper&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Copying versions are not shown for remove()</font></div>
<div class=CC1>  <font color=#dd0000>// and remove_if().</font></div>
<div class=CC1>  sort(v.begin(), cit);</div>
<div class=CC1>  print(v.begin(), cit, <font color=#007f00>&quot;sorted&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  string v2;</div>
<div class=CC1>  v2.resize(cit - v.begin());</div>
<div class=CC1>  unique_copy(v.begin(), cit, v2.begin());</div>
<div class=CC1>  print(v2.begin(), v2.end(), <font color=#007f00>&quot;unique_copy&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Same behavior:</font></div>
<div class=CC1>  cit = unique(v.begin(), cit, equal_to&lt;<font color=#ff7700>char</font>&gt;());</div>
<div class=CC1>  print(v.begin(), cit, <font color=#007f00>&quot;unique
equal_to&lt;char&gt;&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The<b> </b>string <b>v</b> is a container of characters
filled with randomly generated characters. Each character is used in a <b>remove</b>
statement, but the entire string<b> v</b> is displayed each time so you can see
what happens to the rest of the range, after the resulting endpoint (which is
stored in <b>cit</b>).</p>

<p class=MsoNormal>To demonstrate <b>remove_if(&nbsp;)</b>, the standard C
library function <b>isupper(&nbsp;) </b>(in <b>&lt;cctype&gt;</b>)<b> </b>is
called inside the function object class <b>IsUpper</b>, an object of which is<b>
</b>passed as the predicate for <b>remove_if(&nbsp;)</b>.<b> </b>This returns <b>true</b>
only if a character is uppercase, so only lowercase characters will remain.
Here, the end of the range is used in the call to <b>print(&nbsp;)</b> so only
the remaining elements will appear. The copying versions of <b>remove(&nbsp;)</b>
and <b>remove_if(&nbsp;)</b> are not shown because they are a simple variation
on the noncopying versions, which you should be able to use without an example.</p>

<p class=MsoNormal>The range of lowercase letters is sorted in preparation for
testing the “unique” functions. (The “unique” functions are not undefined if
the range isn’t sorted, but it’s probably not what you want.) First, <b>unique_copy(&nbsp;)</b>
puts the unique elements into a new <b>vector</b> using the default element
comparison, and then uses the form of <b>unique(&nbsp;)</b> that takes a
predicate. The predicate is the built-in function object <b>equal_to(&nbsp;)</b>,
which produces the same results as the default element comparison.</p>

<h3><a href="#_TocRef22433886" name="_Toc22433886">Sorting and operations on
sorted ranges</a></h3>

<p class=MsoNormal>A significant category of STL algorithms must operate on a
sorted range. STL provides a number of separate sorting algorithms, depending
on whether the sort should be stable, partial, or just regular (non-stable).
Oddly enough, only the partial sort has a copying version. If you’re using
another sort and you need to work on a copy, you’ll have to make your own copy
before sorting.</p>

<p class=MsoNormal>Once your sequence is sorted, you can perform many
operations on that sequence, from simply locating an element or group of
elements to merging with another sorted sequence or manipulating sequences as
mathematical sets.</p>

<p class=MsoNormal>Each algorithm involved with sorting or operations on sorted
sequences has two versions. The first uses the object’s own <b>operator&lt;</b>
to perform the comparison, and the second uses <b>operator(&nbsp;)(a, b)</b> to
determine the relative order of <b>a</b> and <b>b</b>. Other than this, there
are no differences, so this distinction will not be pointed out in the
description of each algorithm.</p>

<h4>Sorting</h4>

<p class=MsoNormal>The sort algorithms require ranges delimited by
random-access iterators, such as a <b>vector</b> or <b>deque</b>. The <b>list</b>
container has its own built-in <b>sort(&nbsp;)</b> function, since it only
supports bi-directional iteration.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>sort</b>(RandomAccessIterator first, RandomAccessIterator<br>
  last);<br>
void <b>sort</b>(RandomAccessIterator first, RandomAccessIterator<br>
  last, StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Sorts <b>[first, last)</b> into ascending order. The first
form uses <b>operator&lt;</b> and the second form uses the supplied comparator
object to determine the order.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>stable_sort</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last);<br>
void <b>stable_sort</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last, StrictWeakOrdering<br>
  binary_pred);</p>

</div>

<p class=MsoNormal>Sorts <b>[first, last)</b> into ascending order, preserving
the original ordering of equivalent elements. (This is important if elements
can be equivalent but not identical.)</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>partial_sort</b>(RandomAccessIterator first,<br>
  RandomAccessIterator middle, RandomAccessIterator last);<br>
void <b>partial_sort</b>(RandomAccessIterator first,<br>
  RandomAccessIterator middle, RandomAccessIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Sorts the number of elements from <b>[first, last)</b> that
can be placed in the range <b>[first, middle)</b>. The rest of the elements end
up in <b>[middle, last)</b> and have no guaranteed order.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>RandomAccessIterator <b>partial_sort_copy</b>(InputIterator first,<br>
  InputIterator last, RandomAccessIterator result_first,<br>
  RandomAccessIterator result_last);<br>
RandomAccessIterator <b>partial_sort_copy</b>(InputIterator first,<br>
  InputIterator last, RandomAccessIterator result_first,<br>
  RandomAccessIterator result_last, StrictWeakOrdering<br>
  binary_pred);</p>

</div>

<p class=MsoNormal>Sorts the number of elements from <b>[first, last)</b> that
can be placed in the range <b>[result_first, result_last)</b> and copies those
elements into <b>[result_first, result_last)</b>. If the range <b>[first, last)</b>
is smaller than <b>[result_first, result_last)</b>, the smaller number of
elements is used.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>nth_element</b>(RandomAccessIterator first,<br>
  RandomAccessIterator nth, RandomAccessIterator last);<br>
void <b>nth_element</b>(RandomAccessIterator first,<br>
  RandomAccessIterator nth, RandomAccessIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Just like <b>partial_sort(&nbsp;)</b>, <b>nth_element(&nbsp;)</b>
partially orders a range of elements. However, it’s much “less ordered” than <b>partial_sort(&nbsp;)</b>.
The only guarantee from <b>nth_element(&nbsp;)</b> is that whatever <i>location
</i>you choose will become a dividing point. All the elements in the range <b>[first,
nth) </b>will pair-wise satisfy the binary predicate (<b>operator&lt;</b> by
default, as usual),<b> </b>and all the elements in the range <b>(nth, last]</b>
will not. However, neither subrange is in any particular order, unlike <b>partial_sort(&nbsp;)</b>
which has the first range in sorted order.</p>

<p class=MsoNormal>If all you need is this very weak ordering (if, for example,
you’re determining medians, percentiles, and so on), this algorithm is faster
than <b>partial_sort(&nbsp;)</b>.</p>

<h4>Locating elements in sorted ranges</h4>

<p class=MsoNormal>Once a range is sorted, you can use a group of operations to
find elements within those ranges. In the following functions, there are always
two forms. One assumes that the intrinsic <b>operator&lt;</b> performs the
sort, and the second operator must be used if some other comparison function
object performs the sort. You must use the same comparison for locating
elements as you do to perform the sort; otherwise, the results are undefined.
In addition, if you try to use these functions on unsorted ranges, the results
will be undefined.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>binary_search</b>(ForwardIterator first, ForwardIterator<br>
  last, const T&amp; value);<br>
bool <b>binary_search</b>(ForwardIterator first, ForwardIterator<br>
  last, const T&amp; value, StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Tells you whether <b>value</b> appears in the sorted range <b>[first,
last)</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>lower_bound</b>(ForwardIterator first,<br>
  ForwardIterator last, const T&amp; value);<br>
ForwardIterator <b>lower_bound</b>(ForwardIterator first,<br>
  ForwardIterator last, const T&amp; value, StrictWeakOrdering<br>
  binary_pred);</p>

</div>

<p class=MsoNormal>Returns an iterator indicating the first occurrence of <b>value</b>
in the sorted range <b>[first, last)</b>. If <b>value</b> is not present, an
iterator to where it would fit in the sequence is returned.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>ForwardIterator <b>upper_bound</b>(ForwardIterator first,<br>
  ForwardIterator last, const T&amp; value);<br>
ForwardIterator <b>upper_bound</b>(ForwardIterator first,<br>
  ForwardIterator last, const T&amp; value, StrictWeakOrdering<br>
  binary_pred);</p>

</div>

<p class=MsoNormal>Returns an iterator indicating one past the last occurrence
of <b>value</b> in the sorted range <b>[first, last)</b>. If <b>value</b> is
not present, an iterator to where it would fit in the sequence is returned.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>pair&lt;ForwardIterator,
ForwardIterator&gt; <b>equal_range</b>(ForwardIterator first, ForwardIterator last,<br>
  const T&amp; value);<br>
pair&lt;ForwardIterator, ForwardIterator&gt; <b>equal_range</b>(ForwardIterator
first, ForwardIterator last,<br>
  const T&amp; value, StrictWeakOrdering binary_pred);</p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>Essentially
combines <b>lower_bound(&nbsp;)</b> and <b>upper_bound(&nbsp;)</b> to return a <b>pair</b>
indicating the first and one-past-the-last occurrences of <b>value</b> in the
sorted range <b>[first, last)</b>. Both iterators indicate the location where <b>value</b>
would fit if it is not found.</p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>You may find
it surprising that the binary search algorithms take a forward iterator instead
of a random access iterator. (Most explanations of binary search use indexing.)
Remember that a random access iterator “is-a” forward iterator, and can be used
wherever the latter is specified. If the iterator passed to one of these
algorithms in fact supports random access, then the efficient logarithmic-time
procedure is used, otherwise a linear search is performed.<a href="#_ftn96" name="_ftnref96"><span
class=MsoFootnoteReference>[96]</span></a></p>

</div>

<h4>Example</h4>

<p class=MsoNormal>The<b> </b>following example turns each input word into an <b>NString</b>
and adds it to a <b>vector&lt;NString&gt;</b>. The <b>vector</b> is then used
to demonstrate the various sorting and searching algorithms.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:SortedSearchTest.cpp</font></div>
<div class=CC1><font color=#dd0000>// Test searching in sorted ranges.</font></div>
<div class=CC1><font color=#dd0000>// NString</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;NString.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> vector&lt;NString&gt;::iterator sit;</div>
<div class=CC1>  <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;Test.txt&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  cout.setf(ios::boolalpha);</div>
<div class=CC1>  vector&lt;NString&gt; original;</div>
<div class=CC1>  copy(istream_iterator&lt;string&gt;(in),</div>
<div class=CC1>    istream_iterator&lt;string&gt;(),
back_inserter(original));</div>
<div class=CC1>  require(original.size() &gt;= 4, <font color=#007f00>&quot;Must have four
elements&quot;</font>);</div>
<div class=CC1>  vector&lt;NString&gt; v(original.begin(),
original.end()),</div>
<div class=CC1>    w(original.size() / 2);</div>
<div class=CC1>  sort(v.begin(), v.end());</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;sort&quot;</font>);</div>
<div class=CC1>  v = original;</div>
<div class=CC1>  stable_sort(v.begin(), v.end());</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;stable_sort&quot;</font>);</div>
<div class=CC1>  v = original;</div>
<div class=CC1>  sit it = v.begin(), it2;</div>
<div class=CC1>  <font color=#dd0000>// Move iterator to middle</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; v.size() / 2; i++)</div>
<div class=CC1>    ++it;</div>
<div class=CC1>  partial_sort(v.begin(), it, v.end());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;middle = &quot;</font> &lt;&lt; *it
&lt;&lt; endl;</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;partial_sort&quot;</font>);</div>
<div class=CC1>  v = original;</div>
<div class=CC1>  <font color=#dd0000>// Move iterator to a quarter position</font></div>
<div class=CC1>  it = v.begin();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; v.size() / 4; i++)</div>
<div class=CC1>    ++it;</div>
<div class=CC1>  <font color=#dd0000>// Less elements to copy from than to the destination</font></div>
<div class=CC1>  partial_sort_copy(v.begin(), it, w.begin(), w.end());</div>
<div class=CC1>  print(w.begin(), w.end(),
<font color=#007f00>&quot;partial_sort_copy&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Not enough room in destination</font></div>
<div class=CC1>  partial_sort_copy(v.begin(), v.end(),
w.begin(),w.end());</div>
<div class=CC1>  print(w.begin(), w.end(), <font color=#007f00>&quot;w
partial_sort_copy&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// v remains the same through all this process</font></div>
<div class=CC1>  assert(v == original);</div>
<div class=CC1>  nth_element(v.begin(), it, v.end());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;The nth_element = &quot;</font> &lt;&lt;
*it &lt;&lt; endl;</div>
<div class=CC1>  print(v.begin(), v.end(), <font color=#007f00>&quot;nth_element&quot;</font>);</div>
<div class=CC1>  string f = original[rand() % original.size()];</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;binary search: &quot;</font></div>
<div class=CC1>       &lt;&lt; binary_search(v.begin(), v.end(), f)
&lt;&lt; endl;</div>
<div class=CC1>  sort(v.begin(), v.end());</div>
<div class=CC1>  it = lower_bound(v.begin(), v.end(), f);</div>
<div class=CC1>  it2 = upper_bound(v.begin(), v.end(), f);</div>
<div class=CC1>  print(it, it2, <font color=#007f00>&quot;found range&quot;</font>);</div>
<div class=CC1>  pair&lt;sit, sit&gt; ip = equal_range(v.begin(),
v.end(), f);</div>
<div class=CC1>  print(ip.first, ip.second, <font color=#007f00>&quot;equal_range&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example uses the <b>NString</b> class seen earlier,
which stores an occurrence number with copies of a string. The call to <b>stable_sort(&nbsp;)</b>
shows how the original order for objects with equal strings is preserved. You
can also see what happens during a partial sort (the remaining unsorted
elements are in no particular order). There is no “partial stable sort.”</p>

<p class=MsoNormal>Notice in the call to <b>nth_element(&nbsp;)</b> that,
whatever the nth element turns out to be (which will vary from one run to
another because of <b>URandGen</b>), the elements before that are less, and
after that are greater, but the elements have no particular order other than
that. Because of <b>URandGen</b>, there are no duplicates, but if you use a
generator that allows duplicates, you’ll see that the elements before the nth
element will be less than or equal to the nth element.</p>

<p class=MsoNormal>This example also illustrates all three binary search
algorithms. As advertised, <b>lower_bound(&nbsp;)</b> refers to the first
element in the sequence equal to a given key, <b>upper_bound(&nbsp;)</b> points
one past the last, and <b>equal_range(&nbsp;)</b> returns both results as a
pair.</p>

<h4>Merging sorted ranges</h4>

<p class=MsoNormal>As before, the first form of each function assumes that the
intrinsic <b>operator&lt;</b> performs the sort. The second form must be used
if some other comparison function object performs the sort. You must use the
same comparison for locating elements as you do to perform the sort; otherwise,
the results are undefined. In addition, if you try to use these functions on
unsorted ranges, the results will be undefined.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>merge</b>(InputIterator1 first1, InputIterator1<br>
  last1, InputIterator2 first2, InputIterator2 last2,<br>
  OutputIterator result);<br>
OutputIterator <b>merge</b>(InputIterator1 first1, InputIterator1<br>
  last1, InputIterator2 first2, InputIterator2 last2,<br>
  OutputIterator result, StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Copies elements from <b>[first1, last1)</b> and <b>[first2,
last2)</b> into <b>result</b>, such that the resulting range is sorted in
ascending order. This is a stable operation.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>inplace_merge</b>(BidirectionalIterator first,<br>
  BidirectionalIterator middle, BidirectionalIterator<br>
  last);<br>
void <b>inplace_merge</b>(BidirectionalIterator first,<br>
  BidirectionalIterator middle, BidirectionalIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>This assumes that <b>[first, middle)</b> and <b>[middle,
last)</b> are each sorted ranges in the same sequence. The two ranges are
merged so that the resulting range <b>[first, last)</b> contains the combined
ranges in sorted order.</p>

<h4>Example</h4>

<p class=MsoNormal>It’s easier to see what goes on with merging if <b>int</b>s
are used. The following example also emphasizes how the algorithms (and our own
<b>print</b> template) work with arrays as well as containers:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:MergeTest.cpp</font></div>
<div class=CC1><font color=#dd0000>// Test merging in sorted ranges.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 15;</div>
<div class=CC1>  <font color=#ff7700>int</font> a[SZ*2] = {0};</div>
<div class=CC1>  <font color=#dd0000>// Both ranges go in the same array:</font></div>
<div class=CC1>  generate(a, a + SZ, SkipGen(0, 2));</div>
<div class=CC1>  a[3] = 4;</div>
<div class=CC1>  a[4] = 4;</div>
<div class=CC1>  generate(a + SZ, a + SZ*2, SkipGen(1, 3));</div>
<div class=CC1>  print(a, a + SZ, <font color=#007f00>&quot;range1&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  print(a + SZ, a + SZ*2, <font color=#007f00>&quot;range2&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> b[SZ*2] = {0}; <font color=#dd0000>// Initialize all to zero</font></div>
<div class=CC1>  merge(a, a + SZ, a + SZ, a + SZ*2, b);</div>
<div class=CC1>  print(b, b + SZ*2, <font color=#007f00>&quot;merge&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Reset b</font></div>
<div class=CC1>  <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ*2; i++)</span></div>
<div class=CC1><span lang=SV>    </span>b[i] = 0;</div>
<div class=CC1>  inplace_merge(a, a + SZ, a + SZ*2);</div>
<div class=CC1>  print(a, a + SZ*2, <font color=#007f00>&quot;inplace_merge&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font>* end = set_union(a, a + SZ, a + SZ, a + SZ*2, b);</div>
<div class=CC1>  print(b, end, <font color=#007f00>&quot;set_union&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, instead of creating two separate
arrays, both ranges are created end to end in the array <b>a</b>. (This will
come in handy for the <b>inplace_merge</b>.) The first call to <b>merge(&nbsp;)</b>
places the result in a different array, <b>b</b>. For comparison, <b>set_union(&nbsp;)</b>
is also called, which has the same signature and similar behavior, except that
it removes duplicates from the second set. Finally, <b>inplace_merge(&nbsp;)</b>
combines both parts of <b>a</b>.</p>

<h4>Set operations on sorted ranges</h4>

<p class=MsoNormal>Once ranges have been sorted, you can perform mathematical
set operations on them.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>bool <b>includes</b>(InputIterator1 first1, InputIterator1 last1,<br>
  InputIterator2 first2, InputIterator2 last2);<br>
bool <b>includes</b>(InputIterator1 first1, InputIterator1 last1,<br>
  InputIterator2 first2, InputIterator2 last2,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Returns <b>true</b> if <b>[first2, last2)</b> is a subset of
<b>[first1, last1)</b>. Neither range is required to hold only unique elements,
but if <b>[first2, last2)</b> holds <b>n</b> elements of a particular value, <b>[first1,
last1)</b> must also hold at least <b>n</b> elements if the result is to be <b>true</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_union</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result);<br>
OutputIterator <b>set_union</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Creates the mathematical union of two sorted ranges in the <b>result</b>
range, returning the end of the output range. Neither input range is required
to hold only unique elements, but if a particular value appears multiple times
in both input sets, the resulting set will contain the larger number of
identical values.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_intersection</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result);<br>
OutputIterator <b>set_intersection</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Produces, in <b>result</b>, the intersection of the two
input sets, returning the end of the output range—that is, the set of values
that appear in both input sets. Neither input range is required to hold only
unique elements, but if a particular value appears multiple times in both input
sets, the resulting set will contain the smaller number of identical values.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_difference</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result);<br>
OutputIterator <b>set_difference</b>(InputIterator1 first1,<br>
  InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Produces, in <b>result</b>, the mathematical set difference,
returning the end of the output range. All the elements that are in <b>[first1,
last1)</b> but not in <b>[first2, last2)</b> are placed in the result set.
Neither input range is required to hold only unique elements, but if a
particular value appears multiple times in both input sets (<b>n</b> times in
set 1 and <b>m</b> times in set 2), the resulting set will contain <b>max(n-m,
0)</b> copies of that value.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>set_symmetric_difference</b>(InputIterator1<br>
  first1, InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result);<br>
OutputIterator <b>set_symmetric_difference</b>(InputIterator1<br>
  first1, InputIterator1 last1, InputIterator2 first2,<br>
  InputIterator2 last2, OutputIterator result,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Constructs, in <b>result</b>, the set containing:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>All the elements in set 1 that are not in set 2.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>All the elements in set 2 that are not in set 1.</p>

<p class=MsoNormal>Neither input range is required to hold only unique
elements, but if a particular value appears multiple times in both input sets (<b>n</b>
times in set 1 and <b>m</b> times in set 2), the resulting set will contain <b>abs(n-m)</b>
copies of that value, where <b>abs(&nbsp;)</b> is the absolute value. The
return value is the end of the output range.</p>

<h4>Example</h4>

<p class=MsoNormal>It’s easiest to see the set operations demonstrated using
simple <b>vector</b>s of characters. These characters are randomly generated
and then sorted, but the duplicates are retained so that you can see what the
set operations do when there are duplicates.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:SetOperations.cpp</font></div>
<div class=CC1><font color=#dd0000>// Set operations on sorted ranges.</font></div>
<div class=CC1><font color=#dd0000>//{L} Generators</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Generators.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 30;</div>
<div class=CC1>  <font color=#ff7700>char</font> v[SZ + 1], v2[SZ + 1];</div>
<div class=CC1>  CharGen g;</div>
<div class=CC1>  generate(v, v + SZ, g);</div>
<div class=CC1>  generate(v2, v2 + SZ, g);</div>
<div class=CC1>  <span lang=SV>sort(v, v + SZ);</span></div>
<div class=CC1><span lang=SV>  sort(v2, v2 + SZ);</span></div>
<div class=CC1><span lang=SV>  </span>print(v, v + SZ, <font color=#007f00>&quot;v&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  print(v2, v2 + SZ, <font color=#007f00>&quot;v2&quot;</font>, <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>bool</font> b = includes(v, v + SZ, v + SZ/2, v + SZ);</div>
<div class=CC1>  cout.setf(ios::boolalpha);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;includes: &quot;</font> &lt;&lt; b
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>char</font> v3[SZ*2 + 1], *end;</div>
<div class=CC1>  end = set_union(v, v + SZ, v2, v2 + SZ, v3);</div>
<div class=CC1>  print(v3, end, <font color=#007f00>&quot;set_union&quot;</font>, <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  end = set_intersection(v, v + SZ, v2, v2 + SZ, v3);</div>
<div class=CC1>  print(v3, end, <font color=#007f00>&quot;set_intersection&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  end = set_difference(v, v + SZ, v2, v2 + SZ, v3);</div>
<div class=CC1>  print(v3, end, <font color=#007f00>&quot;set_difference&quot;</font>,
<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  end = set_symmetric_difference(v, v + SZ,</div>
<div class=CC1>    v2, v2 + SZ, v3);</div>
<div class=CC1>  print(v3, end,
<font color=#007f00>&quot;set_symmetric_difference&quot;</font>,<font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>After <b>v</b> and <b>v2</b> are generated, sorted, and
printed, the <b>includes(&nbsp;)</b> algorithm is tested by seeing if the
entire range of <b>v</b> contains the last half of <b>v</b>. It does, so the
result should always be true. The array <b>v3</b> holds the output of <b>set_union(&nbsp;)</b>,
<b>set_intersection(&nbsp;)</b>, <b>set_difference(&nbsp;)</b>, and <b>set_symmetric_difference(&nbsp;)</b>,
and the results of each are displayed so you can ponder them and convince
yourself that the algorithms work as promised.</p>

<h3><a href="#_TocRef22433887" name="_Toc22433887">Heap operations</a></h3>

<p class=MsoNormal>A heap is an array-like data structure used to implement a
“priority queue,” which is just a range that is organized in a way that
accommodates retrieving elements by priority according to some comparison
function. The heap operations in the standard library allow a sequence to be
treated as a “heap” data structure, which always efficiently returns the
element of highest priority, without fully ordering the entire sequence.</p>

<p class=MsoNormal>As with the “sort” operations, there are two versions of
each function. The first uses the object’s own <b>operator&lt;</b> to perform
the comparison; the second uses an additional <b>StrictWeakOrdering</b> object’s <b>operator(&nbsp;)(a, b)</b> to compare two objects for <b>a</b> <b>&lt;</b>
<b>b</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>make_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last);<br>
void <b>make_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Turns an arbitrary range into a heap.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>push_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last);<br>
void <b>push_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Adds the element *(<b>last-1)</b> to the heap determined by
the range <b>[first, last-1)</b>. In other words, it places the last element in
its proper location in the heap.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>pop_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last);<br>
void <b>pop_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>Places the largest element (which is actually in <b>*first</b>,
before the operation, because of the way heaps are defined) into the position <b>*(last-1)</b>
<i>and</i> reorganizes the remaining range so that it’s still in heap order. If
you simply grabbed <b>*first</b>, the next element would not be the
next-largest element; so you must use <b>pop_heap(&nbsp;)</b> if you want to
maintain the heap in its proper priority-queue order.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>sort_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last);<br>
void <b>sort_heap</b>(RandomAccessIterator first,<br>
  RandomAccessIterator last,<br>
  StrictWeakOrdering binary_pred);</p>

</div>

<p class=MsoNormal>This could be thought of as the complement to <b>make_heap(&nbsp;)</b>.
It takes a range that is in heap order and turns it into ordinary sorted order,
so it is no longer a heap. That means that if you call <b>sort_heap(&nbsp;)</b>,
you can no longer use <b>push_heap(&nbsp;)</b> or <b>pop_heap(&nbsp;)</b> on
that range. (Rather, you can use those functions, but they won’t do anything
sensible.) This is not a stable sort.</p>

<h3><a href="#_TocRef22433888" name="_Toc22433888">Applying an operation to
each element in a range</a></h3>

<p class=MsoNormal>These algorithms move through the entire range and perform
an operation on each element. They differ in what they do with the results of
that operation: <b>for_each(&nbsp;)</b> discards the return value of the
operation, and <b>transform(&nbsp;)</b> places the results of each operation
into a destination sequence (which can be the original sequence).</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>UnaryFunction <b>for_each</b>(InputIterator first, InputIterator<br>
  last, UnaryFunction f);</p>

</div>

<p class=MsoNormal>Applies the function object <b>f</b> to each element in <b>[first,
last)</b>, discarding the return value from each individual application of <b>f</b>.
If <b>f </b>is just a function pointer, you are typically not interested in the
return value; but if <b>f </b>is an object that maintains some internal state,
it can capture the combined return value of being applied to the range. The
final return value of <b>for_each(&nbsp;)</b> is <b>f</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>transform</b>(InputIterator first, InputIterator<br>
  last, OutputIterator result, UnaryFunction f);<br>
OutputIterator <b>transform</b>(InputIterator1 first,<br>
  InputIterator1 last, InputIterator2 first2,<br>
  OutputIterator result, BinaryFunction f);</p>

</div>

<p class=MsoNormal>Like <b>for_each(&nbsp;)</b>, <b>transform(&nbsp;)</b>
applies a function object <b>f</b> to each element in the range <b>[first,
last)</b>. However, instead of discarding the result of each function call, <b>transform(&nbsp;)</b>
copies the result (using <b>operator=</b>) into <b>*result</b>, incrementing <b>result</b>
after each copy. (The sequence pointed to by <b>result</b> must have enough
storage; otherwise, use an inserter to force insertions instead of
assignments.)</p>

<p class=MsoNormal>The first form of <b>transform(&nbsp;)</b> simply calls <b>f(*first)</b>,
where first ranges through the input sequence. Similarly, the second form calls
<b>f(*first1, *first2)</b>.<b> </b>(Note that the length of the second input
range is determined by the length of the first.) The return value in both cases
is the past-the-end iterator for the resulting output range.</p>

<h4>Examples</h4>

<p class=MsoNormal>Since much of what you do with objects in a container is to
apply an operation to all those objects, these are fairly important algorithms
and merit several illustrations.</p>

<p class=MsoNormal>First, consider <b>for_each(&nbsp;)</b>. This sweeps through
the range, pulling out each element and passing it as an argument as it calls
whatever function object it’s been given. Thus, <b>for_each(&nbsp;)</b>
performs operations that you might normally write out by hand. If you look in
your compiler’s header file at the template defining <b>for_each(&nbsp;)</b>,
you’ll see something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> InputIterator, <font color=#ff7700>class</font> Function&gt;</div>
<div class=CC1>Function for_each(InputIterator first, InputIterator
last,</div>
<div class=CC1>                  Function f) {</div>
<div class=CC1>    <font color=#ff7700>while</font>(first != last)</div>
<div class=CC1>      f(*first++);</div>
<div class=CC1>    <font color=#ff7700>return</font> f;</div>
<div class=CC1>}</div>

</div>

<p class=MsoNormal>The following example shows several ways this template can
be expanded. First, we need a class that keeps track of its objects so we can
know that it’s being properly destroyed:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Counted.h</font></div>
<div class=CC1><font color=#dd0000>// An object that keeps track of itself.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef COUNTED_H</font></div>
<div class=CC1><font color=#7F7F00>#define COUNTED_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Counted {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> count;</div>
<div class=CC1>  <font color=#ff7700>char</font>* ident;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Counted(<font color=#ff7700>char</font>* id) : ident(id) { ++count; }</div>
<div class=CC1>  ~Counted() {</div>
<div class=CC1>    std::cout &lt;&lt; ident &lt;&lt; <font color=#007f00>&quot; count =
&quot;</font></div>
<div class=CC1>              &lt;&lt; --count &lt;&lt; std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> CountedVector : <font color=#ff7700>public</font>
std::vector&lt;Counted*&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  CountedVector(<font color=#ff7700>char</font>* id) {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      push_back(<font color=#ff7700>new</font> Counted(id));</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// COUNTED_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Counted.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Counted.h&quot;</font></div>
<div class=CC1><font color=#ff7700>int</font> Counted::count = 0;</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<p class=MsoNormal>The <b>class Counted</b> keeps a static count of the number
of <b>Counted</b> objects that have been created, and notifies you as they are
destroyed.<a href="#_ftn97" name="_ftnref97"><span
class=MsoFootnoteReference>[97]</span></a> In
addition, each <b>Counted</b> keeps a <b>char*</b> identifier to make tracking
the output easier.</p>

<p class=MsoNormal>The <b>CountedVector</b> is derived from <b>vector&lt;Counted*&gt;</b>,
and in the constructor it creates some <b>Counted</b> objects, handing each one
your desired <b>char*</b>. The <b>CountedVector</b> makes testing quite simple,
as you can see here:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:ForEach.cpp {-mwcc}</font></div>
<div class=CC1><font color=#dd0000>// Use of STL for_each() algorithm.</font></div>
<div class=CC1><font color=#dd0000>//{L} Counted</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Counted.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Function object:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> DeleteT {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> <font color=#ff7700>operator</font>()(T* x) { <font color=#ff7700>delete</font> x; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Template function:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>void</font> wipe(T* x) { <font color=#ff7700>delete</font> x; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CountedVector B(<font color=#007f00>&quot;two&quot;</font>);</div>
<div class=CC1>  for_each(B.begin(), B.end(), DeleteT&lt;Counted&gt;());</div>
<div class=CC1>  CountedVector C(<font color=#007f00>&quot;three&quot;</font>);</div>
<div class=CC1>  for_each(C.begin(), C.end(), wipe&lt;Counted&gt;);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since this is obviously something you might want to do a
lot, why not create an algorithm to <b>delete</b> all the pointers in a
container? You could use <b>transform(&nbsp;)</b>. The value of <b>transform(&nbsp;)</b>
over <b>for_each(&nbsp;)</b> is that <b>transform(&nbsp;)</b> assigns the
result of calling the function object into a resulting range, which can
actually be the input range. That case means a literal transformation for the
input range, since each element would be a modification of its previous value.
In this example, this approach would be especially useful since it’s more
appropriate to assign to each pointer the safe value of zero after calling <b>delete</b>
for that pointer. <b>Transform(&nbsp;)</b> can easily do this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Transform.cpp {-mwcc}</font></div>
<div class=CC1><font color=#dd0000>// Use of STL transform() algorithm.</font></div>
<div class=CC1><font color=#dd0000>//{L} Counted</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Counted.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; T* deleteP(T* x) { <font color=#ff7700>delete</font> x;
<font color=#ff7700>return</font> 0; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>struct</font> Deleter {</div>
<div class=CC1>  T* <font color=#ff7700>operator</font>()(T* x) { <font color=#ff7700>delete</font> x; <font color=#ff7700>return</font> 0; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CountedVector cv(<font color=#007f00>&quot;one&quot;</font>);</div>
<div class=CC1>  transform(cv.begin(), cv.end(), cv.begin(),</div>
<div class=CC1>    deleteP&lt;Counted&gt;);</div>
<div class=CC1>  CountedVector cv2(<font color=#007f00>&quot;two&quot;</font>);</div>
<div class=CC1>  transform(cv2.begin(), cv2.end(), cv2.begin(),</div>
<div class=CC1>    Deleter&lt;Counted&gt;());</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This shows both approaches: using a template function or a
templatized function object. After the call to <b>transform(&nbsp;)</b>, the <b>vector</b>
contains five null pointers, which is safer since any duplicate <b>delete</b>s
will have no effect.</p>

<p class=MsoNormal>One thing you cannot do is <b>delete</b> every pointer in a
collection without wrapping the call to <b>delete </b>inside a function or an
object. That is, you do the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>for_each(a.begin(), a.end(), ptr_fun(<font color=#ff7700>operator</font> <font color=#ff7700>delete</font>));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This has the same problem as the call to <b>destroy(&nbsp;)</b>
did earlier: <b>operator delete(&nbsp;)</b> takes a <b>void*</b>, but iterators
aren’t pointers. Even if you could make it compile, what you’d get is a
sequence of calls to the function that releases the storage. You will not get
the effect of calling <b>delete</b> for each pointer in <b>a</b>, however—the destructor
will not be called. This is typically not what you want, so you will need to wrap
your calls to <b>delete</b>.</p>

<p class=MsoNormal>In the previous example of <b>for_each(&nbsp;)</b>, the
return value of the algorithm was ignored. This return value is the function
that is passed into <b>for_each(&nbsp;)</b>. If the function is just a pointer
to a function, the return value is not very useful, but if it is a function
object, that function object may have internal member data that it uses to
accumulate information about all the objects that it sees during <b>for_each(&nbsp;)</b>.</p>

<p class=MsoNormal>For example, consider a simple model of inventory. Each <b>Inventory</b>
object has the type of product it represents (here, single characters will be
used for product names), the quantity of that product, and the price of each
item:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Inventory.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef INVENTORY_H</font></div>
<div class=CC1><font color=#7F7F00>#define INVENTORY_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::rand;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Inventory {</div>
<div class=CC1>  <font color=#ff7700>char</font> item;</div>
<div class=CC1>  <font color=#ff7700>int</font> quantity;</div>
<div class=CC1>  <font color=#ff7700>int</font> value;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Inventory(<font color=#ff7700>char</font> it, <font color=#ff7700>int</font> quant, <font color=#ff7700>int</font> val)</div>
<div class=CC1>  : item(it), quantity(quant), value(val) {}</div>
<div class=CC1>  <font color=#dd0000>// Synthesized operator= &amp; copy-constructor OK</font></div>
<div class=CC1>  <font color=#ff7700>char</font> getItem() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> item; }</div>
<div class=CC1>  <font color=#ff7700>int</font> getQuantity() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> quantity; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setQuantity(<font color=#ff7700>int</font> q) { quantity = q; }</div>
<div class=CC1>  <font color=#ff7700>int</font> getValue() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> value; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setValue(<font color=#ff7700>int</font> val) { value = val; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(</div>
<div class=CC1>    std::ostream&amp; os, <font color=#ff7700>const</font> Inventory&amp; inv) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; inv.item &lt;&lt; <font color=#007f00>&quot;: &quot;</font></div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot;quantity &quot;</font> &lt;&lt;
inv.quantity</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot;, value &quot;</font> &lt;&lt; inv.value;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A generator:</font></div>
<div class=CC1><font color=#ff7700>struct</font> InvenGen {</div>
<div class=CC1>  Inventory <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>static</font> <font color=#ff7700>char</font> c = 'a';</div>
<div class=CC1>    <font color=#ff7700>int</font> q = rand() % 100;</div>
<div class=CC1>    <font color=#ff7700>int</font> v = rand() % 500;</div>
<div class=CC1>    <font color=#ff7700>return</font> Inventory(c++, q, v);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// INVENTORY_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Member functions get the item name and get and set quantity
and value. An <b>operator&lt;&lt;</b> prints the <b>Inventory</b> object to an <b>ostream</b>.
A generator creates objects that have sequentially labeled items and random quantities
and values.</p>

<p class=MsoNormal>To find out the total number of items and total value, you
can create a function object to use with <b>for_each(&nbsp;)</b> that has data
members to hold the totals:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:CalcInventory.cpp</font></div>
<div class=CC1><font color=#dd0000>// More use of for_each().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Inventory.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// To calculate inventory totals:</font></div>
<div class=CC1><font color=#ff7700>class</font> InvAccum {</div>
<div class=CC1>  <font color=#ff7700>int</font> quantity;</div>
<div class=CC1>  <font color=#ff7700>int</font> value;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  InvAccum() : quantity(0), value(0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>const</font> Inventory&amp; inv) {</div>
<div class=CC1>    quantity += inv.getQuantity();</div>
<div class=CC1>    value += inv.getQuantity() * inv.getValue();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> InvAccum&amp;
ia) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;total quantity: &quot;</font>
&lt;&lt; ia.quantity</div>
<div class=CC1>              &lt;&lt; <font color=#007f00>&quot;, total value: &quot;</font> &lt;&lt;
ia.value;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Inventory&gt; vi;</div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate_n(back_inserter(vi), 15, InvenGen());</div>
<div class=CC1>  print(vi.begin(), vi.end(), <font color=#007f00>&quot;vi&quot;</font>);</div>
<div class=CC1>  InvAccum ia = for_each(vi.begin(),vi.end(),
InvAccum());</div>
<div class=CC1>  cout &lt;&lt; ia &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>InvAccum</b>’s <b>operator(&nbsp;)</b> takes a single
argument, as required by <b>for_each(&nbsp;)</b>. As <b>for_each(&nbsp;)</b>
moves through its range, it takes each object in that range and passes it to <b>InvAccum::operator(&nbsp;)</b>,
which performs calculations and saves the result. At the end of this process, <b>for_each(&nbsp;)</b>
returns the <b>InvAccum</b> object, which is printed.</p>

<p class=MsoNormal>You can do most things to the <b>Inventory</b> objects using
<b>for_each(&nbsp;)</b>. For example, <b>for_each(&nbsp;)</b> can handily
increase all the prices by 10%. But you’ll notice that the <b>Inventory</b> objects
have no way to change the <b>item</b> value. The programmers who designed <b>Inventory</b>
thought this was a good idea. After all, why would you want to change the name
of an item? But marketing has decided that they want a “new, improved” look by
changing all the item names to uppercase. They’ve done studies and determined
that the new names will boost sales (well, marketing needs to have <i>something</i>
to do…). So <b>for_each(&nbsp;)</b> will not work here, but <b>transform(&nbsp;)</b>
will:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:TransformNames.cpp</font></div>
<div class=CC1><font color=#dd0000>// More use of transform().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Inventory.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> NewImproved {</div>
<div class=CC1>  Inventory <font color=#ff7700>operator</font>()(<font color=#ff7700>const</font> Inventory&amp; inv) {</div>
<div class=CC1>    <font color=#ff7700>return</font> Inventory(toupper(inv.getItem()),</div>
<div class=CC1>      inv.getQuantity(), inv.getValue());</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Inventory&gt; vi;</div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  <span lang=SV>generate_n(back_inserter(vi), 15,
InvenGen());</span></div>
<div class=CC1><span lang=SV>  print(vi.begin(), vi.end(),
<font color=#007f00>&quot;vi&quot;</font>);</span></div>
<div class=CC1><span lang=SV>  </span>transform(vi.begin(),vi.end(),vi.begin(),NewImproved());</div>
<div class=CC1>  <span lang=SV>print(vi.begin(), vi.end(),
<font color=#007f00>&quot;vi&quot;</font>);</span></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that the resulting range is the same as the input
range; that is, the transformation is performed in place.</p>

<p class=MsoNormal>Now suppose that the sales department needs to generate
special price lists with different discounts for each item. The original list
must stay the same, and any number of special lists need to be generated. Sales
will give you a separate list of discounts for each new list. To solve this
problem, we can use the second version of <b>transform(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:SpecialList.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using the second version of transform().</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Inventory.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> Discounter {</div>
<div class=CC1>  Inventory <font color=#ff7700>operator</font>()(<font color=#ff7700>const</font> Inventory&amp; inv,</div>
<div class=CC1>    <font color=#ff7700>float</font> discount) {</div>
<div class=CC1>    <font color=#ff7700>return</font> Inventory(inv.getItem(), inv.getQuantity(),</div>
<div class=CC1>      <font color=#ff7700>int</font>(inv.getValue() * (1 - discount)));</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> DiscGen {</div>
<div class=CC1>  <font color=#ff7700>float</font> <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>float</font> r = <font color=#ff7700>float</font>(rand() % 10);</div>
<div class=CC1>    <font color=#ff7700>return</font> r / 100.0;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Inventory&gt; vi;</div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate_n(back_inserter(vi), 15, InvenGen());</div>
<div class=CC1>  print(vi.begin(), vi.end(), <font color=#007f00>&quot;vi&quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>float</font>&gt; disc;</div>
<div class=CC1>  generate_n(back_inserter(disc), 15, DiscGen());</div>
<div class=CC1>  print(disc.begin(), disc.end(), <font color=#007f00>&quot;Discounts:&quot;</font>);</div>
<div class=CC1>  vector&lt;Inventory&gt; discounted;</div>
<div class=CC1>  transform(vi.begin(),vi.end(), disc.begin(),</div>
<div class=CC1>    back_inserter(discounted), Discounter());</div>
<div class=CC1>  print(discounted.begin(),
discounted.end(),<font color=#007f00>&quot;discounted&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Given an <b>Inventory</b> object and a discount percentage,
the <b>Discounter</b> function object produces a new <b>Inventory</b> with the
discounted price. The <b>DiscGen</b> function object just generates random
discount values between 1% and 10% to use for testing. In <b>main(&nbsp;)</b>,
two <b>vector</b>s are created, one for <b>Inventory</b> and one for discounts.
These are passed to <b>transform(&nbsp;)</b> along with a <b>Discounter</b>
object, and <b>transform(&nbsp;) </b>fills a new <b>vector&lt;Inventory&gt;</b>
called <b>discounted</b>.</p>

<h3><a href="#_TocRef22433889" name="_Toc22433889">Numeric algorithms</a></h3>

<p class=MsoNormal>These algorithms are all tucked into the header <b>&lt;numeric&gt;</b>,
since they are primarily useful for performing numeric calculations.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>T <b>accumulate</b>(InputIterator first, InputIterator last, T<br>
  result);<br>
T <b>accumulate</b>(InputIterator first, InputIterator last, T<br>
  result, BinaryFunction f);</p>

</div>

<p class=MsoNormal>The first form is a generalized summation; for each element
pointed to by an iterator <b>i</b> in <b>[first, last)</b>, it performs the
operation <b>result = result + *i</b>, where <b>result</b> is of type <b>T</b>.
However, the second form is more general; it applies the function <b>f(result,
*i)</b> on each element <b>*i</b> in the range from beginning to end.</p>

<p class=MsoNormal>Note the similarity between the second form of <b>transform(&nbsp;)</b>
and the second form of <b>accumulate(&nbsp;)</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>T <b>inner_product</b>(InputIterator1 first1, InputIterator1<br>
  last1, InputIterator2 first2, T init);<br>
T <b>inner_product</b>(InputIterator1 first1, InputIterator1<br>
  last1, InputIterator2 first2, T init, BinaryFunction1<br>
  op1, BinaryFunction2 op2);</p>

</div>

<p class=MsoNormal>Calculates a generalized inner product of the two ranges <b>[first1,
last1)</b> and <b>[first2, first2 + (last1 - first1))</b>. The return value is
produced by multiplying the element from the first sequence by the “parallel”
element in the second sequence and then adding it to the sum. Thus, if you have
two sequences <b>{1, 1, 2, 2}</b> and <b>{1, 2, 3, 4}</b>, the inner product
becomes</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>(1*1) + (1*2) + (2*3) + (2*4)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which is 17. The <b>init</b> argument is the initial value
for the inner product—this is probably zero but may be anything and is especially
important for an empty first sequence, because then it becomes the default
return value. The second sequence must have at least as many elements as the
first.</p>

<p class=MsoNormal>The second form simply applies a pair of functions to its
sequence. The <b>op1</b> function is used in place of addition and <b>op2</b>
is used instead of multiplication. Thus, if you applied the second version of <b>inner_product(&nbsp;)</b>
to the sequence, the result would be the following operations:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>init = op1(init, op2(1,1));</div>
<div class=CC1>init = op1(init, op2(1,2));</div>
<div class=CC1>init = op1(init, op2(2,3));</div>
<div class=CC1>init = op1(init, op2(2,4));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Thus, it’s similar to <b>transform(&nbsp;)</b>, but two
operations are performed instead of one.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>partial_sum</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result);<br>
OutputIterator <b>partial_sum</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result,<br>
  BinaryFunction op);</p>

</div>

<p class=MsoNormal>Calculates a generalized partial sum. A new sequence is
created, beginning at <b>result</b>. Each element is the sum of all the
elements up to the currently selected element in <b>[first, last)</b>. For
example, if the original sequence is <b>{1, 1, 2, 2, 3}</b>, the generated
sequence is <b>{1, 1 + 1, 1 + 1 + 2, 1 + 1 + 2 + 2, 1 + 1 + 2 + 2 + 3}</b>,
that is, <b>{1, 2, 4, 6, 9}</b>.</p>

<p class=MsoNormal>In the second version, the binary function <b>op</b> is used
instead of the <b>+</b> operator to take all the “summation” up to that point
and combine it with the new value. For example, if you use <b>multiplies&lt;int&gt;(&nbsp;)</b>
as the object for the sequence, the output is <b>{1, 1, 2, 4, 12}</b>. Note
that the first output value is always the same as the first input value.</p>

<p class=MsoNormal>The return value is the end of the output range <b>[result,
result + (last - first) )</b>.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>OutputIterator <b>adjacent_difference</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result);<br>
OutputIterator <b>adjacent_difference</b>(InputIterator first,<br>
  InputIterator last, OutputIterator result, BinaryFunction<br>
  op);</p>

</div>

<p class=MsoNormal>Calculates the differences of adjacent elements throughout
the range <b>[first, last)</b>. This means that in the new sequence, the value
is the value of the difference of the current element and the previous element
in the original sequence (the first value is unchanged). For example, if the
original sequence is <b>{1, 1, 2, 2, 3}</b>, the resulting sequence is <b>{1, 1
– 1, 2 – 1, 2 – 2, 3 – 2}</b>, that is: <b>{1, 0, 1, 0, 1}</b>.</p>

<p class=MsoNormal>The second form uses the binary function <b>op</b> instead
of the ‘<b>–</b>’ operator to perform the “differencing.” For example, if you
use <b>multiplies&lt;int&gt;(&nbsp;)</b> as the function object for the
sequence, the output is <b>{1, 1, 2, 4, 6}</b>.</p>

<p class=MsoNormal>The return value is the end of the output range <b>[result,
result + (last - first) )</b>.</p>

<h4>Example</h4>

<p class=MsoNormal>This program tests all the algorithms in <b>&lt;numeric&gt;</b>
in both forms, on integer arrays. You’ll notice that in the test of the form
where you supply the function or functions, the function objects used are the
ones that produce the same result as form one, so the results will be exactly
the same. This should also demonstrate a bit more clearly the operations that
are going on and how to substitute your own operations.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:NumericTest.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;numeric&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[] = { 1, 1, 2, 2, 3, 5, 7, 9, 11, 13 };</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> ASZ = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> a[0];</div>
<div class=CC1>  print(a, a + ASZ, <font color=#007f00>&quot;a&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> r = accumulate(a, a + ASZ, 0);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;accumulate 1: &quot;</font> &lt;&lt; r
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Should produce the same result:</font></div>
<div class=CC1>  r = accumulate(a, a + ASZ, 0, plus&lt;<font color=#ff7700>int</font>&gt;());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;accumulate 2: &quot;</font> &lt;&lt; r
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>int</font> b[] = { 1, 2, 3, 4, 1, 2, 3, 4, 1, 2 };</div>
<div class=CC1>  print(b, b + <font color=#ff7700>sizeof</font> b / <font color=#ff7700>sizeof</font> b[0], <font color=#007f00>&quot;b&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  r = inner_product(a, a + ASZ, b, 0);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;inner_product 1: &quot;</font> &lt;&lt;
r &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Should produce the same result:</font></div>
<div class=CC1>  r = inner_product(a, a + ASZ, b, 0,</div>
<div class=CC1>    plus&lt;<font color=#ff7700>int</font>&gt;(), multiplies&lt;<font color=#ff7700>int</font>&gt;());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;inner_product 2: &quot;</font> &lt;&lt;
r &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>int</font>* it = partial_sum(a, a + ASZ, b);</div>
<div class=CC1>  print(b, it, <font color=#007f00>&quot;partial_sum 1&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Should produce the same result:</font></div>
<div class=CC1>  it = partial_sum(a, a + ASZ, b, plus&lt;<font color=#ff7700>int</font>&gt;());</div>
<div class=CC1>  print(b, it, <font color=#007f00>&quot;partial_sum 2&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  it = adjacent_difference(a, a + ASZ, b);</div>
<div class=CC1>  print(b, it, <font color=#007f00>&quot;adjacent_difference 1&quot;</font>,<font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Should produce the same result:</font></div>
<div class=CC1>  it = adjacent_difference(a, a + ASZ, b, minus&lt;<font color=#ff7700>int</font>&gt;());</div>
<div class=CC1>  print(b, it, <font color=#007f00>&quot;adjacent_difference 2&quot;</font>,<font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that the return value of <b>inner_product(&nbsp;)</b>
and <b>partial_sum(&nbsp;)</b> is the past-the-end iterator for the resulting
sequence, so it is used as the second iterator in the <b>print(&nbsp;)</b>
function.</p>

<p class=MsoNormal>Since the second form of each function allows you to provide
your own function object, only the first form of the function is purely
“numeric.” You could conceivably do things that are not intuitively numeric
with <b>inner_product(&nbsp;)</b>.</p>

<h3><a href="#_TocRef22433890" name="_Toc22433890">General utilities</a></h3>

<p class=MsoNormal>Finally, here are some basic tools that are used with the
other algorithms; you may or may not use them directly yourself.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>(Templates in the &lt;utility&gt;
header)<br>
template&lt;class T1, class T2&gt; struct <b>pair</b>;<br>
template&lt;class T1, class T2&gt; pair&lt;T1, T2&gt;<br>
  <b>make_pair</b>(const T1&amp;, const T2&amp;);</p>

</div>

<p class=MsoNormal>These were described and used earlier in this chapter. A <b>pair</b>
is simply a way to package two objects (which may be of different types) into a
single object. This is typically used when you need to return more than one
object from a function, but it can also be used to create a container that
holds <b>pair </b>objects or to pass more than one object as a single argument.
You access the elements by saying <b>p.first</b> and <b>p.second</b>, where <b>p</b>
is the <b>pair</b> object. The function <b>equal_range(&nbsp;)</b>, described
in this chapter, returns its result as a <b>pair</b> of iterators, for example.
You can <b>insert(&nbsp;)</b> a <b>pair</b> directly into a <b>map</b> or <b>multimap</b>;
a <b>pair</b> is the <b>value_type</b> for those containers.</p>

<p class=MsoNormal>If you want to create a <b>pair </b>“on the fly,” you
typically use the template function <b>make_pair(&nbsp;)</b> rather than
explicitly constructing a <b>pair</b> object. <b>make_pair(&nbsp;)</b> deduces
the types of the arguments it receives, relieving you of the typing as well as
increasing robustness.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>(From &lt;iterator&gt;)<br>
difference_type <b>distance</b>(InputIterator first, InputIterator last);</p>

</div>

<p class=MsoNormal>Tells you the number of elements between <b>first</b> and <b>last</b>.
More precisely, it returns an integral value that tells you the number of times
<b>first</b> must be incremented before it is equal to <b>last</b>. No
dereferencing of the iterators occurs during this process.</p>

<p class=MsoNormal>(From &lt;iterator&gt;)<br>
Moves the iterator <b>i</b> forward by the value of <b>n</b>. (It can also be
moved backward for negative values of <b>n</b> if the iterator is
bidirectional.) This algorithm is aware of the different types of iterators and
will use the most efficient approach. For example, random iterators can be
incremented directly using ordinary arithmetic (<b>i+=n</b>), whereas a
bidirectional iterator must be incremented <b>n</b> times.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>(From &lt;iterator&gt;)<br>
back_insert_iterator&lt;Container&gt;<br>
  <b>back_inserter</b>(Container&amp; x);<br>
front_insert_iterator&lt;Container&gt;<br>
  <b>front_inserter</b>(Container&amp; x);<br>
insert_iterator&lt;Container&gt;<br>
  <b>inserter</b>(Container&amp; x, Iterator i);</p>

</div>

<p class=MsoNormal>These functions are used to create iterators for the given
containers that will insert elements into the container, rather than overwrite
the existing elements in the container using <b>operator= </b>(which is the
default behavior). Each type of iterator uses a different operation for
insertion: <b>back_insert_iterator</b> uses <b>push_back(&nbsp;)</b>, <b>front_insert_iterator</b>
uses <b>push_front(&nbsp;)</b>, and <b>insert_iterator</b> uses <b>insert(&nbsp;)</b>
(and thus it can be used with the associative containers, while the other two
can be used with sequence containers). These will be shown in some detail in
the next chapter.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>const
LessThanComparable&amp; <b>min</b>(const LessThanComparable&amp; a,<br>
  const LessThanComparable&amp; b);<br>
const T&amp; <b>min</b>(const T&amp; a, const T&amp; b,<br>
  BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Returns the lesser of its two arguments, or returns the
first argument if the two are equivalent. The first version performs comparisons
using <b>operator&lt;</b>, and the second passes both arguments to <b>binary_pred</b>
to perform the comparison.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>const
LessThanComparable&amp; <b>max</b>(const LessThanComparable&amp; a,<br>
  const LessThanComparable&amp; b);<br>
const T&amp; <b>max</b>(const T&amp; a, const T&amp; b,<br>
  BinaryPredicate binary_pred);</p>

</div>

<p class=MsoNormal>Exactly like <b>min(&nbsp;)</b>, but returns the greater of
its two arguments.</p>

<div style='border:none;border-top:solid windowtext 1.0pt;padding:1.0pt 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=STLAlgorithmCharChar style='margin-left:0in'>void <b>swap</b>(Assignable&amp; a, Assignable&amp; b);<br>
void <b>iter_swap</b>(ForwardIterator1 a, ForwardIterator2 b);</p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>Exchanges
the values of <b>a</b> and <b>b</b> using assignment. Note that all container
classes use specialized versions of <b>swap(&nbsp;)</b> that are typically more
efficient than this general version.</p>

<p class=MsoNormal style='margin-left:0in;border:none;padding:0in'>The<b>
iter_swap(&nbsp;)</b> function swaps the values that its two arguments
reference.</p>

</div>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef22433891" name="_Toc22433891">Creating your own STL–style algorithms</a></h2>

<p class=MsoNormal>Once you become comfortable with the style of STL
algorithms, you can begin to create your own generic algorithms. Because these
will conform to the conventions of all the other algorithms in the STL, they’re
easy to use for programmers who are familiar with the STL, and thus they become
a way to “extend the STL vocabulary.”</p>

<p class=MsoNormal>The easiest way to approach the problem is to go to the <b>&lt;algorithm&gt;</b>
header file, find something similar to what you need, and pattern your code
after that.<a href="#_ftn98" name="_ftnref98"><span
class=MsoFootnoteReference>[98]</span></a> (Virtually
all STL implementations provide the code for the templates directly in the
header files.)</p>

<p class=MsoNormal>If you take a close look at the list of algorithms in the
Standard C++ library, you might notice a glaring omission: there is no <b>copy_if(&nbsp;)</b>
algorithm. Although it’s true that you can accomplish the same effect with <b>remove_copy_if(&nbsp;)</b>,
this is not quite as convenient because you have to invert the condition.
(Remember, <b>remove_copy_if(&nbsp;)</b> only copies those elements that <i>don’t</i>
match its predicate, in effect <i>removing</i> those that do.) You might be
tempted to write a function object adaptor that negates its predicate before
passing it to <b>remove_copy_if(&nbsp;)</b>, by including a statement something
like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// Assumes pred is the incoming condition</font></div>
<div class=CC1>replace_copy_if(begin, end, not1(pred));</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This seems reasonable, but when you remember that you want
to be able to use predicates that are pointers to raw functions, you see why
this won’t work—<b>not1</b> expects an adaptable function object. The only
solution is to write a <b>copy_if(&nbsp;)</b> algorithm from scratch. Since you
know from inspecting the other copy algorithms that conceptually you need
separate iterators for input and output, the following example will do the job:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:copy_if.h</font></div>
<div class=CC1><font color=#dd0000>// Create your own STL-style
algorithm.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef COPY_IF_H</font></div>
<div class=CC1><font color=#7F7F00>#define COPY_IF_H</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> ForwardIter,</div>
<div class=CC1>  <font color=#ff7700>typename</font> OutputIter, <font color=#ff7700>typename</font> UnaryPred&gt;</div>
<div class=CC1>OutputIter copy_if(ForwardIter begin, ForwardIter end,</div>
<div class=CC1>  OutputIter dest, UnaryPred f) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(begin != end) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(f(*begin))</div>
<div class=CC1>      *dest++ = *begin;</div>
<div class=CC1>    ++begin;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> dest;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// COPY_IF_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that the increment of <b>begin</b> cannot be
integrated into the copy expression.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef22433892" name="_Toc22433892">Summary</a></h2>

<p class=MsoNormal>The goal of this chapter is to give you a practical
understanding of the algorithms in the Standard Template Library. That is, to
make you aware of and comfortable enough with the STL that you begin to use it
on a regular basis (or, at least, to think of using it so you can come back
here and hunt for the appropriate solution). The STL is powerful not only
because it’s a reasonably complete library of tools, but also because it
provides a vocabulary for thinking about problem solutions and it is a framework
for creating additional tools.</p>

<p class=MsoNormal>Although this chapter did show some examples of creating
your own tools, we did not go into the full depth of the theory of the STL
necessary to completely understand all the STL nooks and crannies. Such
understanding will allow you to create tools more sophisticated than those
shown here. This omission was in part because of space limitations, but mostly
because it is beyond the charter of this book—our goal here is to give you
practical understanding that will improve your day-to-day programming skills.</p>

<p class=MsoNormal>A number of books are dedicated solely to the STL (these are
listed in the appendices), but we especially recommend Scott Meyers’<i>
Effective STL</i> (Addison Wesley, 2002).</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef22433893" name="_Toc22433893">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a generator that returns the current value of <b>clock(&nbsp;)</b>
(in <b>&lt;ctime&gt;</b>). Create a <b>list&lt;clock_t&gt;</b>, and fill it
with your generator using <b>generate_n(&nbsp;)</b>. Remove any duplicates in
the list and print it to <b>cout</b> using <b>copy(&nbsp;)</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Using <b>transform(&nbsp;)</b> and <b>toupper(&nbsp;)</b> (in <b>&lt;cctype&gt;</b>),
write a single function call that will convert a string to all uppercase
letters.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>Sum</b> function object template that will accumulate
all the values in a range when used with <b>for_each(&nbsp;)</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write an anagram generator that takes a word as a command-line
argument and produces all possible permutations of the letters.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a “sentence anagram generator” that takes a sentence as a
command-line argument and produces all possible permutations of the words in
the sentence. (It leaves the words alone and just moves them around.)</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a class hierarchy with a base class <b>B</b> and a derived
class <b>D</b>. Put a <b>virtual</b> member function <b>void f(&nbsp;)</b> in <b>B</b>
such that it will print a message indicating that <b>B</b>’s <b>f(&nbsp;)</b>
was called, and redefine this function for <b>D</b> to print a different
message. Create a <b>vector&lt;B*&gt;</b>, and fill it with <b>B</b> and <b>D</b>
objects. Use <b>for_each(&nbsp;)</b> to call <b>f(&nbsp;)</b> for each of the
objects in your <b>vector</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>FunctionObjects.cpp</b> so that it uses <b>float</b>
instead of <b>int</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>FunctionObjects.cpp</b> so that it templatizes the main
body of tests so you can choose which type you’re going to test. (You’ll have
to pull most of <b>main(&nbsp;)</b> out into a separate template function.)</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that takes an integer as a command line argument
and finds all of its factors.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that takes as a command-line argument the name of
a text file. Open this file and read it a word at a time (hint: use <b>&gt;&gt;</b>).
Store each word into a <b>vector&lt;string&gt;</b>. Force all the words to
lowercase, sort them, remove all the duplicates, and print the results.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that finds all the words that are in common
between two input files, using <b>set_intersection(&nbsp;)</b>. Change it to
show the words that are not in common, using <b>set_symmetric_difference(&nbsp;)</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>12.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a program that, given an integer on the command line,
creates a “factorial table” of all the factorials up to and including the
number on the command line. To do this, write a generator to fill a <b>vector&lt;int&gt;</b>,
and then use <b>partial_sum(&nbsp;)</b> with a standard function object.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>13.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>CalcInventory.cpp</b> so that it will find all the
objects that have a quantity that’s less than a certain amount. Provide this
amount as a command-line argument, and use <b>copy_if(&nbsp;)</b> and <b>bind2nd(&nbsp;)</b>
to create the collection of values less than the target value.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>14.&nbsp;&nbsp;&nbsp;&nbsp;</span>Use <b>UrandGen(&nbsp;)</b> to generate 100 numbers. (The size of
the numbers does not matter.) Find which numbers in your range are congruent
mod 23 (meaning they have the same remainder when divided by 23). Manually pick
a random number yourself, and determine whether that number is in your range by
dividing each number in the list by your number and checking if the result is 1
instead of just using <b>find(&nbsp;)</b> with your value.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>15.&nbsp;&nbsp;&nbsp;&nbsp;</span>Fill a <b>vector&lt;double&gt;</b> with numbers representing
angles in radians. Using function object composition, take the sine of all the
elements in your <b>vector</b> (see <b>&lt;cmath&gt;</b>).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>16.&nbsp;&nbsp;&nbsp;&nbsp;</span>Test the speed of your computer. Call <b>srand(time(0))</b>, then
make an array of random numbers. Call <b>srand(time(0))</b> again and generate
the same number of random numbers in a second array. Use <b>equal(&nbsp;)</b>
to see if the arrays are the same. (If your computer is fast enough, <b>time(0)</b>
will return the same value both times it is called.) If the arrays are not the
same, sort them and use <b>mismatch(&nbsp;)</b> to see where they differ. If
they are the same, increase the length of your array and try again.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>17.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create an STL-style algorithm <b>transform_if(&nbsp;)</b>
following the first form of <b>transform(&nbsp;)</b> that performs
transformations only on objects that satisfy a unary predicate. Objects that
don’t satisfy the predicate are omitted from the result. It needs to return a
new “end” iterator.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>18.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create an STL-style algorithm that is an overloaded version of <b>for_each(&nbsp;)</b>
which follows the second form of <b>transform(&nbsp;)</b> and takes two input
ranges so it can pass the objects of the second input range a to a binary
function that it applies to each object of the first range.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>19.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>Matrix</b> class template that is made from a <b>vector&lt;vector&lt;T&gt;
&gt;</b>. Provide it with a friend <b>ostream&amp;
operator&lt;&lt;(ostream&amp;, const Matrix&amp;)</b> to display the matrix.
Create the following binary operations using the STL function objects where
possible: <b>operator+(const Matrix&amp;, const Matrix&amp;)</b> for matrix
addition, <b>operator*(const Matrix&amp;, const vector&lt;int&gt;&amp;)</b> for
multiplying a matrix by a <b>vector</b>, and <b>operator*(const Matrix&amp;,
const Matrix&amp;)</b> for matrix multiplication. (You might need to look up
the mathematical meanings of the matrix operations if you don’t remember them.)
Test your <b>Matrix</b> class template using <b>int</b> and <b>float</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>20.&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=ExercisesCharCharCharCharCharChar>Using the </span>characters<span
class=ExercisesCharCharCharCharCharChar><br>
&quot;~`!@#$%^&amp;*(&nbsp;)_-+=}{[]|\:;&quot;'&lt;.&gt;,?/&quot;,<br>
generate a codebook using an input file given on the command line as a
dictionary of words. Don’t worry about stripping off the non-alphabetic
characters nor worry about case of the words in the dictionary file. Map each
permutation of the character string to a word such as the following:<br>
&quot;=')/%[}]|{*@?!&quot;`,;&gt;&amp;^-~_:$+.#(&lt;\&quot;   apple<br>
&quot;|]\~&gt;#.+%(/-_[`':;=}{*&quot;$^!&amp;?),@&lt;&quot;   carrot<br>
&quot;@=~['].\/&lt;-`&gt;#*)^%+,&quot;;&amp;?!_{:|$}(&quot;   Carrot<br>
etc.</span><span style='font-size:11.0pt'><br>
</span>Make sure that no duplicate codes or words exist in your code
book. Use <b>lexicographical_compare(&nbsp;)</b> to perform a sort on the
codes. Use your code book to encode the dictionary file. Decode your encoding
of the dictionary file, and make sure you get the same contents back.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Using the following names:</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Jon Brittle</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Jane Brittle</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Mike Brittle</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Sharon Brittle</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>George Jensen</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Evelyn Jensen</p>

<p class=ExercisesCharCharCharCharChar style='text-indent:0in'>Find all the
possible ways to arrange them for a wedding picture.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>After being separated for one picture, the bride and groom
decided they wanted to be together for all of them. Find all the possible ways
to arrange the people for the picture if the bride and groom (Jon Brittle and
Jane Brittle) are to be next to each other.<b><span style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I350&gt;</span></b></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A travel company wants to find out the average number of days
people take to travel from one end of the continent to another. The problem is
that in the survey, some people did not take a direct route and took much
longer than is needed (such unusual data points are called “outliers”). Using
the following generator, generate travel days into a <b>vector</b>. Use <b>remove_if(&nbsp;)</b>
to remove all the outliers in your <b>vector</b>. Take the average of the data
in the <b>vector</b> to find out how long people generally take to travel.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
.5in'>&nbsp;</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
.5in'><span style='font-family:"Courier New"'>int travelTime() {</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-family:"Courier New"'>        // The &quot;outlier&quot;</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-family:"Courier New"'>        if(rand() % 10 == 0)</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-family:"Courier New"'>          return rand() % 100;</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-family:"Courier New"'>        // Regular route</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
0in'><span style='font-family:"Courier New"'>        return rand() % 10 + 10;</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.5in;text-indent:
.5in'><span style='font-family:"Courier New"'>}</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'><b><span style='display:none'> &lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I353&gt;</span></b></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>24.&nbsp;&nbsp;&nbsp;&nbsp;</span>Determine how much faster <b>binary_search(&nbsp;)</b> is to <b>find(&nbsp;)</b>
when it comes to searching <i>sorted</i> ranges.<span style='display:none'>&lt;/#&gt;&lt;#TIC2V2_CHAPTER8_I354&gt;</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The army wants to recruit people from its selective service
list. They have decided to recruit those that signed up for the service in 1997
starting from the oldest down to the youngest. Generate an arbitrary amount of
people (give them data members such as <b>age</b> and <b>yearEnrolled</b>) into
a <b>vector</b>. Partition the <b>vector</b> so that those who enrolled in 1997
are ordered at the beginning of the list, starting from the youngest to the
oldest, and leave the remaining part of the list sorted according to age.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>26.&nbsp;&nbsp;&nbsp;&nbsp;</span>Make a <b>class</b> called <b>Town</b> with population, altitude,
and weather data members. Make the weather an <b>enum</b> with <b>{ RAINY,
SNOWY, CLOUDY, CLEAR }</b>. Make a class that generates <b>Town</b> objects.
Generate town names (whether they make sense or not it doesn’t matter) or pull
them off the Internet. Ensure that the whole town name is lower case and there
are no duplicate names. For simplicity, we recommend keeping your town names to
one word. For the population, altitudes, and weather fields, make a generator
that will randomly generate weather conditions, populations within the range
[100 to 1,000,000) and altitudes between [0, 8000) feet. Fill a <b>vector</b>
with your <b>Town</b> objects. Rewrite the <b>vector</b> out to a new file
called <b>Towns.txt</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>27.&nbsp;&nbsp;&nbsp;&nbsp;</span>There was a baby boom, resulting in a 10% population increase in
every town. Update your town data using <b>transform(&nbsp;)</b>, rewrite your
data back out to file.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>28.&nbsp;&nbsp;&nbsp;&nbsp;</span>Find the towns with the highest and lowest population. For this
exercise, implement <b>operator&lt;</b> for your <b>Town</b> class. Also try
implementing a function that returns <b>true</b> if its first parameter is less
than its second. Use it as a predicate to call the algorithm you use.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>29.&nbsp;&nbsp;&nbsp;&nbsp;</span>Find all the towns within the altitudes 2500-3500 feet inclusive.
Implement equality operators for the <b>Town</b> class as needed.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>30.&nbsp;&nbsp;&nbsp;&nbsp;</span>We need to place an airport in a certain altitude, but location
is not a problem. Organize your list of towns so that there are no duplicate
(duplicate meaning that no two altitudes are within the same 100 ft range. Such
classes would include [100, 199), [200, 199), etc. altitudes. Sort this list in
ascending order in at least two different ways using the function objects in <b>&lt;functional&gt;</b>.
Do the same for descending order. Implement relational operators for <b>Town</b>
as needed.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>31.&nbsp;&nbsp;&nbsp;&nbsp;</span>Generate an arbitrary number of random numbers in a stack-based
array. Use <b>max_element(&nbsp;)</b> to find the largest number in array. Swap
it with the number at the end of your array. Find the next largest number and
place it in the array in the position before the previous number. Continue
doing this until all elements have been moved. When the algorithm is complete,
you will have a sorted array. (This is a “selection sort”.)</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>32.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that will take phone numbers from a file (that
also contains names and other suitable information) and change the numbers that
begin with 222 to 863. Be sure to save the old numbers. The file format is as
follows:</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.25in;text-indent:
-.25in'>222 8945</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.25in;text-indent:
-.25in'>756 3920</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.25in;text-indent:
-.25in'>222 8432</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.25in;text-indent:
-.25in'>etc.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>33.&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program that, given a last name, will find everyone with
that last name with his or her corresponding phone number. Use the algorithms
that deal with ranges (<b>lower_bound</b>, <b>upper_bound</b>, <b>equal_range</b>,
etc.). Sort with the last name acting as a primary key and the first name
acting as a secondary key. Assume that you will read the names and numbers from
a file where the format will be as follows. (Be sure to order them so that the
last names are ordered, and the first names are ordered within the last
names.):</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'><b>&nbsp;</b></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>John Doe                        345 9483</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>Nick Bonham                 349 2930</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>Jane Doe                         283 2819</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>&nbsp;</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>34.&nbsp;&nbsp;&nbsp;&nbsp;</span>Given a file with data similar to the following, pull all the
state acronyms from the file and put them in a separate file. (Note that you
can’t depend on the line number for the type of data. The data is on random
lines.)</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>&nbsp;</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>ALABAMA</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>AL</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>AK</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>ALASKA</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>ARIZONA</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>AZ</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>ARKANSAS</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>AR</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>CA</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>CALIFORNIA</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
.25in'>CO</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>COLORADO</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>etc.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>&nbsp;</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:1.0in;text-indent:
0in'>When complete, you should have a file with all the state acronyms which
are:</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.75in;text-indent:
0in'>AL AK AZ AR CA CO CT DE FL GA HI ID IL IN IA KS KY LA ME MD MA MI MN MS MO
MT NE NV NH NJ NM NY NC ND OH OK OR PA RI SC SD TN TX UT VT VA WA WV WI WY</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>35.&nbsp;&nbsp;&nbsp;&nbsp;</span>Make an <b>Employee </b>class with two data members: <b>hours </b>and
<b>hourlyPay</b>. Employee shall also have a <b>calcSalary(&nbsp;)</b> function
which returns the pay for that employee. Generate random hourly pay and hours
for an arbitrary amount of employees. Keep a <b>vector&lt;Employee*&gt;</b>.
Find out how much money the company is going to spend for this pay period.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>36.&nbsp;&nbsp;&nbsp;&nbsp;</span>Race <b>sort(&nbsp;)</b>,<b> partial_sort(&nbsp;)</b>,<b> </b>and
<b>nth_element(&nbsp;)</b> against each other and find out if it’s really worth
the time saved to use one of the weaker sorts if they’re all that’s needed.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section16>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985769" name="_Toc53985769">7: Generic Containers</a></h1>

<p class=Intro style='margin-left:.25in'><i>Container classes </i>are the
solution to a specific kind of code reuse problem. They are building blocks
used to create object–oriented programs, and they make the internals of a
program much easier to construct.</p>

<p class=MsoNormal>A container class describes an object that holds other
objects. Container classes are so important that they were considered
fundamental to early object-oriented languages. In Smalltalk, for example, programmers
think of the language as the program translator together with the class
library, and a critical part of that library is the set of container classes. It
became natural, therefore, for C++ compiler vendors to also include a container
class library. You’ll note that the <b>vector</b> is so useful that it was
introduced in its simplest form early in Volume 1 of this book.</p>

<p class=MsoNormal>Like many other early C++ libraries, early container class
libraries followed Smalltalk’s <i>object-based hierarchy</i>, which worked well
for Smalltalk, but turned out to be awkward and difficult to use in C++.
Another approach was required.</p>

<p class=MsoNormal>The C++ approach to containers is based on templates. The
containers in the Standard C++ library represent a broad range of data
structures designed to work well with the standard algorithms and to meet
common software development needs.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef375545199" name="_Toc375545199">Containers
and iterators</a></h2>

<p class=MsoNormal>If you don’t know how many objects you’re going to need to
solve a particular problem, or how long they will last, you also don’t know
ahead of time how to store those objects. How can you know how much space to
create? The answer is you don’t—until run time.</p>

<p class=MsoNormal>The solution to most problems in object-oriented design
seems simple; you create another type of object. For the storage problem, the
new type of object holds other objects or pointers to objects. This new type of
object, which is typically referred to in C++ as a <i>container</i> (also
called a <i>collection</i> in some languages), expands itself whenever
necessary to accommodate everything you place inside it. You don’t need to know
ahead of time how many objects you’re going to place in a container; you just
create a container object and let it take care of the details.</p>

<p class=MsoNormal>Fortunately, a good object-oriented programming language comes
with a set of containers. In C++, it’s the Standard Template Library (STL). In
some libraries, a generic container is considered good enough for all needs,
and in others (C++ in particular) the library has different types of containers
for different needs: a <b>vector</b> for efficient access to all elements, and
a linked <b>list</b> for efficient insertion at all positions, and several
more, so you can choose the particular type that fits your needs.</p>

<p class=MsoNormal>All containers have some way to put things in and get things
out. The way you place something into a container is fairly obvious; there’s a
function called “push” or “add” or a similar name. The way you retrieve things
from a container is not always as apparent; if an entity is array-like, such as
a <b>vector</b>, you might be able to use an indexing operator or function. But
in many situations this doesn’t make sense. Also, a single-selection function
is restrictive. What if you want to manipulate or compare a group of elements
in the container?</p>

<p class=MsoNormal>The solution for flexible element access is the <i>iterator</i>,
an object whose job is to select the elements within a container and present
them to the user of the iterator. As a class, an iterator also provides a level
of abstraction, which you can use to separate the details of the container from
the code that’s accessing that container. The container, via the iterator, is
seen as a sequence. The iterator lets you traverse the sequence without
worrying about the underlying structure—that is, whether it’s a <b>vector</b>,
a linked <b>list</b>, a <b>set</b>, or something else. This gives you the
flexibility to easily change the underlying data structure without disturbing
the code in your program that traverses the container. Separating iteration
from the container’s control also allows multiple simultaneous iterators.</p>

<p class=MsoNormal>From a design standpoint, all you really want is a sequence
that can be manipulated to solve your problem. If a single type of sequence
satisfied all your needs, there would be no reason to have different types. You
need a choice of containers for two reasons. First, containers provide
different types of interfaces and external behavior. A <b>stack</b> has an
interface and a behavior that is different from that of a <b>queue</b>, which
is different from that of a <b>set</b> or a <b>list</b>. One of these might
provide a more flexible solution to your problem than the other, or it might
provide a clearer abstraction that conveys your design intent. Second,
different containers have different efficiencies for certain operations.
Compare a <b>vector</b> to a <b>list</b>, for example. Both are simple
sequences that can have nearly identical interfaces and external behaviors. But
certain operations can have radically different costs. Randomly accessing
elements in a <b>vector</b> is a constant-time operation; it takes the same
amount of time regardless of the element you select. However, it is expensive
to move through a linked <b>list</b> to randomly access an element, and it
takes longer to find an element if it is farther down the <b>list</b>. On the
other hand, if you want to insert an element in the middle of a sequence, it’s
cheaper with a <b>list</b> than with a <b>vector</b>. The efficiencies of these
and other operations depend on the underlying structure of the sequence. In the
design phase, you might start with a <b>list</b> and, when tuning for
performance, change to a <b>vector</b>, or vice-versa. Because of iterators,
code that merely traverses sequences is insulated from changes in the
underlying sequence implementation.</p>

<p class=MsoNormal>Remember that a container is only a storage cabinet that
holds objects. If that cabinet solves all your needs, it probably doesn’t
really matter <i>how</i> it is implemented. If you’re working in a programming
environment that has built-in overhead due to other factors, the cost
difference between a <b>vector</b> and a linked <b>list</b> might not matter.
You might need only one type of sequence. You can even imagine the “perfect”
container abstraction, which can automatically change its underlying
implementation according to the way it is used.<a href="#_ftn99" name="_ftnref99"><span
class=MsoFootnoteReference>[99]</span></a></p>

<h3><a href="#_TocRef53985771" name="_Toc53985771">STL reference documentation</a></h3>

<p class=MsoNormal>As in the previous chapter, you will notice that this
chapter does not contain exhaustive documentation describing each of the member
functions in each STL container. Although we describe the member functions we
use, we’ve left the full descriptions to others. We recommend the online
resources available for the Dinkumware, Silicon Graphics, and STLPort STL
implementations.<a href="#_ftn100" name="_ftnref100"><span
class=MsoFootnoteReference>[100]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985772" name="_Toc53985772">A
first look</a></h2>

<p class=MsoNormal>Here’s an example using the <b>set</b> class template, a container modeled after a traditional mathematical set and which does not accept
duplicate values. The following <b>set</b> was created to work with <b>int</b>s:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Intset.cpp</font></div>
<div class=CC1><font color=#dd0000>// Simple use of STL set.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  set&lt;<font color=#ff7700>int</font>&gt; intset;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 25; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 10; j++)</div>
<div class=CC1>      <font color=#dd0000>// Try to insert duplicates:</font></div>
<div class=CC1>      intset.insert(j);</div>
<div class=CC1>  assert(intset.size() == 10);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>insert(&nbsp;)</b> member does all the work: it
attempts to insert an element and ignores it if it’s already there. Often the
only activities involved in using a set are simply insertion and testing to see
whether it contains the element. You can also form a union, an intersection, or
a difference of sets and test to see if one set is a subset of another. In this
example, the values 0–9 are inserted into the set 25 times, but only the 10
unique instances are accepted.</p>

<p class=MsoNormal>Now consider taking the form of <b>Intset.cpp</b> and
modifying it to display a list of the words used in a document. The solution
becomes remarkably simple.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:WordSet.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> wordSet(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* fileName) {</div>
<div class=CC1>  ifstream source(fileName);</div>
<div class=CC1>  assure(source, fileName);</div>
<div class=CC1>  string word;</div>
<div class=CC1>  set&lt;string&gt; words;</div>
<div class=CC1>  <font color=#ff7700>while</font>(source &gt;&gt; word)</div>
<div class=CC1>    words.insert(word);</div>
<div class=CC1>  copy(words.begin(), words.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Number of unique words:&quot;</font></div>
<div class=CC1>       &lt;&lt; words.size() &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1)</div>
<div class=CC1>    wordSet(argv[1]);</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    wordSet(<font color=#007f00>&quot;WordSet.cpp&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The only substantive difference here is that the set holds strings
instead of integers. The words are pulled from a file, but the other operations
are similar to those in <b>Intset.cpp</b>. Not only does the output reveal that
duplicates have been ignored, but because of the way <b>set</b> is implemented,
the words are automatically sorted.</p>

<p class=MsoNormal>A <b>set</b> is an example of an <i>associative container</i>,
one of the three categories of containers provided by the Standard C++ library.
The containers and their categories are summarized in the following table:</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:.25in;border-collapse:collapse;border:none'>
 <tr>
  <td valign=top style='border-top:solid windowtext 1.0pt;border-left:none;
  border-bottom:solid windowtext 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Category</p>
  </td>
  <td valign=top style='border-top:solid windowtext 1.0pt;border-left:none;
  border-bottom:solid windowtext 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=tablehead0>Containers</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Sequence Containers</p>
  </td>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>vector</b>, <b>list</b>, <b>deque</b></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Container Adaptors</p>
  </td>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>queue</b>, <b>stack</b>, <b>priority_queue</b></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext>Associative Containers</p>
  </td>
  <td valign=top style='border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=tabletext><b>set</b>, <b>map</b>, <b>multiset</b>, <b>multimap</b></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:6.0pt'>These categories represent
different models that are used for different needs. The Sequence Containers
simply organize their elements linearly, and are the most fundamental type of
containers. For some problems, special properties need to be attached to these
sequences, and that’s exactly what the Container Adaptors do—they model
abstractions such as a queue or stack. The associative containers organize
their data based on keys, allowing for fast retrieval of that data.</p>

<p class=MsoNormal>All the containers in the standard library hold <i>copies</i>
of the objects you place in them, and expand their resources as needed, so your
objects must be <i>copy-constructible</i> (have an accessible copy constructor)
and <i>assignable</i> (have an accessible assignment operator). The key
difference between one container and another is the way the objects are stored
in memory and what operations are available to the user.</p>

<p class=MsoNormal>A <b>vector</b>, as you already know, is a linear sequence
that allows rapid random access to its elements. However, it’s expensive to
insert an element in the middle of a co-located sequence like a <b>vector</b>,
just as it is with an array. A <b>deque</b> (double-ended-queue, pronounced “deck”) also allows random access that’s nearly as fast as<b> vector</b>, but it’s
significantly faster when it needs to allocate new storage, and you can easily
add new elements at the front as well as the back of the sequence. A <b>list</b> is a doubly linked list, so it’s expensive to move around randomly but cheap to
insert an element anywhere. Thus <b>list</b>, <b>deque</b> and <b>vector</b>
are similar in their basic functionality (they all hold linear sequences), but
different in the cost of their activities. For your first attempt at a program,
you could choose any one and experiment with the others only if you’re tuning
for efficiency.</p>

<p class=MsoNormal>Many of the problems you set out to solve will only require
a simple linear sequence such as a <b>vector</b>, <b>deque</b>, or <b>list</b>.
All three have a member function <b>push_back(&nbsp;)</b> that you use to insert a new element at the back of the sequence (<b>deque</b> and <b>list</b> also have <b>push_front(&nbsp;)</b>, which inserts elements at the beginning of the sequence).</p>

<p class=MsoNormal>But how do you retrieve the elements stored in a sequence
container? With a <b>vector</b> or <b>deque</b>, it is possible to use the
indexing <b>operator[&nbsp;]</b>, but that doesn’t work with <b>list</b>. You
can use iterators on all three sequences to access elements. Each container
provides the appropriate type of iterator for accessing its elements.</p>

<p class=MsoNormal>Even though the containers hold objects by value (that is,
they hold copies of whole objects), sometimes you’ll want to store pointers so
that you can refer to objects from a hierarchy and thus take advantage of the
polymorphic behavior of the classes represented. Consider the classic “shape”
example where shapes have a set of common operations, and you have different
types of shapes. Here’s what it looks like using the STL <b>vector</b> to hold
pointers to various <b>Shape</b> types created on the heap:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Stlshape.cpp</font></div>
<div class=CC1><font color=#dd0000>// Simple shapes using the STL.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Shape() {};</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Circle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Circle::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Circle() { cout &lt;&lt; &quot;~Circle” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Triangle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Triangle::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Triangle() { cout &lt;&lt; &quot;~Triangle” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Square : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Square::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Square() { cout &lt;&lt; &quot;~Square” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> std::vector&lt;Shape*&gt; Container;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Container::iterator Iter;</div>
<div class=CC1>  Container shapes;</div>
<div class=CC1>  shapes.push_back(<font color=#ff7700>new</font> Circle);</div>
<div class=CC1>  shapes.push_back(<font color=#ff7700>new</font> Square);</div>
<div class=CC1>  shapes.push_back(<font color=#ff7700>new</font> Triangle);</div>
<div class=CC1>  <font color=#ff7700>for</font>(Iter i = shapes.begin(); i != shapes.end(); i++)</div>
<div class=CC1>    (*i)-&gt;draw();</div>
<div class=CC1>  <font color=#dd0000>// ... Sometime later:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(Iter j = shapes.begin(); j != shapes.end(); j++)</div>
<div class=CC1>    <font color=#ff7700>delete</font> *j;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The creation of <b>Shape</b>, <b>Circle</b>, <b>Square</b>,
and <b>Triangle</b> should be fairly familiar. <b>Shape</b> is an abstract base
class (because of the <i>pure specifier</i> <b>=0</b>) that defines the
interface for all types of <b>Shapes</b>. The derived classes override the <b>virtual</b>
function <b>draw(&nbsp;)</b> to perform the appropriate operation. Now we’d
like to create a bunch of different types of <b>Shape</b> objects, and the
natural place to store them is in an STL container. For convenience, this <b>typedef</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> std::vector&lt;Shape*&gt; Container;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>creates an alias for a <b>vector</b> of <b>Shape*</b>, and
this <b>typedef</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> Container::iterator Iter;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>uses that alias to create another one, for <b>vector&lt;Shape*&gt;::iterator</b>.
Notice that the container type name must be used to produce the appropriate
iterator, which is defined as a nested class. Although there are different
types of iterators (forward, bidirectional, random, and so on), they all have the
same basic interface: you can increment them with <b>++</b>, you can
dereference them to produce the object they’re currently selecting, and you can
test them to see if they’re at the end of the sequence. That’s what you’ll want
to do 90 percent of the time. And that’s what is done in the previous example:
after a container is created, it’s filled with different types of <b>Shape</b>
pointers. Notice that the upcast happens as the <b>Circle</b>, <b>Square</b>,
or <b>Rectangle</b> pointer is added to the <b>Shapes</b> container, which
doesn’t know about those specific types but instead holds only <b>Shape*</b>.
As soon as the pointer is added to the container, it loses its specific
identity and becomes an anonymous <b>Shape*</b>. This is exactly what we want:
toss them all in and let polymorphism sort it out.</p>

<p class=MsoNormal>The first <b>for</b> loop creates an iterator and sets it to
the beginning of the sequence by calling the <b>begin(&nbsp;)</b> member
function for the container. All containers have <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
member functions that produce an iterator selecting, respectively, the beginning
of the sequence and one past the end of the sequence. To test to see if you’re
done, you make sure the iterator is <i>not equal</i> to the iterator produced
by <b>end(&nbsp;)</b>; don’t use <b>&lt;</b> or <b>&lt;=</b>. The only tests
that work are <b>!=</b> and <b>==</b>, so it’s common to write a loop like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>for</font>(Iter i = shapes.begin(); i != shapes.end(); i++)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This says “take me through every element in the sequence.”</p>

<p class=MsoNormal>What do you do with the iterator to produce the element it’s
selecting? You dereference it using (what else?) the ‘<b>*</b>’ (which is
actually an overloaded operator). What you get back is whatever the container
is holding. This container holds <b>Shape*</b>, so that’s what <b>*i</b>
produces. If you want to call a <b>Shape</b> member function, you must do so
with the <b>-&gt;</b> operator, so you write the line:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>(*i)-&gt;draw();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This calls the <b>draw(&nbsp;)</b> function for the <b>Shape*</b>
the iterator is currently selecting. The parentheses are ugly but necessary to
produce the desired operator precedence.</p>

<p class=MsoNormal>As they are destroyed or in other cases where the pointers
are removed, the STL containers <i>do not</i> automatically call <b>delete</b>
for the pointers they contain. If you create an object on the heap with <b>new</b>
and place its pointer in a container, the container can’t tell if that pointer
is also placed inside another container, nor if it refers to heap memory in the
first place. As always, you are responsible for managing your own heap
allocations. The last lines in the program move through and delete every object
in the container so that proper cleanup occurs. The easiest and safest way to
handle pointers in containers is to use smart pointers. It should be noted that
<b>auto_ptr</b> can’t be used for this purpose, so you will need to look
outside of the C++ Standard Library for a suitable smart pointers.<a href="#_ftn101" name="_ftnref101"><span
class=MsoFootnoteReference>[101]</span></a></p>

<p class=MsoNormal>You can change the type of container that this program uses
with two lines. Instead of including <b>&lt;vector&gt;</b>, you include <b>&lt;list&gt;</b>,
and in the first <b>typedef</b> you say:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> std::list&lt;Shape*&gt; Container;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>instead of using a <b>vector</b>. Everything else goes
untouched. This is possible not because of an interface enforced by inheritance
(there is little inheritance in the STL), but because the interface is enforced
by a convention adopted by the designers of the STL, precisely so you could
perform this kind of interchange. Now you can easily switch between <b>vector</b>
and <b>list</b> or any other container that supports the same interface (both
syntactically and semantically) and see which one works fastest for your needs.</p>

<h3><a href="#_TocRef53985773" name="_Toc53985773">Containers of strings</a></h3>

<p class=MsoNormal>In the previous example, at the end of <b>main(&nbsp;)</b>
it was necessary to move through the whole list and <b>delete</b> all the <b>Shape</b>
pointers:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>for</font>(Iter j = shapes.begin(); j != shapes.end(); j++)</div>
<div class=CC1>  <font color=#ff7700>delete</font> *j;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>STL containers make sure that each <i>object</i> they
contain has its destructor called when the container itself is destroyed.
Pointers, however, have no destructor, so we have to <b>delete</b> them
ourselves.</p>

<p class=MsoNormal>This highlights what could be seen as an oversight in the
STL: there’s no facility in any of the STL containers to automatically <b>delete</b>
the pointers they contain, so you must do it manually. It’s as if the
assumption of the STL designers was that containers of pointers weren’t an
interesting problem, but that’s not the case.</p>

<p class=MsoNormal>Automatically deleting a pointer turns out to be problematic
because of the <i>multiple membership</i> problem. If a container holds a
pointer to an object, it’s not unlikely that pointer could also be in another
container. A pointer to an <b>Aluminum</b> object in a list of <b>Trash</b>
pointers could also reside in a list of <b>Aluminum</b> pointers. If that
happens, which list is responsible for cleaning up that object—that is, which
list “owns” the object?</p>

<p class=MsoNormal>This question is virtually eliminated if the object rather
than a pointer resides in the list. Then it seems clear that when the list is
destroyed, the objects it contains must also be destroyed. Here, the STL
shines, as you can see when creating a container of <b>string</b> objects. The
following example stores each incoming line as a <b>string</b> in a <b>vector&lt;string&gt;</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:StringVector.cpp</font></div>
<div class=CC1><font color=#dd0000>// A vector of strings.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;StringVector.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  vector&lt;string&gt; strings;</div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    strings.push_back(line);</div>
<div class=CC1>  <font color=#dd0000>// Do something to the strings...</font></div>
<div class=CC1>  <span lang=SV><font color=#ff7700>int</font> i = 1;</span></div>
<div class=CC1><span lang=SV>  vector&lt;string&gt;::iterator w;</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>for</font>(w = strings.begin(); w !=
strings.end(); w++) {</div>
<div class=CC1>    ostringstream ss;</div>
<div class=CC1>    ss &lt;&lt; i++;</div>
<div class=CC1>    *w = ss.str() + <font color=#007f00>&quot;: &quot;</font> + *w;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Now send them out:</font></div>
<div class=CC1>  copy(strings.begin(), strings.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>  <font color=#dd0000>// Since they aren't pointers, string</font></div>
<div class=CC1>  <font color=#dd0000>// objects clean themselves up!</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Once the <b>vector&lt;string&gt; </b>called <b>strings</b>
is created, each line in the file is read into a <b>string</b> and put in the <b>vector</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    strings.push_back(line);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The operation that’s being performed on this file is to add
line numbers. A <b>stringstream</b> provides easy conversion from an <b>int</b>
to a <b>string</b> of characters representing that <b>int</b>.</p>

<p class=MsoNormal>Assembling <b>string</b> objects is quite easy, since <b>operator+</b>
is overloaded. Sensibly enough, the iterator <b>w</b> can be dereferenced to
produce a string that can be used as both an rvalue <i>and</i> an lvalue:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>*w = ss.str() + <font color=#007f00>&quot;: &quot;</font> + *w;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You may be surprised that you can assign back into the
container via the iterator, but it’s a tribute to the careful design of the
STL.</p>

<p class=MsoNormal>Because the <b>vector&lt;string&gt;</b> contains the
objects, two things are worthy of note. First, as explained before, you don’t
need to explicitly clean up the <b>string</b> objects. Even if you put
addresses of the <b>string</b> objects as pointers into <i>other</i>
containers, it’s clear that <b>strings</b> is the “master list” and maintains
ownership of the objects.</p>

<p class=MsoNormal>Second, you are effectively using dynamic object creation,
and yet you never use <b>new</b> or <b>delete</b>! It’s all taken care of for
you by the <b>vector</b> because it stores <i>copies</i> of the objects you
give it. Thus your coding is significantly cleaned up.</p>

<h3><a href="#_TocRef53985774" name="_Toc53985774">Inheriting from STL containers</a></h3>

<p class=MsoNormal>The power of instantly creating a sequence of elements is
amazing, and it makes you realize how much time you may have lost in the past
solving this particular problem. For example, many utility programs involve
reading a file into memory, modifying the file, and writing it back out to
disk. You might as well take the functionality in <b>StringVector.cpp</b> and
package it into a class for later reuse.</p>

<p class=MsoNormal>Now the question is: do you create a member object of type <b>vector</b>,
or do you inherit? A general object-oriented design guideline is to prefer
composition (member objects) over inheritance, but the standard algorithms
expect sequences that implement a particular interface, so inheritance is often
necessary.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:FileEditor.h</font></div>
<div class=CC1><font color=#dd0000>// A file editor tool.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef FILEEDITOR_H</font></div>
<div class=CC1><font color=#7F7F00>#define FILEEDITOR_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> FileEditor : <font color=#ff7700>public</font>
std::vector&lt;std::string&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> open(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* filename);</div>
<div class=CC1>  FileEditor(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* filename) { open(filename); }</div>
<div class=CC1>  FileEditor() {};</div>
<div class=CC1>  <font color=#ff7700>void</font> write(std::ostream&amp; out = std::cout);</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// FILEEDITOR_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The constructor opens the file and reads it into the <b>FileEditor</b>,
and <b>write(&nbsp;)</b> puts the <b>vector</b> of <b>string</b> onto any <b>ostream</b>.
Notice in <b>write(&nbsp;) </b>that you can have a default argument for the
reference.</p>

<p class=MsoNormal>The implementation is quite simple:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:FileEditor.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;FileEditor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> FileEditor::open(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* filename) {</div>
<div class=CC1>  ifstream in(filename);</div>
<div class=CC1>  assure(in, filename);</div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    push_back(line);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Could also use copy() here:</font></div>
<div class=CC1><font color=#ff7700>void</font> FileEditor::write(ostream&amp; out) {</div>
<div class=CC1>  <font color=#ff7700>for</font>(iterator w = begin(); w != end(); w++)</div>
<div class=CC1>    out &lt;&lt; *w &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The functions from <b>StringVector.cpp</b> are simply
repackaged. Often this is the way classes evolve—you start by creating a program
to solve a particular application and then discover some commonly used
functionality within the program that can be turned into a class.</p>

<p class=MsoNormal>The line-numbering program can now be rewritten using <b>FileEditor</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:FEditTest.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} FileEditor</font></div>
<div class=CC1><font color=#dd0000>// Test the FileEditor tool.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;FileEditor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  FileEditor file;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) {</div>
<div class=CC1>    file.open(argv[1]);</div>
<div class=CC1>  } <font color=#ff7700>else</font> {</div>
<div class=CC1>    file.open(<font color=#007f00>&quot;FEditTest.cpp&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Do something to the lines...</font></div>
<div class=CC1>  <font color=#ff7700>int</font> i = 1;</div>
<div class=CC1>  FileEditor::iterator w = file.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(w != file.end()) {</div>
<div class=CC1>    ostringstream ss;</div>
<div class=CC1>    ss &lt;&lt; i++;</div>
<div class=CC1>    *w = ss.str() + <font color=#007f00>&quot;: &quot;</font> + *w;</div>
<div class=CC1>    ++w;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Now send them to cout:</font></div>
<div class=CC1>  file.write();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now the operation of reading the file is in the constructor:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>FileEditor file(argv[1]);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>(or in the <b>open(&nbsp;) </b>member function), and writing
happens in the single line (which defaults to sending the output to <b>cout</b>):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>file.write();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The bulk of the program is involved with modifying the file
in memory.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985775" name="_Toc53985775">A
plethora of iterators</a></h2>

<p class=MsoNormal><a name=BBB></a>An iterator is an abstraction for genericity.
It works with different types of containers without knowing the underlying
structure of those containers. Most containers support iterators,<a href="#_ftn102" name="_ftnref102"><span
class=MsoFootnoteReference>[102]</span></a> so you can
say:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>&lt;ContainerType&gt;::iterator</div>
<div class=CC1>&lt;ContainerType&gt;::const_iterator</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>to produce the iterator types for a container. Every
container has a <b>begin(&nbsp;)</b> member function that produces an iterator
indicating the beginning of the elements in the container, and an <b>end(&nbsp;)</b>
member function that produces an iterator which is the <i>past-the-end</i><i> </i>marker of the container. If the container is <b>const</b>¸ <b>begin(&nbsp;)</b>
and <b>end(&nbsp;)</b> produce <b>const</b> iterators, which disallow changing
the elements pointed to (because the appropriate operators are <b>const</b>).</p>

<p class=MsoNormal>All iterators can advance within their sequence (via <b>operator++</b>)
and allow <b>==</b> and <b>!=</b> comparisons. Thus, to move an iterator <b>it</b>
forward without running it off the end, you say something like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>while</font>(it != pastEnd) {</div>
<div class=CC1>  <font color=#dd0000>// Do something</font></div>
<div class=CC1>  ++it;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>where <b>pastEnd</b> is the past-the-end marker produced by
the container’s <b>end(&nbsp;)</b> member function.</p>

<p class=MsoNormal>An iterator can be used to produce the container element
that it is currently selecting via the dereferencing operator (<b>operator*</b>).
This can take two forms. If <b>it </b>is an iterator traversing a container, and
<b>f(&nbsp;) </b>is a member function of the type of objects held in the
container, you can say either:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>(*it).f();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>or</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>it-&gt;f();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Knowing this, you can create a template that works with any
container. Here, the <b>apply(&nbsp;)</b> function template calls a member
function for every object in the container, using a pointer to member that is
passed as an argument:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Apply.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using simple iteration.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Cont, <font color=#ff7700>class</font> PtrMemFun&gt;</div>
<div class=CC1><font color=#ff7700>void</font> apply(Cont&amp; c, PtrMemFun f) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Cont::iterator it = c.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != c.end()) {</div>
<div class=CC1>    ((*it).*f)(); <font color=#dd0000>// Alternate form</font></div>
<div class=CC1>    ++it;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Z {</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Z(<font color=#ff7700>int</font> ii) : i(ii) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> g() { ++i; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Z&amp; z) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; z.i;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ostream_iterator&lt;Z&gt; out(cout, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  vector&lt;Z&gt; vz;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 10; i++)</div>
<div class=CC1>    vz.push_back(Z(i));</div>
<div class=CC1>  copy(vz.begin(), vz.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  apply(vz, &amp;Z::g);</div>
<div class=CC1>  copy(vz.begin(), vz.end(), out);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can’t use <b>operator-&gt;</b> here because the
resulting statement would be:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>(it-&gt;*f)();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>which attempts to use the iterator’s <b>operator-&gt;*</b>,
which is not provided by the iterator classes.<a href="#_ftn103" name="_ftnref103"><span
class=MsoFootnoteReference>[103]</span></a></p>

<p class=MsoNormal>It is much easier to use either <b>for_each(&nbsp;)</b> or <b>transform(&nbsp;)</b>
to apply functions to sequences, as you saw in the previous chapter.</p>

<h3><a href="#_TocRef53985776" name="_Toc53985776">Iterators in reversible containers</a></h3>

<p class=MsoNormal>A container may also be <i>reversible</i>, which means that
it can produce iterators that move backward from the end, as well as iterators
that move forward from the beginning. All standard containers support such
bidirectional iteration.</p>

<p class=MsoNormal>A reversible container has the member functions <b>rbegin(&nbsp;)</b> (to produce a <b>reverse_iterator</b> selecting the end) and <b>rend(&nbsp;)</b> (to produce a <b>reverse_iterator</b> indicating “one past the beginning”). If the
container is <b>const</b>, <b>rbegin(&nbsp;)</b> and <b>rend(&nbsp;)</b> will
produce <b>const_reverse_iterator</b>s.</p>

<p class=MsoNormal>The following example uses <b>vector</b> but will work with
all containers that support iteration:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Reversible.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using reversible containers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Reversible.cpp&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;Reversible.cpp&quot;</font>);</div>
<div class=CC1>  string line;</div>
<div class=CC1>  vector&lt;string&gt; lines;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    lines.push_back(line);</div>
<div class=CC1>  <font color=#ff7700>for</font>(vector&lt;string&gt;::reverse_iterator r =
lines.rbegin();</div>
<div class=CC1>      r != lines.rend(); r++)</div>
<div class=CC1>    cout &lt;&lt; *r &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You move backward through the container using the same
syntax as you do when moving forward through a container with an ordinary
iterator.</p>

<h3><a href="#_TocRef53985777" name="_Toc53985777">Iterator categories</a></h3>

<p class=MsoNormal>The iterators in the Standard C++ library are classified
into “categories” that describe their capabilities. The order in which they are
generally described moves from the categories with the most restricted behavior
to those with the most powerful behavior.</p>

<h4>Input: read–only, one pass</h4>

<p class=MsoNormal>The only predefined implementations of input iterators are <b>istream_iterator</b> and <b>istreambuf_iterator</b>, to read from an <b>istream</b>. As you can
imagine, an input iterator can only be dereferenced once for each element
that’s selected, just as you can only read a particular portion of an input
stream once. They can only move forward. A special constructor defines the
past-the-end value. In summary, you can dereference it for reading (once only
for each value) and move it forward.</p>

<h4>Output: write–only, one pass</h4>

<p class=MsoNormal>This is the complement of an input iterator, but for writing
rather than reading. The only predefined implementations of output iterators
are <b>ostream_iterator</b> and <b>ostreambuf_iterator</b>, to write to an <b>ostream</b>, and the less commonly used <b>raw_storage_iterator</b>. Again, these can only be dereferenced once for each written value, and they can only move forward. There is no concept of
a terminal past-the-end value for an output iterator. Summarizing, you can
dereference it for writing (once only for each value) and move it forward.</p>

<h4>Forward: multiple read/write</h4>

<p class=MsoNormal>The forward iterator contains all the functionality of both
the input iterator and the output iterator, plus you can dereference an
iterator location multiple times, so you can read and write to a value multiple
times. As the name implies, you can only move forward. There are no predefined
iterators that are only forward iterators.</p>

<h4>Bidirectional: operator––</h4>

<p class=MsoNormal>The bidirectional iterator has all the functionality of the forward iterator, and in addition it can be moved backward one location at a time
using<br>
<b>operator--</b>. The iterators returned by the <b>list</b> container are
bidirectional.</p>

<h4>Random–access: like a pointer</h4>

<p class=MsoNormal>Finally, the random-access iterator has all the functionality of the bidirectional iterator plus all the functionality of a pointer (a
pointer <i>is</i> a random-access iterator), except that there is no “null”
iterator analogue to a null pointer. Basically, anything you can do with a
pointer you can do with a random-access iterator, including indexing with <b>operator[&nbsp;]</b>,
adding integral values to a pointer to move it forward or backward by a number
of locations, or comparing one iterator to another with comparison operators.</p>

<h4>Is this really important?</h4>

<p class=MsoNormal>Why do you care about this categorization? When you’re just
using containers in a straightforward way (for example, just hand-coding all
the operations you want to perform on the objects in the container), it usually
doesn’t matter. Things either work or they don’t. The iterator categories
become important when:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You use some of the fancier built-in iterator types that will be
demonstrated shortly, or you “graduate” to creating your own iterators
(demonstrated later in this chapter).</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You use the STL algorithms (the subject of the previous chapter).
Each of the algorithms places requirements on its iterators. Knowledge of the
iterator categories is even more important when you create your own reusable
algorithm templates, because the iterator category required by your algorithm
determines how flexible the algorithm will be. If you require only the most
primitive iterator category (input or output), your algorithm will work with <i>everything</i>
(<b>copy(&nbsp;)</b> is an example of this).</p>

<p class=MsoNormal>An iterator’s category is identified by a hierarchy of iterator tag classes. The class names correspond to the iterator categories, and their
derivation reflects the relationship between them:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>struct</font> input_iterator_tag {};</div>
<div class=CC1><font color=#ff7700>struct</font> output_iterator_tag {};</div>
<div class=CC1><font color=#ff7700>struct</font> forward_iterator_tag :</div>
<div class=CC1>  <font color=#ff7700>public</font> input_iterator_tag {};</div>
<div class=CC1><font color=#ff7700>struct</font> bidirectional_iterator_tag :</div>
<div class=CC1>  <font color=#ff7700>public</font> forward_iterator_tag {};</div>
<div class=CC1><font color=#ff7700>struct</font> random_access_iterator_tag :</div>
<div class=CC1>  <font color=#ff7700>public</font> bidirectional_iterator_tag {};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class <b>forward_iterator_tag</b> derives only from <b>input_iterator_tag</b>, not from <b>output_iterator_tag</b>, because we need to have past-the-end
iterator values in algorithms that use forward iterators, but algorithms that
use output iterators always assume that <b>operator*</b> can be dereferenced.
For this reason, it is important to make sure that a past-the-end value is
never passed to an algorithm that expects an output iterator.</p>

<p class=MsoNormal>For efficiency, certain algorithms provide different
implementations for different iterator types, which they infer from the
iterator tag defined by the iterator. We will use some of these tag classes
later in this chapter when we define our own iterator types.</p>

<h3><a href="#_TocRef53985778" name="_Toc53985778">Predefined iterators</a></h3>

<p class=MsoNormal>The STL has a predefined set of iterators that can be quite
handy. For example, you’ve already seen the <b>reverse_iterator</b> objects produced by calling <b>rbegin(&nbsp;)</b> and <b>rend(&nbsp;)</b> for all the basic containers.</p>

<p class=MsoNormal>The <i>insertion iterators</i> are necessary because some of
the STL algorithms—<b>copy(&nbsp;)</b>, for example—use the assignment <b>operator=</b>
to place objects in the destination container. This is a problem when you’re
using the algorithm to <i>fill</i> the container rather than to overwrite items
that are already in the destination container—that is, when the space isn’t
already there. What the insert iterators do is change the implementation of <b>operator=</b>
so that instead of doing an assignment, it calls a “push” or “insert” function
for that container, thus causing it to allocate new space. The constructors for
both <b>back_insert_iterator</b> and <b>front_insert_iterator</b> take a basic sequence container object (<b>vector</b>,<b> deque</b> or <b>list</b>) as their argument and produce an
iterator that calls <b>push_back(&nbsp;)</b> or <b>push_front(&nbsp;)</b>, respectively, to perform assignment. The helper functions <b>back_inserter(&nbsp;)</b> and <b>front_inserter(&nbsp;)</b> produce these insert-iterator objects with a
little less typing. Since all the basic sequence containers support <b>push_back(&nbsp;)</b>,
you will probably find yourself using <b>back_inserter(&nbsp;)</b> with some
regularity.</p>

<p class=MsoNormal>An <b>insert_iterator</b> lets you insert elements in the middle of the sequence, again replacing the meaning of <b>operator=</b>, but this time
by automatically calling <b>insert(&nbsp;)</b> instead of one of the “push” functions. The <b>insert(&nbsp;)</b> member function requires an iterator indicating the
place to insert before, so the <b>insert_iterator</b> requires this iterator in
addition to the container object. The shorthand function <b>inserter(&nbsp;)</b> produces the same object.</p>

<p class=MsoNormal>The following example shows the use of the different types
of inserters:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Inserters.cpp</font></div>
<div class=CC1><font color=#dd0000>// Different types of iterator inserters.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> a[] = { 1, 3, 5, 7, 11, 13, 17, 19, 23 };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Cont&gt; <font color=#ff7700>void</font>
frontInsertion(Cont&amp; ci) {</div>
<div class=CC1>  copy(a, a + <font color=#ff7700>sizeof</font>(a)/sizeof(Cont::value_type),</div>
<div class=CC1>    front_inserter(ci));</div>
<div class=CC1>  copy(ci.begin(), ci.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>typename</font> Cont::value_type&gt;(</div>
<div class=CC1>    cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Cont&gt; <font color=#ff7700>void</font> backInsertion(Cont&amp;
ci) {</div>
<div class=CC1>  copy(a, a + <font color=#ff7700>sizeof</font>(a)/sizeof(Cont::value_type),</div>
<div class=CC1>    back_inserter(ci));</div>
<div class=CC1>  copy(ci.begin(), ci.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>typename</font> Cont::value_type&gt;(</div>
<div class=CC1>    cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Cont&gt; <font color=#ff7700>void</font> midInsertion(Cont&amp;
ci) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Cont::iterator it = ci.begin();</div>
<div class=CC1>  ++it; ++it; ++it;</div>
<div class=CC1>  copy(a, a + <font color=#ff7700>sizeof</font>(a)/(<font color=#ff7700>sizeof</font>(Cont::value_type) * 2),</div>
<div class=CC1>    inserter(ci, it));</div>
<div class=CC1>  copy(ci.begin(), ci.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>typename</font> Cont::value_type&gt;(</div>
<div class=CC1>    cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <span lang=IT>deque&lt;<font color=#ff7700>int</font>&gt; di;</span></div>
<div class=CC1><span lang=IT>  list&lt;<font color=#ff7700>int</font>&gt;  li;</span></div>
<div class=CC1><span lang=IT>  </span>vector&lt;<font color=#ff7700>int</font>&gt; vi;</div>
<div class=CC1>  <font color=#dd0000>// Can't use a front_inserter() with vector</font></div>
<div class=CC1>  <span lang=IT>frontInsertion(di);</span></div>
<div class=CC1><span lang=IT>  frontInsertion(li);</span></div>
<div class=CC1><span lang=IT>  di.clear();</span></div>
<div class=CC1><span lang=IT>  </span>li.clear();</div>
<div class=CC1>  backInsertion(vi);</div>
<div class=CC1>  backInsertion(di);</div>
<div class=CC1>  backInsertion(li);</div>
<div class=CC1>  midInsertion(vi);</div>
<div class=CC1>  midInsertion(di);</div>
<div class=CC1>  midInsertion(li);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since <b>vector</b> does not support <b>push_front(&nbsp;)</b>,
it cannot produce a <b>front_insert_iterator</b>. However, you can see that <b>vector</b>
does support the other two types of insertions (even though, as you shall see
later, <b>insert(&nbsp;)</b> is not an efficient operation for <b>vector</b>).
Note the use of the nested type <b>Cont::value_type</b> instead of hard-coding <b>int</b>.</p>

<h4>More on stream iterators</h4>

<p class=MsoNormal>We introduced the use of the stream iterators <b>ostream_iterator</b> (an output iterator) and <b>istream_iterator</b> (an input iterator) in conjunction with <b>copy(&nbsp;)</b> in the previous chapter. Remember that an output stream
doesn’t have any concept of an “end,” since you can always just keep writing
more elements. However, an input stream eventually terminates (for example,
when you reach the end of a file), so you need a way to represent that. An <b>istream_iterator</b>
has two constructors, one that takes an <b>istream</b> and produces the
iterator you actually read from, and the other which is the default constructor
and produces an object that is the past-the-end sentinel. In the following
program this object is named <b>end</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:StreamIt.cpp</font></div>
<div class=CC1><font color=#dd0000>// Iterators for istreams and ostreams.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;StreamIt.cpp&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;StreamIt.cpp&quot;</font>);</div>
<div class=CC1>  istream_iterator&lt;string&gt; begin(in), end;</div>
<div class=CC1>  ostream_iterator&lt;string&gt; out(cout,
<font color=#007f00>&quot;\n&quot;</font>);</div>
<div class=CC1>  vector&lt;string&gt; vs;</div>
<div class=CC1>  copy(begin, end, back_inserter(vs));</div>
<div class=CC1>  copy(vs.begin(), vs.end(), out);</div>
<div class=CC1>  *out++ = vs[0];</div>
<div class=CC1>  *out++ = <font color=#007f00>&quot;That's all, folks!&quot;</font>;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When <b>in</b> runs out of input (in this case when the end
of the file is reached), <b>init</b> becomes equivalent to <b>end</b>, and the <b>copy(&nbsp;)</b>
terminates.</p>

<p class=MsoNormal>Because <b>out</b> is an <b>ostream_iterator</b><b>&lt;string&gt;</b>, you can simply assign any <b>string</b> object to the dereferenced iterator using <b>operator=</b>,
and that <b>string</b> will be placed on the output stream, as seen in the two assignments
to <b>out</b>. Because <b>out</b> is defined with a newline as its second
argument, these assignments also insert a newline along with each assignment.</p>

<p class=MsoNormal>Although it is possible to create an <b>istream_iterator&lt;char&gt;</b>
and <b>ostream_iterator&lt;char&gt;</b>, these actually <i>parse </i>the input
and thus will, for example, automatically eat whitespace (spaces, tabs, and
newlines), which is not desirable if you want to manipulate an exact
representation of an <b>istream</b>. Instead, you can use the special iterators
<b>istreambuf_iterator</b> and <b>ostreambuf_iterator</b>, which are designed strictly to move characters.<a href="#_ftn104" name="_ftnref104"><span
class=MsoFootnoteReference>[104]</span></a> Although
these are templates, they are meant to be used with template arguments of
either <b>char</b> or <b>wchar_t</b>.<a href="#_ftn105" name="_ftnref105"><span
class=MsoFootnoteReference>[105]</span></a> The
following example lets you compare the behavior of the stream iterators with
the streambuf iterators:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:StreambufIterator.cpp</font></div>
<div class=CC1><font color=#dd0000>// istreambuf_iterator &amp; ostreambuf_iterator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;StreambufIterator.cpp&quot;</font>);</div>
<div class=CC1>  assure(in, <font color=#007f00>&quot;StreambufIterator.cpp&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Exact representation of stream:</font></div>
<div class=CC1>  istreambuf_iterator&lt;<font color=#ff7700>char</font>&gt; isb(in), end;</div>
<div class=CC1>  ostreambuf_iterator&lt;<font color=#ff7700>char</font>&gt; osb(cout);</div>
<div class=CC1>  <font color=#ff7700>while</font>(isb != end)</div>
<div class=CC1>    *osb++ = *isb++; <font color=#dd0000>// Copy 'in' to cout</font></div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  ifstream in2(<font color=#007f00>&quot;StreambufIterator.cpp&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Strips white space:</font></div>
<div class=CC1>  istream_iterator&lt;<font color=#ff7700>char</font>&gt; is(in2), end2;</div>
<div class=CC1>  ostream_iterator&lt;<font color=#ff7700>char</font>&gt; os(cout);</div>
<div class=CC1>  <font color=#ff7700>while</font>(is != end2)</div>
<div class=CC1>    *os++ = *is++;</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The stream iterators use the parsing defined by <b>istream::operator&gt;&gt;</b>,
which is probably not what you want if you are parsing characters directly—it’s
fairly rare that you want all the whitespace stripped out of your character
stream. You’ll virtually always want to use a streambuf iterator when using
characters and streams, rather than a stream iterator. In addition, <b>istream::operator&gt;&gt;</b>
adds significant overhead for each operation, so it is only appropriate for
higher-level operations such as parsing numbers.<a href="#_ftn106" name="_ftnref106"><span
class=MsoFootnoteReference>[106]</span></a></p>

<h4>Manipulating raw storage</h4>

<p class=MsoNormal>The <b>raw_storage_iterator</b> is defined in <b>&lt;memory&gt;</b> and is an output iterator. It is provided to enable algorithms to store their results
in uninitialized memory. The interface is quite simple: the constructor takes
an output iterator that is pointing to the raw memory (typically a pointer),
and the <b>operator=</b> assigns an object into that raw memory. The template
parameters are the type of the output iterator pointing to the raw storage and
the type of object that will be stored. Here’s an example that creates <b>Noisy</b>
objects, which print trace statements for their construction, assignment, and
destruction (we’ll show the <b>Noisy</b> class definition later):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:RawStorageIterator.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Demonstrate the raw_storage_iterator.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> QUANTITY = 10;</div>
<div class=CC1>  <font color=#dd0000>// Create raw storage and cast to desired type:</font></div>
<div class=CC1>  Noisy* np = <font color=#ff7700>reinterpret_cast</font>&lt;Noisy*&gt;(</div>
<div class=CC1>    <font color=#ff7700>new</font> <font color=#ff7700>char</font>[QUANTITY * <font color=#ff7700>sizeof</font>(Noisy)]);</div>
<div class=CC1>  raw_storage_iterator&lt;Noisy*, Noisy&gt; rsi(np);</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; QUANTITY; i++)</div>
<div class=CC1>    *rsi++ = Noisy(); <font color=#dd0000>// Place objects in storage</font></div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  copy(np, np + QUANTITY,</div>
<div class=CC1>    ostream_iterator&lt;Noisy&gt;(cout, <font color=#007f00>&quot;
&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Explicit destructor call for cleanup:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; QUANTITY; j++)</div>
<div class=CC1>    (&amp;np[j])-&gt;~Noisy();</div>
<div class=CC1>  <font color=#dd0000>// Release raw storage:</font></div>
<div class=CC1>  <font color=#ff7700>delete</font> <font color=#ff7700>reinterpret_cast</font>&lt;<font color=#ff7700>char</font>*&gt;(np);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To make the <b>raw_storage_iterator </b>template happy, the
raw storage must be of the same type as the objects you’re creating. That’s why
the pointer from the new array of <b>char</b> is cast to a <b>Noisy*</b>. The
assignment operator forces the objects into the raw storage using the
copy-constructor. Note that the explicit destructor call must be made for proper cleanup, and this also allows the objects to be deleted one at a time
during container manipulation. The expression <b>delete np</b> would be invalid
anyway since the static type of a pointer in a <b>delete</b> expression must be
the same as the type assigned to in the <b>new</b> expression.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985779" name="_Toc53985779">The
basic sequences:<br>
vector, list, deque</a></h2>

<p class=MsoNormal>Sequences keep objects in whatever order you store them.
They differ in the efficiency of their operations, however, so if you are going
to manipulate a sequence in a particular fashion, choose the appropriate
container for those types of manipulations. So far in this book we’ve been
using <b>vector</b> as the container of choice. This is quite often the case in
applications. When you start making more sophisticated uses of containers, however,
it becomes important to know more about their underlying implementations and
behavior so that you can make the right choices.</p>

<h3><a href="#_TocRef53985780" name="_Toc53985780">Basic sequence operations</a></h3>

<p class=MsoNormal>Using a template, the following example shows the operations
supported by all the basic sequences: <b>vector</b>, <b>deque</b>, and <b>list</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:BasicSequenceOperations.cpp</font></div>
<div class=CC1><font color=#dd0000>// The operations available for all the</font></div>
<div class=CC1><font color=#dd0000>// basic sequence Containers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> Container&gt;</div>
<div class=CC1><font color=#ff7700>void</font> print(Container&amp; c, <font color=#ff7700>char</font>* title =
<font color=#007f00>&quot;&quot;</font>) {</div>
<div class=CC1>  cout &lt;&lt; title &lt;&lt; ':' &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>if</font>(c.empty()) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;(empty)&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>typename</font> Container::iterator it;</div>
<div class=CC1>  <font color=#ff7700>for</font>(it = c.begin(); it != c.end(); it++)</div>
<div class=CC1>    cout &lt;&lt; *it &lt;&lt; <font color=#007f00>&quot; &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;size() &quot;</font>      &lt;&lt;
c.size()</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot; max_size() &quot;</font> &lt;&lt;
c.max_size()</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot; front() &quot;</font>    &lt;&lt;
c.front()</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot; back() &quot;</font>     &lt;&lt;
c.back()</div>
<div class=CC1>       &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> ContainerOfInt&gt; <font color=#ff7700>void</font>
basicOps(<font color=#ff7700>char</font>* s) {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;------- &quot;</font> &lt;&lt; s
&lt;&lt; <font color=#007f00>&quot; -------&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> ContainerOfInt Ci;</div>
<div class=CC1>  Ci c;</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after default constructor&quot;</font>);</div>
<div class=CC1>  Ci c2(10, 1); <font color=#dd0000>// 10 elements, values all 1</font></div>
<div class=CC1>  print(c2, <font color=#007f00>&quot;c2 after constructor(10,1)&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>int</font> ia[] = { 1, 3, 5, 7, 9 };</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> IASZ = <font color=#ff7700>sizeof</font>(ia)/sizeof(*ia);</div>
<div class=CC1>  <font color=#dd0000>// Initialize with begin &amp; end iterators:</font></div>
<div class=CC1>  <span lang=IT>Ci c3(ia, ia + IASZ);</span></div>
<div class=CC1><span lang=IT>  </span>print(c3, <font color=#007f00>&quot;c3 after
constructor(iter,iter)&quot;</font>);</div>
<div class=CC1>  Ci c4(c2); <font color=#dd0000>// Copy-constructor</font></div>
<div class=CC1>  print(c4, <font color=#007f00>&quot;c4 after copy-constructor(c2)&quot;</font>);</div>
<div class=CC1>  c = c2; <font color=#dd0000>// Assignment operator</font></div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after operator=c2&quot;</font>);</div>
<div class=CC1>  c.assign(10, 2); <font color=#dd0000>// 10 elements, values all 2</font></div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after assign(10, 2)&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Assign with begin &amp; end iterators:</font></div>
<div class=CC1>  c.assign(ia, ia + IASZ);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after assign(iter, iter)&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c using reverse iterators:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>typename</font> Ci::reverse_iterator rit = c.rbegin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(rit != c.rend())</div>
<div class=CC1>    cout &lt;&lt; *rit++ &lt;&lt; <font color=#007f00>&quot; &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  c.resize(4);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after resize(4)&quot;</font>);</div>
<div class=CC1>  c.push_back(47);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after push_back(47)&quot;</font>);</div>
<div class=CC1>  c.pop_back();</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after pop_back()&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>typename</font> Ci::iterator it = c.begin();</div>
<div class=CC1>  ++it; ++it;</div>
<div class=CC1>  c.insert(it, 74);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after insert(it, 74)&quot;</font>);</div>
<div class=CC1>  it = c.begin();</div>
<div class=CC1>  ++it;</div>
<div class=CC1>  c.insert(it, 3, 96);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after insert(it, 3, 96)&quot;</font>);</div>
<div class=CC1>  it = c.begin();</div>
<div class=CC1>  ++it;</div>
<div class=CC1>  c.insert(it, c3.begin(), c3.end());</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after insert(&quot;</font></div>
<div class=CC1>    <font color=#007f00>&quot;it, c3.begin(), c3.end())&quot;</font>);</div>
<div class=CC1>  it = c.begin();</div>
<div class=CC1>  ++it;</div>
<div class=CC1>  c.erase(it);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after erase(it)&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>typename</font> Ci::iterator it2 = it = c.begin();</div>
<div class=CC1>  ++it;</div>
<div class=CC1>  ++it2; ++it2; ++it2; ++it2; ++it2;</div>
<div class=CC1>  c.erase(it, it2);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after erase(it, it2)&quot;</font>);</div>
<div class=CC1>  c.swap(c2);</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after swap(c2)&quot;</font>);</div>
<div class=CC1>  c.clear();</div>
<div class=CC1>  print(c, <font color=#007f00>&quot;c after clear()&quot;</font>);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  basicOps&lt;vector&lt;<font color=#ff7700>int</font>&gt;
&gt;(<font color=#007f00>&quot;vector&quot;</font>);</div>
<div class=CC1>  basicOps&lt;deque&lt;<font color=#ff7700>int</font>&gt; &gt;(<font color=#007f00>&quot;deque&quot;</font>);</div>
<div class=CC1>  basicOps&lt;list&lt;<font color=#ff7700>int</font>&gt; &gt;(<font color=#007f00>&quot;list&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first function template, <b>print(&nbsp;)</b>,
demonstrates the basic information you can get from any sequence container:
whether it’s empty, its current size, the size of the largest possible
container, the element at the beginning, and the element at the end. You can
also see that every container has <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
member functions that return iterators.</p>

<p class=MsoNormal>The <b>basicOps(&nbsp;)</b> function tests everything else
(and in turn calls <b>print(&nbsp;)</b>), including a variety of constructors:
default, copy-constructor, quantity and initial value, and beginning and ending
iterators. There are an assignment <b>operator=</b> and two kinds of <b>assign(&nbsp;)</b>
member functions. One takes a quantity and an initial value, and the other
takes a beginning and ending iterator.</p>

<p class=MsoNormal>All the basic sequence containers are reversible containers,
as shown by the use of the <b>rbegin(&nbsp;)</b> and <b>rend(&nbsp;)</b> member
functions. A sequence container can be resized, and the entire contents of the
container can be removed with <b>clear(&nbsp;)</b>. When you call <b>resize(&nbsp;)</b> to expand a sequence, the new elements use the default constructor of the type
of element in the sequence, or if they are built-in types, they are
zero-initialized.</p>

<p class=MsoNormal>Using an iterator to indicate where you want to start
inserting into any sequence container, you can <b>insert(&nbsp;)</b> a single element, a number of elements that all have the same value, and a group of
elements from another container using the beginning and ending iterators of
that group.</p>

<p class=MsoNormal>To <b>erase(&nbsp;)</b> a single element from the middle, use an iterator; to <b>erase(&nbsp;)</b> a range of elements, use a pair of iterators.
Notice that since a <b>list</b> supports only bidirectional iterators, all the
iterator motion must be performed with increments and decrements. (If the
containers were limited to <b>vector </b>and <b>deque</b>, which produce
random-access iterators, <b>operator+</b> and <b>operator-</b> could have been
used to move the iterators in bigger jumps.)</p>

<p class=MsoNormal>Although both <b>list</b> and <b>deque</b> support <b>push_front(&nbsp;)</b>
and <b>pop_front(&nbsp;)</b>, <b>vector</b> does not, but <b>push_back(&nbsp;)</b>
and <b>pop_back(&nbsp;) </b>work with all three.</p>

<p class=MsoNormal>The naming of the member function <b>swap(&nbsp;)</b> is a little confusing, since there’s also a nonmember <b>swap(&nbsp;)</b> algorithm
that interchanges the values of any two objects of same type. The member <b>swap(&nbsp;)</b>
swaps everything in one container for another (if the containers hold the same
type), effectively swapping the containers themselves. It does this efficiently
by swapping the contents of each container, which consists mostly of pointers.
The nonmember <b>swap(&nbsp;)</b> algorithm normally uses assignment to interchange
its arguments (an expensive operation for an entire container), but it is
customized through template specialization to call the member <b>swap(&nbsp;)</b>
for the standard containers. There is also an <b>iter_swap</b> algorithm that uses iterators to interchange two elements in the same container.</p>

<p class=MsoNormal>The following sections discuss the particulars of each type
of sequence container.</p>

<h3><a href="#_TocRef53985781" name="_Toc53985781">vector</a></h3>

<p class=MsoNormal>The <b>vector</b> class template is intentionally made to
look like a souped-up array, since it has array-style indexing, but also can
expand dynamically. The <b>vector</b> class template is so fundamentally useful
that it was introduced in a primitive way early in this book and was used
regularly in previous examples. This section will give a more in-depth look at <b>vector</b>.</p>

<p class=MsoNormal>To achieve maximally-efficient indexing and iteration, <b>vector</b>
maintains its storage as a single contiguous array of objects. This is a
critical point to observe in understanding the behavior of <b>vector</b>. It
means that indexing and iteration are lightning-fast, being basically the same
as indexing and iterating over an array of objects. But it also means that
inserting an object anywhere but at the end (that is, appending) is not really
an acceptable operation for a <b>vector</b>. In addition, when a <b>vector</b>
runs out of preallocated storage, to maintain its contiguous array it must
allocate a whole new (larger) chunk of storage elsewhere and copy the objects
to the new storage. This approach produces a number of unpleasant side-effects.</p>

<h4>Cost of overflowing allocated storage</h4>

<p class=MsoNormal>A <b>vector </b>starts by grabbing a block of storage, as if
it’s taking a guess at how many objects you plan to put in it. As long as you
don’t try to put in more objects than can be held in the initial block of
storage, everything proceeds rapidly. (If you <i>do </i>know how many objects
to expect, you can preallocate storage using <b>reserve(&nbsp;)</b>.) But eventually you will put in one too many objects, and the <b>vector </b>responds by:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Allocating a new, bigger piece of storage.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Copying all the objects from the old storage to the new (using
the copy-constructor).</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Destroying all the old objects (the destructor is called for each
one).</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Releasing the old memory.</p>

<p class=MsoNormal>For complex objects, this copy-construction and destruction
can end up being expensive if you often overfill your <b>vector</b>, which is
why <b>vector</b>s (and STL containers in general) are designed for value types
(i.e. types that are cheap to copy). This includes pointers.</p>

<p class=MsoNormal>To see what happens when you’re filling a <b>vector</b>,
here is the <b>Noisy</b> class mentioned earlier. It prints information about
its creations, destructions, assignments, and copy-constructions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Noisy.h</font></div>
<div class=CC1><font color=#dd0000>// A class to track various object activities.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef NOISY_H</font></div>
<div class=CC1><font color=#7F7F00>#define NOISY_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::endl;</div>
<div class=CC1><font color=#ff7700>using</font> std::cout;</div>
<div class=CC1><font color=#ff7700>using</font> std::ostream;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Noisy {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>long</font> create, assign, copycons, destroy;</div>
<div class=CC1>  <font color=#ff7700>long</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Noisy() : id(create++) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;d[&quot;</font> &lt;&lt; id &lt;&lt;
<font color=#007f00>&quot;]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  Noisy(<font color=#ff7700>const</font> Noisy&amp; rv) : id(rv.id) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;c[&quot;</font> &lt;&lt; id &lt;&lt;
<font color=#007f00>&quot;]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    ++copycons;</div>
<div class=CC1>  }</div>
<div class=CC1>  Noisy&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> Noisy&amp; rv) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;(&quot;</font> &lt;&lt; id &lt;&lt;
<font color=#007f00>&quot;)=[&quot;</font> &lt;&lt; rv.id &lt;&lt; <font color=#007f00>&quot;]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    id = rv.id;</div>
<div class=CC1>    ++assign;</div>
<div class=CC1>    <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> Noisy&amp; lv, <font color=#ff7700>const</font>
Noisy&amp; rv) {</div>
<div class=CC1>    <font color=#ff7700>return</font> lv.id &lt; rv.id;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> Noisy&amp; lv,const
Noisy&amp; rv) {</div>
<div class=CC1>    <font color=#ff7700>return</font> lv.id == rv.id;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Noisy() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;~[&quot;</font> &lt;&lt; id &lt;&lt;
<font color=#007f00>&quot;]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    ++destroy;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Noisy&amp; n) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; n.id;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> NoisyReport;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> NoisyGen {</div>
<div class=CC1>  Noisy <font color=#ff7700>operator</font>()() { <font color=#ff7700>return</font> Noisy(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A Singleton. Will automatically report the</font></div>
<div class=CC1><font color=#dd0000>// statistics as the program terminates:</font></div>
<div class=CC1><font color=#ff7700>class</font> NoisyReport {</div>
<div class=CC1>  <font color=#ff7700>static</font> NoisyReport nr;</div>
<div class=CC1>  NoisyReport() {} <font color=#dd0000>// Private constructor</font></div>
<div class=CC1>  NoisyReport &amp; <font color=#ff7700>operator</font>=(NoisyReport &amp;);  <font color=#dd0000>//
Disallowed</font></div>
<div class=CC1>  NoisyReport(<font color=#ff7700>const</font> NoisyReport&amp;);         <font color=#dd0000>//
Disallowed</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  ~NoisyReport() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;\n-------------------\n&quot;</font></div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;Noisy creations: &quot;</font>
&lt;&lt; Noisy::create</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;\nCopy-Constructions: &quot;</font>
&lt;&lt; Noisy::copycons</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;\nAssignments: &quot;</font> &lt;&lt;
Noisy::assign</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot;\nDestructions: &quot;</font> &lt;&lt;
Noisy::destroy &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// NOISY_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Noisy.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>long</font> Noisy::create = 0, Noisy::assign = 0,</div>
<div class=CC1>  Noisy::copycons = 0, Noisy::destroy = 0;</div>
<div class=CC1>NoisyReport NoisyReport::nr;</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each <b>Noisy</b> object has its own identifier, and <b>static</b>
variables keep track of all the creations, assignments (using <b>operator=</b>),
copy-constructions, and destructions. The <b>id</b> is initialized using the <b>create</b>
counter inside the default constructor; the copy-constructor and assignment
operator take their <b>id</b> values from the rvalue. With <b>operator=</b> the
lvalue is already an initialized object, so the old value of <b>id</b> is
printed before it is overwritten with the <b>id</b> from the rvalue.</p>

<p class=MsoNormal>To support certain operations such as sorting and searching
(which are used implicitly by some of the containers), <b>Noisy</b> must have
an <b>operator&lt;</b> and <b>operator==</b>. These simply compare the <b>id</b>
values. The <b>ostream</b> inserter follows the usual form and simply prints
the <b>id</b>.</p>

<p class=MsoNormal>Objects of type <b>NoisyGen</b> are function objects (since
there is an <b>operator(&nbsp;)</b>) that produce <b>Noisy</b> objects during
testing.</p>

<p class=MsoNormal><b>NoisyReport</b> is a Singleton object<a href="#_ftn107" name="_ftnref107"><span
class=MsoFootnoteReference>[107]</span></a> because we
only want one report printed at program termination. It has a <b>private</b>
constructor so no additional <b>NoisyReport</b> objects can be created, it
disallows assignment and copy-construction, and it has a single static instance
of <b>NoisyReport</b> called <b>nr</b>. The only executable statements are in
the destructor, which is called as the program exits and static destructors are
called. This destructor prints the statistics captured by the <b>static</b>
variables in <b>Noisy</b>.</p>

<p class=MsoNormal>Using <b>Noisy.h</b>, the following program shows a <b>vector</b>
overflowing its allocated storage:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:VectorOverflow.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Shows the copy-construction and destruction</font></div>
<div class=CC1><font color=#dd0000>// that occurs when a vector must reallocate.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>int</font> size = 1000;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt;= 2) size = atoi(argv[1]);</div>
<div class=CC1>  vector&lt;Noisy&gt; vn;</div>
<div class=CC1>  Noisy n;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; size; i++)</div>
<div class=CC1>    vn.push_back(n);</div>
<div class=CC1>  cout &lt;&lt; &quot;\n cleaning up “ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can use the default value of 1000, or you can use your
own value by putting it on the command line.</p>

<p class=MsoNormal>When you run this program, you’ll see a single default
constructor call (for <b>n</b>), then a lot of copy-constructor calls, then
some destructor calls, then some more copy-constructor calls, and so on. When
the <b>vector</b> runs out of space in the linear array of bytes it has
allocated, it must (to maintain all the objects in a linear array, which is an
essential part of its job) get a bigger piece of storage and move everything
over, first copying and then destroying the old objects. You can imagine that
if you store a lot of large and complex objects, this process could rapidly
become prohibitive.</p>

<p class=MsoNormal>There are two solutions to this problem. The nicest one
requires that you know beforehand how many objects you’re going to make. In
that case, you can use <b>reserve(&nbsp;)</b> to tell the <b>vector</b> how
much storage to preallocate, thus eliminating all the copies and destructions
and making everything very fast (especially random access to the objects with <b>operator[&nbsp;]</b>).
Note that the use of <b>reserve(&nbsp;)</b> is different from using the <b>vector</b>
constructor with an integral first argument; the latter initializes a
prescribed number of elements using the element type’s default constructor.</p>

<p class=MsoNormal>Generally you won’t know how many objects you’ll need. If <b>vector</b>
reallocations are slowing things down, you can change sequence containers. You
could use a <b>list</b>, but<b> </b>as you’ll see, the <b>deque</b> allows
speedy insertions at either end of the sequence and never needs to copy or
destroy objects as it expands its storage. The <b>deque</b> also allows random
access with <b>operator[&nbsp;]</b>, but it’s not quite as fast as <b>vector</b>’s
<b>operator[&nbsp;]</b>. So if you’re creating all your objects in one part of
the program and randomly accessing them in another, you may find yourself
filling a <b>deque</b> and then creating a <b>vector</b> from the <b>deque</b>
and using the <b>vector</b> for rapid indexing. You don’t want to program this
way habitually—just be aware of these issues (that is, avoid premature
optimization).</p>

<p class=MsoNormal>There is a darker side to <b>vector</b>’s reallocation of
memory, however. Because <b>vector</b> keeps its objects in a nice, neat array,
the iterators used by <b>vector</b> can be simple pointers. This is good—of all
the sequence containers, these pointers allow the fastest selection and
manipulation. Whether they are simple pointers, or whether they are iterator
objects that hold an internal pointer into their container, consider what
happens when you add the one additional object that causes the <b>vector</b> to
reallocate storage and move it elsewhere. The iterator’s pointer is now
pointing off into nowhere:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:VectorCoreDump.cpp</font></div>
<div class=CC1><font color=#dd0000>// Invalidating an iterator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; vi(10, 0);</div>
<div class=CC1>  ostream_iterator&lt;<font color=#ff7700>int</font>&gt; out(cout, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt;::iterator i = vi.begin();</div>
<div class=CC1>  *i = 47;</div>
<div class=CC1>  copy(vi.begin(), vi.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Force it to move memory (could also just add</font></div>
<div class=CC1>  <font color=#dd0000>// enough objects):</font></div>
<div class=CC1>  vi.resize(vi.capacity() + 1);</div>
<div class=CC1>  <font color=#dd0000>// Now i points to wrong memory:</font></div>
<div class=CC1>  *i = 48;  <font color=#dd0000>// Access violation</font></div>
<div class=CC1>  copy(vi.begin(), vi.end(), out); <font color=#dd0000>// No change to
vi[0]</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This illustrates the concept of <i>iterator invalidation</i>. Certain operations cause internal changes to a container’s underlying
data, so any iterators in effect before such changes may no longer be valid
afterward. If your program is breaking mysteriously, look for places where you
hold onto an iterator while adding more objects to a <b>vector</b>. You’ll need
to get a new iterator after adding elements or use <b>operator[&nbsp;] </b>instead
for element selections. If you combine this observation with the awareness of
the potential expense of adding new objects to a <b>vector</b>, you may
conclude that the safest way to use a <b>vector</b> is to fill it up all at
once (ideally, knowing first how many objects you’ll need) and then just use it
(without adding more objects) elsewhere in the program. This is the way <b>vector</b>
has been used in the book up to this point. The Standard C++ library documents the
container operations that invalidate iterators.</p>

<p class=MsoNormal>You may observe that using <b>vector </b>as the “basic”
container in the earlier chapters of this book might not be the best choice in
all cases. This is a fundamental issue in containers and in data structures in
general—the “best” choice varies according to the way the container is used.
The reason <b>vector</b> has been the “best” choice up until now is that it
looks a lot like an array and was thus familiar and easy for you to adopt. But
from now on it’s also worth thinking about other issues when choosing
containers.</p>

<h4>Inserting and erasing elements</h4>

<p class=MsoNormal>The <b>vector</b> is most efficient if:</p>

<p class=Numbered style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.95in'><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You <b>reserve(&nbsp;)</b> the correct amount of storage at the
beginning so the <b>vector</b> never has to reallocate.</p>

<p class=Numbered style='margin-left:.95in'><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You only add and remove elements from the back end.</p>

<p class=MsoNormal>It is possible to insert and erase elements from the middle
of a <b>vector</b> using an iterator, but the following program demonstrates
what a bad idea this is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:VectorInsertAndErase.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Erasing an element from a vector.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Noisy&gt; v;</div>
<div class=CC1>  v.reserve(11);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;11 spaces have been
reserved&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  generate_n(back_inserter(v), 10, NoisyGen());</div>
<div class=CC1>  ostream_iterator&lt;Noisy&gt; out(cout, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  copy(v.begin(), v.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Inserting an element:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  vector&lt;Noisy&gt;::iterator it =</div>
<div class=CC1>    v.begin() + v.size() / 2; <font color=#dd0000>// Middle</font></div>
<div class=CC1>  v.insert(it, Noisy());</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  copy(v.begin(), v.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\nErasing an element:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Cannot use the previous value of it:</font></div>
<div class=CC1>  it = v.begin() + v.size() / 2;</div>
<div class=CC1>  v.erase(it);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  copy(v.begin(), v.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you run the program, you’ll see that the call to <b>reserve(&nbsp;)</b>
really does only allocate storage—no constructors are called. The <b>generate_n(&nbsp;)</b>
call is busy: each call to <b>NoisyGen::operator(&nbsp;)</b> results in a
construction, a copy-construction (into the <b>vector</b>), and a destruction
of the temporary. But when an object is inserted into the <b>vector</b> in the
middle, it must shift everything down to maintain the linear array, and, since
there is enough space, it does this with the assignment operator. (If the
argument of <b>reserve(&nbsp;)</b> is 10 instead of 11, it must reallocate
storage.) When an object is erased from the <b>vector</b>, the assignment
operator is once again used to move everything up to cover the place that is
being erased. (Notice that this requires that the assignment operator properly
clean up the lvalue.) Last, the object on the end of the array is deleted.</p>

<h3><a href="#_TocRef53985782" name="_Toc53985782">deque</a></h3>

<p class=MsoNormal>The <b>deque</b> container is a basic sequence optimized for
adding and removing elements from either end. It also allows for reasonably
fast random access—it has an <b>operator[&nbsp;]</b> like <b>vector</b>.
However, it does not have <b>vector</b>’s constraint of keeping everything in a
single sequential block of memory. Instead, a typical implementation of <b>deque</b>
uses multiple blocks of sequential storage (keeping track of all the blocks and
their order in a mapping structure). For this reason, the overhead for a <b>deque</b>
to add or remove elements at either end is low. In addition, it never needs to
copy and destroy contained objects during a new storage allocation (like <b>vector</b>
does), so it is far more efficient than <b>vector</b> if you are adding an
unknown quantity of objects at either end. This means that <b>vector</b> is the
best choice only if you have a good idea of how many objects you need. In
addition, many of the programs shown earlier in this book that use <b>vector</b>
and <b>push_back(&nbsp;)</b> might have been more efficient had we used a <b>deque</b>
instead. The interface to <b>deque</b> differs only slightly from <b>vector</b>
(<b>deque</b> has a <b>push_front(&nbsp;)</b> and <b>pop_front(&nbsp;)</b>
while <b>vector</b> does not, for example), so converting code from using <b>vector</b>
to using <b>deque</b> is trivial. Consider <b>StringVector.cpp</b>, which can
be changed to use <b>deque</b> by replacing the word “vector” with “deque”
everywhere. The following program adds parallel <b>deque</b> operations to the <b>vector</b>
operations in <b>StringVector.cpp</b> and performs timing comparisons:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:StringDeque.cpp</font></div>
<div class=CC1><font color=#dd0000>// Converted from StringVector.cpp.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;StringDeque.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  <span lang=SV>vector&lt;string&gt; vstrings;</span></div>
<div class=CC1><span lang=SV>  deque&lt;string&gt; dstrings;</span></div>
<div class=CC1><span lang=SV>  </span>string line;</div>
<div class=CC1>  <font color=#dd0000>// Time reading into vector:</font></div>
<div class=CC1>  clock_t ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    vstrings.push_back(line);</div>
<div class=CC1>  ticks = clock() - ticks;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Read into vector: &quot;</font> &lt;&lt;
ticks &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Repeat for deque:</font></div>
<div class=CC1>  ifstream in2(fname);</div>
<div class=CC1>  assure(in2, fname);</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in2, line))</div>
<div class=CC1>    dstrings.push_back(line);</div>
<div class=CC1>  ticks = clock() - ticks;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Read into deque: &quot;</font> &lt;&lt;
ticks &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Now compare indexing:</font></div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; vstrings.size(); i++) {</div>
<div class=CC1>    <span lang=SV>ostringstream ss;</span></div>
<div class=CC1><span lang=SV>    ss &lt;&lt; i;</span></div>
<div class=CC1><span lang=SV>    vstrings[i] = ss.str() + <font color=#007f00>&quot;:
&quot;</font> + vstrings[i];</span></div>
<div class=CC1><span lang=SV>  </span>}</div>
<div class=CC1>  ticks = clock() - ticks;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Indexing vector: &quot;</font> &lt;&lt;
ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t j = 0; j &lt; dstrings.size(); j++) {</div>
<div class=CC1>    <span lang=SV>ostringstream ss;</span></div>
<div class=CC1><span lang=SV>    ss &lt;&lt; j;</span></div>
<div class=CC1><span lang=SV>    dstrings[j] = ss.str() + <font color=#007f00>&quot;:
&quot;</font> + dstrings[j];</span></div>
<div class=CC1><span lang=SV>  </span>}</div>
<div class=CC1>  ticks = clock() - ticks;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Indexing deque: &quot;</font> &lt;&lt;
ticks &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Compare iteration</font></div>
<div class=CC1>  ofstream tmp1(<font color=#007f00>&quot;tmp1.tmp&quot;</font>),
tmp2(<font color=#007f00>&quot;tmp2.tmp&quot;</font>);</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  copy(vstrings.begin(), vstrings.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(tmp1,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>  ticks = clock() - ticks;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Iterating vector: &quot;</font> &lt;&lt;
ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  copy(dstrings.begin(), dstrings.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(tmp2,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>  ticks = clock() - ticks;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Iterating deque: &quot;</font> &lt;&lt;
ticks &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Knowing now what you do about the inefficiency of adding
things to <b>vector</b> because of storage reallocation, you might expect
dramatic differences between the two. However, on a 1.7 MB text file, one
compiler’s program produced the following (measured in platform/compiler
specific clock ticks, not seconds):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Read into vector: 8350</div>
<div class=CC1>Read into deque: 7690</div>
<div class=CC1>Indexing vector: 2360</div>
<div class=CC1>Indexing deque: 2480</div>
<div class=CC1>Iterating vector: 2470</div>
<div class=CC1>Iterating deque: 2410</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A different compiler and platform roughly agreed with this.
It’s not so dramatic, is it? This points out some important issues:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>We (programmers and authors) are typically bad at guessing where
inefficiencies occur in our programs.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:6.0pt;
margin-left:.95in;text-indent:-.45in'><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Efficiency comes from a combination of effects. Here, reading the
lines in and converting them to strings may dominate over the cost of <b>vector</b>
vs. <b>deque</b>.</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The <b>string</b> class is probably fairly well designed in terms
of efficiency.</p>

<p class=MsoNormal>This doesn’t mean you shouldn’t use a <b>deque</b> rather
than a <b>vector</b> when you know that an uncertain number of objects will be
pushed onto the end of the container. On the contrary, you should—when you’re
tuning for performance. But also be aware that performance issues are usually
not where you think they are, and the only way to know for sure where your
bottlenecks are is by testing. Later in this chapter, you’ll see a more “pure”
comparison of performance between <b>vector</b>, <b>deque</b>, and <b>list</b>.</p>

<h3><a href="#_TocRef53985783" name="_Toc53985783">Converting between sequences</a></h3>

<p class=MsoNormal>Sometimes you need the behavior or efficiency of one kind of
container for one part of your program, and you need a different container’s
behavior or efficiency in another part of the program. For example, you may
need the efficiency of a <b>deque</b> when adding objects to the container but
the efficiency of a <b>vector</b> when indexing them. Each of the basic
sequence containers (<b>vector</b>, <b>deque</b>, and <b>list</b>) has a
two-iterator constructor (indicating the beginning and ending of the sequence
to read from when creating a new object) and an <b>assign(&nbsp;)</b> member
function to read into an existing container, so you can easily move objects
from one sequence container to another.</p>

<p class=MsoNormal>The following example reads objects into a <b>deque</b> and
then converts to a <b>vector</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:DequeConversion.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Reading into a Deque, converting to a vector.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>int</font> size = 25;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt;= 2) size = atoi(argv[1]);</div>
<div class=CC1>  deque&lt;Noisy&gt; d;</div>
<div class=CC1>  generate_n(back_inserter(d), size, NoisyGen());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Converting to a
vector(1)&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  vector&lt;Noisy&gt; v1(d.begin(), d.end());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Converting to a
vector(2)&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  vector&lt;Noisy&gt; v2;</div>
<div class=CC1>  v2.reserve(d.size());</div>
<div class=CC1>  v2.assign(d.begin(), d.end());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Cleanup&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can try various sizes, but note that it makes no
difference—the objects are simply copy-constructed into the new <b>vector</b>s.
What’s interesting is that <b>v1</b> does not cause multiple allocations while
building the <b>vector</b>, no matter how many elements you use. You might
initially think that you must follow the process used for <b>v2</b> and
preallocate the storage to prevent messy reallocations, but this is unnecessary
because the constructor used for <b>v1</b> determines the memory requirement
ahead of time.</p>

<h4>Cost of overflowing allocated storage</h4>

<p class=MsoNormal>It’s illuminating to see what happens with a <b>deque</b>
when it overflows a block of storage, in contrast with <b>VectorOverflow.cpp</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:DequeOverflow.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// A deque is much more efficient than a vector when</font></div>
<div class=CC1><font color=#dd0000>// pushing back a lot of elements, since it doesn't</font></div>
<div class=CC1><font color=#dd0000>// require copying and destroying.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>int</font> size = 1000;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt;= 2) size = atoi(argv[1]);</div>
<div class=CC1>  deque&lt;Noisy&gt; dn;</div>
<div class=CC1>  Noisy n;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; size; i++)</div>
<div class=CC1>    dn.push_back(n);</div>
<div class=CC1>  cout &lt;&lt; &quot;\n cleaning up “ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here you will have relatively few (if any) destructors
called before the words “cleaning up” appear in the output. Since the <b>deque</b>
allocates all its storage in blocks instead of a contiguous array like <b>vector</b>,
it never needs to move existing storage of each of its data blocks. (Thus, no
additional copy-constructions and destructions occur.) The <b>deque</b> simply
allocates a new block. For the same reason, the <b>deque</b> can just as
efficiently add elements to the <i>beginning</i> of the sequence, since if it
runs out of storage, it (again) just allocates a new block for the beginning.
(The index block that holds the data blocks together may need to be
reallocated, however.) Insertions in the middle of a <b>deque</b>, however,
could be even messier than for <b>vector</b> (but not as costly).</p>

<p class=MsoNormal>Because of <b>deque</b>’s<b> </b>clever storage management,
an existing iterator is not invalidated after you add new things to either end
of a deque, as it was demonstrated to do with <b>vector</b> (in <b>VectorCoreDump.cpp</b>).
If you stick to what <b>deque</b> is best at—insertions and removals from
either end, reasonably rapid traversals and fairly fast random-access using <b>operator[&nbsp;]</b>—you’ll
be in good shape.</p>

<h3><a href="#_TocRef53985784" name="_Toc53985784">Checked random–access</a></h3>

<p class=MsoNormal>Both <b>vector </b>and <b>deque</b> provide two random
access functions: the indexing operator (<b>operator[&nbsp;]</b>), which you’ve
seen already, and <b>at(&nbsp;)</b>, which checks the boundaries of the
container that’s being indexed and throws an exception if you go out of bounds.
It does cost more to use <b>at(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:IndexingVsAt.cpp</font></div>
<div class=CC1><font color=#dd0000>// Comparing &quot;at()&quot; to operator[].</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>long</font> count = 1000;</div>
<div class=CC1>  <font color=#ff7700>int</font> sz = 1000;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt;= 2) count = atoi(argv[1]);</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt;= 3) sz = atoi(argv[2]);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt; vi(sz);</div>
<div class=CC1>  clock_t ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i1 = 0; i1 &lt; count; i1++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; sz; j++)</div>
<div class=CC1>      <span lang=SV>vi[j];</span></div>
<div class=CC1><span lang=SV>  cout &lt;&lt; <font color=#007f00>&quot;vector[] &quot;</font>
&lt;&lt; clock() - ticks &lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  </span>ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i2 = 0; i2 &lt; count; i2++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; sz; j++)</div>
<div class=CC1>      vi.at(j);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;vector::at() &quot;</font> &lt;&lt;
clock()-ticks &lt;&lt;endl;</div>
<div class=CC1>  deque&lt;<font color=#ff7700>int</font>&gt; di(sz);</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i3 = 0; i3 &lt; count; i3++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; sz; j++)</div>
<div class=CC1>      di[j];</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;deque[] &quot;</font> &lt;&lt; clock() -
ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i4 = 0; i4 &lt; count; i4++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; sz; j++)</div>
<div class=CC1>      di.at(j);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;deque::at() &quot;</font> &lt;&lt;
clock()-ticks &lt;&lt;endl;</div>
<div class=CC1>  <font color=#dd0000>// Demonstrate at() when you go out of bounds:</font></div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    di.at(vi.size() + 1);</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(...) {</div>
<div class=CC1>    cerr &lt;&lt; <font color=#007f00>&quot;Exception thrown&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As you saw in Chapter 1, different systems may handle the
uncaught exception in different ways, but you’ll know one way or another that
something went wrong with the program when using <b>at(&nbsp;)</b>, whereas
it’s possible to remain ignorant when using <b>operator[&nbsp;]</b>.</p>

<h3><a href="#_TocRef53985785" name="_Toc53985785">list</a></h3>

<p class=MsoNormal>A <b>list</b> is implemented as a doubly linked list data
structure and is thus designed for rapid insertion and removal of elements <i>anywhere</i>
in the sequence, whereas for <b>vector</b> and <b>deque </b>this is a much more
costly operation. A list is so slow when randomly accessing elements that it
does not have an <b>operator[&nbsp;]</b>. It’s best used when you’re traversing
a sequence, in order, from beginning to end (or vice-versa), rather than
choosing elements randomly from the middle. Even then the traversal can be
slower than with a <b>vector</b>, but if you aren’t doing a lot of traversals,
that won’t be your bottleneck.</p>

<p class=MsoNormal>The memory overhead of each link in a <b>list</b> requires a
forward and backward pointer on top of the storage for the actual object. Thus,
a <b>list</b> is a better choice when you have larger objects that you’ll be
inserting and removing from the middle of the <b>list</b>.</p>

<p class=MsoNormal>It’s better not to use a <b>list </b>if you think you might
be traversing it a lot, looking for objects, since the amount of time it takes
to get from the beginning of the <b>list</b>—which is the only place you can
start unless you’ve already got an iterator to somewhere you know is closer to
your destination—to the object of interest is proportional to the number of
objects between the beginning and that object.</p>

<p class=MsoNormal>The objects in a <b>list </b>never move after they are
created. “Moving” a list element means changing the links, but never copying or
assigning the actual objects. This means that iterators aren’t invalidated when
items are added to the list as it was demonstrated earlier to be the case <b>vector</b>.
Here’s an example using a <b>list</b> of <b>Noisy</b> objects:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:ListStability.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Things don't move around in lists.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  list&lt;Noisy&gt; l;</div>
<div class=CC1>  ostream_iterator&lt;Noisy&gt; out(cout, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  generate_n(back_inserter(l), 25, NoisyGen());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Printing the list:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  copy(l.begin(), l.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Reversing the list:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  l.reverse();</div>
<div class=CC1>  copy(l.begin(), l.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Sorting the list:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  l.sort();</div>
<div class=CC1>  copy(l.begin(), l.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Swapping two elements:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  list&lt;Noisy&gt;::iterator it1, it2;</div>
<div class=CC1>  it1 = it2 = l.begin();</div>
<div class=CC1>  ++it2;</div>
<div class=CC1>  swap(*it1, *it2);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  copy(l.begin(), l.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Using generic reverse():
&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  reverse(l.begin(), l.end());</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  copy(l.begin(), l.end(), out);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Cleanup&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Operations as seemingly radical as reversing and sorting the
list require no copying of objects because, instead of moving the objects, the
links are simply changed. However, notice that <b>sort(&nbsp;)</b> and <b>reverse(&nbsp;)</b> are member functions of <b>list</b>, so they have special knowledge of the
internals of <b>list</b> and can rearrange the elements instead of copying
them. On the other hand, the <b>swap(&nbsp;)</b> function is a generic
algorithm and doesn’t know about <b>list</b> in particular, so it uses the
copying approach for swapping two elements. In general, use the member version
of an algorithm if that is supplied instead of its generic algorithm
equivalent. In particular, use the generic <b>sort(&nbsp;)</b> and <b>reverse(&nbsp;)</b>
algorithms only with arrays, <b>vector</b>s, and <b>deque</b>s.</p>

<p class=MsoNormal>If you have large, complex objects, you might want to choose
a <b>list</b> first, especially if construction, destruction,
copy-construction, and assignment are expensive and if you are doing things
like sorting the objects or otherwise reordering them a lot.</p>

<h4>Special list operations</h4>

<p class=MsoNormal>The <b>list</b> has some special built-in operations to make
the best use of the structure of the <b>list</b>. You’ve already seen <b>reverse(&nbsp;)</b>
and <b>sort(&nbsp;).</b> Here are some of the others:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:ListSpecialFunctions.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintContainer.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> list&lt;Noisy&gt; LN;</div>
<div class=CC1>  LN l1, l2, l3, l4;</div>
<div class=CC1>  generate_n(back_inserter(l1), 6, NoisyGen());</div>
<div class=CC1>  generate_n(back_inserter(l2), 6, NoisyGen());</div>
<div class=CC1>  generate_n(back_inserter(l3), 6, NoisyGen());</div>
<div class=CC1>  generate_n(back_inserter(l4), 6, NoisyGen());</div>
<div class=CC1>  print(l1, <font color=#007f00>&quot;l1&quot;</font>, <font color=#007f00>&quot; &quot;</font>); print(l2,
<font color=#007f00>&quot;l2&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  print(l3, <font color=#007f00>&quot;l3&quot;</font>, <font color=#007f00>&quot; &quot;</font>); print(l4,
<font color=#007f00>&quot;l4&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  LN::iterator it1 = l1.begin();</div>
<div class=CC1>  ++it1; ++it1; ++it1;</div>
<div class=CC1>  l1.splice(it1, l2);</div>
<div class=CC1>  print(l1, <font color=#007f00>&quot;l1 after splice(it1, l2)&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  print(l2, <font color=#007f00>&quot;l2 after splice(it1, l2)&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  LN::iterator it2 = l3.begin();</div>
<div class=CC1>  ++it2; ++it2; ++it2;</div>
<div class=CC1>  l1.splice(it1, l3, it2);</div>
<div class=CC1>  print(l1, <font color=#007f00>&quot;l1 after splice(it1, l3, it2)&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  LN::iterator it3 = l4.begin(), it4 = l4.end();</div>
<div class=CC1>  ++it3; --it4;</div>
<div class=CC1>  l1.splice(it1, l4, it3, it4);</div>
<div class=CC1>  print(l1, <font color=#007f00>&quot;l1 after
splice(it1,l4,it3,it4)&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  Noisy n;</div>
<div class=CC1>  LN l5(3, n);</div>
<div class=CC1>  generate_n(back_inserter(l5), 4, NoisyGen());</div>
<div class=CC1>  l5.push_back(n);</div>
<div class=CC1>  print(l5, <font color=#007f00>&quot;l5 before remove()&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  l5.remove(l5.front());</div>
<div class=CC1>  print(l5, <font color=#007f00>&quot;l5 after remove()&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  <span lang=SV>l1.sort(); l5.sort();</span></div>
<div class=CC1><span lang=SV>  l5.merge(l1);</span></div>
<div class=CC1><span lang=SV>  </span>print(l5, <font color=#007f00>&quot;l5 after
l5.merge(l1)&quot;</font>, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Cleanup&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>After filling four <b>list</b>s with <b>Noisy</b> objects,
one list is spliced into another in three ways. In the first, the entire list <b>l2</b>
is spliced into <b>l1</b> at the iterator <b>it1</b>. Notice that after the
splice, <b>l2</b> is empty—splicing means removing the elements from the source
list. The second splice inserts elements from <b>l3 </b>starting at <b>it2</b>
into <b>l1 </b>starting at <b>it1</b>. The third splice starts at <b>it1</b>
and uses elements from <b>l4</b> starting at <b>it3</b> and ending at <b>it4</b>.
The seemingly redundant mention of the source list is because the elements must
be erased from the source list as part of the transfer to the destination list.</p>

<p class=MsoNormal>The output from the code that demonstrates <b>remove(&nbsp;)</b> shows that the list does not have to be sorted in order for all the elements
of a particular value to be removed.</p>

<p class=MsoNormal>Finally, if you <b>merge(&nbsp;)</b> one list with another,
the merge only works sensibly if the lists have been sorted. What you end up
with in that case is a sorted list containing all the elements from both lists
(the source list is erased—that is, the elements are <i>moved</i> to the
destination list).</p>

<p class=MsoNormal>A <b>unique(&nbsp;)</b> member function removes all duplicates, but only if you sort the <b>list</b> first:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:UniqueList.cpp</font></div>
<div class=CC1><font color=#dd0000>// Testing list's unique() function.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> a[] = { 1, 3, 1, 4, 1, 5, 1, 6, 1 };</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>int</font> ASZ = <font color=#ff7700>sizeof</font> a / <font color=#ff7700>sizeof</font> *a;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// For output:</font></div>
<div class=CC1>  ostream_iterator&lt;<font color=#ff7700>int</font>&gt; out(cout, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>  list&lt;<font color=#ff7700>int</font>&gt; li(a, a + ASZ);</div>
<div class=CC1>  li.unique();</div>
<div class=CC1>  <font color=#dd0000>// Oops! No duplicates removed:</font></div>
<div class=CC1>  copy(li.begin(), li.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Must sort it first:</font></div>
<div class=CC1>  li.sort();</div>
<div class=CC1>  copy(li.begin(), li.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Now unique() will have an effect:</font></div>
<div class=CC1>  li.unique();</div>
<div class=CC1>  copy(li.begin(), li.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>list</b> constructor used here takes the starting and
past-the-end iterator from another container and copies all the elements from
that container into itself. Here, the “container” is just an array, and the
“iterators” are pointers into that array, but because of the design of the STL,
the <b>list</b> constructor works with arrays just as easily as with any other
container.</p>

<p class=MsoNormal>The <b>unique(&nbsp;)</b> function will remove only <i>adjacent</i>
duplicate elements, and thus sorting is typically necessary before calling <b>unique(&nbsp;)</b>.
The exception is when the problem you’re trying to solve includes eliminating
adjacent duplicates according to the current ordering.</p>

<p class=MsoNormal>Four additional <b>list </b>member functions are not
demonstrated here: a <b>remove_if(&nbsp;)</b> that takes a predicate, which
decides whether an object should be removed; a <b>unique(&nbsp;)</b> that takes
a binary predicate to perform uniqueness comparisons; a <b>merge(&nbsp;)</b>
that takes an additional argument which performs comparisons; and a <b>sort(&nbsp;)</b>
that takes a comparator (to provide a comparison or override the existing one).</p>

<h4>list vs. set</h4>

<p class=MsoNormal>Looking at the previous example, you might note that if you
want a sorted sequence with no duplicates, you could get that result with a <b>set</b>.
It’s interesting to compare the performance of the two containers:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:ListVsSet.cpp</font></div>
<div class=CC1><font color=#dd0000>// Comparing list and set performance.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintContainer.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Obj {</div>
<div class=CC1>  <font color=#ff7700>int</font> a[20]; <font color=#dd0000>// To take up extra space</font></div>
<div class=CC1>  <font color=#ff7700>int</font> val;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Obj() : val(rand() % 500) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font></div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> Obj&amp; a, <font color=#ff7700>const</font> Obj&amp; b) {</div>
<div class=CC1>    <font color=#ff7700>return</font> a.val &lt; b.val;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font></div>
<div class=CC1>  <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> Obj&amp; a, <font color=#ff7700>const</font> Obj&amp; b) {</div>
<div class=CC1>    <font color=#ff7700>return</font> a.val == b.val;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Obj&amp; a) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; a.val;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> ObjGen {</div>
<div class=CC1>  Obj <font color=#ff7700>operator</font>()() { <font color=#ff7700>return</font> Obj(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 5000;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  list&lt;Obj&gt; lo;</div>
<div class=CC1>  clock_t ticks = clock();</div>
<div class=CC1>  generate_n(back_inserter(lo), SZ, ObjGen());</div>
<div class=CC1>  lo.sort();</div>
<div class=CC1>  lo.unique();</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;list:&quot;</font> &lt;&lt; clock() -
ticks &lt;&lt; endl;</div>
<div class=CC1>  set&lt;Obj&gt; so;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  generate_n(inserter(so, so.begin()),</div>
<div class=CC1>    SZ, ObjGen());</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;set:&quot;</font> &lt;&lt; clock() -
ticks &lt;&lt; endl;</div>
<div class=CC1>  print(lo);</div>
<div class=CC1>  print(so);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you run the program, you should discover that <b>set</b>
is much faster than <b>list</b>. This is reassuring—after all, it is <b>set</b>’s
primary job description to hold only unique elements in sorted order!</p>

<p class=MsoNormal>This example uses the header <b>PrintContainer.h</b>, which
contains a function template that prints any sequence container to an output
stream. <b>PrintContainer.h</b> is defined as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//:
C07:PrintContainer.h</font></div>
<div class=CC1><font color=#dd0000>// Prints a
sequence container</font></div>
<div class=CC1><font color=#7F7F00>#ifndef
PRINT_CONTAINER_H</font></div>
<div class=CC1><font color=#7F7F00>#define
PRINT_CONTAINER_H</font></div>
<div class=CC1><font color=#7F7F00>#include
&quot;../C06/PrintSequence.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font>
Cont&gt;</div>
<div class=CC1><font color=#ff7700>void</font>
print(Cont&amp; c, <font color=#ff7700>const</font> <font color=#ff7700>char</font>* nm = <font color=#007f00>&quot;&quot;</font>,</div>
<div class=CC1>          
<font color=#ff7700>const</font> <font color=#ff7700>char</font>* sep = <font color=#007f00>&quot;\n&quot;</font>,</div>
<div class=CC1>           std::ostream&amp;
os = std::cout) {</div>
<div class=CC1> 
print(c.begin(), c.end(), nm, sep, os);</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>print(&nbsp;)</b> template defined here just calls
the <b>print(&nbsp;)</b> function template we defined in the previous chapter
in <b>PrintSequence.h</b>.</p>

<h3><a href="#_TocRef53985786" name="_Toc53985786">Swapping sequences</a></h3>

<p class=MsoNormal>We mentioned earlier that all basic sequences have a member
function <b>swap(&nbsp;)</b> that’s designed to switch one sequence with
another (but only for sequences of the same type). The member <b>swap(&nbsp;)</b>
makes use of its knowledge of the internal structure of the particular
container in order to be efficient:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Swapping.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// All basic sequence containers can be swapped.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintContainer.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>ostream_iterator&lt;Noisy&gt; out(cout, <font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Cont&gt; <font color=#ff7700>void</font> testSwap(<font color=#ff7700>char</font>* cname) {</div>
<div class=CC1>  Cont c1, c2;</div>
<div class=CC1>  generate_n(back_inserter(c1), 10, NoisyGen());</div>
<div class=CC1>  generate_n(back_inserter(c2), 5, NoisyGen());</div>
<div class=CC1>  cout &lt;&lt; endl &lt;&lt; cname &lt;&lt;
<font color=#007f00>&quot;:&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  print(c1, <font color=#007f00>&quot;c1&quot;</font>); print(c2, <font color=#007f00>&quot;c2&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n Swapping the &quot;</font> &lt;&lt;
cname &lt;&lt; <font color=#007f00>&quot;:&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  c1.swap(c2);</div>
<div class=CC1>  print(c1, <font color=#007f00>&quot;c1&quot;</font>); print(c2, <font color=#007f00>&quot;c2&quot;</font>);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  testSwap&lt;vector&lt;Noisy&gt; &gt;(<font color=#007f00>&quot;vector&quot;</font>);</div>
<div class=CC1>  testSwap&lt;deque&lt;Noisy&gt;
&gt;(<font color=#007f00>&quot;deque&quot;</font>);</div>
<div class=CC1>  testSwap&lt;list&lt;Noisy&gt; &gt;(<font color=#007f00>&quot;list&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you run this, you’ll discover that each type of
sequence container can swap one sequence for another without any copying or
assignments, even if the sequences are of different sizes. In effect, you’re
completely swapping the resources of one object for another.</p>

<p class=MsoNormal>The STL algorithms also contain a <b>swap(&nbsp;)</b>, and
when this function is applied to two containers of the same type, it uses the
member <b>swap(&nbsp;)</b> to achieve fast performance. Consequently, if you
apply the <b>sort(&nbsp;)</b> algorithm to a container of containers, you will
find that the performance is very fast—it turns out that fast sorting of a
container of containers was a design goal of the STL.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985787" name="_Toc53985787">set</a></h2>

<p class=MsoNormal>The <b>set</b> container accepts only one copy of each element.
It also sorts the elements. (Sorting isn’t intrinsic to the conceptual
definition of a set, but the STL <b>set</b> stores its elements in a balanced
tree data structure to provide rapid lookups, thus producing sorted results
when you traverse it.) The first two examples in this chapter used <b>set</b>s.</p>

<p class=MsoNormal>Consider the problem of creating an index for a book. You
might like to start with all the words in the book, but you only want one
instance of each word, and you want them sorted. A <b>set</b> is perfect for
this and solves the problem effortlessly. However, there’s also the problem of
punctuation and any other nonalpha characters, which must be stripped off to
generate proper words. One solution to this problem is to use the Standard C
library functions <b>isalpha(&nbsp;)</b> and <b>isspace(&nbsp;)</b> to extract
only the characters you want. You can replace all unwanted characters with
spaces so that you can easily extract valid words from each line you read:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:WordList.cpp</font></div>
<div class=CC1><font color=#dd0000>// Display a list of words used in a document.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>char</font> replaceJunk(<font color=#ff7700>char</font> c) {</div>
<div class=CC1>  <font color=#dd0000>// Only keep alphas, space (as a delimiter), and '</font></div>
<div class=CC1>  <font color=#ff7700>return</font> (isalpha(c) || c == '\'') ? c : ' ';</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;WordList.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  set&lt;string&gt; wordlist;</div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line)) {</div>
<div class=CC1>    transform(line.begin(), line.end(), line.begin(),</div>
<div class=CC1>              replaceJunk);</div>
<div class=CC1>    istringstream is(line);</div>
<div class=CC1>    string word;</div>
<div class=CC1>    <font color=#ff7700>while</font>(is &gt;&gt; word)</div>
<div class=CC1>      wordlist.insert(word);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Output results:</font></div>
<div class=CC1>  copy(wordlist.begin(), wordlist.end(),</div>
<div class=CC1>       ostream_iterator&lt;string&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The call to <b>transform(&nbsp;)</b> replaces each character
to be ignored with a space. The set container not only ignores duplicate words,
but compares the words it keeps according to the function object <b>less&lt;string&gt;</b>
(the default second template argument for the <b>set</b> container), which in
turn uses <b>string::operator&lt;(&nbsp;)</b>, so the words emerge in
alphabetical order.</p>

<p class=MsoNormal>You don’t need to use a <b>set</b> just to get a sorted
sequence. You can use the <b>sort(&nbsp;)</b> function (along with a multitude
of other functions in the STL) on different STL containers. However, it’s
likely that <b>set</b> will be faster here. Using a set is particularly handy
when you just want to do lookup, since its <b>find(&nbsp;)</b> member function has logarithmic complexity and so is much faster than the generic <b>find(&nbsp;)</b>
algorithm. As you recall, the generic <b>find(&nbsp;)</b> algorithm needs to
traverse the whole range until it finds the search element (resulting in a
worst-case complexity of N, and an average complexity of N/2). However, if you
have a sequence container that is already sorted, use <b>equal_range(&nbsp;)</b>
for logarithmic complexity when finding elements.</p>

<p class=MsoNormal>The following version shows how to build the list of words
with an <b>istreambuf_iterator</b> that moves the characters from one place
(the input stream) to another (a <b>string </b>object), depending on whether
the Standard C library function <b>isalpha(&nbsp;)</b> returns true:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:WordList2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates istreambuf_iterator and insert
iterators.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstring&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;WordList2.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  istreambuf_iterator&lt;<font color=#ff7700>char</font>&gt; p(in), end;</div>
<div class=CC1>  set&lt;string&gt; wordlist;</div>
<div class=CC1>  <font color=#ff7700>while</font>(p != end) {</div>
<div class=CC1>    string word;</div>
<div class=CC1>    insert_iterator&lt;string&gt; ii(word, word.begin());</div>
<div class=CC1>    <font color=#dd0000>// Find the first alpha character:</font></div>
<div class=CC1>    <font color=#ff7700>while</font>(p != end &amp;&amp; !isalpha(*p))</div>
<div class=CC1>      ++p;</div>
<div class=CC1>    <font color=#dd0000>// Copy until the first non-alpha character:</font></div>
<div class=CC1>    <font color=#ff7700>while</font>(p != end &amp;&amp; isalpha(*p))</div>
<div class=CC1>      *ii++ = *p++;</div>
<div class=CC1>    <font color=#ff7700>if</font>(word.size() != 0)</div>
<div class=CC1>      wordlist.insert(word);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Output results:</font></div>
<div class=CC1>  copy(wordlist.begin(), wordlist.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example was suggested by Nathan Myers, who invented the
<b>istreambuf_iterator</b> and its relatives. This iterator extracts
information character by character from a stream. Although the <b>istreambuf_iterator
</b>template argument might imply that you could extract, for example, <b>int</b>s
instead of <b>char</b>, that’s not the case. The argument must be of some
character type—a regular <b>char</b> or a wide character.</p>

<p class=MsoNormal>After the file is open, an <b>istreambuf_iterator</b> called
<b>p</b> is attached to the <b>istream</b> so characters can be extracted from
it. The <b>set&lt;string&gt;</b> called <b>wordlist</b> will hold the resulting
words.</p>

<p class=MsoNormal>The <b>while</b> loop reads words until it finds the end of
the input stream. This is detected using the default constructor for <b>istreambuf_iterator</b>,
which produces the past-the-end iterator object <b>end</b>. Thus, if you want
to test to make sure you’re not at the end of the stream, you simply say <b>p
!= end</b>.</p>

<p class=MsoNormal>The second type of iterator that’s used here is the <b>insert_iterator</b>, which you saw previously. This inserts objects into a container. Here, the
“container” is the <b>string</b> called <b>word</b>, which, for the purposes of
<b>insert_iterator</b>, behaves like a container. The constructor for <b>insert_iterator</b>
requires the container and an iterator indicating where it should start
inserting the characters. You could also use a <b>back_insert_iterator</b>, which requires that the container have a <b>push_back(&nbsp;)</b> (<b>string</b> does).</p>

<p class=MsoNormal>After the <b>while</b> loop sets everything up, it begins by
looking for the first alpha character, incrementing <b>start</b> until that
character is found. It then copies characters from one iterator to the other,
stopping when a nonalpha character is found. Each <b>word</b>, assuming it is
nonempty, is added to <b>wordlist</b>.</p>

<h3><a href="#_TocRef53985788" name="_Toc53985788">A completely reusable tokenizer</a></h3>

<p class=MsoNormal>The word list examples use different approaches to extract
tokens from a stream, neither of which is very flexible. Since the STL
containers and algorithms all revolve around iterators, the most flexible
solution will itself use an iterator. You could think of the <b>TokenIterator</b>
as an iterator that wraps itself around any other iterator that can produce characters.
Because it is certainly a type of input iterator (the most primitive type of
iterator), it can provide input to any STL algorithm. Not only is it a useful
tool in itself, the following <b>TokenIterator</b> is also a good example of
how you can design your own iterators.<a href="#_ftn108" name="_ftnref108"><span
class=MsoFootnoteReference>[108]</span></a></p>

<p class=MsoNormal>The <b>TokenIterator</b> class is doubly flexible. First,
you can choose the type of iterator that will produce the <b>char</b> input.
Second, instead of just saying what characters represent the delimiters, <b>TokenIterator</b>
will use a predicate that is a function object whose <b>operator(&nbsp;)</b>
takes a <b>char</b> and decides whether it should be in the token. Although the
two examples given here have a static concept of what characters belong in a
token, you could easily design your own function object to change its state as
the characters are read, producing a more sophisticated parser.</p>

<p class=MsoNormal>The following header file contains two basic predicates, <b>Isalpha</b>
and <b>Delimiters</b>, along with the template for <b>TokenIterator</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:TokenIterator.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TOKENITERATOR_H</font></div>
<div class=CC1><font color=#7F7F00>#define TOKENITERATOR_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cctype&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> Isalpha : std::unary_function&lt;<font color=#ff7700>char</font>, <font color=#ff7700>bool</font>&gt;
{</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>char</font> c) { <font color=#ff7700>return</font> std::isalpha(c); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Delimiters : std::unary_function&lt;<font color=#ff7700>char</font>,
<font color=#ff7700>bool</font>&gt; {</div>
<div class=CC1>  std::string exclude;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Delimiters() {}</div>
<div class=CC1>  Delimiters(<font color=#ff7700>const</font> std::string&amp; excl) :
exclude(excl) {}</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>char</font> c) {</div>
<div class=CC1>    <font color=#ff7700>return</font> exclude.find(c) == std::string::npos;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> InputIter, <font color=#ff7700>class</font> Pred = Isalpha&gt;</div>
<div class=CC1><font color=#ff7700>class</font> TokenIterator : <font color=#ff7700>public</font> std::iterator&lt;</div>
<div class=CC1>    std::input_iterator_tag, std::string,
std::ptrdiff_t&gt; {</div>
<div class=CC1>  InputIter first;</div>
<div class=CC1>  InputIter last;</div>
<div class=CC1>  std::string word;</div>
<div class=CC1>  Pred predicate;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  TokenIterator(InputIter begin, InputIter end,</div>
<div class=CC1>    Pred pred = Pred())</div>
<div class=CC1>    : first(begin), last(end), predicate(pred) {</div>
<div class=CC1>      ++*<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  TokenIterator() {} <font color=#dd0000>// End sentinel</font></div>
<div class=CC1>  <font color=#dd0000>// Prefix increment:</font></div>
<div class=CC1>  TokenIterator&amp; <font color=#ff7700>operator</font>++() {</div>
<div class=CC1>    word.resize(0);</div>
<div class=CC1>    first = std::find_if(first, last, predicate);</div>
<div class=CC1>    <font color=#ff7700>while</font>(first != last &amp;&amp; predicate(*first))</div>
<div class=CC1>      word += *first++;</div>
<div class=CC1>    <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Postfix increment</font></div>
<div class=CC1>  <font color=#ff7700>class</font> CaptureState {</div>
<div class=CC1>    std::string word;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    CaptureState(<font color=#ff7700>const</font> std::string&amp; w) : word(w) {}</div>
<div class=CC1>    std::string <font color=#ff7700>operator</font>*() { <font color=#ff7700>return</font> word; }</div>
<div class=CC1>  };</div>
<div class=CC1>  CaptureState <font color=#ff7700>operator</font>++(<font color=#ff7700>int</font>) {</div>
<div class=CC1>    CaptureState d(word);</div>
<div class=CC1>    ++*<font color=#ff7700>this</font>;</div>
<div class=CC1>    <font color=#ff7700>return</font> d;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Produce the actual value:</font></div>
<div class=CC1>  std::string <font color=#ff7700>operator</font>*() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> word; }</div>
<div class=CC1>  <font color=#ff7700>const</font> std::string* <font color=#ff7700>operator</font>-&gt;() <font color=#ff7700>const</font> { <font color=#ff7700>return</font>
&amp;word; }</div>
<div class=CC1>  <font color=#dd0000>// Compare iterators:</font></div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> TokenIterator&amp;) {</div>
<div class=CC1>    <font color=#ff7700>return</font> word.size() == 0 &amp;&amp; first == last;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font> TokenIterator&amp; rv) {</div>
<div class=CC1>    <font color=#ff7700>return</font> !(*<font color=#ff7700>this</font> == rv);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TOKENITERATOR_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>TokenIterator</b> class derives from the <b>std::iterator</b>
template. It might appear that some kind of functionality comes with <b>std::iterator</b>,
but it is purely a way of tagging an iterator, to tell a container that uses it
what it can do. Here, you can see <b>input_iterator_tag</b> as the <b>iterator_category</b>
template argument—this tells anyone who asks that a <b>TokenIterator</b> only
has the capabilities of an input iterator and cannot be used with algorithms
requiring more sophisticated iterators. Apart from the tagging, <b>std::iterator</b>
doesn’t do anything beyond providing several useful type definitions. You must implement
all other functionality yourself.</p>

<p class=MsoNormal>The <b>TokenIterator</b> class may look a little strange at
first, because the first constructor requires both a “begin” and an “end”
iterator as arguments, along with the predicate. Remember, this is a “wrapper”
iterator that has no idea how to tell when it’s at the end of its input, so the
ending iterator is necessary in the first constructor. The reason for the
second (default) constructor is that the STL algorithms (and any algorithms you
write) need a <b>TokenIterator </b>sentinel to be the past-the-end value. Since
all the information necessary to see if the <b>TokenIterator</b> has reached
the end of its input is collected in the first constructor, this second
constructor creates a <b>TokenIterator</b> that is merely used as a placeholder
in algorithms.</p>

<p class=MsoNormal>The core of the behavior happens in <b>operator++</b>. This
erases the current value of <b>word</b> using <b>string::resize(&nbsp;)</b> and
then finds the first character that satisfies the predicate (thus discovering
the beginning of the new token) using <b>find_if(&nbsp;)</b>. The resulting
iterator is assigned to <b>first</b>, thus moving <b>first</b> forward to the
beginning of the token. Then, as long as the end of the input is not reached
and the predicate is satisfied, input characters are copied into <b>word</b>.
Finally, the <b>TokenIterator</b> object is returned and must be dereferenced
to access the new token.</p>

<p class=MsoNormal>The postfix increment requires an object of type <b>CaptureState</b>
to hold the value before the increment, so it can be returned. Producing the
actual value is a straightforward <b>operator*</b>. The only other functions to
define for an output iterator are the <b>operator==</b> and <b>operator!=</b>
to indicate whether the <b>TokenIterator</b> has reached the end of its input.
You can see that the argument for <b>operator== </b>is ignored—it only cares
about whether it has reached its internal <b>last</b> iterator. Notice that <b>operator!=</b>
is defined in terms of <b>operator==</b>.</p>

<p class=MsoNormal>A good test of <b>TokenIterator</b> includes a number of
different sources of input characters, including a <b>streambuf_iterator</b>, a
<b>char*</b>, and a <b>deque&lt;char&gt;::iterator</b>. Finally, the original
word list problem is solved:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:TokenIteratorTest.cpp {-g++}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;TokenIterator.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;TokenIteratorTest.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  ostream_iterator&lt;string&gt; out(cout,
<font color=#007f00>&quot;\n&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>typedef</font> istreambuf_iterator&lt;<font color=#ff7700>char</font>&gt; IsbIt;</div>
<div class=CC1>  IsbIt begin(in), isbEnd;</div>
<div class=CC1>  Delimiters delimiters(&quot;
\t\n~;()\&quot;&lt;&gt;:{}[]+-=&amp;*#.,/\\&quot;);</div>
<div class=CC1>  TokenIterator&lt;IsbIt, Delimiters&gt;</div>
<div class=CC1>    wordIter(begin, isbEnd, delimiters), end;</div>
<div class=CC1>  vector&lt;string&gt; wordlist;</div>
<div class=CC1>  copy(wordIter, end, back_inserter(wordlist));</div>
<div class=CC1>  <font color=#dd0000>// Output results:</font></div>
<div class=CC1>  copy(wordlist.begin(), wordlist.end(), out);</div>
<div class=CC1>  *out++ =
<font color=#007f00>&quot;-----------------------------------&quot;</font>;</div>
<div class=CC1>  <font color=#dd0000>// Use a char array as the source:</font></div>
<div class=CC1>  <font color=#ff7700>char</font>* cp = <font color=#007f00>&quot;typedef
std::istreambuf_iterator&lt;char&gt; It&quot;</font>;</div>
<div class=CC1>  TokenIterator&lt;<font color=#ff7700>char</font>*, Delimiters&gt;</div>
<div class=CC1>    charIter(cp, cp + strlen(cp), delimiters), end2;</div>
<div class=CC1>  vector&lt;string&gt; wordlist2;</div>
<div class=CC1>  copy(charIter, end2, back_inserter(wordlist2));</div>
<div class=CC1>  copy(wordlist2.begin(), wordlist2.end(), out);</div>
<div class=CC1>  *out++ =
<font color=#007f00>&quot;-----------------------------------&quot;</font>;</div>
<div class=CC1>  <font color=#dd0000>// Use a deque&lt;char&gt; as the source:</font></div>
<div class=CC1>  ifstream in2(<font color=#007f00>&quot;TokenIteratorTest.cpp&quot;</font>);</div>
<div class=CC1>  deque&lt;<font color=#ff7700>char</font>&gt; dc;</div>
<div class=CC1>  copy(IsbIt(in2), IsbIt(), back_inserter(dc));</div>
<div class=CC1> 
TokenIterator&lt;deque&lt;<font color=#ff7700>char</font>&gt;::iterator,Delimiters&gt;</div>
<div class=CC1>    dcIter(dc.begin(), dc.end(), delimiters), end3;</div>
<div class=CC1>  vector&lt;string&gt; wordlist3;</div>
<div class=CC1>  copy(dcIter, end3, back_inserter(wordlist3));</div>
<div class=CC1>  copy(wordlist3.begin(), wordlist3.end(), out);</div>
<div class=CC1>  *out++ =
<font color=#007f00>&quot;-----------------------------------&quot;</font>;</div>
<div class=CC1>  <font color=#dd0000>// Reproduce the Wordlist.cpp example:</font></div>
<div class=CC1>  ifstream in3(<font color=#007f00>&quot;TokenIteratorTest.cpp&quot;</font>);</div>
<div class=CC1>  TokenIterator&lt;IsbIt, Delimiters&gt;</div>
<div class=CC1>    wordIter2(IsbIt(in3), isbEnd, delimiters);</div>
<div class=CC1>  set&lt;string&gt; wordlist4;</div>
<div class=CC1>  <font color=#ff7700>while</font>(wordIter2 != end)</div>
<div class=CC1>    wordlist4.insert(*wordIter2++);</div>
<div class=CC1>  copy(wordlist4.begin(), wordlist4.end(), out);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When using an <b>istreambuf_iterator</b>, you create one to
attach to the <b>istream</b> object and one with the default constructor as the
past-the-end marker. Both are used to create the <b>TokenIterator</b> that will
produce the tokens; the default constructor produces the faux <b>TokenIterator</b>
past-the-end sentinel. (This is just a placeholder and is ignored.) The<b>
TokenIterator</b> produces <b>string</b>s that are inserted into a container of
<b>string</b>—here a <b>vector&lt;string&gt;</b> is used in all cases except
the last. (You could also concatenate the results onto a <b>string</b>.) Other
than that, a <b>TokenIterator</b> works like any other input iterator.</p>

<p class=MsoNormal>When defining a bidirectional (and therefore also a random
access) iterator, you can get reverse iterators “for free” by using the <b>std::reverse_iterator
</b>adaptor. If you have already defined an iterator for a container with
bidirectional capabilities, you can get a reverse iterator from your forward-traversing
iterator with lines like the following inside your container class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// Assume &quot;iterator&quot; is your nested iterator type</font></div>
<div class=CC1><font color=#ff7700>typedef</font> std::reverse_iterator&lt;iterator&gt;
reverse_iterator;</div>
<div class=CC1>reverse_iterator rbegin() {return
reverse_iterator(end());</div>
<div class=CC1>reverse_iterator rend() {return
reverse_iterator(begin());</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>std::reverse_iterator</b> adaptor does all the work
for you. For example, if you use the <b>*</b> operator to dereference your
reverse iterator, it automatically decrements a temporary copy of the forward
iterator it is holding in order to return the correct element, since reverse
iterators logically point one position past the element they refer to.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985789" name="_Toc53985789">stack</a></h2>

<p class=MsoNormal>The <b>stack</b> container, along with <b>queue</b> and <b>priority_queue</b>, are classified as <i>adaptors</i>, which means they adapt one of the basic sequence containers to store their data. This is an unfortunate case of
confusing what something does with the details of its underlying
implementation—the fact that these are called “adaptors” is of primary value
only to the creator of the library. When you use them, you generally don’t care
that they’re adaptors, but instead that they solve your problem. Admittedly
it’s useful at times to know that you can choose an alternate implementation or
build an adaptor from an existing container object, but that’s generally one level
removed from the adaptor’s behavior. So, while you may see it emphasized
elsewhere that a particular container is an adaptor, we’ll only point out that
fact when it’s useful. Note that each type of adaptor has a default container
that it’s built upon, and this default is the most sensible implementation. In
most cases you won’t need to concern yourself with the underlying
implementation.</p>

<p class=MsoNormal>The following example shows <b>stack&lt;string&gt;</b>
implemented in the three ways: the default (which uses <b>deque</b>), then with
a <b>vector</b>, and finally with a <b>list</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Stack1.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstrates the STL stack.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stack&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Rearrange comments below to use different versions.</font></div>
<div class=CC1><font color=#ff7700>typedef</font> stack&lt;string&gt; Stack1; <font color=#dd0000>// Default:
deque&lt;string&gt;</font></div>
<div class=CC1><font color=#dd0000>// typedef stack&lt;string, vector&lt;string&gt; &gt;
Stack2;</font></div>
<div class=CC1><font color=#dd0000>// typedef stack&lt;string, list&lt;string&gt; &gt;
Stack3;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Stack1.cpp&quot;</font>);</div>
<div class=CC1>  Stack1 textlines; <font color=#dd0000>// Try the different versions</font></div>
<div class=CC1>  <font color=#dd0000>// Read file and store lines in the stack:</font></div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    textlines.push(line + <font color=#007f00>&quot;\n&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Print lines from the stack and pop them:</font></div>
<div class=CC1>  <font color=#ff7700>while</font>(!textlines.empty()) {</div>
<div class=CC1>    cout &lt;&lt; textlines.top();</div>
<div class=CC1>    textlines.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>top(&nbsp;)</b> and <b>pop(&nbsp;)</b> operations will probably seem non-intuitive if you’ve used other <b>stack</b> classes. When you call <b>pop(&nbsp;)</b>,
it returns <b>void</b> rather than the top element that you might have
expected. If you want the top element, you get a reference to it with <b>top(&nbsp;)</b>.
It turns out this is more efficient, since a traditional <b>pop(&nbsp;)</b> must
return a value rather than a reference and thus invokes the copy-constructor.
More important, it is <i>exception safe</i>, as we discussed in Chapter 1. If <b>pop(&nbsp;)</b>
both changed the state of the stack and attempted to return the top element, an
exception in the element’s copy-constructor could cause the element to be lost.
When you’re using a <b>stack</b> (or a <b>priority_queue</b>, described later),
you can efficiently refer to <b>top(&nbsp;)</b> as many times as you want and
then discard the top element explicitly using <b>pop(&nbsp;)</b>. (Perhaps if
some term other than the familiar “pop” had been used, this would have been a
bit clearer.)</p>

<p class=MsoNormal>The <b>stack</b> template has a simple interface—essentially
the member functions you saw earlier. Since it only makes sense to access a
stack at its top, no iterators are available for traversing it. Nor are there
sophisticated forms of initialization, but if you need that, you can use the
underlying container upon which the <b>stack</b> is implemented. For example,
suppose you have a function that expects a <b>stack</b> interface, but in the
rest of your program you need the objects stored in a <b>list</b>. The
following program stores each line of a file along with the leading number of
spaces in that line. (You might imagine it as a starting point for performing
some kind of source-code reformatting.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Stack2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Converting a list to a stack.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stack&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Expects a stack:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Stk&gt;</div>
<div class=CC1><font color=#ff7700>void</font> stackOut(Stk&amp; s, ostream&amp; os = cout) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(!s.empty()) {</div>
<div class=CC1>    os &lt;&lt; s.top() &lt;&lt; <font color=#007f00>&quot;\n&quot;</font>;</div>
<div class=CC1>    s.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Line {</div>
<div class=CC1>  string line; <font color=#dd0000>// Without leading spaces</font></div>
<div class=CC1>  size_t lspaces; <font color=#dd0000>// Number of leading spaces</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Line(string s) : line(s) {</div>
<div class=CC1>    lspaces = line.find_first_not_of(' ');</div>
<div class=CC1>    <font color=#ff7700>if</font>(lspaces == string::npos)</div>
<div class=CC1>      lspaces = 0;</div>
<div class=CC1>    line = line.substr(lspaces);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Line&amp; l) {</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; l.lspaces; i++)</div>
<div class=CC1>      <span lang=SV>os &lt;&lt; ' ';</span></div>
<div class=CC1><span lang=SV>    <font color=#ff7700>return</font> os &lt;&lt; l.line;</span></div>
<div class=CC1><span lang=SV>  </span>}</div>
<div class=CC1>  <font color=#dd0000>// Other functions here...</font></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Stack2.cpp&quot;</font>);</div>
<div class=CC1>  list&lt;Line&gt; lines;</div>
<div class=CC1>  <font color=#dd0000>// Read file and store lines in the list:</font></div>
<div class=CC1>  string s;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, s))</div>
<div class=CC1>    lines.push_front(s);</div>
<div class=CC1>  <font color=#dd0000>// Turn the list into a stack for printing:</font></div>
<div class=CC1>  stack&lt;Line, list&lt;Line&gt; &gt; stk(lines);</div>
<div class=CC1>  stackOut(stk);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The function that requires the <b>stack</b> interface just
sends each <b>top(&nbsp;)</b> object to an <b>ostream</b> and then removes it
by calling <b>pop(&nbsp;)</b>. The <b>Line</b> class determines the number of
leading spaces and then stores the contents of the line <i>without</i> the
leading spaces. The <b>ostream</b> <b>operator&lt;&lt;</b> re-inserts the
leading spaces so the line prints properly, but you can easily change the
number of spaces by changing the value of <b>lspaces</b>. (The member functions
to do this are not shown here.) In <b>main(&nbsp;)</b>, the input file is read
into a <b>list&lt;Line&gt;</b>, and then each line in the list is copied into a
<b>stack</b> that is sent to <b>stackOut(&nbsp;)</b>.</p>

<p class=MsoNormal>You cannot iterate through a <b>stack</b>; this emphasizes
that you only want to perform <b>stack</b> operations when you create a <b>stack</b>.
You can get equivalent “stack” functionality using a <b>vector</b> and its <b>back(&nbsp;)</b>,
<b>push_back(&nbsp;)</b>, and <b>pop_back(&nbsp;)</b> member functions, and
then you have all the additional functionality of the <b>vector</b>. The
program <b>Stack1.cpp</b> can be rewritten to show this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Stack3.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using a vector as a stack; modified Stack1.cpp.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  ifstream in(<font color=#007f00>&quot;Stack3.cpp&quot;</font>);</div>
<div class=CC1>  vector&lt;string&gt; textlines;</div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(in, line))</div>
<div class=CC1>    textlines.push_back(line + <font color=#007f00>&quot;\n&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>while</font>(!textlines.empty()) {</div>
<div class=CC1>    cout &lt;&lt; textlines.back();</div>
<div class=CC1>    textlines.pop_back();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This produces the same output as <b>Stack1.cpp</b>, but you
can now perform <b>vector</b> operations as well. A <b>list</b> can also push
things at the front, but it’s generally less efficient than using <b>push_back(&nbsp;)</b>
with <b>vector</b>. (In addition, <b>deque</b> is usually more efficient than <b>list</b>
for pushing things at the front.)</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985790" name="_Toc53985790">queue</a></h2>

<p class=MsoNormal>The <b>queue</b> container is a restricted form of a <b>deque</b>—you
can only enter elements at one end and pull them off the other end.
Functionally, you could use a <b>deque</b> anywhere you need a <b>queue</b>,
and you would then also have the additional functionality of the <b>deque</b>.
The only reason you need to use a <b>queue</b> rather than a <b>deque</b>,
then, is when you want to emphasize that you will only be performing queue-like
behavior.</p>

<p class=MsoNormal>The <b>queue</b> class is an adaptor like <b>stack</b>, in
that it is built on top of another sequence container. As you might guess, the
ideal implementation for a <b>queue</b> is a <b>deque</b>, and that is the
default template argument for the <b>queue</b>; you’ll rarely need a different
implementation.</p>

<p class=MsoNormal>Queues are often used if you want to model a system where
some elements are waiting to be served by other elements in the system. A
classic example of this is the “bank-teller problem.” Customers arrive at
random intervals, get into a line, and then are served by a set of tellers.
Since the customers arrive randomly and each takes a random amount of time to
be served, there’s no way to deterministically know how long the line will be
at any time. However, it’s possible to simulate the situation and see what
happens.</p>

<p class=MsoNormal>In a realistic simulation each customer and teller should be
run by a separate thread. What we’d like is a multithreaded environment so that
each customer or teller would have his own thread. However, Standard C++ has no
support for multithreading. On the other hand, with a little adjustment to the
code, it’s possible to simulate enough multithreading to provide a satisfactory
solution.<a href="#_ftn109" name="_ftnref109"><span
class=MsoFootnoteReference>[109]</span></a></p>

<p class=MsoNormal>In multithreading, multiple threads of control run
simultaneously, sharing the same address space. Quite often you have fewer CPUs
than you do threads (and often only one CPU). To give the illusion that each
thread has its own CPU, a <i>time-slicing</i> mechanism says “OK, current
thread, you’ve had enough time. I’m going to stop you and give time to some
other thread.” This automatic stopping and starting of threads is called <i>preemptive,
</i>and it means you (the programmer) don’t need to manage the threading
process.</p>

<p class=MsoNormal>An alternative approach has each thread voluntarily yield
the CPU to the scheduler, which then finds another thread that needs running.
Instead, we’ll build the “time-slicing” into the classes in the system. Here,
it will be the tellers that represent the “threads,” (the customers will be
passive). Each teller will have an infinite-looping <b>run(&nbsp;)</b> member
function that will execute for a certain number of “time units” and then simply
return. By using the ordinary return mechanism, we eliminate the need for any
swapping. The resulting program, although small, provides a remarkably
reasonable simulation:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:BankTeller.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Using a queue and simulated multithreading</font></div>
<div class=CC1><font color=#dd0000>// to model a bank teller system.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Customer {</div>
<div class=CC1>  <font color=#ff7700>int</font> serviceTime;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Customer() : serviceTime(0) {}</div>
<div class=CC1>  Customer(<font color=#ff7700>int</font> tm) : serviceTime(tm) {}</div>
<div class=CC1>  <font color=#ff7700>int</font> getTime() { <font color=#ff7700>return</font> serviceTime; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setTime(<font color=#ff7700>int</font> newtime) { serviceTime = newtime; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Customer&amp;
c) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; '[' &lt;&lt; c.serviceTime
&lt;&lt; ']';</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Teller {</div>
<div class=CC1>  queue&lt;Customer&gt;&amp; customers;</div>
<div class=CC1>  Customer current;</div>
<div class=CC1>  <font color=#ff7700>enum</font> { SLICE = 5 };</div>
<div class=CC1>  <font color=#ff7700>int</font> ttime; <font color=#dd0000>// Time left in slice</font></div>
<div class=CC1>  <font color=#ff7700>bool</font> busy; <font color=#dd0000>// Is teller serving a customer?</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Teller(queue&lt;Customer&gt;&amp; cq)</div>
<div class=CC1>  : customers(cq), ttime(0), busy(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  Teller&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> Teller&amp; rv) {</div>
<div class=CC1>    customers = rv.customers;</div>
<div class=CC1>    current = rv.current;</div>
<div class=CC1>    ttime = rv.ttime;</div>
<div class=CC1>    busy = rv.busy;</div>
<div class=CC1>    <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isBusy() { <font color=#ff7700>return</font> busy; }</div>
<div class=CC1>  <font color=#ff7700>void</font> run(<font color=#ff7700>bool</font> recursion = <font color=#ff7700>false</font>) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(!recursion)</div>
<div class=CC1>      ttime = SLICE;</div>
<div class=CC1>    <font color=#ff7700>int</font> servtime = current.getTime();</div>
<div class=CC1>    <font color=#ff7700>if</font>(servtime &gt; ttime) {</div>
<div class=CC1>      servtime -= ttime;</div>
<div class=CC1>      current.setTime(servtime);</div>
<div class=CC1>      busy = <font color=#ff7700>true</font>; <font color=#dd0000>// Still working on current</font></div>
<div class=CC1>      <font color=#ff7700>return</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>if</font>(servtime &lt; ttime) {</div>
<div class=CC1>      ttime -= servtime;</div>
<div class=CC1>      <font color=#ff7700>if</font>(!customers.empty()) {</div>
<div class=CC1>        current = customers.front();</div>
<div class=CC1>        customers.pop(); <font color=#dd0000>// Remove it</font></div>
<div class=CC1>        busy = <font color=#ff7700>true</font>;</div>
<div class=CC1>        run(<font color=#ff7700>true</font>); <font color=#dd0000>// Recurse</font></div>
<div class=CC1>      }</div>
<div class=CC1>      <font color=#ff7700>return</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>if</font>(servtime == ttime) {</div>
<div class=CC1>      <font color=#dd0000>// Done with current, set to empty:</font></div>
<div class=CC1>      current = Customer(0);</div>
<div class=CC1>      busy = <font color=#ff7700>false</font>;</div>
<div class=CC1>      <font color=#ff7700>return</font>; <font color=#dd0000>// No more time in this slice</font></div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Inherit to access protected implementation:</font></div>
<div class=CC1><font color=#ff7700>class</font> CustomerQ : <font color=#ff7700>public</font> queue&lt;Customer&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
CustomerQ&amp; cd) {</div>
<div class=CC1>    copy(cd.c.begin(), cd.c.end(),</div>
<div class=CC1>      ostream_iterator&lt;Customer&gt;(os,
<font color=#007f00>&quot;&quot;</font>));</div>
<div class=CC1>    <font color=#ff7700>return</font> os;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CustomerQ customers;</div>
<div class=CC1>  list&lt;Teller&gt; tellers;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> list&lt;Teller&gt;::iterator TellIt;</div>
<div class=CC1>  tellers.push_back(Teller(customers));</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  clock_t ticks = clock();</div>
<div class=CC1>  <font color=#dd0000>// Run simulation for at least 5 seconds:</font></div>
<div class=CC1>  <font color=#ff7700>while</font>(clock() &lt; ticks + 5 * CLOCKS_PER_SEC) {</div>
<div class=CC1>    <font color=#dd0000>// Add a random number of customers to the</font></div>
<div class=CC1>    <font color=#dd0000>// queue, with random service times:</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; rand() % 5; i++)</div>
<div class=CC1>      customers.push(Customer(rand() % 15 + 1));</div>
<div class=CC1>    cout &lt;&lt; '{' &lt;&lt; tellers.size() &lt;&lt;
'}'</div>
<div class=CC1>         &lt;&lt; customers &lt;&lt; endl;</div>
<div class=CC1>    <font color=#dd0000>// Have the tellers service the queue:</font></div>
<div class=CC1>    <font color=#ff7700>for</font>(TellIt i = tellers.begin();</div>
<div class=CC1>      i != tellers.end(); i++)</div>
<div class=CC1>      (*i).run();</div>
<div class=CC1>    cout &lt;&lt; '{' &lt;&lt; tellers.size() &lt;&lt;
'}'</div>
<div class=CC1>         &lt;&lt; customers &lt;&lt; endl;</div>
<div class=CC1>    <font color=#dd0000>// If line is too long, add another teller:</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(customers.size() / tellers.size() &gt; 2)</div>
<div class=CC1>      tellers.push_back(Teller(customers));</div>
<div class=CC1>    <font color=#dd0000>// If line is short enough, remove a teller:</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(tellers.size() &gt; 1 &amp;&amp;</div>
<div class=CC1>      customers.size() / tellers.size() &lt; 2)</div>
<div class=CC1>      <font color=#ff7700>for</font>(TellIt i = tellers.begin();</div>
<div class=CC1>        i != tellers.end(); i++)</div>
<div class=CC1>        <font color=#ff7700>if</font>(!(*i).isBusy()) {</div>
<div class=CC1>          tellers.erase(i);</div>
<div class=CC1>          <font color=#ff7700>break</font>; <font color=#dd0000>// Out of for loop</font></div>
<div class=CC1>        }</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each customer requires a certain amount of service time,
which is the number of time units that a teller must spend on the customer to
serve that customer’s needs. The amount of service time will be different for
each customer and will be determined randomly. In addition, you won’t know how
many customers will be arriving in each interval, so this will also be
determined randomly.</p>

<p class=MsoNormal>The <b>Customer </b>objects are kept in a <b>queue&lt;Customer&gt;</b>,
and each <b>Teller</b> object keeps a reference to that queue.<b> </b>When a <b>Teller</b>
object is finished with its current <b>Customer</b> object, that <b>Teller</b>
will get another <b>Customer</b> from the queue and begin working on the new <b>Customer</b>,
reducing the <b>Customer</b>’s service time during each time slice that the <b>Teller</b>
is allotted. All this logic is in the <b>run(&nbsp;)</b> member function, which
is basically a three-way <b>if</b> statement based on whether the amount of
time necessary to serve the customer is less than, greater than, or equal to
the amount of time left in the teller’s current time slice. Notice that if the <b>Teller</b>
has more time after finishing with a <b>Customer</b>, it gets a new customer
and recurses into itself.</p>

<p class=MsoNormal>Just as with a <b>stack</b>, when you use a <b>queue</b>,
it’s only a <b>queue</b> and doesn’t have any of the other functionality of the
basic sequence containers. This includes the ability to get an iterator in
order to step through the <b>stack</b>. However, the underlying sequence
container (that the <b>queue</b> is built upon) is held as a <b>protected</b>
member inside the <b>queue</b>, and the identifier for this member is specified
in the C++ Standard as ‘<b>c</b>’, which means that you can derive from <b>queue</b>
to access the underlying implementation. The <b>CustomerQ</b> class does
exactly that, for the sole purpose of defining an <b>ostream</b> <b>operator&lt;&lt;</b>
that can iterate through the <b>queue</b> and display its members.</p>

<p class=MsoNormal>The driver for the simulation is the <b>while</b> loop in <b>main(&nbsp;)</b>,
which uses processor ticks (defined in <b>&lt;ctime&gt;</b>) to determine if
the simulation has run for at least 5 seconds. At the beginning of each pass
through the loop, a random number of customers is added, with random service
times. Both the number of tellers and the queue contents are displayed so you
can see the state of the system. After running each teller, the display is
repeated. At this point, the system adapts by comparing the number of customers
and the number of tellers. If the line is too long, another teller is added,
and if it is short enough, a teller can be removed. In this adaptation section
of the program you can experiment with policies regarding the optimal addition
and removal of tellers. If this is the only section that you’re modifying, you
might want to encapsulate policies inside different objects.</p>

<p class=MsoNormal>We’ll revisit this example in a multithreaded exercise in
Chapter 11.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985791" name="_Toc53985791">Priority
queues</a></h2>

<p class=MsoNormal>When you <b>push(&nbsp;)</b> an object onto a <b>priority_queue</b>, that object is sorted into the queue according to a comparison function or
function object. (You can allow the default <b>less</b> template to supply
this, or you can provide one of your own.) The <b>priority_queue</b> ensures
that when you look at the <b>top(&nbsp;)</b> element, it will be the one with
the highest priority. When you’re done with it, you call <b>pop(&nbsp;)</b> to
remove it and bring the next one into place. Thus, the <b>priority_queue</b>
has nearly the same interface as a <b>stack</b>, but it behaves differently.</p>

<p class=MsoNormal>Like <b>stack</b> and <b>queue</b>, <b>priority_queue</b> is
an adaptor that is built on top of one of the basic sequences—the default
sequence being <b>vector</b>.</p>

<p class=MsoNormal>It’s trivial to make a <b>priority_queue</b> that works with
<b>int</b>s:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue1.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  priority_queue&lt;<font color=#ff7700>int</font>&gt; pqi;</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This pushes into the <b>priority_queue </b>100 random values
from 0 to 24. When you run this program you’ll see that duplicates are allowed,
and the highest values appear first. To show how you can change the ordering by
providing your own function or function object, the following program gives
lower-valued numbers the highest priority:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Changing the priority.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;functional&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  priority_queue&lt;<font color=#ff7700>int</font>, vector&lt;<font color=#ff7700>int</font>&gt;,
greater&lt;<font color=#ff7700>int</font>&gt; &gt; pqi;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A more interesting problem is a to-do list, where each
object contains a <b>string</b> and a primary and secondary priority value:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue3.cpp</font></div>
<div class=CC1><font color=#dd0000>// A more complex use of priority_queue.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> ToDoItem {</div>
<div class=CC1>  <font color=#ff7700>char</font> primary;</div>
<div class=CC1>  <font color=#ff7700>int</font> secondary;</div>
<div class=CC1>  string item;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  ToDoItem(string td, <font color=#ff7700>char</font> pri = 'A', <font color=#ff7700>int</font> sec = 1)</div>
<div class=CC1>  : primary(pri), secondary(sec), item(td) {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(</div>
<div class=CC1>    <font color=#ff7700>const</font> ToDoItem&amp; x, <font color=#ff7700>const</font> ToDoItem&amp; y) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(x.primary &gt; y.primary)</div>
<div class=CC1>      <font color=#ff7700>return</font> <font color=#ff7700>true</font>;</div>
<div class=CC1>    <font color=#ff7700>if</font>(x.primary == y.primary)</div>
<div class=CC1>      <font color=#ff7700>if</font>(x.secondary &gt; y.secondary)</div>
<div class=CC1>        <font color=#ff7700>return</font> <font color=#ff7700>true</font>;</div>
<div class=CC1>    <font color=#ff7700>return</font> <font color=#ff7700>false</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> ToDoItem&amp;
td) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; td.primary &lt;&lt; td.secondary</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; td.item;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  priority_queue&lt;ToDoItem&gt; toDoList;</div>
<div class=CC1>  toDoList.push(ToDoItem(<font color=#007f00>&quot;Empty trash&quot;</font>, 'C',
4));</div>
<div class=CC1>  toDoList.push(ToDoItem(<font color=#007f00>&quot;Feed dog&quot;</font>, 'A',
2));</div>
<div class=CC1>  toDoList.push(ToDoItem(<font color=#007f00>&quot;Feed bird&quot;</font>, 'B',
7));</div>
<div class=CC1>  toDoList.push(ToDoItem(<font color=#007f00>&quot;Mow lawn&quot;</font>, 'C',
3));</div>
<div class=CC1>  toDoList.push(ToDoItem(<font color=#007f00>&quot;Water lawn&quot;</font>, 'A',
1));</div>
<div class=CC1>  toDoList.push(ToDoItem(<font color=#007f00>&quot;Feed cat&quot;</font>, 'B',
1));</div>
<div class=CC1>  <font color=#ff7700>while</font>(!toDoList.empty()) {</div>
<div class=CC1>    cout &lt;&lt; toDoList.top() &lt;&lt; endl;</div>
<div class=CC1>    toDoList.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>ToDoItem</b>’s <b>operator&lt;</b> must be a
nonmember function for it to work with <b>less&lt; &gt;</b>. Other than that,
everything happens automatically. The output is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>A1: Water lawn</div>
<div class=CC1>A2: Feed dog</div>
<div class=CC1>B1: Feed cat</div>
<div class=CC1>B7: Feed bird</div>
<div class=CC1>C3: Mow lawn</div>
<div class=CC1>C4: Empty trash</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You cannot iterate through a <b>priority_queue</b>, but it’s
possible to simulate the behavior of a <b>priority_queue</b> using a <b>vector</b>,
thus allowing you access to that <b>vector</b>. You can do this by looking at
the implementation of <b>priority_queue</b>, which uses <b>make_heap(&nbsp;)</b>, <b>push_heap(&nbsp;)</b>, and <b>pop_heap(&nbsp;)</b>. (These are the soul of the <b>priority_queue</b>—in fact you could say that the heap <i>is</i> the
priority queue and that <b>priority_queue</b><b> </b>is just a wrapper around it.) This turns out to be reasonably straightforward, but you might think that a
shortcut is possible. Since the container used by <b>priority_queue</b> is <b>protected</b>
(and has the identifier, according to the Standard C++ specification, named <b>c</b>),
you can inherit a new class that provides access to the underlying implementation:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue4.cpp</font></div>
<div class=CC1><font color=#dd0000>// Manipulating the underlying implementation.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> PQI : <font color=#ff7700>public</font> priority_queue&lt;<font color=#ff7700>int</font>&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  vector&lt;<font color=#ff7700>int</font>&gt;&amp; impl() { <font color=#ff7700>return</font> c; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  PQI pqi;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>  copy(pqi.impl().begin(), pqi.impl().end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>However, if you run this program, you’ll discover that the <b>vector</b>
doesn’t contain the items in the descending order that you get when you call <b>pop(&nbsp;)</b>, the order that you want from the priority queue. It would seem
that if you want to create a <b>vector</b> that is a priority queue, you have
to do it by hand, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue5.cpp</font></div>
<div class=CC1><font color=#dd0000>// Building your own priority queue.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> Compare&gt;</div>
<div class=CC1><font color=#ff7700>class</font> PQV : <font color=#ff7700>public</font> vector&lt;T&gt; {</div>
<div class=CC1>  Compare comp;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  PQV(Compare cmp = Compare()) : comp(cmp) {</div>
<div class=CC1>    make_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>const</font> T&amp; top() { <font color=#ff7700>return</font> <font color=#ff7700>this</font>-&gt;front(); }</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; x) {</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;push_back(x);</div>
<div class=CC1>    push_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop() {</div>
<div class=CC1>    pop_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;pop_back();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  PQV&lt; <font color=#ff7700>int</font>, less&lt;<font color=#ff7700>int</font>&gt; &gt; pqi;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>  copy(pqi.begin(), pqi.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>But this program behaves in the same way as the previous
one! What you are seeing in the underlying <b>vector</b> is called a <i>heap</i>.<i>
</i>This heap data structure represents the tree of the priority queue (stored
in the linear structure of the <b>vector</b>), but when you iterate through it,
you do not get a linear priority-queue order. You might think that you can
simply call <b>sort_heap(&nbsp;)</b>, but that only works once, and then you
don’t have a heap anymore, but instead a sorted list. This means that to go
back to using it as a heap, the user must remember to call <b>make_heap(&nbsp;)
</b>first. This can be encapsulated into your custom priority queue:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue6.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> Compare&gt;</div>
<div class=CC1><font color=#ff7700>class</font> PQV : <font color=#ff7700>public</font> vector&lt;T&gt; {</div>
<div class=CC1>  Compare comp;</div>
<div class=CC1>  <font color=#ff7700>bool</font> sorted;</div>
<div class=CC1>  <font color=#ff7700>void</font> assureHeap() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(sorted) {</div>
<div class=CC1>      <font color=#dd0000>// Turn it back into a heap:</font></div>
<div class=CC1>      make_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>      sorted = <font color=#ff7700>false</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  PQV(Compare cmp = Compare()) : comp(cmp) {</div>
<div class=CC1>    make_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>    sorted = <font color=#ff7700>false</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>const</font> T&amp; top() {</div>
<div class=CC1>    assureHeap();</div>
<div class=CC1>    <font color=#ff7700>return</font> <font color=#ff7700>this</font>-&gt;front();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; x) {</div>
<div class=CC1>    assureHeap();</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;push_back(x); <font color=#dd0000>// Put it at the end</font></div>
<div class=CC1>    <font color=#dd0000>// Re-adjust the heap:</font></div>
<div class=CC1>    push_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop() {</div>
<div class=CC1>    assureHeap();</div>
<div class=CC1>    <font color=#dd0000>// Move the top element to the last position:</font></div>
<div class=CC1>    pop_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>    <font color=#ff7700>this</font>-&gt;pop_back();<font color=#dd0000>// Remove that element</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> sort() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(!sorted) {</div>
<div class=CC1>      sort_heap(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end(), comp);</div>
<div class=CC1>      reverse(<font color=#ff7700>this</font>-&gt;begin(),this-&gt;end());</div>
<div class=CC1>      sorted = <font color=#ff7700>true</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  PQV&lt; <font color=#ff7700>int</font>, less&lt;<font color=#ff7700>int</font>&gt; &gt; pqi;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++) {</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>    copy(pqi.begin(), pqi.end(),</div>
<div class=CC1>      ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot;
&quot;</font>));</div>
<div class=CC1>    cout &lt;&lt; &quot;\n-----” &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  pqi.sort();</div>
<div class=CC1>  copy(pqi.begin(), pqi.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If <b>sorted</b> is true, the <b>vector</b> is not organized
as a heap but instead as a sorted sequence. The <b>assureHeap(&nbsp;)</b>
function guarantees that it’s put back into heap form before performing any
heap operations on it. The first <b>for</b> loop in <b>main(&nbsp;)</b> now has
the additional quality that it displays the heap as it is being built.</p>

<p class=MsoNormal>In the previous two programs we had to introduce a seemingly
extraneous usage of the “<b>this-&gt;</b>” prefix. Although some compilers do
not require it, the standard definition of C++ does. Note that the class <b>PQV</b>
derives from <b>vector&lt;T&gt;</b>, therefore <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>,
inherited from <b>vector&lt;T&gt;</b>, are dependent names.<a href="#_ftn110" name="_ftnref110"><span
class=MsoFootnoteReference>[110]</span></a> Compilers can’t
look up names from dependent base classes in the definition of a template (<b>vector</b>,
in this case) because for a given instantiation an explicitly specialized
version of the template might be used that does not have a given member. The
special naming requirement guarantees that you won’t end up calling a base
class member in some cases and possibly a function from an enclosing scope
(such as a global one) in other cases. The compiler has no way of knowing that
a call to <b>begin(&nbsp;)</b> is dependent, so we must give it a clue with a “<b>this&#8209;&gt;</b>”
qualification.<a href="#_ftn111" name="_ftnref111"><span
class=MsoFootnoteReference>[111]</span></a> This
tells the compiler that <b>begin(&nbsp;)</b> is in the scope of <b>PQV</b>, so
it waits until an instance of <b>PQV</b> is fully instantiated. If this
qualifying prefix is left out, the compiler will attempt an early lookup for
the names <b>begin</b> and <b>end</b> (at template definition time, and will
fail to find them because there are no such names declared in enclosing lexical
scopes in this example). In the code above, however, the compiler waits until
the point of instantiation of <b>pqi</b>, and then finds the correct
specializations of <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b> in <b>vector&lt;int&gt;</b>.</p>

<p class=MsoNormal>The only drawback to this solution is that the user must
remember to call <b>sort(&nbsp;) </b>before viewing it as a sorted sequence
(although one could conceivably redefine all the member functions that produce
iterators so that they guarantee sorting). Another solution is to create a
priority queue that is not a <b>vector</b>, but will build you a <b>vector</b>
whenever you want one:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue7.cpp</font></div>
<div class=CC1><font color=#dd0000>// A priority queue that will hand you a vector.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T, <font color=#ff7700>class</font> Compare&gt; <font color=#ff7700>class</font> PQV {</div>
<div class=CC1>  vector&lt;T&gt; v;</div>
<div class=CC1>  Compare comp;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// Don't need to call make_heap(); it's empty:</font></div>
<div class=CC1>  PQV(Compare cmp = Compare()) : comp(cmp) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> push(<font color=#ff7700>const</font> T&amp; x) {</div>
<div class=CC1>    v.push_back(x); <font color=#dd0000>// Put it at the end</font></div>
<div class=CC1>    <font color=#dd0000>// Re-adjust the heap:</font></div>
<div class=CC1>    push_heap(v.begin(), v.end(), comp);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pop() {</div>
<div class=CC1>    <font color=#dd0000>// Move the top element to the last position:</font></div>
<div class=CC1>    pop_heap(v.begin(), v.end(), comp);</div>
<div class=CC1>    v.pop_back(); <font color=#dd0000>// Remove that element</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>const</font> T&amp; top() { <font color=#ff7700>return</font> v.front(); }</div>
<div class=CC1>  <font color=#ff7700>bool</font> empty() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> v.empty(); }</div>
<div class=CC1>  <font color=#ff7700>int</font> size() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> v.size(); }</div>
<div class=CC1>  <font color=#ff7700>typedef</font> vector&lt;T&gt; TVec;</div>
<div class=CC1>  TVec getVector() {</div>
<div class=CC1>    TVec r(v.begin(), v.end());</div>
<div class=CC1>    <font color=#dd0000>// It’s already a heap</font></div>
<div class=CC1>    sort_heap(r.begin(), r.end(), comp);</div>
<div class=CC1>    <font color=#dd0000>// Put it into priority-queue order:</font></div>
<div class=CC1>    reverse(r.begin(), r.end());</div>
<div class=CC1>    <font color=#ff7700>return</font> r;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  PQV&lt;<font color=#ff7700>int</font>, less&lt;<font color=#ff7700>int</font>&gt; &gt; pqi;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>  <font color=#ff7700>const</font> vector&lt;<font color=#ff7700>int</font>&gt;&amp; v = pqi.getVector();</div>
<div class=CC1>  copy(v.begin(), v.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>PQV</b> class template follows the same form as the
STL’s <b>priority_queue</b>, but has the additional member <b>getVector(&nbsp;)</b>,
which creates a new <b>vector</b> that’s a copy of the one in <b>PQV </b>(which
means that it’s already a heap). It then sorts that copy (leaving <b>PQV</b>’s <b>vector</b>
untouched), and reverses the order so that traversing the new <b>vector</b>
produces the same effect as popping the elements from the priority queue.</p>

<p class=MsoNormal>You may observe that the approach of deriving from <b>priority_queue</b>
used in <b>PriorityQueue4.cpp</b> could be used with the above technique to
produce more succinct code:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PriorityQueue8.cpp</font></div>
<div class=CC1><font color=#dd0000>// A more compact version of PriorityQueue7.cpp.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;queue&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> PQV : <font color=#ff7700>public</font>
priority_queue&lt;T&gt; {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>typedef</font> vector&lt;T&gt; TVec;</div>
<div class=CC1>  TVec getVector() {</div>
<div class=CC1>    TVec r(<font color=#ff7700>this</font>-&gt;c.begin(),this-&gt;c.end());</div>
<div class=CC1>    <font color=#dd0000>// c is already a heap</font></div>
<div class=CC1>    sort_heap(r.begin(), r.end(), <font color=#ff7700>this</font>-&gt;comp);</div>
<div class=CC1>    <font color=#dd0000>// Put it into priority-queue order:</font></div>
<div class=CC1>    reverse(r.begin(), r.end());</div>
<div class=CC1>    <font color=#ff7700>return</font> r;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  PQV&lt;<font color=#ff7700>int</font>&gt; pqi;</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    pqi.push(rand() % 25);</div>
<div class=CC1>  <font color=#ff7700>const</font> vector&lt;<font color=#ff7700>int</font>&gt;&amp; v = pqi.getVector();</div>
<div class=CC1>  copy(v.begin(), v.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>while</font>(!pqi.empty()) {</div>
<div class=CC1>    cout &lt;&lt; pqi.top() &lt;&lt; ' ';</div>
<div class=CC1>    pqi.pop();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The brevity of this solution makes it the simplest and most
desirable, plus it’s guaranteed that the user will not have a <b>vector</b> in
the unsorted state. The only potential problem is that the <b>getVector(&nbsp;)</b>
member function returns the <b>vector&lt;T&gt;</b> by value, which might cause
some overhead issues with complex values of the parameter type <b>T</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985792" name="_Toc53985792">Holding
bits</a></h2>

<p class=MsoNormal>Because C is a language that purports to be “close to the
hardware,” many have found it dismaying that there is no native binary
representation for numbers. Decimal, of course, and hexadecimal (tolerable only
because it’s easier to group the bits in your mind), but octal? Ugh. Whenever
you read specs for chips you’re trying to program, they don’t describe the chip
registers in octal or even hexadecimal—they use binary. And yet C won’t let you
say <b>0b0101101</b>, which is the obvious solution for a language close to the
hardware.</p>

<p class=MsoNormal>Although there’s still no native binary representation in
C++, things have improved with the addition of two classes: <b>bitset</b> and <b>vector&lt;bool&gt;</b>, both of which are designed to manipulate a group of
on-off values.<a href="#_ftn112" name="_ftnref112"><span
class=MsoFootnoteReference>[112]</span></a> The
primary differences between these types are:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Each <b>bitset</b> holds a fixed number of bits. You establish
the quantity of bits in the <b>bitset</b> template argument. The <b>vector&lt;bool&gt;</b>
can, like a regular <b>vector</b>, expand dynamically to hold any number of <b>bool</b>
values.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The <b>bitset</b> template is explicitly designed for performance
when manipulating bits, and is not a “regular” STL container. As such, it has
no iterators. The number of bits, being a template parameter, is known at
compile time and allows the underlying integral array to be stored on the
runtime stack. The <b>vector&lt;bool&gt;</b> container, on the other hand, is a
specialization of a <b>vector</b> and so has all the operations of a normal <b>vector</b>—the
specialization is just designed to be space efficient for <b>bool</b>.</p>

<p class=MsoNormal>There is no trivial conversion between a <b>bitset</b> and a
<b>vector&lt;bool&gt;</b>, which implies that the two are for very different
purposes. Furthermore, neither is a traditional “STL container.” The <b>bitset</b>
template class has an interface for bit-level operations and in no way
resembles the STL containers we’ve discussed up to this point. The <b>vector&lt;bool&gt;</b>
specialization of <b>vector</b> is similar to an STL-like container, but it
differs as discussed below.</p>

<h3><a href="#_TocRef53985793" name="_Toc53985793"><span style='font-weight:normal'>bitset&lt;n&gt;</span></a></h3>

<p class=MsoNormal>The template for <b>bitset</b> accepts an unsigned integral
template argument that is the number of bits to represent. Thus, <b>bitset&lt;10&gt;</b>
is a different type than <b>bitset&lt;20&gt;</b>, and you cannot perform
comparisons, assignments, and so on between the two.</p>

<p class=MsoNormal>A <b>bitset</b> provides the most commonly used bitwise
operations in an efficient form. However, each <b>bitset</b> is implemented by
logically packing bits in an array of integral types (typically <b>unsigned</b>
<b>long</b>s, which contain at least 32 bits). In addition, the only conversion
from a <b>bitset</b> to a numerical value is to an <b>unsigned long</b> (via
the function <b>to_ulong(&nbsp;)</b>).</p>

<p class=MsoNormal>The following example tests almost all the functionality of
the <b>bitset</b> (the missing operations are redundant or trivial).<b> </b>You’ll
see the description of each of the bitset outputs to the right of the output so
that the bits all line up and you can compare them to the source values. If you
still don’t understand bitwise operations, running this program should help.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:BitSet.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Exercising the bitset class.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;bitset&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;climits&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 32;</div>
<div class=CC1><font color=#ff7700>typedef</font> bitset&lt;SZ&gt; BS;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> bits&gt; bitset&lt;bits&gt;
randBitset() {</div>
<div class=CC1>  bitset&lt;bits&gt; r(rand());</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; bits/16 - 1; i++) {</div>
<div class=CC1>    r &lt;&lt;= 16;</div>
<div class=CC1>    <font color=#dd0000>// &quot;OR&quot; together with a new lower 16
bits:</font></div>
<div class=CC1>    r |= bitset&lt;bits&gt;(rand());</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> r;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(bitset&lt;16&gt;) = &quot;</font></div>
<div class=CC1>       &lt;&lt; <font color=#ff7700>sizeof</font>(bitset&lt;16&gt;) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(bitset&lt;32&gt;) = &quot;</font></div>
<div class=CC1>       &lt;&lt; <font color=#ff7700>sizeof</font>(bitset&lt;32&gt;) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(bitset&lt;48&gt;) = &quot;</font></div>
<div class=CC1>       &lt;&lt; <font color=#ff7700>sizeof</font>(bitset&lt;48&gt;) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(bitset&lt;64&gt;) = &quot;</font></div>
<div class=CC1>       &lt;&lt; <font color=#ff7700>sizeof</font>(bitset&lt;64&gt;) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(bitset&lt;65&gt;) = &quot;</font></div>
<div class=CC1>       &lt;&lt; <font color=#ff7700>sizeof</font>(bitset&lt;65&gt;) &lt;&lt; endl;</div>
<div class=CC1>  BS a(randBitset&lt;SZ&gt;()), b(randBitset&lt;SZ&gt;());</div>
<div class=CC1>  <font color=#dd0000>// Converting from a bitset:</font></div>
<div class=CC1>  <font color=#ff7700>unsigned</font> <font color=#ff7700>long</font> ul = a.to_ulong();</div>
<div class=CC1>  cout &lt;&lt; a &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Converting a string to a bitset:</font></div>
<div class=CC1>  string cbits(<font color=#007f00>&quot;111011010110111&quot;</font>);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;as a string = &quot;</font> &lt;&lt;
cbits &lt;&lt;endl;</div>
<div class=CC1>  cout &lt;&lt; BS(cbits) &lt;&lt; <font color=#007f00>&quot;
[BS(cbits)]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; BS(cbits, 2) &lt;&lt; <font color=#007f00>&quot; [BS(cbits,
2)]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; BS(cbits, 2, 11) &lt;&lt; <font color=#007f00>&quot; [BS(cbits,
2, 11)]&quot;</font>&lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; a &lt;&lt; <font color=#007f00>&quot; [a]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; b &lt;&lt; <font color=#007f00>&quot; [b]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  <font color=#dd0000>// Bitwise AND:</font></div>
<div class=CC1>  cout &lt;&lt; (a &amp; b) &lt;&lt; <font color=#007f00>&quot; [a &amp;
b]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (BS(a) &amp;= b) &lt;&lt; <font color=#007f00>&quot; [a
&amp;= b]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Bitwise OR:</font></div>
<div class=CC1>  cout &lt;&lt; (a | b) &lt;&lt; <font color=#007f00>&quot; [a | b]&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (BS(a) |= b) &lt;&lt; <font color=#007f00>&quot; [a |=
b]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Exclusive OR:</font></div>
<div class=CC1>  cout &lt;&lt; (a ^ b) &lt;&lt; <font color=#007f00>&quot; [a ^ b]&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (BS(a) ^= b) &lt;&lt; <font color=#007f00>&quot; [a ^=
b]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; a &lt;&lt; <font color=#007f00>&quot; [a]&quot;</font> &lt;&lt;
endl; <font color=#dd0000>// For reference</font></div>
<div class=CC1>  <font color=#dd0000>// Logical left shift (fill with zeros):</font></div>
<div class=CC1>  cout &lt;&lt; (BS(a) &lt;&lt;= SZ/2) &lt;&lt; <font color=#007f00>&quot;
[a &lt;&lt;= (SZ/2)]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (a &lt;&lt; SZ/2) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; a &lt;&lt; <font color=#007f00>&quot; [a]&quot;</font> &lt;&lt;
endl; <font color=#dd0000>// For reference</font></div>
<div class=CC1>  <font color=#dd0000>// Logical right shift (fill with zeros):</font></div>
<div class=CC1>  cout &lt;&lt; (BS(a) &gt;&gt;= SZ/2) &lt;&lt; <font color=#007f00>&quot;
[a &gt;&gt;= (SZ/2)]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (a &gt;&gt; SZ/2) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; a &lt;&lt; <font color=#007f00>&quot; [a]&quot;</font> &lt;&lt;
endl; <font color=#dd0000>// For reference</font></div>
<div class=CC1>  cout &lt;&lt; BS(a).set() &lt;&lt; <font color=#007f00>&quot;
[a.set()]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++)</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>if</font>(!a.test(i)) {</div>
<div class=CC1>      cout &lt;&lt; BS(a).set(i)</div>
<div class=CC1>           &lt;&lt; <font color=#007f00>&quot; [a.set(&quot;</font> &lt;&lt; i
&lt;&lt;<font color=#007f00>&quot;)]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>      <font color=#ff7700>break</font>; <font color=#dd0000>// Just do one example of this</font></div>
<div class=CC1>    }</div>
<div class=CC1>  cout &lt;&lt; BS(a).reset() &lt;&lt; <font color=#007f00>&quot;
[a.reset()]&quot;</font>&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; SZ; j++)</div>
<div class=CC1>    <font color=#ff7700>if</font>(a.test(j)) {</div>
<div class=CC1>      cout &lt;&lt; BS(a).reset(j)</div>
<div class=CC1>           &lt;&lt; <font color=#007f00>&quot; [a.reset(&quot;</font> &lt;&lt; j
&lt;&lt;<font color=#007f00>&quot;)]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>      <font color=#ff7700>break</font>; <font color=#dd0000>// Just do one example of this</font></div>
<div class=CC1>    }</div>
<div class=CC1>  cout &lt;&lt; BS(a).flip() &lt;&lt; <font color=#007f00>&quot;
[a.flip()]&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; ~a &lt;&lt; <font color=#007f00>&quot; [~a]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; a &lt;&lt; <font color=#007f00>&quot; [a]&quot;</font> &lt;&lt;
endl; <font color=#dd0000>// For reference</font></div>
<div class=CC1>  cout &lt;&lt; BS(a).flip(1) &lt;&lt; <font color=#007f00>&quot;
[a.flip(1)]&quot;</font>&lt;&lt; endl;</div>
<div class=CC1>  BS c;</div>
<div class=CC1>  cout &lt;&lt; c &lt;&lt; <font color=#007f00>&quot; [c]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c.count() = &quot;</font> &lt;&lt;
c.count() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c.any() = &quot;</font></div>
<div class=CC1>       &lt;&lt; (c.any() ? <font color=#007f00>&quot;true&quot;</font> :
<font color=#007f00>&quot;false&quot;</font>) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c.none() = &quot;</font></div>
<div class=CC1>       &lt;&lt; (c.none() ? <font color=#007f00>&quot;true&quot;</font> :
<font color=#007f00>&quot;false&quot;</font>) &lt;&lt; endl;</div>
<div class=CC1>  c[1].flip(); c[2].flip();</div>
<div class=CC1>  cout &lt;&lt; c &lt;&lt; <font color=#007f00>&quot; [c]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c.count() = &quot;</font> &lt;&lt;
c.count() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c.any() = &quot;</font></div>
<div class=CC1>       &lt;&lt; (c.any() ? <font color=#007f00>&quot;true&quot;</font> :
<font color=#007f00>&quot;false&quot;</font>) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;c.none() = &quot;</font></div>
<div class=CC1>       &lt;&lt; (c.none() ? <font color=#007f00>&quot;true&quot;</font> :
<font color=#007f00>&quot;false&quot;</font>) &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Array indexing operations:</font></div>
<div class=CC1>  c.reset();</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t k = 0; k &lt; c.size(); k++)</div>
<div class=CC1>    <font color=#ff7700>if</font>(k % 2 == 0)</div>
<div class=CC1>      c[k].flip();</div>
<div class=CC1>  cout &lt;&lt; c &lt;&lt; <font color=#007f00>&quot; [c]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  c.reset();</div>
<div class=CC1>  <font color=#dd0000>// Assignment to bool:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t ii = 0; ii &lt; c.size(); ii++)</div>
<div class=CC1>    c[ii] = (rand() % 100) &lt; 25;</div>
<div class=CC1>  cout &lt;&lt; c &lt;&lt; <font color=#007f00>&quot; [c]&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  <font color=#dd0000>// bool test:</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(c[1])</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;c[1] == true&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;c[1] == false&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To generate interesting random <b>bitset</b>s, the <b>randBitset(&nbsp;)</b>
function is created. This function demonstrates <b>operator&lt;&lt;=</b> by
shifting each 16 random bits to the left until the <b>bitset</b> (which is
templatized in this function for size) is full. The generated number and each
new 16 bits are combined using the <b>operator|=</b>.</p>

<p class=MsoNormal>The <b>main(&nbsp;)</b> function first shows the unit size
of a <b>bitset</b>. If it is less than 32 bits, <b>sizeof</b> produces 4 (4
bytes = 32 bits), which is the size of a single <b>long</b> on most implementations.
If it’s between 32 and 64, it requires two <b>long</b>s, greater than 64
requires 3 <b>long</b>s, and so on. Thus, you make the best use of space if you
use a bit quantity that fits in an integral number of <b>long</b>s. However,
notice there’s no extra overhead for the object—it’s as if you were hand-coding
for a <b>long</b>.</p>

<p class=MsoNormal>Although there are no other numerical conversions from <b>bitset</b>
besides <b>to_ulong(&nbsp;)</b>, there is a <b>stream inserter </b>that
produces a <b>string</b> containing ones and zeros, and this can be as long as
the actual <b>bitset</b>.</p>

<p class=MsoNormal>There’s still no primitive format for binary values, but <b>bitset</b>
supports the next best thing: a <b>string</b> of ones and zeros with the
least-significant bit (lsb) on the right. The three constructors demonstrated take
the entire <b>string</b>, the <b>string</b> starting at character 2, and the
string from character 2 through 11. You can write to an <b>ostream</b> from a <b>bitset</b>
using <b>operator&lt;&lt;</b>,<b> </b>and it comes out as ones and zeros. You
can also read from an <b>istream</b> using <b>operator&gt;&gt;</b> (not shown
here).</p>

<p class=MsoNormal>You’ll notice that <b>bitset</b> only has three nonmember
operators: <i>and</i> (<b>&amp;</b>), <i>or</i> (<b>|</b>), and <i>exclusive-or</i>
(<b>^</b>). Each of these creates a new <b>bitset </b>as its return value. All
the member operators opt for the more efficient <b>&amp;=</b>, <b>|=</b>, and
so on, where a temporary is not created. However, these forms change the <b>bitset</b>’s
value (which is <b>a</b> in most of the tests in the above example). To prevent
this, we created a temporary to be used as the lvalue by invoking the
copy-constructor on <b>a</b>; this is why you see the form <b>BS(a)</b>. The
result of each test is displayed, and occasionally <b>a</b> is reprinted so you
can easily look at it for reference.</p>

<p class=MsoNormal>The rest of the example should be self-explanatory when you
run it; if not you can find the details in your compiler’s documentation or in
the other documentation mentioned earlier in this chapter.</p>

<h3><a href="#_TocRef53985794" name="_Toc53985794">vector&lt;bool&gt;</a></h3>

<p class=MsoNormal>The <b>vector&lt;bool&gt;</b> container is a specialization of the <b>vector</b> template. A normal <b>bool</b> variable requires at least one byte,
but since a <b>bool</b> only has two states, the ideal implementation of <b>vector&lt;bool&gt;</b>
is such that each <b>bool</b> value only requires one bit. Since typical
library implementations pack the bits into integral arrays, the iterator must
be specially defined and cannot be a pointer to <b>bool</b>.</p>

<p class=MsoNormal>The bit-manipulation functions for <b>vector&lt;bool&gt;</b>
are much more limited than those of <b>bitset</b>. The only member function
that was added to those already in <b>vector</b> is <b>flip(&nbsp;)</b>, to
invert all the bits. There is no <b>set(&nbsp;)</b> or <b>reset(&nbsp;)</b> as
in <b>bitset</b>. When you use <b>operator[&nbsp;]</b>, you get back an object
of type <b>vector&lt;bool&gt;::reference</b>, which also has a <b>flip(&nbsp;)</b>
to invert that individual bit.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:VectorOfBool.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstrate the vector&lt;bool&gt; specialization.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;bitset&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;<font color=#ff7700>bool</font>&gt; vb(10, <font color=#ff7700>true</font>);</div>
<div class=CC1>  vector&lt;<font color=#ff7700>bool</font>&gt;::iterator it;</div>
<div class=CC1>  <font color=#ff7700>for</font>(it = vb.begin(); it != vb.end(); it++)</div>
<div class=CC1>    cout &lt;&lt; *it;</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  vb.push_back(<font color=#ff7700>false</font>);</div>
<div class=CC1>  ostream_iterator&lt;<font color=#ff7700>bool</font>&gt; out(cout, <font color=#007f00>&quot;&quot;</font>);</div>
<div class=CC1>  copy(vb.begin(), vb.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>bool</font> ab[] = { <font color=#ff7700>true</font>, <font color=#ff7700>false</font>, <font color=#ff7700>false</font>, <font color=#ff7700>true</font>, <font color=#ff7700>true</font>,</div>
<div class=CC1>    <font color=#ff7700>true</font>, <font color=#ff7700>true</font>, <font color=#ff7700>false</font>, <font color=#ff7700>false</font>, <font color=#ff7700>true</font> };</div>
<div class=CC1>  <font color=#dd0000>// There's a similar constructor:</font></div>
<div class=CC1>  vb.assign(ab, ab + <font color=#ff7700>sizeof</font>(ab)/sizeof(<font color=#ff7700>bool</font>));</div>
<div class=CC1>  copy(vb.begin(), vb.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  vb.flip(); <font color=#dd0000>// Flip all bits</font></div>
<div class=CC1>  copy(vb.begin(), vb.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; vb.size(); i++)</div>
<div class=CC1>    vb[i] = 0; <font color=#dd0000>// (Equivalent to &quot;false&quot;)</font></div>
<div class=CC1>  vb[4] = <font color=#ff7700>true</font>;</div>
<div class=CC1>  vb[5] = 1;</div>
<div class=CC1>  vb[7].flip(); <font color=#dd0000>// Invert one bit</font></div>
<div class=CC1>  copy(vb.begin(), vb.end(), out);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Convert to a bitset:</font></div>
<div class=CC1>  ostringstream os;</div>
<div class=CC1>  copy(vb.begin(), vb.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>bool</font>&gt;(os, <font color=#007f00>&quot;&quot;</font>));</div>
<div class=CC1>  bitset&lt;10&gt; bs(os.str());</div>
<div class=CC1>  cout &lt;&lt; &quot;Bitset:” &lt;&lt; endl &lt;&lt;
bs &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The last part of this example takes a <b>vector&lt;bool&gt;</b>
and converts it to a <b>bitset</b> by first turning it into a <b>string</b> of
ones and zeros. Here, you must know the size of the <b>bitset</b> at compile
time. You can see that this conversion is not the kind of operation you’ll want
to do on a regular basis.</p>

<p class=MsoNormal>The <b>vector&lt;bool&gt;</b> specialization is a “crippled”
STL container in the sense that certain guarantees that other containers
provide are missing. For example, with the other containers the following
relationships hold:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>// Let c be an STL container other than
vector&lt;bool&gt;:</font></div>
<div class=CC1>T&amp; r = c.front();</div>
<div class=CC1>T* p = &amp;*c.begin();</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>For all other containers, the <b>front(&nbsp;)</b> function
yields an lvalue (something you can get a non-const reference to), and <b>begin(&nbsp;)</b>
must yield something you can dereference and then take the address of. Neither
is possible because bits are not addressable. Both <b>vector&lt;bool&gt;</b>
and <b>bitset</b> use a proxy class (the nested <b>reference</b> class,
mentioned earlier) to read and set bits as necessary.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985795" name="_Toc53985795">Associative
containers</a></h2>

<p class=MsoNormal>The <b>set</b>, <b>map</b>, <b>multiset</b>, and <b>multimap</b>
are called <i>associative containers</i> because they associate <i>keys</i>
with <i>values</i>. Well, at least <b>map</b>s and <b>multimap</b>s associate
keys with values, but you can look at a <b>set</b> as a <b>map</b> that has no
values, only keys (and they can in fact be implemented this way), and the same
for the relationship between <b>multiset</b> and <b>multimap</b>. So, because
of the structural similarity, <b>set</b>s and <b>multiset</b>s are lumped in
with associative containers.</p>

<p class=MsoNormal>The most important basic operations with associative
containers are putting things in and, in the case of a <b>set</b>, seeing if
something is in the set. In the case of a <b>map</b>, you want to first see if
a key is in the <b>map</b>, and if it exists, you want the associated value for
that key. There are many variations on this theme, but that’s the fundamental
concept. The following example shows these basics:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:AssociativeBasics.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Basic operations with sets and maps.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Noisy na[7];</div>
<div class=CC1>  <font color=#dd0000>// Add elements via constructor:</font></div>
<div class=CC1>  set&lt;Noisy&gt; ns(na, na + <font color=#ff7700>sizeof</font>
na/sizeof(Noisy));</div>
<div class=CC1>  Noisy n;</div>
<div class=CC1>  ns.insert(n); <font color=#dd0000>// Ordinary insertion</font></div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Check for set membership:</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;ns.count(n)= &quot;</font> &lt;&lt;
ns.count(n) &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>if</font>(ns.find(n) != ns.end())</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;n(&quot;</font> &lt;&lt; n &lt;&lt;
<font color=#007f00>&quot;) found in ns&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Print elements:</font></div>
<div class=CC1>  copy(ns.begin(), ns.end(),</div>
<div class=CC1>    ostream_iterator&lt;Noisy&gt;(cout, <font color=#007f00>&quot;
&quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  map&lt;<font color=#ff7700>int</font>, Noisy&gt; nm;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 10; i++)</div>
<div class=CC1>    nm[i]; <font color=#dd0000>// Automatically makes pairs</font></div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t j = 0; j &lt; nm.size(); j++)</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;nm[&quot;</font> &lt;&lt; j
&lt;&lt;<font color=#007f00>&quot;] = &quot;</font> &lt;&lt; nm[j] &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  nm[10] = n;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  nm.insert(make_pair(47, n));</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;\n nm.count(10)= &quot;</font> &lt;&lt;
nm.count(10) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;nm.count(11)= &quot;</font> &lt;&lt;
nm.count(11) &lt;&lt; endl;</div>
<div class=CC1>  map&lt;<font color=#ff7700>int</font>, Noisy&gt;::iterator it = nm.find(6);</div>
<div class=CC1>  <font color=#ff7700>if</font>(it != nm.end())</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;value:&quot;</font> &lt;&lt;
(*it).second</div>
<div class=CC1>         &lt;&lt; <font color=#007f00>&quot; found in nm at location
6&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>for</font>(it = nm.begin(); it != nm.end(); it++)</div>
<div class=CC1>    cout &lt;&lt; (*it).first &lt;&lt; <font color=#007f00>&quot;:&quot;</font>
&lt;&lt; (*it).second &lt;&lt; <font color=#007f00>&quot;, &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n-----------” &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>set&lt;Noisy&gt;</b> object <b>ns</b> is created
using two iterators into an array of <b>Noisy</b> objects, but there is also a
default constructor and a copy-constructor, and you can pass in an object that
provides an alternate scheme for doing comparisons. Both <b>set</b>s and <b>map</b>s
have an <b>insert(&nbsp;)</b> member function to put things in, and you can
check to see if an object is already in an associative container in two ways.
The <b>count(&nbsp;) </b>member function, when given a key, will tell you how
many times that key occurs. (This can only be zero or one in a <b>set</b> or <b>map</b>,
but it can be more than one with a <b>multiset</b> or <b>multimap</b>.) The <b>find(&nbsp;)</b>
member function will produce an iterator indicating the first occurrence (with <b>set</b>
and <b>map</b>, the <i>only</i> occurrence) of the key that you give it or will
produce the past-the-end iterator if it can’t find the key. The <b>count(&nbsp;)</b>
and <b>find(&nbsp;)</b> member functions exist for all the associative
containers, which makes sense. The associative containers also have member
functions <b>lower_bound(&nbsp;)</b>, <b>upper_bound(&nbsp;)</b>, and <b>equal_range(&nbsp;)</b>,
which only make sense for <b>multiset</b> and <b>multimap</b>, as you will see.
(But don’t try to figure out how they would be useful for <b>set</b> and <b>map</b>,
since they are designed for dealing with a range of duplicate keys, which those
containers don’t allow.)</p>

<p class=MsoNormal>Designing an <b>operator[&nbsp;]</b> always presents a bit
of a dilemma. Because it’s intended to be treated as an array-indexing
operation, people don’t tend to think about performing a test before they use
it. But what happens if you decide to index out of the bounds of the array? One
option is to throw an exception, but with a <b>map</b>, “indexing out of the
array” could mean that you want to create a new entry at that location, and
that’s the way the STL <b>map</b> treats it. The first <b>for</b> loop after
the creation of the <b>map&lt;int</b>,<b> Noisy&gt; nm</b> just “looks up”
objects using the <b>operator[&nbsp;]</b>, but this is actually creating new <b>Noisy</b>
objects! The <b>map</b> creates a new key-value pair (using the default
constructor for the value) if you look up a value with <b>operator[&nbsp;]</b>
and it isn’t there. This means that if you really just want to look something
up and not create a new entry, you must use the member functions <b>count(&nbsp;)</b>
(to see if it’s there) or <b>find(&nbsp;)</b> (to get an iterator to it).</p>

<p class=MsoNormal>A number of problems are associated with the <b>for</b> loop
that prints the values of the container using <b>operator[&nbsp;]</b>. First,
it requires integral keys (which we happen to have here). Next and worse, if
all the keys are not sequential, you’ll end up counting from zero to the size
of the container, and if some spots don’t have key-value pairs, you’ll
automatically create them and miss some of the higher values of the keys.
Finally, if you look at the output from the <b>for</b> loop, you’ll see that
things are <i>very</i> busy, and it’s quite puzzling at first why there are so
many constructions and destructions for what appears to be a simple lookup. The
answer only becomes clear when you look at the code in the <b>map</b> template
for <b>operator[&nbsp;]</b>, which will be something like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>mapped_type&amp; <font color=#ff7700>operator</font>[] (<font color=#ff7700>const</font> key_type&amp; k) {</div>
<div class=CC1>  value_type tmp(k,T());</div>
<div class=CC1>  <font color=#ff7700>return</font> (*((insert(tmp)).first)).second;</div>
<div class=CC1>}</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>map::insert(&nbsp;)</b> function takes a key-value
pair and does nothing if there is already an entry in the map with the given
key—otherwise it inserts an entry for the key. In either case, it returns a new
key-value pair holding an iterator to the inserted pair as its first element
and holding true as the second element if an insertion took place. The members <b>first</b>
and <b>second</b> give the key and value, respectively, because <b>map::value_type</b>
is really just a <b>typedef</b> for a <b>std::pair</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typedef</font> pair&lt;<font color=#ff7700>const</font> Key, T&gt; value_type;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You’ve seen the <b>std::pair</b> template before. It’s a
simple holder for two values of independent types, as you can see by its
definition:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T1, <font color=#ff7700>class</font> T2&gt; <font color=#ff7700>struct</font> pair {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> T1 first_type;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> T2 second_type;</div>
<div class=CC1>  T1 first;</div>
<div class=CC1>  T2 second;</div>
<div class=CC1>  pair();</div>
<div class=CC1>  pair(<font color=#ff7700>const</font> T1&amp; x, <font color=#ff7700>const</font> T2&amp; y) : first(x),
second(y) {}</div>
<div class=CC1>  <font color=#dd0000>// Templatized copy-constructor:</font></div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> U, <font color=#ff7700>class</font> V&gt; pair(<font color=#ff7700>const</font>
pair&lt;U, V&gt; &amp;p);</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>pair</b> template class is very useful, especially
when you want to return two objects from a function (since a <b>return</b>
statement only takes one object). There’s even a shorthand for creating a pair
called <b>make_pair(&nbsp;)</b>, which is used in <b>AssociativeBasics.cpp</b>.</p>

<p class=MsoNormal>So to retrace the steps, <b>map::value_type</b> is a <b>pair</b>
of the key and the value of the map—actually, it’s a single entry for the map.
But notice that <b>pair</b> packages its objects by value, which means that
copy-constructions are necessary to get the objects into the <b>pair</b>. Thus,
the creation of <b>tmp</b> in <b>map::operator[&nbsp;]</b> will involve at
least a copy-constructor call and destructor call for each object in the <b>pair</b>.
Here, we’re getting off easy because the key is an <b>int</b>. But if you want
to really see what kind of activity can result from <b>map::operator[&nbsp;]</b>,
try running this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:NoisyMap.cpp</font></div>
<div class=CC1><font color=#dd0000>// Mapping Noisy to Noisy.</font></div>
<div class=CC1><font color=#dd0000>//{L} Noisy</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Noisy.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  map&lt;Noisy, Noisy&gt; mnn;</div>
<div class=CC1>  Noisy n1, n2;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n--------” &lt;&lt; endl;</div>
<div class=CC1>  mnn[n1] = n2;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n--------” &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; mnn[n1] &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; &quot;\n--------” &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You’ll see that both the insertion and lookup generate a lot
of extra objects, and that’s because of the creation of the <b>tmp</b> object.
If you look back up at <b>map::operator[&nbsp;]</b>, you’ll see that the second
line calls <b>insert(&nbsp;)</b>, passing it <b>tmp</b>—that is, <b>operator[&nbsp;]</b>
does an insertion every time. The return value of <b>insert(&nbsp;)</b> is a
different kind of <b>pair</b>, where <b>first</b> is an iterator pointing to
the key-value <b>pair</b> that was just inserted, and <b>second</b> is a <b>bool</b>
indicating whether the insertion took place. You can see that <b>operator[&nbsp;]</b>
grabs <b>first</b> (the iterator), dereferences it to produce the <b>pair</b>,
and then returns the <b>second</b>, which is the value at that location.</p>

<p class=MsoNormal>So on the upside, <b>map</b> has this fancy “make a new
entry if one isn’t there” behavior, but the downside is that you <i>always</i>
get a lot of extra object creations and destructions when you use <b>map::operator[&nbsp;]</b>.
Fortunately, <b>AssociativeBasics.cpp</b> also demonstrates how to reduce the
overhead of insertions and deletions, by avoiding <b>operator[&nbsp;]</b> if
you don’t need it. The <b>insert(&nbsp;)</b> member function is slightly more
efficient than <b>operator[&nbsp;]</b>. With a <b>set</b>, you hold only one
object, but with a <b>map</b>, you hold key-value pairs; so <b>insert(&nbsp;)</b>
requires a <b>pair</b> as its argument. Here’s where <b>make_pair(&nbsp;)</b>
comes in handy, as you can see.</p>

<p class=MsoNormal>For looking objects up in a <b>map</b>, you can use <b>count(&nbsp;)</b>
to see whether a key is in the map, or you can use <b>find(&nbsp;)</b> to
produce an iterator pointing directly at the key-value pair. Again, since the <b>map</b>
contains <b>pair</b>s, that’s what the iterator produces when you dereference
it, so you have to select <b>first</b> and <b>second</b>. When you run <b>AssociativeBasics.cpp</b>,
you’ll notice that the iterator approach involves no extra object creations or
destructions. It’s not as easy to write or read, though.</p>

<h3><a href="#_TocRef53985796" name="_Toc53985796">Generators and fillers<br>
for associative containers</a></h3>

<p class=MsoNormal>You’ve seen how useful the <b>fill(&nbsp;)</b>, <b>fill_n(&nbsp;)</b>,
<b>generate(&nbsp;)</b>, and <b>generate_n(&nbsp;)</b> function templates in <b>&lt;algorithm&gt;</b>
have been for filling the sequential containers (<b>vector</b>, <b>list</b>,
and <b>deque</b>) with data. However, these are implemented by using <b>operator=
</b>to assign values into the sequential containers, and the way that you add
objects to associative containers is with their respective <b>insert(&nbsp;)</b>
member functions. Thus, the default “assignment” behavior causes a problem when
trying to use the “fill” and “generate” functions with associative containers.</p>

<p class=MsoNormal>One solution is to duplicate the “fill” and “generate”
functions, creating new ones that can be used with associative containers. It
turns out that only the <b>fill_n(&nbsp;)</b> and <b>generate_n(&nbsp;)</b>
functions can be duplicated (<b>fill(&nbsp;) </b>and <b>generate(&nbsp;) </b>copy
sequences, which doesn’t make sense with associative containers), but the job
is fairly easy, since you have the <b>&lt;algorithm&gt;</b> header file to work
from:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:assocGen.h</font></div>
<div class=CC1><font color=#dd0000>// The fill_n() and generate_n() equivalents</font></div>
<div class=CC1><font color=#dd0000>// for associative containers.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef ASSOCGEN_H</font></div>
<div class=CC1><font color=#7F7F00>#define ASSOCGEN_H</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Assoc, <font color=#ff7700>class</font> Count, <font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> assocFill_n(Assoc&amp; a, Count n, <font color=#ff7700>const</font> T&amp;
val) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(n-- &gt; 0)</div>
<div class=CC1>    a.insert(val);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Assoc, <font color=#ff7700>class</font> Count, <font color=#ff7700>class</font> Gen&gt;</div>
<div class=CC1><font color=#ff7700>void</font> assocGen_n(Assoc&amp; a, Count n, Gen g) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(n-- &gt; 0)</div>
<div class=CC1>    a.insert(g());</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// ASSOCGEN_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that instead of using iterators, the container
class itself is passed (by reference, of course).</p>

<p class=MsoNormal>This code demonstrates two valuable lessons. The first is
that if the algorithms don’t do what you want, copy the nearest thing and
modify it. You have the example at hand in the STL header, so most of the work
has already been done.</p>

<p class=MsoNormal>The second lesson is more pointed: if you look long enough,
there’s probably a way to do it in the STL <i>without</i> inventing anything
new. The present problem can instead be solved by using an <b>insert_iterator</b>
(produced by a call to <b>inserter(&nbsp;)</b>), which calls <b>insert(&nbsp;)</b>
to place items in the container instead of <b>operator=</b>. This is <i>not</i>
simply a variation of <b>front_insert_iterator</b> or <b>back_insert_iterator</b>
because those iterators use <b>push_front(&nbsp;)</b> and <b>push_back(&nbsp;)</b>,
respectively. Each of the insert iterators is different by virtue of the member
function it uses for insertion, and <b>insert(&nbsp;)</b> is the one we need.
Here’s a demonstration that shows filling and generating both a <b>map</b> and
a <b>set</b>. (It can also be used with <b>multimap</b> and <b>multiset</b>.)
First, some templatized generators are created. (This may seem like overkill,
but you never know when you’ll need them. For that reason they’re placed in a
header file.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:SimpleGenerators.h</font></div>
<div class=CC1><font color=#dd0000>// Generic generators, including one that creates pairs.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;utility&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A generator that increments its value:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T&gt; <font color=#ff7700>class</font> IncrGen {</div>
<div class=CC1>  T i;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  IncrGen(T ii) : i(ii) {}</div>
<div class=CC1>  T <font color=#ff7700>operator</font>()() { <font color=#ff7700>return</font> i++; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A generator that produces an STL pair&lt;&gt;:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> T1, <font color=#ff7700>typename</font> T2&gt; <font color=#ff7700>class</font> PairGen
{</div>
<div class=CC1>  T1 i;</div>
<div class=CC1>  T2 j;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  PairGen(T1 ii, T2 jj) : i(ii), j(jj) {}</div>
<div class=CC1>  std::pair&lt;T1,T2&gt; <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>return</font> std::pair&lt;T1,T2&gt;(i++, j++);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>namespace</font> std {</div>
<div class=CC1><font color=#dd0000>// A generic global operator&lt;&lt; for printing any
STL pair&lt;&gt;:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> F, <font color=#ff7700>typename</font> S&gt; ostream&amp;</div>
<div class=CC1><font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
pair&lt;F,S&gt;&amp; p) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; p.first &lt;&lt; <font color=#007f00>&quot;\t&quot;</font>
&lt;&lt; p.second &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Both generators expect that <b>T</b> can be incremented, and
they simply use <b>operator++</b> to generate new values from whatever you used
for initialization. <b>PairGen</b> creates an STL <b>pair</b> object as its
return value, and that’s what can be placed into a <b>map</b> or <b>multimap</b>
using <b>insert(&nbsp;)</b>.</p>

<p class=MsoNormal>The last function is a generalization of <b>operator&lt;&lt;</b>
for <b>ostream</b>s, so that any <b>pair</b> can be printed, assuming each
element of the <b>pair </b>supports a stream <b>operator&lt;&lt;</b>. (It is in
namespace <b>std</b> for the strange name lookup reasons discussed in Chapter 5,
and explained once again after <b>Thesaurus.cpp</b> later on in this chapter.)
As you can see in the following, this allows the use of <b>copy(&nbsp;)</b> to
output the <b>map</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:AssocInserter.cpp</font></div>
<div class=CC1><font color=#dd0000>// Using an insert_iterator so fill_n() and generate_n()</font></div>
<div class=CC1><font color=#dd0000>// can be used with associative containers.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;SimpleGenerators.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  set&lt;<font color=#ff7700>int</font>&gt; s;</div>
<div class=CC1>  fill_n(inserter(s, s.begin()), 10, 47);</div>
<div class=CC1>  generate_n(inserter(s, s.begin()), 10,</div>
<div class=CC1>    IncrGen&lt;<font color=#ff7700>int</font>&gt;(12));</div>
<div class=CC1>  copy(s.begin(), s.end(),</div>
<div class=CC1>    ostream_iterator&lt;<font color=#ff7700>int</font>&gt;(cout, <font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>  map&lt;<font color=#ff7700>int</font>, <font color=#ff7700>int</font>&gt; m;</div>
<div class=CC1>  fill_n(inserter(m, m.begin()), 10,
make_pair(90,120));</div>
<div class=CC1>  generate_n(inserter(m, m.begin()), 10,</div>
<div class=CC1>    PairGen&lt;<font color=#ff7700>int</font>, <font color=#ff7700>int</font>&gt;(3, 9));</div>
<div class=CC1>  copy(m.begin(), m.end(),</div>
<div class=CC1>    ostream_iterator&lt;pair&lt;<font color=#ff7700>int</font>,int&gt;
&gt;(cout,<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The second argument to <b>inserter</b> is an iterator, which
is an optimization hint to help the insertion go faster (instead of always
starting the search at the root of the underlying tree). Since an <b>insert_iterator</b>
can be used with many different types of containers, with non-associative
containers it is more than a hint—it is required.</p>

<p class=MsoNormal>Note how the <b>ostream_iterator</b> is created to output a <b>pair</b>.
This won’t work if the <b>operator&lt;&lt;</b> isn’t created. Since it’s a
template, it is automatically instantiated for <b>pair&lt;int, int&gt;</b>.</p>

<h3><a href="#_TocRef53985797" name="_Toc53985797">The magic of maps</a></h3>

<p class=MsoNormal>An ordinary array uses an integral value to index into a
sequential set of elements of some type. A <b>map</b> is an <i>associative array</i>, which means you associate one object with another in an array-like
fashion. Instead of selecting an array element with a number as you do with an
ordinary array, you look it up with an object! The example that follows counts
the words in a text file, so the index is the <b>string</b> object representing
the word, and the value being looked up is the object that keeps count of the
strings.</p>

<p class=MsoNormal>In a single-item container such as a <b>vector</b> or a <b>list</b>,
only one thing is being held. But in a <b>map</b>, you’ve got two things: the <i>key</i> (what you look up by, as in <b>mapname[key]</b>) and the <i>value</i>
that results from the lookup with the key. If you simply want to move through
the entire <b>map</b> and list each key-value pair, you use an iterator, which
when dereferenced produces a <b>pair</b> object containing both the key and the
value. You access the members of a <b>pair</b> by selecting <b>first</b> or <b>second</b>.</p>

<p class=MsoNormal>This same philosophy of packaging two items together is also
used to insert elements into the map, but the <b>pair</b> is created as part of
the instantiated <b>map</b> and is called <b>value_type</b>, containing the key
and the value. So one option for inserting a new element is to create a <b>value_type</b>
object, loading it with the appropriate objects and then calling the <b>insert(&nbsp;)</b>
member function for the <b>map</b>. Instead, the following example uses the
aforementioned special feature of <b>map</b>: if you’re trying to find an
object by passing in a key to <b>operator[&nbsp;]</b> and that object doesn’t
exist, <b>operator[&nbsp;]</b> will automatically insert a new key-value pair
for you, using the default constructor for the value object. With that in mind,
consider an implementation of a word-counting program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:WordCount.cpp</font></div>
<div class=CC1><font color=#dd0000>// Count occurrences of words using a map.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> map&lt;string, <font color=#ff7700>int</font>&gt; WordMap;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> WordMap::iterator WMIter;</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname = <font color=#007f00>&quot;WordCount.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  WordMap wordmap;</div>
<div class=CC1>  string word;</div>
<div class=CC1>  <font color=#ff7700>while</font>(in &gt;&gt; word)</div>
<div class=CC1>    wordmap[word]++;</div>
<div class=CC1>  <font color=#ff7700>for</font>(WMIter w = wordmap.begin(); w != wordmap.end();
w++)</div>
<div class=CC1>    cout &lt;&lt; w-&gt;first &lt;&lt; <font color=#007f00>&quot;: &quot;</font>
&lt;&lt; w-&gt;second &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example shows the power of <i>zero-initialization</i>. Consider this line of code from the program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>wordmap[word]++;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This expression increments the <b>int</b> associated with <b>word</b>.
If there isn’t such a word in the map, a key-value pair for the word is
automatically inserted, with the value initialized to zero by a call to the
pseudo-constructor <b>int(&nbsp;)</b>, which returns a 0.</p>

<p class=MsoNormal>Printing the entire list requires traversing it with an
iterator. (There’s no <b>copy(&nbsp;)</b> shortcut for a <b>map</b> unless you
want to write an <b>operator&lt;&lt; </b>for the <b>pair</b> in the map.) As
previously mentioned, dereferencing this iterator produces a <b>pair</b>
object, with the <b>first</b> member the key and the <b>second</b> member the
value.</p>

<p class=MsoNormal>If you want to find the count for a particular word, you can
use the array index operator, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>cout &lt;&lt; <font color=#007f00>&quot;the: &quot;</font> &lt;&lt; wordmap[<font color=#007f00>&quot;the&quot;</font>] &lt;&lt;
endl;</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that one of the great advantages of the <b>map</b>
is the clarity of the syntax; an associative array makes intuitive sense to the
reader. (Note, however, that if “the” isn’t already in the <b>wordmap</b>, a
new entry will be created!)</p>

<h3><a href="#_TocRef53985798" name="_Toc53985798">Multimaps and duplicate
keys</a></h3>

<p class=MsoNormal>A <b>multimap</b> is a <b>map</b> that can contain duplicate
keys. At first this may seem like a strange idea, but it can occur surprisingly
often. A phone book, for example, can have many entries with the same name.</p>

<p class=MsoNormal>Suppose you are monitoring wildlife, and you want to keep
track of where and when each type of animal is spotted. Thus, you may see many
animals of the same kind, all in different locations and at different times. So
if the type of animal is the key, you’ll need a <b>multimap</b>. Here’s what it
looks like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:WildLifeMonitor.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DataPoint {</div>
<div class=CC1>  <font color=#ff7700>int</font> x, y; <font color=#dd0000>// Location coordinates</font></div>
<div class=CC1>  time_t time; <font color=#dd0000>// Time of Sighting</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DataPoint() : x(0), y(0), time(0) {}</div>
<div class=CC1>  DataPoint(<font color=#ff7700>int</font> xx, <font color=#ff7700>int</font> yy, time_t tm) :</div>
<div class=CC1>    x(xx), y(yy), time(tm) {}</div>
<div class=CC1>  <font color=#dd0000>// Synthesized operator=, copy-constructor OK</font></div>
<div class=CC1>  <font color=#ff7700>int</font> getX() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> x; }</div>
<div class=CC1>  <font color=#ff7700>int</font> getY() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> y; }</div>
<div class=CC1>  <font color=#ff7700>const</font> time_t* getTime() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> &amp;time; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string animal[] = {</div>
<div class=CC1>  <font color=#007f00>&quot;chipmunk&quot;</font>, <font color=#007f00>&quot;beaver&quot;</font>,
<font color=#007f00>&quot;marmot&quot;</font>, <font color=#007f00>&quot;weasel&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;squirrel&quot;</font>, <font color=#007f00>&quot;ptarmigan&quot;</font>,
<font color=#007f00>&quot;bear&quot;</font>, <font color=#007f00>&quot;eagle&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;hawk&quot;</font>, <font color=#007f00>&quot;vole&quot;</font>, <font color=#007f00>&quot;deer&quot;</font>,
<font color=#007f00>&quot;otter&quot;</font>, <font color=#007f00>&quot;hummingbird&quot;</font>,</div>
<div class=CC1>};</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>int</font> ASZ = <font color=#ff7700>sizeof</font> animal/sizeof *animal;</div>
<div class=CC1>vector&lt;string&gt; animals(animal, animal + ASZ);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// All the information is contained in a</font></div>
<div class=CC1><font color=#dd0000>// &quot;Sighting,&quot; which can be sent to an
ostream:</font></div>
<div class=CC1><font color=#ff7700>typedef</font> pair&lt;string, DataPoint&gt; Sighting;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp;</div>
<div class=CC1><font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Sighting&amp;
s) {</div>
<div class=CC1>  <font color=#ff7700>return</font> os &lt;&lt; s.first &lt;&lt; <font color=#007f00>&quot; sighted at
x= &quot;</font></div>
<div class=CC1>    &lt;&lt; s.second.getX() &lt;&lt; <font color=#007f00>&quot;, y= &quot;</font>
&lt;&lt; s.second.getY()</div>
<div class=CC1>    &lt;&lt; <font color=#007f00>&quot;, time = &quot;</font> &lt;&lt;
ctime(s.second.getTime());</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A generator for Sightings:</font></div>
<div class=CC1><font color=#ff7700>class</font> SightingGen {</div>
<div class=CC1>  vector&lt;string&gt;&amp; animals;</div>
<div class=CC1>  <font color=#ff7700>enum</font> { D = 100 };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  SightingGen(vector&lt;string&gt;&amp; an) :
animals(an) {}</div>
<div class=CC1>  Sighting <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    Sighting result;</div>
<div class=CC1>    <font color=#ff7700>int</font> select = rand() % animals.size();</div>
<div class=CC1>    result.first = animals[select];</div>
<div class=CC1>    result.second = DataPoint(</div>
<div class=CC1>      rand() % D, rand() % D, time(0));</div>
<div class=CC1>    <font color=#ff7700>return</font> result;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Display a menu of animals, allow the user to</font></div>
<div class=CC1><font color=#dd0000>// select one, return the index value:</font></div>
<div class=CC1><font color=#ff7700>int</font> menu() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;select an animal or 'q' to quit:
&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; animals.size(); i++)</div>
<div class=CC1>    cout &lt;&lt;'['&lt;&lt; i &lt;&lt;']'&lt;&lt;
animals[i] &lt;&lt; ' ';</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>  string reply;</div>
<div class=CC1>  cin &gt;&gt; reply;</div>
<div class=CC1>  <font color=#ff7700>if</font>(reply.at(0) == 'q') <font color=#ff7700>return</font> 0;</div>
<div class=CC1>  istringstream r(reply);</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1>  r &gt;&gt; i; <font color=#dd0000>// Converts to int</font></div>
<div class=CC1>  i %= animals.size();</div>
<div class=CC1>  <font color=#ff7700>return</font> i;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> multimap&lt;string, DataPoint&gt; DataMap;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> DataMap::iterator DMIter;</div>
<div class=CC1>  DataMap sightings;</div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate_n(inserter(sightings, sightings.begin()),</div>
<div class=CC1>    50, SightingGen(animals));</div>
<div class=CC1>  <font color=#dd0000>// Print everything:</font></div>
<div class=CC1>  copy(sightings.begin(), sightings.end(),</div>
<div class=CC1>    ostream_iterator&lt;Sighting&gt;(cout,
<font color=#007f00>&quot;&quot;</font>));</div>
<div class=CC1>  <font color=#dd0000>// Print sightings for selected animal:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> count = 1; count &lt; 10; count++) {</div>
<div class=CC1>    <font color=#dd0000>// Use menu to get selection:</font></div>
<div class=CC1>    <font color=#dd0000>// int i = menu();</font></div>
<div class=CC1>    <font color=#dd0000>// Generate randomly (for automated testing):</font></div>
<div class=CC1>    <font color=#ff7700>int</font> i = rand() % animals.size();</div>
<div class=CC1>    <font color=#dd0000>// Iterators in &quot;range&quot; denote begin, one</font></div>
<div class=CC1>    <font color=#dd0000>// past end of matching range:</font></div>
<div class=CC1>    pair&lt;DMIter, DMIter&gt; range =</div>
<div class=CC1>      sightings.equal_range(animals[i]);</div>
<div class=CC1>    copy(range.first, range.second,</div>
<div class=CC1>      ostream_iterator&lt;Sighting&gt;(cout,
<font color=#007f00>&quot;&quot;</font>));</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>All the data about a sighting is encapsulated into the class
<b>DataPoint</b>, which is simple enough that it can rely on the synthesized
assignment and copy-constructor. It uses the Standard C library time functions
to record the time of the sighting.</p>

<p class=MsoNormal>In the array of <b>string</b>, <b>animal</b>, notice that
the <b>char*</b> constructor is automatically used during initialization, which
makes initializing an array of <b>string</b> quite convenient. Since it’s
easier to use the animal names in a <b>vector</b>, the length of the array is
calculated, and a <b>vector&lt;string&gt;</b> is initialized using the <b>vector(iterator,
iterator)</b> constructor.</p>

<p class=MsoNormal>The key-value pairs that make up a <b>Sighting</b> are the <b>string</b>,
which names the type of animal, and the <b>DataPoint</b>, which says where and
when it was sighted. The standard <b>pair</b> template combines these two types
and is typedefed to produce the <b>Sighting</b> type. Then an <b>ostream</b> <b>operator&lt;&lt;</b>
is created for <b>Sighting</b>; this will allow you to iterate through a <b>map</b>
or <b>multimap</b> of <b>Sighting</b>s<b> </b>and display it.</p>

<p class=MsoNormal><b>SightingGen</b> generates random sightings at random data
points to use for testing. It has the usual <b>operator(&nbsp;)</b> necessary
for a function object, but it also has a constructor to capture and store a
reference to a <b>vector&lt;string&gt;</b>, which is where the aforementioned
animal names are stored.</p>

<p class=MsoNormal>A <b>DataMap</b> is a <b>multimap</b> of <b>string</b>-<b>DataPoint</b>
pairs, which means it stores <b>Sighting</b>s. It is filled with 50 <b>Sighting</b>s
using <b>generate_n(&nbsp;)</b> and displayed. (Notice that because there is an
<b>operator&lt;&lt;</b> that takes a <b>Sighting</b>, an <b>ostream_iterator</b>
can be created.) At this point the user is asked to select the animal for which
they want to see all the sightings. If you press <b>q</b>, the program will
quit, but if you select an animal number, the <b>equal_range(&nbsp;)</b> member
function is invoked. This returns an iterator (<b>DMIter</b>) to the beginning
of the set of matching pairs and an iterator indicating past-the-end of the
set. Since only one object can be returned from a function, <b>equal_range(&nbsp;)</b>
makes use of <b>pair</b>. Since the <b>range</b> pair has the beginning and
ending iterators of the matching set, those iterators can be used in <b>copy(&nbsp;)</b>
to print all the sightings for a particular type of animal.</p>

<h3><a href="#_TocRef53985799" name="_Toc53985799">Multisets</a></h3>

<p class=MsoNormal>You’ve seen the <b>set</b>, which allows only one object of
each value to be inserted. The <b>multiset</b> is odd by comparison since it allows more than one object of each value to be inserted. This seems to go against the whole
idea of “setness,” where you can ask, “Is ‘it’ in this set?” If there can be
more than one “it,” what does that question mean?</p>

<p class=MsoNormal>With some thought, you can see that it makes little sense to
have more than one object of the same value in a set if those duplicate objects
are <i>exactly</i> the same (with the possible exception of counting
occurrences of objects, but as seen earlier in this chapter that can be handled
in an alternative, more elegant fashion). Thus, each duplicate object will have
something that makes it “different” from the other duplicates—most likely
different state information that is not used in the calculation of the key
during the comparison. That is, to the comparison operation, the objects look
the same, but they contain some differing internal state.</p>

<p class=MsoNormal>Like any STL container that must order its elements, the <b>multiset</b>
template uses the <b>less</b> function object by default to determine element
ordering. This uses the contained class’s <b>operator&lt;</b>, but you can always
substitute your own comparison function.</p>

<p class=MsoNormal>Consider a simple class that contains one element that is
used in the comparison and another that is not:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:MultiSet1.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstration of multiset behavior.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> X {</div>
<div class=CC1>  <font color=#ff7700>char</font> c; <font color=#dd0000>// Used in comparison</font></div>
<div class=CC1>  <font color=#ff7700>int</font> i; <font color=#dd0000>// Not used in comparison</font></div>
<div class=CC1>  <font color=#dd0000>// Don't need default constructor and operator=</font></div>
<div class=CC1>  X();</div>
<div class=CC1>  X&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> X&amp;);</div>
<div class=CC1>  <font color=#dd0000>// Usually need a copy-constructor (but the</font></div>
<div class=CC1>  <font color=#dd0000>// synthesized version works here)</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <span lang=SV>X(<font color=#ff7700>char</font> cc, <font color=#ff7700>int</font> ii) : c(cc), i(ii) {}</span></div>
<div class=CC1><span lang=SV>  </span><font color=#dd0000>// Notice no operator== is
required</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> X&amp; x, <font color=#ff7700>const</font> X&amp;
y) {</div>
<div class=CC1>    <font color=#ff7700>return</font> x.c &lt; y.c;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
X x) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; x.c &lt;&lt; <font color=#007f00>&quot;:&quot;</font>
&lt;&lt; x.i;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Xgen {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> i;</div>
<div class=CC1>  <font color=#dd0000>// Number of characters to select from:</font></div>
<div class=CC1>  <font color=#ff7700>enum</font> { SPAN = 6 };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  X <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>char</font> c = 'A' + rand() % SPAN;</div>
<div class=CC1>    <font color=#ff7700>return</font> X(c, i++);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Xgen::i = 0;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> multiset&lt;X&gt; Xmset;</div>
<div class=CC1><font color=#ff7700>typedef</font> Xmset::const_iterator Xmit;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Xmset mset;</div>
<div class=CC1>  <font color=#dd0000>// Fill it with X's:</font></div>
<div class=CC1>  srand(time(0));  <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  generate_n(inserter(mset, mset.begin()), 25, Xgen());</div>
<div class=CC1>  <font color=#dd0000>// Initialize a regular set from mset:</font></div>
<div class=CC1>  set&lt;X&gt; unique(mset.begin(), mset.end());</div>
<div class=CC1>  copy(unique.begin(), unique.end(),</div>
<div class=CC1>    ostream_iterator&lt;X&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  cout &lt;&lt; &quot;\n----” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Iterate over the unique values:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(set&lt;X&gt;::iterator i = unique.begin();</div>
<div class=CC1>      i != unique.end(); i++) {</div>
<div class=CC1>    pair&lt;Xmit, Xmit&gt; p = mset.equal_range(*i);</div>
<div class=CC1>    copy(p.first,p.second,
ostream_iterator&lt;X&gt;(cout, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>    cout &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In <b>X</b>, all the comparisons are made with the <b>char c</b>.
The comparison is performed with <b>operator&lt;</b>, which is all that is
necessary for the <b>multiset</b>, since in this example the default <b>less</b>
comparison object is used. The class <b>Xgen</b> randomly generates <b>X</b>
objects, but the comparison value is restricted to the span from <b>‘A</b>’ to
‘<b>E</b>’. In <b>main(&nbsp;)</b>, a <b>multiset&lt;X&gt;</b> is created and
filled with 25 <b>X</b> objects using <b>Xgen</b>, guaranteeing that there will
be duplicate keys. So that we know what the unique values are, a regular <b>set&lt;X&gt;</b>
is created from the <b>multiset</b> (using the <b>iterator, iterator</b>
constructor). These values are displayed, and then each one produces the <b>equal_range(&nbsp;)</b>
in the <b>multiset</b> (<b>equal_range(&nbsp;)</b> has the same meaning here as
it does with <b>multimap</b>: all the elements with matching keys). Each set of
matching keys is then printed.</p>

<p class=MsoNormal>As a second example, a (possibly) more elegant version of <b>WordCount.cpp</b>
can be created using <b>multiset</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:MultiSetWordCount.cpp</font></div>
<div class=CC1><font color=#dd0000>// Count occurrences of words using a multiset.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../require.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* fname =
<font color=#007f00>&quot;MultiSetWordCount.cpp&quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &gt; 1) fname = argv[1];</div>
<div class=CC1>  ifstream in(fname);</div>
<div class=CC1>  assure(in, fname);</div>
<div class=CC1>  multiset&lt;string&gt; wordmset;</div>
<div class=CC1>  string word;</div>
<div class=CC1>  <font color=#ff7700>while</font>(in &gt;&gt; word)</div>
<div class=CC1>    wordmset.insert(word);</div>
<div class=CC1>  <font color=#ff7700>typedef</font> multiset&lt;string&gt;::iterator MSit;</div>
<div class=CC1>  MSit it = wordmset.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != wordmset.end()) {</div>
<div class=CC1>    pair&lt;MSit, MSit&gt; p = wordmset.equal_range(*it);</div>
<div class=CC1>    <font color=#ff7700>int</font> count = distance(p.first, p.second);</div>
<div class=CC1>    cout &lt;&lt; *it &lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt;
count &lt;&lt; endl;</div>
<div class=CC1>    it = p.second; <font color=#dd0000>// Move to the next word</font></div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The setup in <b>main(&nbsp;)</b> is identical to <b>WordCount.cpp</b>,
but then each word is simply inserted into the <b>multiset&lt;string&gt;</b>.
An iterator is created and initialized to the beginning of the <b>multiset</b>;
dereferencing this iterator produces the current word. The <b>equal_range(&nbsp;)</b>
member function (not generic algorithm) produces the starting and ending
iterators of the word that’s currently selected, and the algorithm <b>distance(&nbsp;)</b>
(defined in <b>&lt;iterator&gt;</b>) counts the number of elements in that
range. The iterator <b>it </b>is then moved forward to the end of the range,
which puts it at the next word. If you’re unfamiliar with the <b>multiset</b>,
this code can seem more complex. The density of it and the lack of need for
supporting classes such as <b>Count</b> has a lot of appeal.</p>

<p class=MsoNormal>In the end, is this really a “set,” or should it be called
something else? An alternative is the generic “bag” that is defined in some
container libraries, since a bag holds anything, without
discrimination—including duplicate objects. This is close, but it doesn’t quite
fit since a bag has no specification about how elements should be ordered. A <b>multiset</b>
(which requires that all duplicate elements be adjacent to each other) is even
more restrictive than the concept of a set. A set implementation might use a
hashing function to order its elements, which would not put them in sorted
order. Besides, if you want to store a bunch of objects without any special
criteria, you will probably just use a <b>vector</b>, <b>deque</b>, or <b>list</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985800" name="_Toc53985800">Combining
STL containers</a></h2>

<p class=MsoNormal>When using a thesaurus, you want to know all the words that
are similar to a particular word. When you look up a word, then, you want a
list of words as the result. Here, the “multi” containers (<b>multimap</b> or <b>multiset</b>)
are not appropriate. The solution is to combine containers, which is easily
done using the STL. Here, we need a tool that turns out to be a powerful
general concept, which is a <b>map</b> that associates a string with a <b>vector</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Thesaurus.cpp</font></div>
<div class=CC1><font color=#dd0000>// A map of vectors.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> map&lt;string, vector&lt;string&gt; &gt;
Thesaurus;</div>
<div class=CC1><font color=#ff7700>typedef</font> pair&lt;string, vector&lt;string&gt; &gt;
TEntry;</div>
<div class=CC1><font color=#ff7700>typedef</font> Thesaurus::iterator TIter;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Name lookup work-around:</font></div>
<div class=CC1><font color=#ff7700>namespace</font> std {</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,const
TEntry&amp; t) {</div>
<div class=CC1>  os &lt;&lt; t.first &lt;&lt; <font color=#007f00>&quot;: &quot;</font>;</div>
<div class=CC1>  copy(t.second.begin(), t.second.end(),</div>
<div class=CC1>    ostream_iterator&lt;string&gt;(os, <font color=#007f00>&quot; &quot;</font>));</div>
<div class=CC1>  <font color=#ff7700>return</font> os;</div>
<div class=CC1>}</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A generator for thesaurus test entries:</font></div>
<div class=CC1><font color=#ff7700>class</font> ThesaurusGen {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>const</font> string letters;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>int</font> maxSize() { <font color=#ff7700>return</font> letters.size(); }</div>
<div class=CC1>  TEntry <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    TEntry result;</div>
<div class=CC1>    <font color=#ff7700>if</font>(count &gt;= maxSize()) count = 0;</div>
<div class=CC1>    result.first = letters[count++];</div>
<div class=CC1>    <font color=#ff7700>int</font> entries = (rand() % 5) + 2;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; entries; i++) {</div>
<div class=CC1>      <font color=#ff7700>int</font> choice = rand() % maxSize();</div>
<div class=CC1>      <font color=#ff7700>char</font> cbuf[2] = { 0 };</div>
<div class=CC1>      cbuf[0] = letters[choice];</div>
<div class=CC1>      result.second.push_back(cbuf);</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>return</font> result;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> ThesaurusGen::count = 0;</div>
<div class=CC1><font color=#ff7700>const</font> string ThesaurusGen::letters(<font color=#007f00>&quot;ABCDEFGHIJKL&quot;</font></div>
<div class=CC1> 
<font color=#007f00>&quot;MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</font>);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Ask for a &quot;word&quot; to look up:</font></div>
<div class=CC1>string menu(Thesaurus&amp; thesaurus) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(<font color=#ff7700>true</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Select a \&quot;word\&quot;, 0
to quit: &quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>for</font>(TIter it = thesaurus.begin();</div>
<div class=CC1>        it != thesaurus.end(); it++)</div>
<div class=CC1>      cout &lt;&lt; (*it).first &lt;&lt; ' ';</div>
<div class=CC1>    cout &lt;&lt; endl;</div>
<div class=CC1>    string reply;</div>
<div class=CC1>    cin &gt;&gt; reply;</div>
<div class=CC1>    <font color=#ff7700>if</font>(reply.at(0) == '0') exit(0); <font color=#dd0000>// Quit</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(thesaurus.find(reply) == thesaurus.end())</div>
<div class=CC1>      <font color=#ff7700>continue</font>; <font color=#dd0000>// Not in list, try again</font></div>
<div class=CC1>    <font color=#ff7700>return</font> reply;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  Thesaurus thesaurus;</div>
<div class=CC1>  <font color=#dd0000>// Fill with 10 entries:</font></div>
<div class=CC1>  generate_n(inserter(thesaurus, thesaurus.begin()),</div>
<div class=CC1>    10, ThesaurusGen());</div>
<div class=CC1>  <font color=#dd0000>// Print everything:</font></div>
<div class=CC1>  copy(thesaurus.begin(), thesaurus.end(),</div>
<div class=CC1>    ostream_iterator&lt;TEntry&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>));</div>
<div class=CC1>  <font color=#dd0000>// Create a list of the keys:</font></div>
<div class=CC1>  string keys[10];</div>
<div class=CC1>  <font color=#ff7700>int</font> i = 0;</div>
<div class=CC1>  <font color=#ff7700>for</font>(TIter it = thesaurus.begin();</div>
<div class=CC1>    it != thesaurus.end(); it++)</div>
<div class=CC1>    keys[i++] = (*it).first;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> count = 0; count &lt; 10; count++) {</div>
<div class=CC1>    <font color=#dd0000>// Enter from the console:</font></div>
<div class=CC1>    <font color=#dd0000>// string reply = menu(thesaurus);</font></div>
<div class=CC1>    <font color=#dd0000>// Generate randomly</font></div>
<div class=CC1>    string reply = keys[rand() % 10];</div>
<div class=CC1>    vector&lt;string&gt;&amp; v = thesaurus[reply];</div>
<div class=CC1>    copy(v.begin(), v.end(),</div>
<div class=CC1>      ostream_iterator&lt;string&gt;(cout, <font color=#007f00>&quot;
&quot;</font>));</div>
<div class=CC1>    cout &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A <b>Thesaurus</b> maps a <b>string</b> (the word) to a <b>vector&lt;string&gt;</b>
(the synonyms). A <b>TEntry </b>is a single entry in a <b>Thesaurus</b>. By
creating an <b>ostream operator&lt;&lt;</b> for a <b>TEntry</b>, a single entry
from the <b>Thesaurus</b> can easily be printed (and the whole <b>Thesaurus</b>
can easily be printed with <b>copy(&nbsp;)</b>). Notice the very strange placement
of the stream inserter: we put it inside the <b>std</b> namespace!<a href="#_ftn113" name="_ftnref113"><span
class=MsoFootnoteReference>[113]</span></a> This <b>operator&lt;&lt;(&nbsp;)</b>
function is used by <b>ostream_iterator</b> in the first call to <b>copy(&nbsp;)</b>
in <b>main(&nbsp;)</b> above. When the compiler instantiates the needed <b>ostream_iterator</b>
specialization, according to the rules of argument-dependent lookup (ADL) it
only looks in <b>std</b> because that is where all the arguments to <b>copy(&nbsp;)</b>
are declared. If we declared our inserter in the global namespace (by removing
the namespace block around it), then it would not be found. By placing it in <b>std</b>
we enable ADL to find it.</p>

<p class=MsoNormal>The <b>ThesaurusGen</b> creates “words” (which are just
single letters) and “synonyms” for those words (which are just other randomly
chosen single letters) to be used as thesaurus entries. It randomly chooses the
number of synonym entries to make, but there must be at least two. All the
letters are chosen by indexing into a <b>static string</b> that is part of <b>ThesaurusGen</b>.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, a <b>Thesaurus</b> is created,
filled with 10 entries and printed using the <b>copy(&nbsp;)</b> algorithm. The
<b>menu(&nbsp;)</b> function asks the user to choose a “word” to look up by
typing the letter of that word. The <b>find(&nbsp;)</b> member function discovers
whether the entry exists in the <b>map</b>. (Remember, you don’t want to use <b>operator[&nbsp;]</b>,
which will automatically make a new entry if it doesn’t find a match!) If so, <b>operator[&nbsp;]</b>
fetches out the <b>vector&lt;string&gt;</b> that is displayed. The selection of
the <b>reply</b> string is generated randomly, to allow automated testing.</p>

<p class=MsoNormal>Because templates make the expression of powerful concepts
easy, you can take this concept much further, creating a <b>map</b> of <b>vector</b>s
containing <b>map</b>s, and so on. For that matter, you can combine any of the
STL containers this way.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985801" name="_Toc53985801">Cleaning
up<br>
containers of pointers</a></h2>

<p class=MsoNormal>In <b>Stlshape.cpp</b>, the pointers did not clean
themselves up automatically. It would be convenient to be able to do this
easily, rather than writing out the code each time. Here is a function template
that will clean up the pointers in any sequence container. Note that it is
placed in the book’s root directory for easy access:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: :purge.h</font></div>
<div class=CC1><font color=#dd0000>// Delete pointers in an STL sequence container.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef PURGE_H</font></div>
<div class=CC1><font color=#7F7F00>#define PURGE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Seq&gt; <font color=#ff7700>void</font> purge(Seq&amp; c) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Seq::iterator i;</div>
<div class=CC1>  <font color=#ff7700>for</font>(i = c.begin(); i != c.end(); ++i) {</div>
<div class=CC1>    <font color=#ff7700>delete</font> *i;</div>
<div class=CC1>    *i = 0;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Iterator version:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> InpIt&gt; <font color=#ff7700>void</font> purge(InpIt begin,
InpIt end) {</div>
<div class=CC1>  <font color=#ff7700>while</font>(begin != end) {</div>
<div class=CC1>    <font color=#ff7700>delete</font> *begin;</div>
<div class=CC1>    *begin = 0;</div>
<div class=CC1>    ++begin;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// PURGE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In the first version of <b>purge(&nbsp;)</b>, note that <b>typename</b>
is absolutely necessary. This is exactly the case that keyword was designed to
solve: <b>Seq</b> is a template argument, and <b>iterator</b> is something that
is nested within that template. So what does <b>Seq::iterator</b> refer to? The
<b>typename</b> keyword specifies that it refers to a type, and not something
else.</p>

<p class=MsoNormal>Although the container version of <b>purge(&nbsp;)</b> must
work with an STL-style container, the iterator version of <b>purge(&nbsp;)</b>
will work with any range, including an array.</p>

<p class=MsoNormal>Here is a rewrite of <b>Stlshape.cpp</b>, modified to use
the <b>purge(&nbsp;)</b> function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Stlshape2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Stlshape.cpp with the purge() function.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Shape() {};</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Circle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Circle::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Circle() { cout &lt;&lt; &quot;~Circle” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Triangle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Triangle::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Triangle() { cout &lt;&lt; &quot;~Triangle” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Square : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Square::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Square() { cout &lt;&lt; &quot;~Square” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> std::vector&lt;Shape*&gt; Container;</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Container::iterator Iter;</div>
<div class=CC1>  Container shapes;</div>
<div class=CC1>  shapes.push_back(<font color=#ff7700>new</font> Circle);</div>
<div class=CC1>  shapes.push_back(<font color=#ff7700>new</font> Square);</div>
<div class=CC1>  shapes.push_back(<font color=#ff7700>new</font> Triangle);</div>
<div class=CC1>  <font color=#ff7700>for</font>(Iter i = shapes.begin(); i != shapes.end(); i++)</div>
<div class=CC1>    (*i)-&gt;draw();</div>
<div class=CC1>  purge(shapes);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When using <b>purge(&nbsp;)</b>, carefully consider
ownership issues. If an object pointer is held in more than one container, be
sure not to delete it twice, and you don’t want to destroy the object in the
first container before the second one is finished with it. Purging the same
container twice is not a problem because <b>purge(&nbsp;)</b> sets the pointer
to zero once it deletes that pointer, and calling <b>delete</b> for a zero
pointer is a safe operation.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985802" name="_Toc53985802">Creating
your own containers</a></h2>

<p class=MsoNormal>With the STL as a foundation, you can create your own
containers. Assuming you follow the same model of providing iterators, your new
container will behave as if it were a built-in STL container.</p>

<p class=MsoNormal>Consider the “ring” data structure, which is a circular
sequence container. If you reach the end, it just wraps around to the
beginning. This can be implemented on top of a <b>list</b> as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Ring.cpp</font></div>
<div class=CC1><font color=#dd0000>// Making a &quot;ring&quot; data structure from the
STL.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;list&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Ring {</div>
<div class=CC1>  list&lt;T&gt; lst;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// Declaration necessary so the following</font></div>
<div class=CC1>  <font color=#dd0000>// 'friend' statement sees this 'iterator'</font></div>
<div class=CC1>  <font color=#dd0000>// instead of std::iterator:</font></div>
<div class=CC1>  <font color=#ff7700>class</font> iterator;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> iterator;</div>
<div class=CC1>  <font color=#ff7700>class</font> iterator : <font color=#ff7700>public</font> std::iterator&lt;</div>
<div class=CC1>    std::bidirectional_iterator_tag,T,ptrdiff_t&gt;{</div>
<div class=CC1>    <font color=#ff7700>typename</font> list&lt;T&gt;::iterator it;</div>
<div class=CC1>    list&lt;T&gt;* r;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    iterator(list&lt;T&gt;&amp; lst,</div>
<div class=CC1>      <font color=#ff7700>const</font> <font color=#ff7700>typename</font> list&lt;T&gt;::iterator&amp; i)</div>
<div class=CC1>    : it(i), r(&amp;lst) {}</div>
<div class=CC1>    <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> iterator&amp; x) <font color=#ff7700>const</font> {</div>
<div class=CC1>      <font color=#ff7700>return</font> it == x.it;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font> iterator&amp; x) <font color=#ff7700>const</font> {</div>
<div class=CC1>      <font color=#ff7700>return</font> !(*<font color=#ff7700>this</font> == x);</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>typename</font> list&lt;T&gt;::reference <font color=#ff7700>operator</font>*() <font color=#ff7700>const</font>
{</div>
<div class=CC1>      <font color=#ff7700>return</font> *it;</div>
<div class=CC1>    }</div>
<div class=CC1>    iterator&amp; <font color=#ff7700>operator</font>++() {</div>
<div class=CC1>      ++it;</div>
<div class=CC1>      <font color=#ff7700>if</font>(it == r-&gt;end())</div>
<div class=CC1>        it = r-&gt;begin();</div>
<div class=CC1>      <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    iterator <font color=#ff7700>operator</font>++(<font color=#ff7700>int</font>) {</div>
<div class=CC1>      iterator tmp = *<font color=#ff7700>this</font>;</div>
<div class=CC1>      ++*<font color=#ff7700>this</font>;</div>
<div class=CC1>      <font color=#ff7700>return</font> tmp;</div>
<div class=CC1>    }</div>
<div class=CC1>    iterator&amp; <font color=#ff7700>operator</font>--() {</div>
<div class=CC1>      <font color=#ff7700>if</font>(it == r-&gt;begin())</div>
<div class=CC1>        it = r-&gt;end();</div>
<div class=CC1>      --it;</div>
<div class=CC1>      <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    iterator <font color=#ff7700>operator</font>--(<font color=#ff7700>int</font>) {</div>
<div class=CC1>      iterator tmp = *<font color=#ff7700>this</font>;</div>
<div class=CC1>      --*<font color=#ff7700>this</font>;</div>
<div class=CC1>      <font color=#ff7700>return</font> tmp;</div>
<div class=CC1>    }</div>
<div class=CC1>    iterator insert(<font color=#ff7700>const</font> T&amp; x) {</div>
<div class=CC1>      <font color=#ff7700>return</font> iterator(*r, r-&gt;insert(it, x));</div>
<div class=CC1>    }</div>
<div class=CC1>    iterator erase() {</div>
<div class=CC1>      <font color=#ff7700>return</font> iterator(*r, r-&gt;erase(it));</div>
<div class=CC1>    }</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#ff7700>void</font> push_back(<font color=#ff7700>const</font> T&amp; x) { lst.push_back(x); }</div>
<div class=CC1>  iterator begin() { <font color=#ff7700>return</font> iterator(lst, lst.begin());
}</div>
<div class=CC1>  <font color=#ff7700>int</font> size() { <font color=#ff7700>return</font> lst.size(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Ring&lt;string&gt; rs;</div>
<div class=CC1>  rs.push_back(<font color=#007f00>&quot;one&quot;</font>);</div>
<div class=CC1>  rs.push_back(<font color=#007f00>&quot;two&quot;</font>);</div>
<div class=CC1>  rs.push_back(<font color=#007f00>&quot;three&quot;</font>);</div>
<div class=CC1>  rs.push_back(<font color=#007f00>&quot;four&quot;</font>);</div>
<div class=CC1>  rs.push_back(<font color=#007f00>&quot;five&quot;</font>);</div>
<div class=CC1>  Ring&lt;string&gt;::iterator it = rs.begin();</div>
<div class=CC1>  ++it; ++it;</div>
<div class=CC1>  it.insert(<font color=#007f00>&quot;six&quot;</font>);</div>
<div class=CC1>  it = rs.begin();</div>
<div class=CC1>  <font color=#dd0000>// Twice around the ring:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; rs.size() * 2; i++)</div>
<div class=CC1>    cout &lt;&lt; *it++ &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that most of the coding is in the iterator. The <b>Ring</b>
<b>iterator</b> must know how to loop back to the beginning, so it must keep a
reference to the <b>list </b>of<b> </b>its “parent” <b>Ring</b> object in order
to know if it’s at the end and how to get back to the beginning.</p>

<p class=MsoNormal>You’ll notice that the interface for <b>Ring</b> is quite
limited; in particular, there is no <b>end(&nbsp;)</b>, since a ring just keeps
looping. This means that you won’t be able to use a <b>Ring</b> in any STL
algorithms that require a past-the-end iterator, which are many. (It turns out that
adding this feature is a nontrivial exercise.) Although this can seem limiting,
consider <b>stack</b>, <b>queue</b>, and <b>priority_queue</b>, which don’t
produce any iterators at all!</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985803" name="_Toc53985803">STL
extensions</a></h2>

<p class=MsoNormal>Although the STL containers may provide all the functionality
you’ll ever need, they are not complete. For example, the standard
implementations of <b>set</b> and <b>map</b> use trees, and although these are
reasonably fast, they may not be fast enough for your needs. In the C++
Standards Committee it was generally agreed that hashed implementations of <b>set</b>
and <b>map</b> should have been included in Standard C++, however, there was
not enough time to add these components, and thus they were left out.<a href="#_ftn114" name="_ftnref114"><span
class=MsoFootnoteReference>[114]</span></a></p>

<p class=MsoNormal>Fortunately, alternatives are freely available. One of the
nice things about the STL is that it establishes a basic model for creating
STL-like classes, so anything built using the same model is easy to understand
if you are already familiar with the STL.</p>

<p class=MsoNormal>The SGI STL from Silicon Graphics<a href="#_ftn115" name="_ftnref115"><span
class=MsoFootnoteReference>[115]</span></a> is one of the
most robust implementations of the STL and can be used to replace your
compiler’s STL if that is found wanting. In addition, SGI has added a number of
extensions including <b>hash_set</b>, <b>hash_multiset</b>, <b>hash_map</b>, <b>hash_multimap</b>, <b>slist</b> (a singly linked list), and <b>rope</b> (a variant of <b>string</b> optimized for very large strings and fast concatenation
and substring operations).</p>

<p class=MsoNormal>Let’s consider a performance comparison between a tree-based
<b>map</b> and the SGI <b>hash_map</b>. To keep things simple, the mappings
will be from <b>int</b> to <b>int</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:MapVsHashMap.cpp</font></div>
<div class=CC1><font color=#dd0000>// The hash_map header is not part of the Standard C++
STL.</font></div>
<div class=CC1><font color=#dd0000>// It is an extension that is only available as part of
the</font></div>
<div class=CC1><font color=#dd0000>// SGI STL (Included with the dmc distribution).</font></div>
<div class=CC1><font color=#dd0000>// You can add the header by hand for all of these:</font></div>
<div class=CC1><font color=#dd0000>//{-bor}{-msc}{-g++}{-mwcc}</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;hash_map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  hash_map&lt;<font color=#ff7700>int</font>, <font color=#ff7700>int</font>&gt; hm;</div>
<div class=CC1>  map&lt;<font color=#ff7700>int</font>, <font color=#ff7700>int</font>&gt; m;</div>
<div class=CC1>  clock_t ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 1000; j++)</div>
<div class=CC1>      m.insert(make_pair(j,j));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;map insertions: &quot;</font> &lt;&lt;
clock() - ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 1000; j++)</div>
<div class=CC1>      hm.insert(make_pair(j,j));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;hash_map insertions: &quot;</font></div>
<div class=CC1>       &lt;&lt; clock() - ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 1000; j++)</div>
<div class=CC1>      m[j];</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;map::operator[] lookups: &quot;</font></div>
<div class=CC1>       &lt;&lt; clock() - ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 1000; j++)</div>
<div class=CC1>      hm[j];</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;hash_map::operator[] lookups:
&quot;</font></div>
<div class=CC1>       &lt;&lt; clock() - ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 1000; j++)</div>
<div class=CC1>      m.find(j);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;map::find() lookups: &quot;</font></div>
<div class=CC1>       &lt;&lt; clock() - ticks &lt;&lt; endl;</div>
<div class=CC1>  ticks = clock();</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 100; i++)</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> j = 0; j &lt; 1000; j++)</div>
<div class=CC1>      hm.find(j);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;hash_map::find() lookups: &quot;</font></div>
<div class=CC1>       &lt;&lt; clock() - ticks &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The performance test we ran showed a speed improvement of
roughly 4: 1 for the <b>hash_map</b> over the <b>map</b> in all operations (and
as expected, <b>find(&nbsp;)</b> is slightly faster than <b>operator[&nbsp;]</b>
for lookups for both types of map). If a profiler shows a bottleneck in your <b>map</b>,
consider a <b>hash_map</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985804" name="_Toc53985804">Non–STL
containers</a></h2>

<p class=MsoNormal>There are two “non-STL” containers in the standard library: <b>bitset</b> and <b>valarray</b>.<a href="#_ftn116" name="_ftnref116"><span
class=MsoFootnoteReference>[116]</span></a> We
say “non-STL” because neither of these containers fulfills all the requirements
of STL containers. The <b>bitset</b> container, which we covered earlier in
this chapter, packs bits into integers and does not allow direct addressing of
its members. The <b>valarray</b> template class is a <b>vector</b>-like
container that is optimized for efficient numeric computation. Neither
container provides iterators. Although you can instantiate a <b>valarray</b>
with nonnumeric types, it has mathematical functions that are intended to
operate with numeric data, such as <b>sin</b>, <b>cos</b>, <b>tan</b>, and so
on.</p>

<p class=MsoNormal>Here’s a tool to print elements in a <b>valarray</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:PrintValarray.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef PRINTVALARRAY_H</font></div>
<div class=CC1><font color=#7F7F00>#define PRINTVALARRAY_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;valarray&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> print(<font color=#ff7700>const</font> <font color=#ff7700>char</font>* lbl, <font color=#ff7700>const</font>
std::valarray&lt;T&gt;&amp; a) {</div>
<div class=CC1>  std::cout &lt;&lt; lbl &lt;&lt; <font color=#007f00>&quot;: &quot;</font>;</div>
<div class=CC1>  <font color=#ff7700>for</font>(std::size_t i = 0; i &lt; a.size(); ++i)</div>
<div class=CC1>    std::cout &lt;&lt; a[i] &lt;&lt; ' ';</div>
<div class=CC1>  std::cout &lt;&lt; std::endl;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// PRINTVALARRAY_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Most of <b>valarray</b>’s functions and operators operate on
a <b>valarray</b> as a whole, as the following example illustrates:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Valarray1.cpp {-bor}</font></div>
<div class=CC1><font color=#dd0000>// Illustrates basic valarray functionality.</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintValarray.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>double</font> f(<font color=#ff7700>double</font> x) { <font color=#ff7700>return</font> 2.0 * x - 1.0; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>double</font> n[] = { 1.0, 2.0, 3.0, 4.0 };</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>double</font>&gt; v(n, <font color=#ff7700>sizeof</font> n / <font color=#ff7700>sizeof</font> n[0]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;v&quot;</font>, v);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>double</font>&gt; sh(v.shift(1));</div>
<div class=CC1>  print(<font color=#007f00>&quot;shift 1&quot;</font>, sh);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>double</font>&gt; acc(v + sh);</div>
<div class=CC1>  print(<font color=#007f00>&quot;sum&quot;</font>, acc);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>double</font>&gt; trig(sin(v) + cos(acc));</div>
<div class=CC1>  print(<font color=#007f00>&quot;trig&quot;</font>, trig);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>double</font>&gt; p(pow(v, 3.0));</div>
<div class=CC1>  print(<font color=#007f00>&quot;3rd power&quot;</font>, p);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>double</font>&gt; app(v.apply(f));</div>
<div class=CC1>  print(<font color=#007f00>&quot;f(v)&quot;</font>, app);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>bool</font>&gt; eq(v == app);</div>
<div class=CC1>  print(<font color=#007f00>&quot;v == app?&quot;</font>, eq);</div>
<div class=CC1>  <font color=#ff7700>double</font> x = v.min();</div>
<div class=CC1>  <font color=#ff7700>double</font> y = v.max();</div>
<div class=CC1>  <font color=#ff7700>double</font> z = v.sum();</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;x = &quot;</font> &lt;&lt; x &lt;&lt;
<font color=#007f00>&quot;, y = &quot;</font> &lt;&lt; y</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot;, z = &quot;</font> &lt;&lt; z  &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>valarray</b> class provides a constructor that takes
an array of the target type and the count of elements in the array to
initialize the new <b>valarray</b>. The <b>shift(&nbsp;)</b> member function
shifts each <b>valarray</b> element one position to the left (or to the right,
if its argument is negative) and fills in holes with the default value for the
type (zero in this case). There is also a <b>cshift(&nbsp;)</b> member function
that does a circular shift (or “rotate”). All mathematical operators and
functions are overloaded to operate on <b>valarray</b>s, and binary operators
require <b>valarray</b> arguments of the same type and size. The <b>apply(&nbsp;)</b>
member function, like the <b>transform(&nbsp;)</b> algorithm, applies a
function to each element, but the result is collected into a result <b>valarray</b>.
The relational operators return suitably-sized instances of <b>valarray&lt;bool&gt;</b>
that indicate the result of element-by-element comparisons, such as with <b>eq</b>
above. Most operations return a new result array, but a few, such as <b>min(&nbsp;)</b>,
<b>max(&nbsp;)</b>, and <b>sum(&nbsp;)</b>, return a single scalar value, for
obvious reasons.</p>

<p class=MsoNormal>The most interesting thing you can do with <b>valarray</b>s
is reference subsets of their elements, not only for extracting information,
but also for updating it. A subset of a <b>valarray</b> is called a <i>slice</i>, and certain operators use slices to do their work. The following sample program
uses slices:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:Valarray2.cpp {-bor}{-dmc}</font></div>
<div class=CC1><font color=#dd0000>// Illustrates slices and masks.</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;PrintValarray.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>int</font> data[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
};</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; v(data, 12);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; r1(v[slice(0, 4, 3)]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;slice(0,4,3)&quot;</font>, r1);</div>
<div class=CC1>  <font color=#dd0000>// Extract conditionally</font></div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; r2(v[v &gt; 6]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;elements &gt; 6&quot;</font>, r2);</div>
<div class=CC1>  <font color=#dd0000>// Square first column</font></div>
<div class=CC1>  v[slice(0, 4, 3)] *= valarray&lt;<font color=#ff7700>int</font>&gt;(v[slice(0,
4, 3)]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;after squaring first column&quot;</font>, v);</div>
<div class=CC1>  <font color=#dd0000>// Restore it</font></div>
<div class=CC1>  <font color=#ff7700>int</font> idx[] = { 1, 4, 7, 10 };</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; save(idx, 4);</div>
<div class=CC1>  v[slice(0, 4, 3)] = save;</div>
<div class=CC1>  print(<font color=#007f00>&quot;v restored&quot;</font>, v);</div>
<div class=CC1>  <font color=#dd0000>// Extract a 2-d subset: { { 1, 3, 5 }, { 7, 9, 11 }
}</font></div>
<div class=CC1>  valarray&lt;size_t&gt; siz(2);</div>
<div class=CC1>  siz[0] = 2;</div>
<div class=CC1>  siz[1] = 3;</div>
<div class=CC1>  valarray&lt;size_t&gt; gap(2);</div>
<div class=CC1>  gap[0] = 6;</div>
<div class=CC1>  gap[1] = 2;</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; r3(v[gslice(0, siz, gap)]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;2-d slice&quot;</font>, r3);</div>
<div class=CC1>  <font color=#dd0000>// Extract a subset via a boolean mask (bool
elements)</font></div>
<div class=CC1>  valarray&lt;<font color=#ff7700>bool</font>&gt; mask(<font color=#ff7700>false</font>, 5);</div>
<div class=CC1>  mask[1] = mask[2] = mask[4] = <font color=#ff7700>true</font>;</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; r4(v[mask]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;v[mask]&quot;</font>, r4);</div>
<div class=CC1>  <font color=#dd0000>// Extract a subset via an index mask (size_t
elements)</font></div>
<div class=CC1>  size_t idx2[] = { 2, 2, 3, 6 };</div>
<div class=CC1>  valarray&lt;size_t&gt; mask2(idx2, 4);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; r5(v[mask2]);</div>
<div class=CC1>  print(<font color=#007f00>&quot;v[mask2]&quot;</font>, r5);</div>
<div class=CC1>  <font color=#dd0000>// Use an index mask in assignment</font></div>
<div class=CC1>  valarray&lt;<font color=#ff7700>char</font>&gt; text(<font color=#007f00>&quot;now is the
time&quot;</font>, 15);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>char</font>&gt; caps(<font color=#007f00>&quot;NITT&quot;</font>, 4);</div>
<div class=CC1>  valarray&lt;size_t&gt; idx3(4);</div>
<div class=CC1>  idx3[0] = 0;</div>
<div class=CC1>  idx3[1] = 4;</div>
<div class=CC1>  idx3[2] = 7;</div>
<div class=CC1>  idx3[3] = 11;</div>
<div class=CC1>  text[idx3] = caps;</div>
<div class=CC1>  print(<font color=#007f00>&quot;capitalized&quot;</font>, text);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A <b>slice</b> object takes three arguments: the starting
index, the number of elements to extract, and the “stride,” which is the gap
between elements of interest. Slices can be used as indexes into an existing <b>valarray</b>,
and a new <b>valarray</b> containing the extracted elements is returned. A <b>valarray</b>
of <b>bool</b>, such as is returned by the expression <b>v &gt; 6</b>, can be
used as an index into another <b>valarray</b>; the elements corresponding to
the <b>true</b> slots are extracted. As you can see, you can also use slices
and masks as indexes on the left side of an assignment. A <b>gslice</b> object
(for “generalized slice”) is like a slice, except that the counts and strides
are themselves arrays, which means you can interpret a <b>valarray</b> as a
multidimensional array. The example above extracts a 2 by 3 array from <b>v</b>,
where the numbers start at zero and the numbers for the first dimension are
found six slots apart in <b>v</b>, and the others two apart, which effectively
extracts the matrix</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>1 3 5</div>
<div class=CC1>7 9 11</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here is the complete output for this program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>slice(0,4,3): 1 4 7 10</div>
<div class=CC1>elements &gt; 6: 7 8 9 10</div>
<div class=CC1>after squaring v: 1 2 3 16 5 6 49 8 9 100 11 12</div>
<div class=CC1>v restored: 1 2 3 4 5 6 7 8 9 10 11 12</div>
<div class=CC1>2-d slice: 1 3 5 7 9 11</div>
<div class=CC1>v[mask]: 2 3 5</div>
<div class=CC1><span lang=IT>v[mask2]: 3 3 4 7</span></div>
<div class=CC1><span lang=IT>capitalized: N o w   I s   T h e   T i m e</span></div>

</div>

<div class=CC1><span lang=IT>&nbsp;</span></div>

<p class=MsoNormal>A practical example of slices is found in matrix
multiplication. Consider how you would write a function to multiply two
matrices of integers with arrays.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>void</font> matmult(<font color=#ff7700>const</font> <font color=#ff7700>int</font> a[][MAXCOLS], size_t m, size_t
n,</div>
<div class=CC1>             <font color=#ff7700>const</font> <font color=#ff7700>int</font> b[][MAXCOLS], size_t p, size_t
q,</div>
<div class=CC1>             <font color=#ff7700>int</font> result[][MAXCOLS);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This function multiplies the <b>m</b>-by-<b>n</b> matrix <b>a</b>
by the <b>p</b>-by-<b>q</b> matrix <b>b</b>, where <b>n</b> and <b>p</b> are expected
to be equal. As you can see, without something like <b>valarray</b>, you need
to fix the maximum value for the second dimension of each matrix, since
locations in arrays are statically determined. It is also difficult to return a
result array by value, so the caller usually passes the result array as an
argument.</p>

<p class=MsoNormal>Using <b>valarray</b>, you can not only pass any size matrix,
but you can also easily process matrices of any type, and return the result by
value. Here’s how:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C07:MatrixMultiply.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses valarray to multiply matrices</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cmath&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iomanip&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;valarray&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Prints a valarray as a square matrix</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1><font color=#ff7700>void</font> printMatrix(<font color=#ff7700>const</font> valarray&lt;T&gt;&amp; a, size_t
n) {</div>
<div class=CC1>  size_t siz = n*n;</div>
<div class=CC1>  assert(siz &lt;= a.size());</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; siz; ++i) {</div>
<div class=CC1>    cout &lt;&lt; setw(5) &lt;&lt; a[i];</div>
<div class=CC1>    cout &lt;&lt; ((i+1)%n ? ' ' : '\n');</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Multiplies compatible matrices in valarrays</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt;</div>
<div class=CC1>valarray&lt;T&gt;</div>
<div class=CC1>matmult(<font color=#ff7700>const</font> valarray&lt;T&gt;&amp; a, size_t arows,
size_t acols,</div>
<div class=CC1>        <font color=#ff7700>const</font> valarray&lt;T&gt;&amp; b, size_t brows,
size_t bcols) {</div>
<div class=CC1>  assert(acols == brows);</div>
<div class=CC1>  valarray&lt;T&gt; result(arows * bcols);</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; arows; ++i)</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t j = 0; j &lt; bcols; ++j) {</div>
<div class=CC1>      <font color=#dd0000>// Take dot product of row a[i] and col b[j]</font></div>
<div class=CC1>      valarray&lt;T&gt; row = a[slice(acols*i, acols,
1)];</div>
<div class=CC1>      valarray&lt;T&gt; col = b[slice(j, brows,
bcols)];</div>
<div class=CC1>      result[i*bcols + j] = (row * col).sum();</div>
<div class=CC1>    }</div>
<div class=CC1>  <font color=#ff7700>return</font> result;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> n = 3;</div>
<div class=CC1>  <font color=#ff7700>int</font> adata[n*n] = {1,0,-1,2,2,-3,3,4,0};</div>
<div class=CC1>  <font color=#ff7700>int</font> bdata[n*n] = {3,4,-1,1,-3,0,-1,1,2};</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; a(adata, n*n);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; b(bdata, n*n);</div>
<div class=CC1>  valarray&lt;<font color=#ff7700>int</font>&gt; c(matmult(a, n, n, b, n, n));</div>
<div class=CC1>  printMatrix(c, n);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each entry in the result matrix <b>c</b> is the dot product
of a row in <b>a</b> with a column in <b>b</b>. By taking slices, you can
extract these rows and columns as <b>valarray</b>s and use the global <b>*</b>
operator and <b>sum(&nbsp;)</b> function provided by <b>valarray</b> to do the
work succinctly. The result <b>valarray</b> is computed at runtime; there’s no
need to worry about the static limitations of array dimensions. You do have to
compute linear offsets of the position <b>[i][j]</b> yourself (see the formula <b>i*bcols
+ j</b> above), but the size and type freedom is worth it.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985805" name="_Toc53985805">Summary</a></h2>

<p class=MsoNormal>The goal of this chapter was not just to introduce the STL
containers in some considerable depth. Although every detail could not be
covered here, you now know enough that you can look up further information in
the other resources. Our hope is that this chapter has helped you grasp the
power available in the STL and shown you how much faster and more efficient
your programming activities can be by understanding and using the STL.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985806" name="_Toc53985806">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>set&lt;char&gt;</b>, open a file (whose name is
provided on the command line), and read that file in a <b>char</b> at a time,
placing each <b>char</b> in the set. Print the results, and observe the
organization. Are there any letters in the alphabet that are not used in that
particular file?</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create three sequences of <b>Noisy</b> objects, a <b>vector</b>, <b>deque</b>,
and <b>list</b>. Sort them. Now write a function template to receive the <b>vector</b>
and <b>deque</b> sequences as a parameter to sort them and record the sorting
time. Write a specialized template function to do the same for <b>list</b>
(ensure to call its member <b>sort(&nbsp;)</b> instead of the generic
algorithm). Compare the performance of the different sequence types.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Write a program to compare the speed of sorting a list using <b>list::sort(&nbsp;)</b>
vs. using <b>std::sort(&nbsp;)</b> (the STL algorithm version of <b>sort(&nbsp;)</b>).</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a generator that produces random <b>int</b> values between
0 and 20 inclusive, and use it to fill a <b>multiset&lt;int&gt;</b>. Count the
occurrences of each value, following the example given in <b>MultiSetWordCount.cpp</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Change <b>StlShape.cpp</b> so that it uses a <b>deque</b> instead
of a <b>vector</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>Reversible.cpp</b> so it works with <b>deque</b> and <b>list</b>
instead of <b>vector</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use a <b>stack&lt;int&gt;</b> and populate it with a Fibonacci
sequence. The program’s command line should take the number of Fibonacci
elements desired, and you should have a loop that looks at the last two
elements on the stack and pushes a new one for every pass through the loop.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Using only three <b>stack</b>s (<i>source</i>, <i>sorted</i>, and
<i>losers</i>), sort a random sequence of numbers by first placing the numbers on
the <i>source</i> stack. Assume the number on the top of the <i>source</i> is
the largest, and push it on the <i>sorted</i> stack. Continue to pop the <i>source</i>
stack comparing it with the top of the <i>sorted</i> stack. Whichever number is
the smallest, pop it from its stack and push it onto the on the <i>losers’</i>
stack. Once the <i>source</i> stack is empty, repeat the process using the <i>losers’</i>
stack as the <i>source</i> stack, and use the <i>source</i> stack as the <i>losers’</i>
stack. The algorithm completes when all the numbers have been placed into the <i>winners’</i>
stack.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Open a text file whose name is provided on the command line. Read
the file a word at a time, and use a <b>multiset&lt;string&gt;</b> to create a
word count for each word.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>WordCount.cpp</b> so that it uses <b>insert(&nbsp;)</b>
instead of <b>operator[&nbsp;]</b> to insert elements in the map.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a class that has an <b>operator&lt;</b> and an <b>ostream&amp;
operator&lt;&lt;</b>. The class should contain a priority number. Create a
generator for your class that makes a random priority number. Fill a <b>priority_queue</b>
using your generator, and then pull the elements out to show they are in the
proper order.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>12.&nbsp;&nbsp;&nbsp;&nbsp;</span>Rewrite <b>Ring.cpp</b> so it uses a <b>deque</b> instead of a <b>list</b>
for its underlying implementation.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>13.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>Ring.cpp</b> so that the underlying implementation can
be chosen using a template argument. (Let that template argument default to <b>list</b>.)</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>14.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create an iterator class called <b>BitBucket</b> that just
absorbs whatever you send to it without writing it anywhere.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>15.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a kind of “hangman” game. Create a class that contains a <b>char</b>
and a <b>bool</b> to indicate whether that <b>char</b> has been guessed yet.
Randomly select a word from a file, and read it into a <b>vector</b> of your
new type. Repeatedly ask the user for a character guess, and after each guess,
display the characters in the word that have been guessed, and display
underscores for the characters that haven’t. Allow a way for the user to guess
the whole word. Decrement a value for each guess, and if the user can get the
whole word before the value goes to zero, they win.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>16.&nbsp;&nbsp;&nbsp;&nbsp;</span>Open a file and read it into a single string. Turn the string
into a <b>stringstream</b>. Read tokens from the <b>stringstream</b> into a <b>list&lt;string&gt;</b>
using a <b>TokenIterator</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>17.&nbsp;&nbsp;&nbsp;&nbsp;</span>Compare the performance of <b>stack</b> based on whether it is
implemented with <b>vector</b>, <b>deque</b>, or <b>list</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>18.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a template that implements a singly-linked list called <b>SList</b>.
Provide a default constructor and <b>begin(&nbsp;)</b> and <b>end(&nbsp;)</b>
functions (via an appropriate nested iterator), <b>insert(&nbsp;)</b>, <b>erase(&nbsp;)</b>
and a destructor.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>19.&nbsp;&nbsp;&nbsp;&nbsp;</span>Generate a sequence of random integers, storing them into an
array of <b>int</b>. Initialize a <b>valarray&lt;int&gt;</b> with its contents.
Compute the sum, minimum value, maximum value, average, and median of the
integers using <b>valarray</b> operations.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>20.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>valarray&lt;int&gt;</b> with 12 random values. Create
another <b>valarray&lt;int&gt;</b> with 20 random values. You will interpret
the first <b>valarray</b> as a 3 x 4 matrix of <b>int</b>s and the second as a
4 x 5 matrix of <b>int</b>s, and multiply them by the rules of matrix
multiplication. Store the result in a <b>valarray&lt;int&gt;</b> of size 15,
representing the 3 x 5 result matrix. Use slices to multiply the rows of the
first matrix time the columns of the second. Print the result in rectangular
matrix form.</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section17>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985807" name="_Toc53985807">Part 3: Special Topics</a></h1>

<p class=Intro style='margin-left:.25in'>The mark of a professional appears in his or her attention to
the finer points of the craft. In this section of the book we discuss advanced
features of C++ along with development techniques used by polished C++
professionals.</p>

<p class=MsoNormal>Sometimes you may need to depart from the conventional
wisdom of sound object-oriented design by inspecting the runtime type of an
object. Most of the time you should let virtual functions do that job for you,
but when writing special-purpose software tools, such as debuggers, database
viewers, or class browsers, you’ll need to determine type information at
runtime. This is where the runtime type identification (RTTI) mechanism becomes
useful. RTTI is the topic of Chapter 8.</p>

<p class=MsoNormal>Multiple inheritance has taken abuse over the years, and
some languages don’t even support it. Nonetheless, when used properly, it can
be a powerful tool for crafting elegant, efficient code. A number of standard
practices involving multiple inheritance have evolved over the years, which we
present in Chapter 9.</p>

<p class=MsoNormal>Perhaps the most notable innovation in software development
since object-oriented techniques is the use of design patterns. A design
pattern describes solutions for many of the common problems involved in
designing software, and can be applied in many situations and implemented in
any language. In chapter 10 we describe a selected number of design patterns
and implement them in C++.</p>

<p class=MsoNormal>Chapter 11 explains the benefits and challenges of multithreaded
programming. The current version of Standard C++ does not specify support for
threads, even though most operating systems provide them. We use a portable, freely
available threading library to illustrate how C++ programmers can take
advantage of threads to build more usable and responsive applications.</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section18>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985808" name="_Toc53985808">8: Runtime Type Identification</a></h1>

<p class=Intro style='margin-left:.25in'>Runtime type identification (RTTI)
lets you find the dynamic type of an object when you have only a pointer or a
reference to the base type.</p>

<p class=MsoNormal>This can be thought of as a “secondary” feature in C++, pragmatism
to help out when you get into rare difficult situations. Normally, you’ll want
to intentionally ignore the exact type of an object and let the virtual
function mechanism implement the correct behavior for that type. On occasion,
however, it’s useful to know the exact <i>runtime</i> (that is, most derived)
type of an object for which you only have a base pointer. With this information,
you may perform a special-case operation more efficiently or prevent a
base-class interface from becoming ungainly. It happens enough that most class
libraries contain virtual functions to produce runtime type information. When
exception handling was added to C++, that feature required information about
the runtime type of objects, so it became an easy next step to build in access
to that information. This chapter explains what RTTI is for and how to use it.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985809" name="_Toc53985809">Runtime
casts</a></h2>

<p class=MsoNormal>One way to determine the runtime type of an object through a
pointer or reference is to employ a <i>runtime cast</i>, which verifies that the attempted conversion is valid. This is useful when you need to cast a base-class
pointer to a derived type. Since inheritance hierarchies are typically depicted
with base classes above derived classes, such a cast is called a <i>downcast</i>.</p>

<p class=MsoNormal>Consider the following class hierarchy:</p>

<p class=MsoNormal align=center style='margin-bottom:6.0pt;text-align:center'><img
width=417 height=253 src="TicV2_files/image012.gif"></p>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In the code that follows, the <b>Investment</b> class has an
extra operation that the other classes do not, so it is important to be able to
know at runtime whether a <b>Security</b> pointer refers to a <b>Investment</b>
object or not. To implement checked runtime casts, each class keeps an integral
identifier to distinguish it from other classes in the hierarchy.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:CheckedCast.cpp</font></div>
<div class=CC1><font color=#dd0000>// Checks casts at runtime.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Security {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>enum</font> { BASEID = 0 };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Security() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>bool</font> isA(<font color=#ff7700>int</font> id) { <font color=#ff7700>return</font> (id == BASEID); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Stock : <font color=#ff7700>public</font> Security {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Security Super;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>enum</font> { OFFSET = 1, TYPEID = BASEID + OFFSET };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>bool</font> isA(<font color=#ff7700>int</font> id) {</div>
<div class=CC1>    <font color=#ff7700>return</font> id == TYPEID || Super::isA(id);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> Stock* dynacast(Security* s) {</div>
<div class=CC1>    <font color=#ff7700>return</font> (s-&gt;isA(TYPEID)) ?
<font color=#ff7700>static_cast</font>&lt;Stock*&gt;(s) : 0;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bond : <font color=#ff7700>public</font> Security {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Security Super;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>enum</font> { OFFSET = 2, TYPEID = BASEID + OFFSET };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>bool</font> isA(<font color=#ff7700>int</font> id) {</div>
<div class=CC1>    <font color=#ff7700>return</font> id == TYPEID || Super::isA(id);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> Bond* dynacast(Security* s) {</div>
<div class=CC1>    <font color=#ff7700>return</font> (s-&gt;isA(TYPEID)) ?
<font color=#ff7700>static_cast</font>&lt;Bond*&gt;(s) : 0;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Investment : <font color=#ff7700>public</font> Security {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Security Super;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>enum</font> { OFFSET = 3, TYPEID = BASEID + OFFSET };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>bool</font> isA(<font color=#ff7700>int</font> id) {</div>
<div class=CC1>    <font color=#ff7700>return</font> id == TYPEID || Super::isA(id);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> Investment* dynacast(Security* s) {</div>
<div class=CC1>    <font color=#ff7700>return</font> (s-&gt;isA(TYPEID)) ?</div>
<div class=CC1>      <font color=#ff7700>static_cast</font>&lt;Investment*&gt;(s) : 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> special() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;special Investment
function&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Metal : <font color=#ff7700>public</font> Investment {</div>
<div class=CC1>  <font color=#ff7700>typedef</font> Investment Super;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>enum</font> { OFFSET = 4, TYPEID = BASEID + OFFSET };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>bool</font> isA(<font color=#ff7700>int</font> id) {</div>
<div class=CC1>    <font color=#ff7700>return</font> id == TYPEID || Super::isA(id);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>static</font> Metal* dynacast(Security* s) {</div>
<div class=CC1>    <font color=#ff7700>return</font> (s-&gt;isA(TYPEID)) ?
<font color=#ff7700>static_cast</font>&lt;Metal*&gt;(s) : 0;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Security*&gt; portfolio;</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Metal);</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Investment);</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Bond);</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Stock);</div>
<div class=CC1>  <font color=#ff7700>for</font>(vector&lt;Security*&gt;::iterator it =
portfolio.begin();</div>
<div class=CC1>       it != portfolio.end(); ++it) {</div>
<div class=CC1>    Investment* cm = Investment::dynacast(*it);</div>
<div class=CC1>    <font color=#ff7700>if</font>(cm)</div>
<div class=CC1>      cm-&gt;special();</div>
<div class=CC1>    <font color=#ff7700>else</font></div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;not an Investment&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;cast from intermediate
pointer:&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  Security* sp = <font color=#ff7700>new</font> Metal;</div>
<div class=CC1>  Investment* cp = Investment::dynacast(sp);</div>
<div class=CC1>  <font color=#ff7700>if</font>(cp) cout &lt;&lt; <font color=#007f00>&quot;  it's an Investment&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <span lang=SV>Metal* mp = Metal::dynacast(sp);</span></div>
<div class=CC1><span lang=SV>  </span><font color=#ff7700>if</font>(mp) cout &lt;&lt; <font color=#007f00>&quot; 
it's a Metal too!&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  purge(portfolio);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The polymorphic <b>isA(&nbsp;)</b> function checks to see if
its argument is compatible with its type argument (<b>id</b>), which means that
either <b>id</b> matches the object’s <b>typeID</b> exactly or it matches one
of the object’s ancestors (hence the call to <b>Super::isA(&nbsp;)</b> in that
case). The <b>dynacast(&nbsp;)</b> function, which is static in each class,
calls <b>isA(&nbsp;)</b> for its pointer argument to check if the cast is
valid. If <b>isA(&nbsp;)</b> returns <b>true</b>, the cast is valid, and a
suitably cast pointer is returned. Otherwise, the null pointer is returned,
which tells the caller that the cast is not valid, meaning that the original
pointer is not pointing to an object compatible with (convertible to) the
desired type. All this machinery is necessary to be able to check intermediate
casts, such as from a <b>Security</b> pointer that refers to a <b>Metal</b>
object to a <b>Investment</b> pointer in the previous example program.<a href="#_ftn117" name="_ftnref117"><span
class=MsoFootnoteReference>[117]</span></a></p>

<p class=MsoNormal>For most programs downcasting is unnecessary, and is actually
discouraged, since everyday polymorphism solves most problems in object-oriented
application programs. However, the ability to check a cast to a more derived
type is important for utility programs such as debuggers, class browsers, and
databases. C++ provides such a checked cast with the <b>dynamic_cast</b> operator. The following program is a rewrite of the previous example using <b>dynamic_cast</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:Security.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef SECURITY_H</font></div>
<div class=CC1><font color=#7F7F00>#define SECURITY_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Security {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Security() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Stock : <font color=#ff7700>public</font> Security {};</div>
<div class=CC1><font color=#ff7700>class</font> Bond : <font color=#ff7700>public</font> Security {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Investment : <font color=#ff7700>public</font> Security {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> special() {</div>
<div class=CC1>    std::cout &lt;&lt; &quot;special Investment
function” &lt;&lt;std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Metal : <font color=#ff7700>public</font> Investment {};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// SECURITY_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:CheckedCast2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Uses RTTI’s dynamic_cast.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Security.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Security*&gt; portfolio;</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Metal);</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Investment);</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Bond);</div>
<div class=CC1>  portfolio.push_back(<font color=#ff7700>new</font> Stock);</div>
<div class=CC1>  <font color=#ff7700>for</font>(vector&lt;Security*&gt;::iterator it =</div>
<div class=CC1>       portfolio.begin();</div>
<div class=CC1>       it != portfolio.end(); ++it) {</div>
<div class=CC1>    Investment* cm =
<font color=#ff7700>dynamic_cast</font>&lt;Investment*&gt;(*it);</div>
<div class=CC1>    <font color=#ff7700>if</font>(cm)</div>
<div class=CC1>      cm-&gt;special();</div>
<div class=CC1>    <font color=#ff7700>else</font></div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;not a Investment&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; &quot;cast from intermediate pointer:”
&lt;&lt; endl;</div>
<div class=CC1>  Security* sp = <font color=#ff7700>new</font> Metal;</div>
<div class=CC1>  Investment* cp = <font color=#ff7700>dynamic_cast</font>&lt;Investment*&gt;(sp);</div>
<div class=CC1>  <font color=#ff7700>if</font>(cp) cout &lt;&lt; &quot;  it's an Investment”
&lt;&lt; endl;</div>
<div class=CC1>  Metal* mp = <font color=#ff7700>dynamic_cast</font>&lt;Metal*&gt;(sp);</div>
<div class=CC1>  <font color=#ff7700>if</font>(mp) cout &lt;&lt; &quot;  it's a Metal too!”
&lt;&lt; endl;</div>
<div class=CC1>  purge(portfolio);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example is much shorter, since most of the code in the
original example was just the overhead for checking the casts. The target type
of a <b>dynamic_cast</b> is placed in angle brackets, like the other new-style
C++ casts (<b>static_cast</b>, and so on), and the object to cast appears as
the operand. <b>dynamic_cast</b> requires that the types you use it with be <i>polymorphic</i> if you want safe downcasts.<a href="#_ftn118" name="_ftnref118"><span
class=MsoFootnoteReference>[118]</span></a> This
in turn requires that the class must have at least one virtual function.
Fortunately, the <b>Security</b> base class has a virtual destructor, so we
didn’t have to invent an extra function to get the job done. Because <b>dynamic_cast</b>
does its work at runtime, using the virtual table, it tends to be more
expensive than the other new-style casts.</p>

<p class=MsoNormal>You can also use <b>dynamic_cast</b> with references instead
of pointers, but since there is no such thing as a null reference, you need
another way to know if the cast fails. That “other way” is to catch a <b>bad_cast</b> exception, as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:CatchBadCast.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Security.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Metal m;</div>
<div class=CC1>  Security&amp; s = m;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Investment&amp; c =
<font color=#ff7700>dynamic_cast</font>&lt;Investment&amp;&gt;(s);</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;It's an Investment&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(bad_cast&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;s is not an Investment
type&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Bond&amp; b = <font color=#ff7700>dynamic_cast</font>&lt;Bond&amp;&gt;(s);</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;It's a Bond&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(bad_cast&amp;) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;It's not a Bond type&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>bad_cast</b> class is defined in the <b>&lt;typeinfo&gt;</b> header, and, like most of the standard library, is declared in the <b>std</b>
namespace.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985810" name="_Toc53985810">The
</a><span style='font-weight:normal'>typeid</span> operator</h2>

<p class=MsoNormal>The other way to get runtime information for an object is
through the <b>typeid</b> operator. This operator returns an object of class <b>type_info</b>, which yields information about the type of object to which it was applied. If the type is polymorphic, it gives information about the most derived
type that applies (the <i>dynamic type</i>); otherwise it yields static type information. One use of the <b>typeid</b> operator is to get the name of the dynamic
type of an object as a <b>const char*</b>, as you can see in the following
example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:TypeInfo.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates the typeid operator.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> PolyBase { <font color=#ff7700>virtual</font> ~PolyBase() {} };</div>
<div class=CC1><font color=#ff7700>struct</font> PolyDer : PolyBase { PolyDer() {} };</div>
<div class=CC1><font color=#ff7700>struct</font> NonPolyBase {};</div>
<div class=CC1><font color=#ff7700>struct</font> NonPolyDer : NonPolyBase { NonPolyDer(<font color=#ff7700>int</font>) {} };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Test polymorphic Types</font></div>
<div class=CC1>  <font color=#ff7700>const</font> PolyDer pd;</div>
<div class=CC1>  <font color=#ff7700>const</font> PolyBase* ppb = &amp;pd;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(ppb).name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(*ppb).name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; boolalpha &lt;&lt; (<font color=#ff7700>typeid</font>(*ppb) ==
<font color=#ff7700>typeid</font>(pd))</div>
<div class=CC1>       &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (<font color=#ff7700>typeid</font>(PolyDer) == <font color=#ff7700>typeid</font>(<font color=#ff7700>const</font>
PolyDer))</div>
<div class=CC1>       &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Test non-polymorphic Types</font></div>
<div class=CC1>  <font color=#ff7700>const</font> NonPolyDer npd(1);</div>
<div class=CC1>  <font color=#ff7700>const</font> NonPolyBase* nppb = &amp;npd;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(nppb).name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(*nppb).name() &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; (<font color=#ff7700>typeid</font>(*nppb) == <font color=#ff7700>typeid</font>(npd)) &lt;&lt;
endl;</div>
<div class=CC1>  <font color=#dd0000>// Test a built-in type</font></div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(i).name() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The output from this program using one particular compiler is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>struct</font> PolyBase <font color=#ff7700>const</font> *</div>
<div class=CC1><font color=#ff7700>struct</font> PolyDer</div>
<div class=CC1><font color=#ff7700>true</font></div>
<div class=CC1><font color=#ff7700>true</font></div>
<div class=CC1><font color=#ff7700>struct</font> NonPolyBase <font color=#ff7700>const</font> *</div>
<div class=CC1><font color=#ff7700>struct</font> NonPolyBase</div>
<div class=CC1><font color=#ff7700>false</font></div>
<div class=CC1><font color=#ff7700>int</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The first output line just echoes the static type of <b>ppb</b>
because it is a pointer. To get RTTI to kick in, you need to look at the
pointer or reference destination object, which is illustrated in the second
line. Notice that RTTI ignores top-level <b>const</b> and <b>volatile</b> qualifiers. With non-polymorphic types, you just get the static type (the type of the pointer
itself). As you can see, built-in types are also supported.</p>

<p class=MsoNormal>It turns out that you can’t store the result of a <b>typeid</b>
operation in a <b>type_info</b> object, because there are no accessible
constructors and assignment is disallowed. You must use it as we have shown. In
addition, the actual string returned by <b>type_info::name(&nbsp;)</b> is compiler dependent. For a class named <b>C</b>, for example, some compilers
return “class C” instead of just “C.” Applying <b>typeid</b> to an expression
that dereferences a null pointer will cause a <b>bad_typeid</b> exception (also defined in <b>&lt;typeinfo&gt;</b>) to be thrown.</p>

<p class=MsoNormal>The following example shows that the class name that <b>type_info::name(&nbsp;)</b>
returns is fully qualified:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:RTTIandNesting.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> One {</div>
<div class=CC1>  <font color=#ff7700>class</font> Nested {};</div>
<div class=CC1>  Nested* n;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  One() : n(<font color=#ff7700>new</font> Nested) {}</div>
<div class=CC1>  ~One() { <font color=#ff7700>delete</font> n; }</div>
<div class=CC1>  Nested* nested() { <font color=#ff7700>return</font> n; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  One o;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(*o.nested()).name() &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since <b>Nested</b> is a member type of the <b>One</b>
class, the result is <b>One::Nested</b>.</p>

<p class=MsoNormal>You can also ask a <b>type_info</b> object if it precedes
another <b>type_info</b> object in the implementation-defined “collation
sequence” (the native ordering rules for text), using <b>before(type_info&amp;)</b>, which returns <b>true</b> or <b>false</b>. When you say,</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>if</font>(<font color=#ff7700>typeid</font>(me).before(<font color=#ff7700>typeid</font>(you))) <font color=#dd0000>// ...</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>you’re asking if <b>me</b> occurs before <b>you</b> in the
current collation sequence. This is useful if you use <b>type_info</b> objects
as keys.</p>

<h3><a href="#_TocRef312374140" name="_Toc312374140">Casting to intermediate
levels</a></h3>

<p class=MsoNormal>As you saw in the earlier program that used the hierarchy of
<b>Security</b> classes, <b>dynamic_cast</b> can detect both exact types and, in an inheritance hierarchy with multiple levels, intermediate types. Here is
another example.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:IntermediateCast.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> B1 {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~B1() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> B2 {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~B2() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MI : <font color=#ff7700>public</font> B1, <font color=#ff7700>public</font> B2 {};</div>
<div class=CC1><font color=#ff7700>class</font> Mi2 : <font color=#ff7700>public</font> MI {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <span lang=IT>B2* b2 = <font color=#ff7700>new</font> Mi2;</span></div>
<div class=CC1><span lang=IT>  Mi2* mi2 =
<font color=#ff7700>dynamic_cast</font>&lt;Mi2*&gt;(b2);</span></div>
<div class=CC1><span lang=IT>  MI* mi = <font color=#ff7700>dynamic_cast</font>&lt;MI*&gt;(b2);</span></div>
<div class=CC1><span lang=IT>  </span>B1* b1 =
<font color=#ff7700>dynamic_cast</font>&lt;B1*&gt;(b2);</div>
<div class=CC1>  assert(<font color=#ff7700>typeid</font>(b2) != <font color=#ff7700>typeid</font>(Mi2*));</div>
<div class=CC1>  assert(<font color=#ff7700>typeid</font>(b2) == <font color=#ff7700>typeid</font>(B2*));</div>
<div class=CC1>  <font color=#ff7700>delete</font> b2;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This example has the extra complication of multiple
inheritance (you’ll learn more about multiple inheritance later in this chapter,
and in Chapter 9). If you create an <b>Mi2</b> and upcast it to the root (in this case, one of the two possible roots is chosen), the <b>dynamic_cast</b>
back to either of the derived levels <b>MI</b> or <b>Mi2</b> is successful.</p>

<p class=MsoNormal>You can even cast from one root to the other:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>  B1* b1 = <font color=#ff7700>dynamic_cast</font>&lt;B1*&gt;(b2);</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This is successful because <b>B2</b> is actually pointing to
a <b>Mi2</b> object, which contains a subobject of type <b>B1</b>.</p>

<p class=MsoNormal>Casting to intermediate levels brings up an interesting
difference between <b>dynamic_cast</b> and <b>typeid</b>. The <b>typeid</b> operator always produces a reference to a static <b>type_info</b> object that describes the dynamic type of the object. Thus, it doesn’t give you
intermediate-level information. In the following expression (which is <b>true</b>),
<b>typeid</b> doesn’t see <b>b2</b> as a pointer to the derived type, like <b>dynamic_cast</b>
does:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typeid</font>(b2) != <font color=#ff7700>typeid</font>(Mi2*)</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The type of <b>b2</b> is simply the exact type of the
pointer:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>typeid</font>(b2) == <font color=#ff7700>typeid</font>(B2*)</div>

</div>

<div class=CC1>&nbsp;</div>

<h3><a href="#_TocRef312374141" name="_Toc312374141"><span style='font-weight:
normal'>void</span> pointers</a></h3>

<p class=MsoNormal>RTTI only works for complete types, meaning that all class
information must be available when <b>typeid</b> is used. In particular, it
doesn’t work with <b>void</b> pointers:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:VoidRTTI.cpp</font></div>
<div class=CC1><font color=#dd0000>// RTTI &amp; void pointers.</font></div>
<div class=CC1><font color=#dd0000>//!#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Stimpy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> happy() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> joy() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Stimpy() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>void</font>* v = <font color=#ff7700>new</font> Stimpy;</div>
<div class=CC1>  <font color=#dd0000>// Error:</font></div>
<div class=CC1><font color=#dd0000>//!  Stimpy* s = dynamic_cast&lt;Stimpy*&gt;(v);</font></div>
<div class=CC1>  <font color=#dd0000>// Error:</font></div>
<div class=CC1><font color=#dd0000>//!  cout &lt;&lt; typeid(*v).name() &lt;&lt; endl;</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A <b>void*</b> truly means “no type information.”<a href="#_ftn119" name="_ftnref119"><span
class=MsoFootnoteReference>[119]</span></a></p>

<h3><a href="#_TocRef312374142" name="_Toc312374142">Using RTTI with
templates</a></h3>

<p class=MsoNormal>Class templates work well with RTTI, since all they do is
generate classes. As usual, RTTI provides a convenient way to obtain the name
of the class you’re in. The following example prints the order of constructor
and destructor calls:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:ConstructorOrder.cpp</font></div>
<div class=CC1><font color=#dd0000>// Order of constructor calls.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>int</font> id&gt; <font color=#ff7700>class</font> Announce {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Announce() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#ff7700>typeid</font>(*<font color=#ff7700>this</font>).name() &lt;&lt; <font color=#007f00>&quot;
constructor&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Announce() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#ff7700>typeid</font>(*<font color=#ff7700>this</font>).name() &lt;&lt; <font color=#007f00>&quot;
destructor&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> X : <font color=#ff7700>public</font> Announce&lt;0&gt; {</div>
<div class=CC1>  Announce&lt;1&gt; m1;</div>
<div class=CC1>  Announce&lt;2&gt; m2;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  X() { cout &lt;&lt; <font color=#007f00>&quot;X::X()&quot;</font> &lt;&lt; endl;
}</div>
<div class=CC1>  ~X() { cout &lt;&lt; <font color=#007f00>&quot;X::~X()&quot;</font> &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() { X x; } <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This template uses a constant <b>int</b> to differentiate
one class from another, but type arguments would work as well. Inside both the
constructor and destructor, RTTI information produces the name of the class to
print. The class <b>X</b> uses both inheritance and composition to create a
class that has an interesting order of constructor and destructor calls. The output
is</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>Announce&lt;0&gt; constructor</div>
<div class=CC1>Announce&lt;1&gt; constructor</div>
<div class=CC1>Announce&lt;2&gt; constructor</div>
<div class=CC1>X::X()</div>
<div class=CC1>X::~X()</div>
<div class=CC1>Announce&lt;2&gt; destructor</div>
<div class=CC1>Announce&lt;1&gt; destructor</div>
<div class=CC1>Announce&lt;0&gt; destructor</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Of course, you may get different output depending on how
your compiler represents its <b>name(&nbsp;)</b> information.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593312" name="_Toc305593312">Multiple
inheritance</a></h2>

<p class=MsoNormal>The RTTI mechanisms must work properly with all the complexities of multiple inheritance, including <b>virtual</b> base
classes (discussed in depth in the next chapter—you may want to come back here
after reading Chapter 9):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:RTTIandMultipleInheritance.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> BB {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~BB() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> B1 : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> BB {};</div>
<div class=CC1><font color=#ff7700>class</font> B2 : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> BB {};</div>
<div class=CC1><font color=#ff7700>class</font> MI : <font color=#ff7700>public</font> B1, <font color=#ff7700>public</font> B2 {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  BB* bbp = <font color=#ff7700>new</font> MI; <font color=#dd0000>// Upcast</font></div>
<div class=CC1>  <font color=#dd0000>// Proper name detection:</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>typeid</font>(*bbp).name() &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Dynamic_cast works properly:</font></div>
<div class=CC1>  MI* mip = <font color=#ff7700>dynamic_cast</font>&lt;MI*&gt;(bbp);</div>
<div class=CC1>  <font color=#dd0000>// Can't force old-style cast:</font></div>
<div class=CC1><span lang=IT><font color=#dd0000>//! MI* mip2 = (MI*)bbp; // Compile error</span></font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The<b> typeid(&nbsp;) </b>operator<b> </b>properly detects
the name of the actual object, even through the <b>virtual</b> base class
pointer. The <b>dynamic_cast</b> also works correctly. But the compiler won’t
even allow you to try to force a cast the old way:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=IT>MI* mip = (MI*)bbp; <font color=#dd0000>// Compile-time error</span></font></div>

</div>

<div class=CC1><span lang=IT>&nbsp;</span></div>

<p class=MsoNormal>The compiler knows this is never the right thing to do, so
it requires that you use a <b>dynamic_cast</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593313" name="_Toc305593313">Sensible
uses for RTTI</a></h2>

<p class=MsoNormal>Because you can discover type information from an anonymous
polymorphic pointer, RTTI is ripe for misuse by the novice, because RTTI may make sense before virtual functions do. For many people coming from a
procedural background, it’s difficult not to organize programs into sets of <b>switch</b>
statements. They could accomplish this with RTTI and thus lose the important
value of polymorphism in code development and maintenance. The intent of C++ is
that you use virtual functions throughout your code and that you only use RTTI
when you must.</p>

<p class=MsoNormal>However, using virtual functions as they are intended
requires that you have control of the base-class definition, because at some
point in the extension of your program you may discover the base class doesn’t
include the virtual function you need. If the base class comes from a library
or is otherwise controlled by someone else, one solution to the problem is RTTI;
you can derive a new type and add your extra member function. Elsewhere in the
code you can detect your particular type and call that member function. This
doesn’t destroy the polymorphism and extensibility of the program, because
adding a new type will not require you to hunt for switch statements. However,
when you add new code in the main body that requires your new feature, you’ll
have to detect your particular type.</p>

<p class=MsoNormal>Putting a feature in a base class might mean that, for the
benefit of one particular class, all the other classes derived from that base
require some meaningless stub for a pure virtual function. This makes the
interface less clear and annoys those who must override pure virtual functions
when they derive from that base class.</p>

<p class=MsoNormal>Finally, RTTI will sometimes solve efficiency problems. If your code uses polymorphism in a nice way, but it turns out that one of your objects
reacts to this general-purpose code in a horribly inefficient way, you can pick
that type out using RTTI and write case-specific code to improve the efficiency.</p>

<h3><a href="#_TocRef312374147" name="_Toc312374147">A trash recycler</a></h3>

<p class=MsoNormal>To further illustrate a practical use of RTTI, the following
program simulates a trash recycler. Different kinds of “trash” are inserted
into a single container and then later sorted according to their dynamic types.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:Trash.h</font></div>
<div class=CC1><font color=#dd0000>// Describing trash.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TRASH_H</font></div>
<div class=CC1><font color=#7F7F00>#define TRASH_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Trash {</div>
<div class=CC1>  <font color=#ff7700>float</font> _weight;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Trash(<font color=#ff7700>float</font> wt) : _weight(wt) {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>float</font> value() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  <font color=#ff7700>float</font> weight() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> _weight; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Trash() {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;~Trash()&quot;</font> &lt;&lt;
std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Aluminum : <font color=#ff7700>public</font> Trash {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>float</font> val;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Aluminum(<font color=#ff7700>float</font> wt) : Trash(wt) {}</div>
<div class=CC1>  <font color=#ff7700>float</font> value() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> val; }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> value(<font color=#ff7700>float</font> newval) {</div>
<div class=CC1>    val = newval;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Paper : <font color=#ff7700>public</font> Trash {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>float</font> val;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Paper(<font color=#ff7700>float</font> wt) : Trash(wt) {}</div>
<div class=CC1>  <font color=#ff7700>float</font> value() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> val; }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> value(<font color=#ff7700>float</font> newval) {</div>
<div class=CC1>    val = newval;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Glass : <font color=#ff7700>public</font> Trash {</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>float</font> val;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Glass(<font color=#ff7700>float</font> wt) : Trash(wt) {}</div>
<div class=CC1>  <font color=#ff7700>float</font> value() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> val; }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> value(<font color=#ff7700>float</font> newval) {</div>
<div class=CC1>    val = newval;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TRASH_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>static</b> values representing the price per unit of
the trash types are defined in the implementation file:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:Trash.cpp {O}</font></div>
<div class=CC1><font color=#dd0000>// A Trash Recycler.</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Trash.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>float</font> Aluminum::val = 1.67;</div>
<div class=CC1><font color=#ff7700>float</font> Paper::val = 0.10;</div>
<div class=CC1><font color=#ff7700>float</font> Glass::val = 0.23;</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>sumValue(&nbsp;)</b> template iterates through a
container, displaying and calculating results:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:Recycle.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Trash</font></div>
<div class=CC1><font color=#dd0000>// A Trash Recycler.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Trash.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Sums up the value of the Trash in a bin:</font></div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Container&gt;</div>
<div class=CC1><font color=#ff7700>void</font> sumValue(Container&amp; bin, ostream&amp; os) {</div>
<div class=CC1>  <font color=#ff7700>typename</font> Container::iterator tally = bin.begin();</div>
<div class=CC1>  <font color=#ff7700>float</font> val = 0;</div>
<div class=CC1>  <font color=#ff7700>while</font>(tally != bin.end()) {</div>
<div class=CC1>    val += (*tally)-&gt;weight() *
(*tally)-&gt;value();</div>
<div class=CC1>    os &lt;&lt; <font color=#007f00>&quot;weight of &quot;</font> &lt;&lt;
<font color=#ff7700>typeid</font>(**tally).name()</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot; = &quot;</font> &lt;&lt;
(*tally)-&gt;weight() &lt;&lt; endl;</div>
<div class=CC1>    ++tally;</div>
<div class=CC1>  }</div>
<div class=CC1>  os &lt;&lt; <font color=#007f00>&quot;Total value = &quot;</font> &lt;&lt; val
&lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  vector&lt;Trash*&gt; bin;</div>
<div class=CC1>  <font color=#dd0000>// Fill up the Trash bin:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 30; i++)</div>
<div class=CC1>    <font color=#ff7700>switch</font>(rand() % 3) {</div>
<div class=CC1>      <font color=#ff7700>case</font> 0 :</div>
<div class=CC1>        bin.push_back(<font color=#ff7700>new</font> Aluminum((rand() %
1000)/10.0));</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> 1 :</div>
<div class=CC1>        bin.push_back(<font color=#ff7700>new</font> Paper((rand() % 1000)/10.0));</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> 2 :</div>
<div class=CC1>        bin.push_back(<font color=#ff7700>new</font> Glass((rand() % 1000)/10.0));</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  <font color=#dd0000>// Note: bins hold exact type of object, not base
type:</font></div>
<div class=CC1>  vector&lt;Glass*&gt; glassBin;</div>
<div class=CC1>  vector&lt;Paper*&gt; paperBin;</div>
<div class=CC1>  vector&lt;Aluminum*&gt; alumBin;</div>
<div class=CC1>  vector&lt;Trash*&gt;::iterator sorter = bin.begin();</div>
<div class=CC1>  <font color=#dd0000>// Sort the Trash:</font></div>
<div class=CC1>  <font color=#ff7700>while</font>(sorter != bin.end()) {</div>
<div class=CC1>    Aluminum* ap =
<font color=#ff7700>dynamic_cast</font>&lt;Aluminum*&gt;(*sorter);</div>
<div class=CC1>    Paper* pp = <font color=#ff7700>dynamic_cast</font>&lt;Paper*&gt;(*sorter);</div>
<div class=CC1>    Glass* gp = <font color=#ff7700>dynamic_cast</font>&lt;Glass*&gt;(*sorter);</div>
<div class=CC1>    <font color=#ff7700>if</font>(ap) alumBin.push_back(ap);</div>
<div class=CC1>    <font color=#ff7700>else</font> <font color=#ff7700>if</font>(pp) paperBin.push_back(pp);</div>
<div class=CC1>    <font color=#ff7700>else</font> <font color=#ff7700>if</font>(gp) glassBin.push_back(gp);</div>
<div class=CC1>    ++sorter;</div>
<div class=CC1>  }</div>
<div class=CC1>  sumValue(alumBin, cout);</div>
<div class=CC1>  sumValue(paperBin, cout);</div>
<div class=CC1>  sumValue(glassBin, cout);</div>
<div class=CC1>  sumValue(bin, cout);</div>
<div class=CC1>  purge(bin);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The trash
is thrown unclassified into a single bin, so the specific type information is
“lost.” But later the specific type information must be recovered to properly
sort the trash, and so RTTI is used.</a></p>

<p class=MsoNormal>We can improve this solution by using a <b>map</b> that
associates pointers to <b>type_info</b> objects with a <b>vector</b> of <b>Trash</b>
pointers. Since a map requires an ordering predicate, we provide one named <b>TInfoLess</b>
that calls <b>type_info::before(&nbsp;)</b>. As we insert <b>Trash</b> pointers
into the map, they are automatically associated with their <b>type_info</b>
key. Notice that <b>sumValue(&nbsp;)</b> must be defined differently here:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C08:Recycle2.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Trash</font></div>
<div class=CC1><font color=#dd0000>// Recyling with a map.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;typeinfo&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;utility&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Trash.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Comparator for type_info pointers</font></div>
<div class=CC1><font color=#ff7700>struct</font> TInfoLess {</div>
<div class=CC1>  <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>()(<font color=#ff7700>const</font> type_info* t1, <font color=#ff7700>const</font> type_info*
t2)</div>
<div class=CC1>  <font color=#ff7700>const</font> { <font color=#ff7700>return</font> t1-&gt;before(*t2); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> map&lt;<font color=#ff7700>const</font> type_info*, vector&lt;Trash*&gt;,
TInfoLess&gt;</div>
<div class=CC1>  TrashMap;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Sums up the value of the Trash in a bin:</font></div>
<div class=CC1><font color=#ff7700>void</font> sumValue(<font color=#ff7700>const</font> TrashMap::value_type&amp; p,
ostream&amp; os) {</div>
<div class=CC1>  vector&lt;Trash*&gt;::const_iterator tally =
p.second.begin();</div>
<div class=CC1>  <font color=#ff7700>float</font> val = 0;</div>
<div class=CC1>  <font color=#ff7700>while</font>(tally != p.second.end()) {</div>
<div class=CC1>    val += (*tally)-&gt;weight() *
(*tally)-&gt;value();</div>
<div class=CC1>    os &lt;&lt; <font color=#007f00>&quot;weight of &quot;</font></div>
<div class=CC1>       &lt;&lt; p.first-&gt;name()  <font color=#dd0000>//
type_info::name()</font></div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot; = &quot;</font> &lt;&lt;
(*tally)-&gt;weight() &lt;&lt; endl;</div>
<div class=CC1>    ++tally;</div>
<div class=CC1>  }</div>
<div class=CC1>  os &lt;&lt; <font color=#007f00>&quot;Total value = &quot;</font> &lt;&lt; val
&lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  TrashMap bin;</div>
<div class=CC1>  <font color=#dd0000>// Fill up the Trash bin:</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 30; i++) {</div>
<div class=CC1>    Trash* tp;</div>
<div class=CC1>    <font color=#ff7700>switch</font>(rand() % 3) {</div>
<div class=CC1>      <font color=#ff7700>case</font> 0 :</div>
<div class=CC1>        tp = <font color=#ff7700>new</font> Aluminum((rand() % 1000)/10.0);</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> 1 :</div>
<div class=CC1>        tp = <font color=#ff7700>new</font> Paper((rand() % 1000)/10.0);</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> 2 :</div>
<div class=CC1>        tp = <font color=#ff7700>new</font> Glass((rand() % 1000)/10.0);</div>
<div class=CC1>        <font color=#ff7700>break</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>    bin[&amp;typeid(*tp)].push_back(tp);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Print sorted results</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(TrashMap::iterator p = bin.begin();</div>
<div class=CC1>      p != bin.end(); ++p) {</div>
<div class=CC1>    sumValue(*p, cout);</div>
<div class=CC1>    purge(p-&gt;second);</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We’ve modified <b>sumValue(&nbsp;)</b> to call <b>type_info::name(&nbsp;)</b>
directly, since the <b>type_info</b> object is now available as the first
member of the <b>TrashMap::value_type</b> pair. This avoids the extra call to <b>typeid</b>
to get the name of the type of <b>Trash</b> being processed that was necessary
in the previous version of this program.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312374148" name="_Toc312374148">Mechanism and overhead of RTTI</a></h2>

<p class=MsoNormal>Typically, RTTI is implemented by placing an additional pointer in a class’s virtual function table. This pointer points to the <b>type_info</b> structure for that particular type. The effect of a <b>typeid(&nbsp;)</b>
expression is quite simple: the virtual function table pointer fetches the <b>type_info</b>
pointer, and a reference to the resulting <b>type_info</b> structure is
produced. Since this is just a two-pointer dereference operation, it is a
constant time operation.</p>

<p class=MsoNormal>For a <b>dynamic_cast&lt;destination*&gt;(source_pointer)</b>,
most cases are quite straightforward: <b>source_pointer</b>’s RTTI information
is retrieved, and RTTI information for the type <b>destination*</b> is fetched.
A library routine then determines whether <b>source_pointer</b>’s type is of
type <b>destination*</b> or a base class of <b>destination*</b>. The pointer it
returns may be adjusted because of multiple inheritance if the base type isn’t the first base of the derived class. The situation is more complicated with
multiple inheritance because a base type may appear more than once in an
inheritance hierarchy and virtual base classes are used.</p>

<p class=MsoNormal>Because the library routine used for <b>dynamic_cast</b>
must check through a list of base classes, the overhead for <b>dynamic_cast</b>
may be higher than <b>typeid(&nbsp;)</b> (but you get different information,
which may be essential to your solution), and it may take more time to discover
a base class than a derived class. In addition, <b>dynamic_cast</b> compares
any type to any other type; you aren’t restricted to comparing types within the
same hierarchy. This adds extra overhead to the library routine used by <b>dynamic_cast</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593317" name="_Toc305593317">Summary</a></h2>

<p class=MsoNormal>Although normally you upcast a pointer to a base class and
then use the generic interface of that base class (via virtual functions),
occasionally you get into a corner where things can be more effective if you
know the dynamic type of the object pointed to by a base pointer, and that’s
what RTTI provides. The most common misuse may come from the programmer who
doesn’t understand virtual functions and uses RTTI to do type-check coding
instead. The philosophy of C++ seems to be to provide you with powerful tools
and guard for type violations and integrity, but if you want to deliberately
misuse or get around a language feature, there’s nothing to stop you. Sometimes
a slight burn is the fastest way to gain experience.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312374155" name="_Toc312374155">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>Base</b> class with a <b>virtual</b> destructor and a
<b>Derived</b> class that inherits from <b>Base</b>. Create a <b>vector</b> of <b>Base</b>
pointers that point to <b>Base</b> and <b>Derived</b> objects randomly. Using the
contents your <b>vector</b>, fill a second <b>vector</b> with all the <b>Derived</b>
pointers. Compare execution times between <b>typeid(&nbsp;)</b> and <b>dynamic_cast</b>
to see which is faster.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>C16:AutoCounter.h</b> in Volume 1 of this book so that
it becomes a useful debugging tool. It will be used as a nested member of each
class that you are interested in tracing. Turn <b>AutoCounter</b> into a
template that takes the class name of the surrounding class as the template
argument, and in all the error messages use RTTI to print the name of the
class.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Use RTTI to assist in program debugging by printing out the exact
name of a template using <b>typeid(&nbsp;)</b>. Instantiate the template for
various types and see what the results are.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify the <b>Instrument</b> hierarchy from Chapter 14 of Volume
1 by first copying <b>Wind5.cpp</b> to a new location. Now add a virtual <b>clearSpitValve(&nbsp;)</b>
function to the <b>Wind</b> class, and redefine it for all the classes
inherited from <b>Wind</b>. Instantiate a <b>vector</b> to hold <b>Instrument</b>
pointers, and fill it with various types of <b>Instrument</b> objects created
using the <b>new</b> operator. Now use RTTI to move through the container
looking for objects in class <b>Wind</b>, or derived from <b>Wind</b>. Call the
<b>clearSpitValve(&nbsp;)</b> function for these objects. Notice that it would
unpleasantly confuse the Instrument base class if it contained a <b>clearSpitValve(&nbsp;)</b>
function.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify the previous exercise to place a <b>prepareInstrument(&nbsp;)</b>
function in the base class, which calls appropriate functions (such as <b>clearSpitValve(&nbsp;)</b>,
when it fits). Note that <b>prepareInstrument(&nbsp;)</b> is a sensible
function to place in the base class, and it eliminates the need for RTTI in the
previous exercise.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>vector</b> of pointers to 10 random <b>Shape</b>
objects (at least <b>Square</b>s and <b>Circle</b>s, for example). The <b>draw(&nbsp;)</b>
member function should be overridden in each concrete class to print the
dimensions of the object being drawn (the length or the radius, whichever
applies). Write a <b>main(&nbsp;)</b> program that draws all the <b>Square</b>s
in your container first, sorted by length, and then draws all <b>Circle</b>s,
sorted by radius.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a large <b>vector</b> of pointers to random <b>Shape</b>
objects. Write a non-virtual <b>draw(&nbsp;)</b> function in <b>Shape</b> that
uses RTTI to determine the dynamic type of each object and executes the
appropriate code to “draw” the object with a switch statement. Then rewrite
your <b>Shape</b> hierarchy the “right way,” using virtual functions. Compare
the code sizes and execution times of the two approaches.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a hierarchy of <b>Pet</b> classes, including <b>Dog</b>, <b>Cat</b>,
and <b>Horse</b>. Also create a hierarchy of <b>Food</b> classes: <b>Beef</b>, <b>Fish</b>,
and <b>Oats</b>. The <b>Dog</b> class has a member function, <b>eat(&nbsp;)</b>,
that takes a <b>Beef</b> parameter, likewise, <b>Cat::eat(&nbsp;)</b> takes a <b>Fish</b>
object, and <b>Oats</b> objects are passed to <b>Horse::eat(&nbsp;)</b>. Create
a <b>vector</b> of pointers to random <b>Pet</b> objects, and visit each <b>Pet</b>,
passing the correct type of <b>Food</b> object to its <b>eat(&nbsp;)</b>
function.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a global function named <b>drawQuad(&nbsp;)</b> that takes
a reference to a <b>Shape</b> object. It calls the <b>draw(&nbsp;)</b> function
of its <b>Shape</b> parameter if it has four sides (that is, if it’s a <b>Square</b>
or <b>Rectangle</b>). Otherwise, it prints the message “Not a quadrilateral”.
Traverse a <b>vector</b> of pointers to random <b>Shape</b>s, calling <b>drawQuad(&nbsp;)</b>
for each one. Place <b>Square</b>s, <b>Rectangle</b>s, <b>Circle</b>s and <b>Triangle</b>s
in your <b>vector</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Sort a <b>vector</b> of random <b>Shape</b> objects by class
name. Use <b>type_info::before(&nbsp;)</b> as the comparison function for
sorting.</p>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:always'>
</span>

<div class=Section19>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985820" name="_Toc53985820">9: Multiple Inheritance</a></h1>

<p class=Intro style='margin-left:.25in'>The basic concept of multiple
inheritance (MI) sounds simple enough: you create a new type by inheriting from
more than one base class. The syntax is exactly what you’d expect, and as long
as the inheritance diagrams are simple, MI can be simple as well.</p>

<p class=MsoNormal>However, MI can introduce a number of ambiguities and
strange situations, which are covered in this chapter. But first, it is helpful
to get some perspective on the subject.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593286" name="_Toc305593286">Perspective</a></h2>

<p class=MsoNormal>Before C++, the most successful object-oriented language was
Smalltalk. Smalltalk was created from the ground up as an object-oriented
language. It is often referred to as <i>pure,</i> whereas C++ is called a <i>hybrid</i>
language because it supports multiple programming paradigms, not just the object-oriented paradigm. One of the design decisions made with Smalltalk was that all
classes would be derived in a single hierarchy, rooted in a single base class
(called <b>Object</b>—this is the model for the <i>object-based hierarchy</i>).<a href="#_ftn120" name="_ftnref120"><span
class=MsoFootnoteReference>[120]</span></a> You cannot
create a new class in Smalltalk without deriving it from an existing class,
which is why it takes a certain amount of time to become productive in
Smalltalk: you must learn the class library before you can start making new
classes. The Smalltalk class hierarchy is therefore a single monolithic tree.</p>

<p class=MsoNormal>Classes in Smalltalk usually have a number of things in
common, and they always have <i>some</i> things in common (the characteristics
and behaviors of <b>Object</b>), so you don’t often run into a situation where
you need to inherit from more than one base class. However, with C++ you can create as many distinct inheritance trees as you want. So for logical completeness the language
must be able to combine more than one class at a time—thus the need for multiple
inheritance.</p>

<p class=MsoNormal>It was not obvious, however, that programmers required
multiple inheritance, and there was (and still is) a lot of disagreement about
whether it is essential in C++. MI was added in AT&amp;T <b>cfront</b> release 2.0 in 1989 and was the first significant change to the language over
version 1.0.<a href="#_ftn121" name="_ftnref121"><span
class=MsoFootnoteReference>[121]</span></a> Since
then, a number of other features have been added to Standard C++ (notably
templates) that change the way we think about programming and place MI in a
much less important role. You can think of MI as a “minor” language feature
that is seldom involved in your daily design decisions.</p>

<p class=MsoNormal>One of the most pressing arguments for MI involved
containers. Suppose you want to create a container that everyone can easily
use. One approach is to use <b>void*</b> as the type inside the container. The
Smalltalk approach, however, is to make a container that holds <b>Object</b>s,
since <b>Object</b> is the base type of the Smalltalk hierarchy. Because
everything in Smalltalk is ultimately derived from <b>Object</b>, a container
that holds <b>Object</b>s can hold anything.</p>

<p class=MsoNormal>Now consider the situation in C++. Suppose vendor <b>A</b>
creates an object-based hierarchy that includes a useful set of containers
including one you want to use called <b>Holder</b>. Next you come across vendor
<b>B</b>’s class hierarchy that contains some other class that is important to
you, a <b>BitImage</b> class, for example, that holds graphic images. The only
way to make a <b>Holder</b> of <b>BitImage</b>s is to derive a new class from
both <b>Object</b>, so it can be held in the <b>Holder</b>, and <b>BitImage</b>:</p>

<p class=Figure align=center style='margin-bottom:12.0pt;text-align:center'><img
width=279 height=185 src="TicV2_files/image013.gif"></p>

<p class=MsoNormal>This was seen as an important reason for MI, and a number of
class libraries were built on this model. However, as you saw in Chapter 5, the
addition of templates has changed the way containers are created, so this
situation is no longer a driving issue for MI.</p>

<p class=MsoNormal>The other reason you may need MI is related to design. You
can intentionally use MI to make a design more flexible or useful (or at least
seemingly so). An example of this is in the original <b>iostream</b> library
design (which still persists in today’s template design, as you saw in Chapter
4):</p>

<p class=MsoNormal align=center style='margin-left:0in;text-align:center'><img
width=371 height=253 src="TicV2_files/image014.gif"></p>

<p class=MsoNormal>Both <b>istream</b> and <b>ostream</b> are useful classes by
themselves, but they can also be derived from simultaneously by a class that
combines both their characteristics and behaviors. The class <b>ios</b>
provides what is common to all stream classes, and so in this case MI is a
code-factoring mechanism.</p>

<p class=MsoNormal>Regardless of what motivates you to use MI, it’s harder to
use than it might appear.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985822" name="_Toc53985822">Interface
inheritance</a></h2>

<p class=MsoNormal>One use of multiple inheritance that is not controversial
pertains to <i>interface inheritance</i>. In C++, all inheritance is <i>implementation
inheritance</i>, because everything in a base class, interface and
implementation, becomes part of a derived class. It is not possible to inherit
only part of a class (the interface alone, say). As Chapter 14 of Volume 1
explains, private and protected inheritance make it possible to restrict access
to members inherited from base classes when used by clients of a derived class
object, but this doesn’t affect the derived class; it still contains all base
class data and can access all non-private base class members.</p>

<p class=MsoNormal>Interface inheritance, on the other hand, only adds member
function <i>declarations</i> to a derived class interface and is not directly
supported in C++. The usual technique to simulate interface inheritance in C++
is to derive from an <i>interface class</i>, which is a class that contains
only declarations (no data or function bodies). These declarations will be pure
virtual functions, except for the destructor. Here is an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Interfaces.cpp</font></div>
<div class=CC1><font color=#dd0000>// Multiple interface inheritance.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Printable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Printable() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> print(ostream&amp;) <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Intable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Intable() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>int</font> toInt() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Stringable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Stringable() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> string toString() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Able : <font color=#ff7700>public</font> Printable, <font color=#ff7700>public</font> Intable,</div>
<div class=CC1>             <font color=#ff7700>public</font> Stringable {</div>
<div class=CC1>  <font color=#ff7700>int</font> myData;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Able(<font color=#ff7700>int</font> x) { myData = x; }</div>
<div class=CC1>  <font color=#ff7700>void</font> print(ostream&amp; os) <font color=#ff7700>const</font> { os &lt;&lt;
myData; }</div>
<div class=CC1>  <font color=#ff7700>int</font> toInt() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> myData; }</div>
<div class=CC1>  <span lang=SV>string toString() <font color=#ff7700>const</font> {</span></div>
<div class=CC1><span lang=SV>    ostringstream os;</span></div>
<div class=CC1><span lang=SV>    os &lt;&lt; myData;</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>return</font> os.str();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> testPrintable(<font color=#ff7700>const</font> Printable&amp; p) {</div>
<div class=CC1>  p.print(cout);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> testIntable(<font color=#ff7700>const</font> Intable&amp; n) {</div>
<div class=CC1>  cout &lt;&lt; n.toInt() + 1 &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> testStringable(<font color=#ff7700>const</font> Stringable&amp; s) {</div>
<div class=CC1>  cout &lt;&lt; s.toString() + <font color=#007f00>&quot;th&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Able a(7);</div>
<div class=CC1>  testPrintable(a);</div>
<div class=CC1>  testIntable(a);</div>
<div class=CC1>  testStringable(a);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class <b>Able</b> “implements” the interfaces <b>Printable</b>,
<b>Intable</b>, and <b>Stringable</b> because it provides implementations for
the functions they declare. Because <b>Able</b> derives from all three classes,
<b>Able</b> objects have multiple “is-a” relationships. For example, the object
<b>a</b> can act as a <b>Printable</b> object because its class, <b>Able</b>,
derives publicly from <b>Printable</b> and provides an implementation for <b>print(&nbsp;)</b>.
The test functions have no need to know the most-derived type of their
parameter; they just need an object that is substitutable for their parameter’s
type.</p>

<p class=MsoNormal>As usual, a template solution is more compact:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Interfaces2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Implicit interface inheritance via templates.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Able {</div>
<div class=CC1>  <font color=#ff7700>int</font> myData;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Able(<font color=#ff7700>int</font> x) { myData = x; }</div>
<div class=CC1>  <font color=#ff7700>void</font> print(ostream&amp; os) <font color=#ff7700>const</font> { os &lt;&lt; myData;
}</div>
<div class=CC1>  <font color=#ff7700>int</font> toInt() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> myData; }</div>
<div class=CC1>  <span lang=SV>string toString() <font color=#ff7700>const</font> {</span></div>
<div class=CC1><span lang=SV>    ostringstream os;</span></div>
<div class=CC1><span lang=SV>    os &lt;&lt; myData;</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>return</font> os.str();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Printable&gt;</div>
<div class=CC1><font color=#ff7700>void</font> testPrintable(<font color=#ff7700>const</font> Printable&amp; p) {</div>
<div class=CC1>  p.print(cout);</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Intable&gt;</div>
<div class=CC1><font color=#ff7700>void</font> testIntable(<font color=#ff7700>const</font> Intable&amp; n) {</div>
<div class=CC1>  cout &lt;&lt; n.toInt() + 1 &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Stringable&gt;</div>
<div class=CC1><font color=#ff7700>void</font> testStringable(<font color=#ff7700>const</font> Stringable&amp; s) {</div>
<div class=CC1>  cout &lt;&lt; s.toString() + <font color=#007f00>&quot;th&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Able a(7);</div>
<div class=CC1>  testPrintable(a);</div>
<div class=CC1>  testIntable(a);</div>
<div class=CC1>  testStringable(a);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The names <b>Printable</b>, <b>Intable</b>, and <b>Stringable</b>
are now just template parameters that assume the existence of the operations
indicated in their respective contexts. In other words, the test functions can
accept arguments of any type that provides a member function definition with
the correct signature and return type; deriving from a common base class in not
necessary. Some people are more comfortable with the first version because the
type names guarantee by inheritance that the expected interfaces are
implemented. Others are content with the fact that if the operations required
by the test functions are not satisfied by their template type arguments, the
error is still caught at compile time. The latter approach is technically a
“weaker” form of type checking than the former (inheritance) approach, but the
effect on the programmer (and the program) is the same. This is one form of weak typing that is acceptable to many of today’s C++ programmers.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985823" name="_Toc53985823">Implementation
inheritance</a></h2>

<p class=MsoNormal>As we stated earlier, C++ provides only implementation
inheritance, meaning that you always inherit <i>everything</i> from your base
classes. This can be good because it frees you from having to implement everything
in the derived class, as we had to do with the interface inheritance examples
earlier. A common use of multiple inheritance involves using <i>mixin classes</i>, which are classes that exist to add capabilities to other classes through
inheritance. Mixin classes are not intended to be instantiated by themselves.</p>

<p class=MsoNormal>As an example, suppose we are clients of a class that
supports access to a database. In this scenario, you only have a header file
available—part of the point here is that you don’t have access to the source
code for the implementation. For illustration, assume the following
implementation of a <b>Database</b> class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Database.h</font></div>
<div class=CC1><font color=#dd0000>// A prototypical resource class.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DATABASE_H</font></div>
<div class=CC1><font color=#7F7F00>#define DATABASE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> DatabaseError : std::runtime_error {</div>
<div class=CC1>  DatabaseError(<font color=#ff7700>const</font> std::string&amp; msg)</div>
<div class=CC1>    : std::runtime_error(msg) {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Database {</div>
<div class=CC1>  std::string dbid;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Database(<font color=#ff7700>const</font> std::string&amp; dbStr) : dbid(dbStr)
{}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Database() {}</div>
<div class=CC1>  <font color=#ff7700>void</font> open() <font color=#ff7700>throw</font>(DatabaseError) {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;Connected to &quot;</font>
&lt;&lt; dbid &lt;&lt; std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> close() {</div>
<div class=CC1>    std::cout &lt;&lt; dbid &lt;&lt; <font color=#007f00>&quot;
closed&quot;</font> &lt;&lt; std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Other database functions...</font></div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DATABASE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We’re leaving out actual database functionality (storing,
retrieving, and so on), but that’s not important here. Using this class
requires a database connection string and that you call <b>Database::open(&nbsp;)</b>
to connect and <b>Database::close(&nbsp;)</b> to disconnect:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:UseDatabase.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Database.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Database db(<font color=#007f00>&quot;MyDatabase&quot;</font>);</div>
<div class=CC1>  db.open();</div>
<div class=CC1>  <font color=#dd0000>// Use other db functions...</font></div>
<div class=CC1>  db.close();</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F7F>/* Output:</div>
<div class=CC1>connected to MyDatabase</div>
<div class=CC1>MyDatabase closed</div>
<div class=CC1>*/</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In a typical client-server situation, a client will have
multiple objects sharing a connection to a database. It is important that the
database eventually be closed, but only after access to it is no longer
required. It is common to encapsulate this behavior through a class that tracks
the number of client entities using the database connection and to
automatically terminate the connection when that count goes to zero. To add
reference counting to the <b>Database</b> class, we use multiple inheritance to
mix a class named <b>Countable</b> into the <b>Database</b> class to create a
new class, <b>DBConnection</b>. Here’s the <b>Countable</b> mixin class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Countable.h</font></div>
<div class=CC1><font color=#dd0000>// A &quot;mixin&quot; class.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef COUNTABLE_H</font></div>
<div class=CC1><font color=#7F7F00>#define COUNTABLE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Countable {</div>
<div class=CC1>  <font color=#ff7700>long</font> count;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  Countable() { count = 0; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Countable() { assert(count == 0); }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>long</font> attach() { <font color=#ff7700>return</font> ++count; }</div>
<div class=CC1>  <font color=#ff7700>long</font> detach() {</div>
<div class=CC1>    <font color=#ff7700>return</font> (--count &gt; 0) ? count : (<font color=#ff7700>delete</font> <font color=#ff7700>this</font>, 0);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>long</font> refCount() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> count; }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// COUNTABLE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>It is evident that this is not a standalone class because
its constructor is <b>protected</b>; it requires a friend or a derived class to
use it. It is important that the destructor is virtual, because it is called
only from the <b>delete this</b> statement in <b>detach(&nbsp;)</b>, and we
want derived objects to be properly destroyed.<a href="#_ftn122" name="_ftnref122"><span
class=MsoFootnoteReference>[122]</span></a></p>

<p class=MsoNormal>The <b>DBConnection</b> class inherits both <b>Database</b>
and <b>Countable</b> and provides a static <b>create(&nbsp;)</b> function that
initializes its <b>Countable</b> subobject. This is an example of the Factory
Method design pattern, discussed in the next chapter:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:DBConnection.h</font></div>
<div class=CC1><font color=#dd0000>// Uses a &quot;mixin&quot; class.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DBCONNECTION_H</font></div>
<div class=CC1><font color=#7F7F00>#define DBCONNECTION_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Countable.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Database.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DBConnection : <font color=#ff7700>public</font> Database, <font color=#ff7700>public</font> Countable
{</div>
<div class=CC1>  DBConnection(<font color=#ff7700>const</font> DBConnection&amp;); <font color=#dd0000>// Disallow
copy</font></div>
<div class=CC1>  DBConnection&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> DBConnection&amp;);</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  DBConnection(<font color=#ff7700>const</font> string&amp; dbStr)
<font color=#ff7700>throw</font>(DatabaseError)</div>
<div class=CC1>  : Database(dbStr) { open(); }</div>
<div class=CC1>  ~DBConnection() { close(); }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> DBConnection*</div>
<div class=CC1>  create(<font color=#ff7700>const</font> string&amp; dbStr) <font color=#ff7700>throw</font>(DatabaseError)
{</div>
<div class=CC1>    DBConnection* con = <font color=#ff7700>new</font> DBConnection(dbStr);</div>
<div class=CC1>    con-&gt;attach();</div>
<div class=CC1>    assert(con-&gt;refCount() == 1);</div>
<div class=CC1>    <font color=#ff7700>return</font> con;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Other added functionality as desired...</font></div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DBCONNECTION_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>We now have a reference-counted database connection without
modifying the <b>Database</b> class, and we can safely assume that it will not
be surreptitiously terminated. The opening and closing is done using the Resource Acquisition Is Initialization (RAII) idiom mentioned in Chapter 1 via the <b>DBConnection</b>
constructor and destructor. This makes the <b>DBConnection</b> easy to use:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:UseDatabase2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Tests the Countable &quot;mixin&quot; class.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DBConnection.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DBClient {</div>
<div class=CC1>  DBConnection* db;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DBClient(DBConnection* dbCon) {</div>
<div class=CC1>    db = dbCon;</div>
<div class=CC1>    db-&gt;attach();</div>
<div class=CC1>  }</div>
<div class=CC1>  ~DBClient() { db-&gt;detach(); }</div>
<div class=CC1>  <font color=#dd0000>// Other database requests using db…</font></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  DBConnection* db =
DBConnection::create(<font color=#007f00>&quot;MyDatabase&quot;</font>);</div>
<div class=CC1>  assert(db-&gt;refCount() == 1);</div>
<div class=CC1>  DBClient c1(db);</div>
<div class=CC1>  assert(db-&gt;refCount() == 2);</div>
<div class=CC1>  DBClient c2(db);</div>
<div class=CC1>  assert(db-&gt;refCount() == 3);</div>
<div class=CC1>  <font color=#dd0000>// Use database, then release attach from original
create</font></div>
<div class=CC1>  db-&gt;detach();</div>
<div class=CC1>  assert(db-&gt;refCount() == 2);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The call to <b>DBConnection::create(&nbsp;)</b> calls <b>attach(&nbsp;)</b>,
so when we’re finished, we must explicitly call <b>detach(&nbsp;)</b> to
release the original hold on the connection. Note that the <b>DBClient</b>
class also uses RAII to manage its use of the connection. When the program
terminates, the destructors for the two <b>DBClient</b> objects will decrement
the reference count (by calling <b>detach(&nbsp;)</b>, which <b>DBConnection</b>
inherited from <b>Countable</b>), and the database connection will be closed (because
of <b>Countable</b>’s virtual destructor) when the count reaches zero after the
object <b>c1</b> is destroyed.</p>

<p class=MsoNormal>A template approach is commonly used for mixin inheritance,
allowing the user to specify at compile time which flavor of mixin is desired.
This way you can use different reference-counting approaches without explicitly
defining <b>DBConnection</b> twice. Here’s how it’s done:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:DBConnection2.h</font></div>
<div class=CC1><font color=#dd0000>// A parameterized mixin.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DBCONNECTION2_H</font></div>
<div class=CC1><font color=#7F7F00>#define DBCONNECTION2_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Database.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::string;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Counter&gt;</div>
<div class=CC1><font color=#ff7700>class</font> DBConnection : <font color=#ff7700>public</font> Database, <font color=#ff7700>public</font> Counter {</div>
<div class=CC1>  DBConnection(<font color=#ff7700>const</font> DBConnection&amp;); <font color=#dd0000>// Disallow
copy</font></div>
<div class=CC1>  DBConnection&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> DBConnection&amp;);</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  DBConnection(<font color=#ff7700>const</font> string&amp; dbStr)
<font color=#ff7700>throw</font>(DatabaseError)</div>
<div class=CC1>  : Database(dbStr) { open(); }</div>
<div class=CC1>  ~DBConnection() { close(); }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> DBConnection* create(<font color=#ff7700>const</font> string&amp; dbStr)</div>
<div class=CC1>  <font color=#ff7700>throw</font>(DatabaseError) {</div>
<div class=CC1>    DBConnection* con = <font color=#ff7700>new</font> DBConnection(dbStr);</div>
<div class=CC1>    con-&gt;attach();</div>
<div class=CC1>    assert(con-&gt;refCount() == 1);</div>
<div class=CC1>    <font color=#ff7700>return</font> con;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Other added functionality as desired...</font></div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DBCONNECTION2_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The only change here is the template prefix to the class
definition (and renaming <b>Countable</b> to <b>Counter</b> for clarity). We
could also make the database class a template parameter (had we multiple
database access classes to choose from), but it is not a mixin since it is a
standalone class. The following example uses the original <b>Countable</b> as
the <b>Counter</b> mixin type, but we could use any type that implements the
appropriate interface (<b>attach(&nbsp;)</b>, <b>detach(&nbsp;)</b>, and so
on):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:UseDatabase3.cpp</font></div>
<div class=CC1><font color=#dd0000>// Tests a parameterized &quot;mixin&quot; class.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Countable.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DBConnection2.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DBClient {</div>
<div class=CC1>  DBConnection&lt;Countable&gt;* db;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DBClient(DBConnection&lt;Countable&gt;* dbCon) {</div>
<div class=CC1>    db = dbCon;</div>
<div class=CC1>    db-&gt;attach();</div>
<div class=CC1>  }</div>
<div class=CC1>  ~DBClient() { db-&gt;detach(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  DBConnection&lt;Countable&gt;* db =</div>
<div class=CC1>   
DBConnection&lt;Countable&gt;::create(<font color=#007f00>&quot;MyDatabase&quot;</font>);</div>
<div class=CC1>  assert(db-&gt;refCount() == 1);</div>
<div class=CC1>  DBClient c1(db);</div>
<div class=CC1>  assert(db-&gt;refCount() == 2);</div>
<div class=CC1>  DBClient c2(db);</div>
<div class=CC1>  assert(db-&gt;refCount() == 3);</div>
<div class=CC1>  db-&gt;detach();</div>
<div class=CC1>  assert(db-&gt;refCount() == 2);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The general pattern for multiple parameterized mixins is
simply</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> Mixin1, <font color=#ff7700>class</font> Mixin2, … , <font color=#ff7700>class</font>
MixinK&gt;</div>
<div class=CC1><font color=#ff7700>class</font> Subject : <font color=#ff7700>public</font> Mixin1,</div>
<div class=CC1>                <font color=#ff7700>public</font> Mixin2,</div>
<div class=CC1>                …</div>
<div class=CC1>                <font color=#ff7700>public</font> MixinK {…};</div>

</div>

<div class=CC1>&nbsp;</div>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985824" name="_Toc53985824">Duplicate
subobjects</a></h2>

<p class=MsoNormal>When you inherit from a base class, you get a copy of all the data members of that base class in your derived class. The following
program shows how multiple base subobjects might be laid out in memory:<a href="#_ftn123" name="_ftnref123"><span
class=MsoFootnoteReference>[123]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Offset.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates layout of subobjects with MI.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> A { <font color=#ff7700>int</font> x; };</div>
<div class=CC1><font color=#ff7700>class</font> B { <font color=#ff7700>int</font> y; };</div>
<div class=CC1><font color=#ff7700>class</font> C : <font color=#ff7700>public</font> A, <font color=#ff7700>public</font> B { <font color=#ff7700>int</font> z; };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(A) == &quot;</font> &lt;&lt;
<font color=#ff7700>sizeof</font>(A) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(B) == &quot;</font> &lt;&lt;
<font color=#ff7700>sizeof</font>(B) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;sizeof(C) == &quot;</font> &lt;&lt;
<font color=#ff7700>sizeof</font>(C) &lt;&lt; endl;</div>
<div class=CC1>  C c;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;&amp;c == &quot;</font> &lt;&lt; &amp;c
&lt;&lt; endl;</div>
<div class=CC1>  A* ap = &amp;c;</div>
<div class=CC1>  B* bp = &amp;c;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;ap == &quot;</font> &lt;&lt;
<font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>void</font>*&gt;(ap) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;bp == &quot;</font> &lt;&lt;
<font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>void</font>*&gt;(bp) &lt;&lt; endl;</div>
<div class=CC1>  C* cp = <font color=#ff7700>static_cast</font>&lt;C*&gt;(bp);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;cp == &quot;</font> &lt;&lt;
<font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>void</font>*&gt;(cp) &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;bp == cp? &quot;</font> &lt;&lt;
boolalpha &lt;&lt; (bp == cp) &lt;&lt; endl;</div>
<div class=CC1>  cp = 0;</div>
<div class=CC1>  bp = cp;</div>
<div class=CC1>  cout &lt;&lt; bp &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F7F>/* Output:</div>
<div class=CC1>sizeof(A) == 4</div>
<div class=CC1>sizeof(B) == 4</div>
<div class=CC1>sizeof(C) == 12</div>
<div class=CC1>&amp;c == 1245052</div>
<div class=CC1>ap == 1245052</div>
<div class=CC1>bp == 1245056</div>
<div class=CC1>cp == 1245052</div>
<div class=CC1>bp == cp? true</div>
<div class=CC1>0</div>
<div class=CC1>*/</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>As you can see, the <b>B</b> portion of the object <b>c</b>
is offset 4 bytes from the beginning of the entire object, suggesting the
following layout:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=96
height=190 src="TicV2_files/image015.gif"></p>

<p class=MsoNormal>The object <b>c</b> begins with it’s <b>A</b> subobject,
then the <b>B</b> portion, and finally the data from the complete type <b>C</b>
itself. Since a <b>C</b> is-an <b>A</b> and is-a <b>B</b>, it is possible to
upcast to either base type. When upcasting to an <b>A</b>, the resulting
pointer points to the <b>A</b> portion, which happens to be at the beginning of
the C object, so the address <b>ap</b> is the same as the expression <b>&amp;c</b>.
When upcasting to a <b>B</b>, however, the resulting pointer must point to
where the <b>B</b> subobject actually resides because class B knows nothing
about class <b>C</b> (or class <b>A</b>, for that matter). In other words, the
object pointed to by <b>bp</b> must be able to behave as a standalone <b>B</b>
object (except for any required polymorphic behavior).</p>

<p class=MsoNormal>When casting <b>bp</b> back to a <b>C*</b>, since the
original object was a <b>C</b> in the first place, the location where the <b>B</b>
subobject resides is known, so the pointer is adjusted back to the original
address of the complete object. If <b>bp</b> had been pointing to a standalone <b>B</b>
object instead of a <b>C</b> object in the first place, the cast would be
illegal.<a href="#_ftn124" name="_ftnref124"><span
class=MsoFootnoteReference>[124]</span></a> Furthermore,
in the comparison <b>bp == cp</b>, <b>cp</b> is implicitly converted to a <b>B*</b>,
since that is the only way to make the comparison meaningful (that is,
upcasting is always allowed), hence the <b>true</b> result. So when converting
back and forth between subobjects and complete types, the appropriate offset is
applied.</p>

<p class=MsoNormal>The null pointer requires special handling, obviously, since
blindly subtracting an offset when converting to or from a <b>B</b> subobject
will result in an invalid address if the pointer was zero to start with. For
this reason, when casting to or from a <b>B*</b>, the compiler generates logic
to check first to see if the pointer is zero. If it isn’t, it applies the
offset; otherwise, it leaves it as zero.</p>

<p class=MsoNormal>With the syntax we’ve seen so far, if you have multiple base
classes, and if those base classes in turn have a common base class, you will
have two copies of the top-level base, as you can see in the following example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Duplicate.cpp</font></div>
<div class=CC1><font color=#dd0000>// Shows duplicate subobjects.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> x;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Top(<font color=#ff7700>int</font> n) { x = n; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>public</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> y;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Left(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { y = n; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>public</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> z;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Right(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { z = n; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {</div>
<div class=CC1>  <font color=#ff7700>int</font> w;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Bottom(<font color=#ff7700>int</font> i, <font color=#ff7700>int</font> j, <font color=#ff7700>int</font> k, <font color=#ff7700>int</font> m)</div>
<div class=CC1>  : Left(i, k), Right(j, k) { w = m; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b(1, 2, 3, 4);</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>sizeof</font> b &lt;&lt; endl; <font color=#dd0000>// 20</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since the size of <b>b</b> is 20 bytes,<a href="#_ftn125" name="_ftnref125"><span
class=MsoFootnoteReference>[125]</span></a> there are
five integers altogether in a complete <b>Bottom</b> object. A typical class
diagram for this scenario usually appears as:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=348
height=233 src="TicV2_files/image016.gif"></p>

<p class=MsoNormal>This is the so-called “diamond inheritance”, but in this case it would be better rendered as:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=348
height=233 src="TicV2_files/image017.gif"></p>

<p class=MsoNormal>The awkwardness of this design surfaces in the constructor
for the <b>Bottom</b> class in the previous code. The user thinks that only
four integers are required, but which arguments should be passed to the two
parameters that <b>Left</b> and <b>Right</b> require? Although this design is
not inherently “wrong,” it is usually not what an application needs. It also
presents a problem when trying to convert a pointer to a <b>Bottom</b> object
to a pointer to <b>Top</b>. As we showed earlier, the address may need to be
adjusted, depending on where the subobject resides within the complete object,
but here there are <i>two</i> <b>Top</b> subobjects to choose from. The
compiler doesn’t know which to choose, so such an upcast is ambiguous and is
not allowed. The same reasoning explains why a <b>Bottom</b> object would not
be able to call a function that is only defined in <b>Top</b>. If such a
function <b>Top::f(&nbsp;)</b> existed, calling <b>b.f(&nbsp;)</b> above would
need to refer to a <b>Top</b> subobject as an execution context, and there are
two to choose from.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985825" name="_Toc53985825">Virtual
base classes</a></h2>

<p class=MsoNormal>What we usually want in such cases is <i>true</i> diamond
inheritance, where a single <b>Top</b> object is shared by both <b>Left</b> and
<b>Right</b> subobjects within a complete <b>Bottom</b> object, which is what
the first class diagram depicts. This is achieved by making <b>Top</b> a <i>virtual
base class</i> of <b>Left</b> and <b>Right</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:VirtualBase.cpp</font></div>
<div class=CC1><font color=#dd0000>// Shows a shared subobject via a virtual base.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>int</font> x;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Top(<font color=#ff7700>int</font> n) { x = n; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Top() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Top&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; t.x;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>int</font> y;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Left(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { y = n; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>int</font> z;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Right(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { z = n; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {</div>
<div class=CC1>  <font color=#ff7700>int</font> w;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Bottom(<font color=#ff7700>int</font> i, <font color=#ff7700>int</font> j, <font color=#ff7700>int</font> k, <font color=#ff7700>int</font> m)</div>
<div class=CC1>  : Top(i), Left(0, j), Right(0, k) { w = m; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Bottom&amp;
b) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; b.x &lt;&lt; ',' &lt;&lt; b.y
&lt;&lt; ',' &lt;&lt; b.z</div>
<div class=CC1>      &lt;&lt; ',' &lt;&lt; b.w;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b(1, 2, 3, 4);</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>sizeof</font> b &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; b &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>void</font>*&gt;(&amp;b)
&lt;&lt; endl;</div>
<div class=CC1>  Top* p = <font color=#ff7700>static_cast</font>&lt;Top*&gt;(&amp;b);</div>
<div class=CC1>  cout &lt;&lt; *p &lt;&lt; endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>void</font>*&gt;(p) &lt;&lt;
endl;</div>
<div class=CC1>  cout &lt;&lt; <font color=#ff7700>dynamic_cast</font>&lt;<font color=#ff7700>void</font>*&gt;(p) &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Each virtual base of a given type refers to the same object,
no matter where it appears in the hierarchy.<a href="#_ftn126" name="_ftnref126"><span
class=MsoFootnoteReference>[126]</span></a> This
means that when a <b>Bottom</b> object is instantiated, the object layout may
look something like this:</p>

<p class=MsoNormal align=center style='margin-bottom:0in;margin-bottom:.0001pt;
text-align:center'><img width=197 height=268 src="TicV2_files/image018.gif"></p>

<p class=MsoNormal>The <b>Left</b> and <b>Right</b> subobjects each have a
pointer (or some conceptual equivalent) to the shared <b>Top</b> subobject, and
all references to that subobject in <b>Left</b> and <b>Right</b> member
functions will go through those these pointers.<a href="#_ftn127" name="_ftnref127"><span
class=MsoFootnoteReference>[127]</span></a> Here, there
is no ambiguity when upcasting from a <b>Bottom</b> to a <b>Top</b> object,
since there is only one <b>Top</b> object to convert to.</p>

<p class=MsoNormal>The output of the previous program is as follows:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>36</div>
<div class=CC1>1,2,3,4</div>
<div class=CC1>1245032</div>
<div class=CC1>1</div>
<div class=CC1>1245060</div>
<div class=CC1>1245032</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The addresses printed suggest that this particular
implementation does indeed store the <b>Top</b> subobject at the end of the
complete object (although it’s not really important where it goes). The result
of a <b>dynamic_cast</b> to <b>void*</b> always resolves to the address of the
complete object.</p>

<p class=MsoNormal>Although it is technically illegal to do so<a href="#_ftn128" name="_ftnref128"><span
class=MsoFootnoteReference>[128]</span></a>, if you
remove the virtual destructor (and the <b>dynamic_cast</b> statement, so the
program will compile), the size of <b>Bottom</b> decreases to 24 bytes. That
seems to be a decrease equivalent to the size of three pointers. Why?</p>

<p class=MsoNormal>It’s important not to take these numbers too literally.
Other compilers we use manage only to increase the size by four bytes when the
virtual constructor is added. Not being compiler writers, we can’t tell you
their secrets. We can tell you, however, that with multiple inheritance, a
derived object must behave as if it has multiple VPTRs, one for each of its
direct base classes that also have virtual functions. It’s as simple as that.
Compilers make whatever optimizations their authors invent, but the behavior
must be the same.</p>

<p class=MsoNormal>The strangest thing in the previous code is the initializer
for <b>Top</b> in the <b>Bottom</b> constructor. Normally one doesn’t worry
about initializing subobjects beyond direct base classes, since all classes
take care of initializing their own bases. There are, however, multiple paths
from <b>Bottom</b> to <b>Top</b>, so relying on the intermediate classes <b>Left</b>
and <b>Right</b> to pass along the necessary initialization data results in an
ambiguity—who is responsible for performing the initialization? For this
reason, the <i>most derived class</i> must initialize a virtual base. But what
about the expressions in the <b>Left</b> and <b>Right</b> constructors that
also initialize <b>Top</b>? They are certainly necessary when creating
standalone <b>Left</b> or <b>Right</b> objects, but must be <i>ignored</i> when
a <b>Bottom</b> object is created (hence the zeros in their initializers in the
<b>Bottom</b> constructor—any values in those slots are ignored when the <b>Left</b>
and <b>Right</b> constructors execute in the context of a <b>Bottom</b>
object). The compiler takes care of all this for you, but it’s important to
understand where the responsibility lies. Always make sure that <i>all concrete
(nonabstract) classes</i> in a multiple inheritance hierarchy are aware of any
virtual bases and initialize them appropriately.</p>

<p class=MsoNormal>These rules of responsibility apply not only to
initialization, but to all operations that span the class hierarchy. Consider
the stream inserter in the previous code. We made the data protected so we
could “cheat” and access inherited data in <b>operator&lt;&lt;(ostream&amp;,
const Bottom&amp;)</b>. It usually makes more sense to assign the work of
printing each subobject to its corresponding class and have the derived class
call its base class functions as needed. What would happen if we tried that
with <b>operator&lt;&lt;(&nbsp;)</b>, as the following code illustrates?</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:VirtualBase2.cpp</font></div>
<div class=CC1><font color=#dd0000>// How NOT to implement operator&lt;&lt;.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> x;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Top(<font color=#ff7700>int</font> n) { x = n; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Top() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Top&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; t.x;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> y;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Left(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { y = n; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Left&amp; l) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font>
Top&amp;&gt;(l) &lt;&lt; ',' &lt;&lt; l.y;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> z;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Right(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { z = n; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Right&amp; r) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font>
Top&amp;&gt;(r) &lt;&lt; ',' &lt;&lt; r.z;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {</div>
<div class=CC1>  <font color=#ff7700>int</font> w;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Bottom(<font color=#ff7700>int</font> i, <font color=#ff7700>int</font> j, <font color=#ff7700>int</font> k, <font color=#ff7700>int</font> m)</div>
<div class=CC1>  : Top(i), Left(0, j), Right(0, k) { w = m; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Bottom&amp; b){</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font>
Left&amp;&gt;(b)</div>
<div class=CC1>      &lt;&lt; ',' &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font>
Right&amp;&gt;(b)</div>
<div class=CC1>      &lt;&lt; ',' &lt;&lt; b.w;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b(1, 2, 3, 4);</div>
<div class=CC1>  cout &lt;&lt; b &lt;&lt; endl;  <font color=#dd0000>// 1,2,1,3,4</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can’t just blindly share the responsibility upward in
the usual fashion, because the <b>Left</b> and <b>Right</b> stream inserters
each call the <b>Top</b> inserter, and again there will be duplication of data.
Instead you need to mimic what the compiler does with initialization. One
solution is to provide special functions in the classes that know about the virtual
base class, which ignore the virtual base when printing (leaving the job to the
most derived class):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:VirtualBase3.cpp</font></div>
<div class=CC1><font color=#dd0000>// A correct stream inserter.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> x;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Top(<font color=#ff7700>int</font> n) { x = n; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Top() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Top&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; t.x;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> y;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> specialPrint(ostream&amp; os) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#dd0000>// Only print Left's part</font></div>
<div class=CC1>    os &lt;&lt; ','&lt;&lt; y;</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Left(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { y = n; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Left&amp; l) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font>
Top&amp;&gt;(l) &lt;&lt; ',' &lt;&lt; l.y;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1>  <font color=#ff7700>int</font> z;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> specialPrint(ostream&amp; os) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#dd0000>// Only print Right's part</font></div>
<div class=CC1>    os &lt;&lt; ','&lt;&lt; z;</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Right(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> n) : Top(m) { z = n; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Right&amp; r) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font>
Top&amp;&gt;(r) &lt;&lt; ',' &lt;&lt; r.z;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {</div>
<div class=CC1>  <font color=#ff7700>int</font> w;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Bottom(<font color=#ff7700>int</font> i, <font color=#ff7700>int</font> j, <font color=#ff7700>int</font> k, <font color=#ff7700>int</font> m)</div>
<div class=CC1>  : Top(i), Left(0, j), Right(0, k) { w = m; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Bottom&amp; b){</div>
<div class=CC1>    os &lt;&lt; <font color=#ff7700>static_cast</font>&lt;<font color=#ff7700>const</font> Top&amp;&gt;(b);</div>
<div class=CC1>    <span lang=SV>b.Left::specialPrint(os);</span></div>
<div class=CC1><span lang=SV>    b.Right::specialPrint(os);</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>return</font> os &lt;&lt; ','
&lt;&lt; b.w;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b(1, 2, 3, 4);</div>
<div class=CC1>  cout &lt;&lt; b &lt;&lt; endl;  <font color=#dd0000>// 1,2,3,4</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>specialPrint(&nbsp;)</b> functions are <b>protected</b>
since they will be called only by <b>Bottom</b>. They print only their own data
and ignore their <b>Top</b> subobject because the <b>Bottom</b> inserter is in
control when these functions are called. The <b>Bottom</b> inserter must know
about the virtual base, just as a <b>Bottom</b> constructor needs to. This same
reasoning applies to assignment operators in a hierarchy with a virtual base,
as well as to any function, member or not, that wants to share the work
throughout all classes in the hierarchy.</p>

<p class=MsoNormal>Having discussed virtual base classes, we can now illustrate
the “full story” of object initialization. Since virtual bases give rise to shared subobjects, it makes sense that they should be available before the sharing
takes place. So the order of initialization of subobjects follows these rules,
recursively:</p>

<p class=Numbered style='margin-left:.95in'><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>All virtual base class subobjects are initialized, in top-down,
left-to-right order according to where they appear in class definitions.</p>

<p class=Numbered style='margin-left:.95in'><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Non-virtual base classes are then initialized in the usual order.</p>

<p class=Numbered style='margin-left:.95in'><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>All member objects are initialized in declaration order.</p>

<p class=Numbered style='margin-left:.95in'><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The complete object’s constructor executes.</p>

<p class=Numbered>The following program illustrates this behavior:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:VirtInit.cpp</font></div>
<div class=CC1><font color=#dd0000>// Illustrates initialization order with virtual bases.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> M {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  M(<font color=#ff7700>const</font> string&amp; s) { cout &lt;&lt; <font color=#007f00>&quot;M &quot;</font>
&lt;&lt; s &lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> A {</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  A(<font color=#ff7700>const</font> string&amp; s) : m(<font color=#007f00>&quot;in A&quot;</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;A &quot;</font> &lt;&lt; s &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~A() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> B {</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  B(<font color=#ff7700>const</font> string&amp; s) : m(<font color=#007f00>&quot;in B&quot;</font>)  {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;B &quot;</font> &lt;&lt; s &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~B() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> C {</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  C(<font color=#ff7700>const</font> string&amp; s) : m(<font color=#007f00>&quot;in C&quot;</font>)  {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;C &quot;</font> &lt;&lt; s &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~C() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> D {</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  D(<font color=#ff7700>const</font> string&amp; s) : m(<font color=#007f00>&quot;in D&quot;</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;D &quot;</font> &lt;&lt; s &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~D() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> E : <font color=#ff7700>public</font> A, <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> B, <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> C
{</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  E(<font color=#ff7700>const</font> string&amp; s) : A(<font color=#007f00>&quot;from E&quot;</font>),
B(<font color=#007f00>&quot;from E&quot;</font>),</div>
<div class=CC1>  <span lang=IT>C(<font color=#007f00>&quot;from E&quot;</font>), m(<font color=#007f00>&quot;in
E&quot;</font>) {</span></div>
<div class=CC1><span lang=IT>    </span>cout &lt;&lt; <font color=#007f00>&quot;E &quot;</font>
&lt;&lt; s &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> F : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> B, <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> C, <font color=#ff7700>public</font> D
{</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  F(<font color=#ff7700>const</font> string&amp; s) : B(<font color=#007f00>&quot;from F&quot;</font>),
C(<font color=#007f00>&quot;from F&quot;</font>),</div>
<div class=CC1>  D(<font color=#007f00>&quot;from F&quot;</font>), m(<font color=#007f00>&quot;in F&quot;</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;F &quot;</font> &lt;&lt; s &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> G : <font color=#ff7700>public</font> E, <font color=#ff7700>public</font> F {</div>
<div class=CC1>  M m;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  G(<font color=#ff7700>const</font> string&amp; s) : B(<font color=#007f00>&quot;from G&quot;</font>),
C(<font color=#007f00>&quot;from G&quot;</font>),</div>
<div class=CC1>  E(<font color=#007f00>&quot;from G&quot;</font>),  F(<font color=#007f00>&quot;from G&quot;</font>),
m(<font color=#007f00>&quot;in G&quot;</font>) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;G &quot;</font> &lt;&lt; s &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  G g(<font color=#007f00>&quot;from main&quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The classes in this code can be represented by the following
diagram:</p>

<p class=MsoNormal><img width=504 height=244 src="TicV2_files/image019.gif">Each
class has an embedded member of type <b>M</b>. Note that only four derivations
are virtual: <b>E</b> from <b>B</b> and <b>C</b>, and <b>F</b> from <b>B</b>
and <b>C</b>. The output of this program is:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>M in B</div>
<div class=CC1>B from G</div>
<div class=CC1>M in C</div>
<div class=CC1>C from G</div>
<div class=CC1>M in A</div>
<div class=CC1>A from E</div>
<div class=CC1><span lang=IT>M in E</span></div>
<div class=CC1><span lang=IT>E from G</span></div>
<div class=CC1><span lang=IT>M in D</span></div>
<div class=CC1>D from F</div>
<div class=CC1>M in F</div>
<div class=CC1>F from G</div>
<div class=CC1>M in G</div>
<div class=CC1>G from main</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The initialization of <b>g</b> requires its <b>E</b> and <b>F</b>
part to first be initialized, but the <b>B</b> and <b>C</b> subobjects are
initialized first because they are virtual bases and are initialized from <b>G</b>’s
initializer, <b>G</b> being the most-derived class. The class <b>B</b> has no
base classes, so according to rule 3, its member object <b>m</b> is initialized,
then its constructor prints “<b>B</b> from <b>G</b>”, and similarly for the <b>C</b>
subject of <b>E</b>. The <b>E</b> subobject requires <b>A</b>, <b>B</b>, and <b>C</b>
subobjects. Since <b>B</b> and <b>C</b> have already been initialized, the <b>A</b>
subobject of the <b>E</b> subobject is initialized next, and then the <b>E</b>
subobject itself. The same scenario repeats for <b>g</b>’s <b>F</b> subobject,
but without duplicating the initialization of the virtual bases.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985826" name="_Toc53985826">Name
lookup issues</a></h2>

<p class=MsoNormal>The ambiguities we have illustrated with subobjects apply to
any names, including function names. If a class has multiple direct base
classes that share member functions of the same name, and you call one of those
member functions, the compiler doesn’t know which one to choose. The following
sample program would report such an error:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:AmbiguousName.cpp {-xo}</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Top() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b;</div>
<div class=CC1>  b.f(); <font color=#dd0000>// Error here</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class <b>Bottom</b> has inherited two functions of the
same name (the signature is irrelevant, since name lookup occurs before
overload resolution), and there is no way to choose between them. The usual
technique to disambiguate the call is to qualify the function call with the
base class name:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:BreakTie.cpp</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Top() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>using</font> Left::f;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b;</div>
<div class=CC1>  b.f(); <font color=#dd0000>// Calls Left::f()</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The name <b>Left::f</b> is now found in the scope of <b>Bottom</b>,
so the name <b>Right::f</b> is not even considered. To introduce extra
functionality beyond what <b>Left::f(&nbsp;)</b> provides, you implement a <b>Bottom::f(&nbsp;)</b>
function that calls <b>Left::f(&nbsp;)</b>.</p>

<p class=MsoNormal>Functions with the same name occurring in different branches
of a hierarchy often conflict. The following hierarchy has no such problem:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Dominance.cpp</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Top() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Left : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Right : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> Top {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bottom : <font color=#ff7700>public</font> Left, <font color=#ff7700>public</font> Right {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Bottom b;</div>
<div class=CC1>  b.f(); <font color=#dd0000>// Calls Left::f()</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here, there is no explicit <b>Right::f(&nbsp;)</b>. Since <b>Left::f(&nbsp;)</b>
is the most derived, it is chosen. Why? Well, pretend that <b>Right</b> did not
exist, giving the single-inheritance hierarchy <b>Top &lt;= Left &lt;= Bottom</b>.
You would certainly expect <b>Left::f(&nbsp;)</b> to be the function called by
the expression <b>b.f(&nbsp;)</b> because of normal scope rules: a derived
class is considered a nested scope of a base class. In general, a name <b>A::f</b>
<i>dominates</i> the name <b>B::f</b> if <b>A</b> derives from <b>B</b>,
directly or indirectly, or in other words, if <b>A</b> is “more derived” in the
hierarchy than <b>B</b>.<a href="#_ftn129" name="_ftnref129"><span
class=MsoFootnoteReference>[129]</span></a> Therefore,
in choosing between two functions with the same name, the compiler chooses the
one that dominates. If there is no dominant name, there is an ambiguity.</p>

<p class=MsoNormal> The following program further illustrates the dominance
principle:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Dominance2.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> A {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~A() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> f() { cout &lt;&lt; <font color=#007f00>&quot;A::f\n&quot;</font>;
}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> B : <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> A {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt; <font color=#007f00>&quot;B::f\n&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> C : <font color=#ff7700>public</font> B {};</div>
<div class=CC1><font color=#ff7700>class</font> D : <font color=#ff7700>public</font> C, <font color=#ff7700>virtual</font> <font color=#ff7700>public</font> A {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  B* p = <font color=#ff7700>new</font> D;</div>
<div class=CC1>  p-&gt;f(); <font color=#dd0000>// Calls B::f()</font></div>
<div class=CC1>  <font color=#ff7700>delete</font> p;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class diagram for this hierarchy is</p>

<p class=MsoNormal align=center style='text-align:center'><img width=195
height=317 src="TicV2_files/image020.gif"></p>

<p class=MsoNormal>The class <b>A</b> is a (direct, in
this case) base class for <b>B</b>, and so the name <b>B::f</b> dominates <b>A::f</b>.</a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593291" name="_Toc305593291">Avoiding
MI</a></h2>

<p class=MsoNormal>When the question of whether to use multiple inheritance
comes up, ask at least two questions:</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Do you need to show the public interfaces of both these classes
through your new type? (See instead if one class can be contained within the
other, with only some of its interface exposed in the new class.)</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Do you need to upcast to both of the base classes? (This also
applies when you have more than two base classes.)</p>

<p class=MsoNormal>If you can answer “no” to either question, you can avoid
using MI and should probably do so.</p>

<p class=MsoNormal>Watch for the situation where one class needs to be upcast
only as a function argument. In that case, the class can be embedded and an
automatic type conversion function provided in your new class to produce a
reference to the embedded object. Any time you use an object of your new class
as an argument to a function that expects the embedded object, the type
conversion function is used.<a href="#_ftn130" name="_ftnref130"><span
class=MsoFootnoteReference>[130]</span></a> However,
type conversion can’t be used for normal polymorphic member function selection;
that requires inheritance. Preferring composition over inheritance is a good
overall design guideline.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593292" name="_Toc305593292">Extending
an interface</a></h2>

<p class=MsoNormal>One of the best uses for multiple inheritance involves code that’s out of your control. Suppose you’ve acquired a library that consists
of a header file and compiled member functions, but no source code for member
functions. This library is a class hierarchy with virtual functions, and it
contains some global functions that take pointers to the base class of the
library; that is, it uses the library objects polymorphically. Now suppose you
build an application around this library and write your own code that uses the
base class polymorphically.</p>

<p class=MsoNormal>Later in the development of the project or sometime during
its maintenance, you discover that the base-class interface provided by the
vendor doesn’t provide what you need: a function may be non-virtual and you
need it to be virtual, or a virtual function is completely missing in the
interface, but essential to the solution of your problem. Multiple inheritance can
be the solution.</p>

<p class=MsoNormal>For example, here’s the header file for a library you
acquire:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Vendor.h</font></div>
<div class=CC1><font color=#dd0000>// Vendor-supplied class header</font></div>
<div class=CC1><font color=#dd0000>// You only get this &amp; the compiled Vendor.obj.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef VENDOR_H</font></div>
<div class=CC1><font color=#7F7F00>#define VENDOR_H</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Vendor {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> v() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>void</font> f() <font color=#ff7700>const</font>; <font color=#dd0000>// Might want this to be virtual...</font></div>
<div class=CC1>  ~Vendor(); <font color=#dd0000>// Oops! Not virtual!</font></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Vendor1 : <font color=#ff7700>public</font> Vendor {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> v() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>void</font> f() <font color=#ff7700>const</font>;</div>
<div class=CC1>  ~Vendor1();</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> A(<font color=#ff7700>const</font> Vendor&amp;);</div>
<div class=CC1><font color=#ff7700>void</font> B(<font color=#ff7700>const</font> Vendor&amp;);</div>
<div class=CC1><font color=#dd0000>// Etc.</font></div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// VENDOR_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Assume the library is much bigger, with more derived classes
and a larger interface. Notice that it also includes the functions <b>A(&nbsp;)</b>
and <b>B(&nbsp;)</b>, which take a base reference and treat it polymorphically.
Here’s the implementation file for the library:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Vendor.cpp {O}</font></div>
<div class=CC1><font color=#dd0000>// Assume this is compiled and unavailable to you.</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Vendor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Vendor::v() <font color=#ff7700>const</font> { cout &lt;&lt;
<font color=#007f00>&quot;Vendor::v()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Vendor::f() <font color=#ff7700>const</font> { cout &lt;&lt;
<font color=#007f00>&quot;Vendor::f()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Vendor::~Vendor() { cout &lt;&lt; <font color=#007f00>&quot;~Vendor()&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Vendor1::v() <font color=#ff7700>const</font> { cout &lt;&lt;
<font color=#007f00>&quot;Vendor1::v()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> Vendor1::f() <font color=#ff7700>const</font> { cout &lt;&lt;
<font color=#007f00>&quot;Vendor1::f()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Vendor1::~Vendor1() { cout &lt;&lt;
<font color=#007f00>&quot;~Vendor1()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> A(<font color=#ff7700>const</font> Vendor&amp; v) {</div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>  v.v();</div>
<div class=CC1>  v.f();</div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> B(<font color=#ff7700>const</font> Vendor&amp; v) {</div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>  v.v();</div>
<div class=CC1>  v.f();</div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In your project, this source code is unavailable to you.
Instead, you get a compiled file as <b>Vendor.obj</b> or <b>Vendor.lib</b> (or
with the equivalent file suffixes for your system).</p>

<p class=MsoNormal>The problem occurs in the use of this library. First, the
destructor isn’t virtual.<a href="#_ftn131" name="_ftnref131"><span
class=MsoFootnoteReference>[131]</span></a> In
addition, <b>f(&nbsp;)</b> was not made virtual; we assume the library creator
decided it wouldn’t need to be. You also discover that the interface to the
base class is missing a function essential to the solution of your problem.
Also suppose you’ve already written a fair amount of code using the existing
interface (not to mention the functions <b>A(&nbsp;)</b> and <b>B(&nbsp;)</b>,
which are out of your control), and you don’t want to change it.</p>

<p class=MsoNormal>To repair the problem, create your own class interface and
multiply inherit a new set of derived classes from your interface and from the
existing classes:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C09:Paste.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Vendor</font></div>
<div class=CC1><font color=#dd0000>// Fixing a mess with MI.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Vendor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MyBase { <font color=#dd0000>// Repair Vendor interface</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> v() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> f() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  <font color=#dd0000>// New interface function:</font></div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> g() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~MyBase() { cout &lt;&lt;
<font color=#007f00>&quot;~MyBase()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Paste1 : <font color=#ff7700>public</font> MyBase, <font color=#ff7700>public</font> Vendor1 {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> v() <font color=#ff7700>const</font> {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Paste1::v()&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    Vendor1::v();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> f() <font color=#ff7700>const</font> {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Paste1::f()&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    Vendor1::f();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> g() <font color=#ff7700>const</font> { cout &lt;&lt; &quot;Paste1::g()”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Paste1() { cout &lt;&lt; &quot;~Paste1()” &lt;&lt;
endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Paste1&amp; p1p = *<font color=#ff7700>new</font> Paste1;</div>
<div class=CC1>  MyBase&amp; mp = p1p; <font color=#dd0000>// Upcast</font></div>
<div class=CC1>  cout &lt;&lt; &quot;calling f()” &lt;&lt; endl;</div>
<div class=CC1>  mp.f();  <font color=#dd0000>// Right behavior</font></div>
<div class=CC1>  cout &lt;&lt; &quot;calling g()” &lt;&lt; endl;</div>
<div class=CC1>  mp.g(); <font color=#dd0000>// New behavior</font></div>
<div class=CC1>  cout &lt;&lt; &quot;calling A(p1p)” &lt;&lt; endl;</div>
<div class=CC1>  A(p1p); <font color=#dd0000>// Same old behavior</font></div>
<div class=CC1>  cout &lt;&lt; &quot;calling B(p1p)” &lt;&lt; endl;</div>
<div class=CC1>  B(p1p);  <font color=#dd0000>// Same old behavior</font></div>
<div class=CC1>  cout &lt;&lt; &quot;delete mp” &lt;&lt; endl;</div>
<div class=CC1>  <font color=#dd0000>// Deleting a reference to a heap object:</font></div>
<div class=CC1>  <font color=#ff7700>delete</font> &amp;mp; <font color=#dd0000>// Right behavior</font></div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In <b>MyBase</b> (which does <i>not</i> use MI), both <b>f(&nbsp;)</b>
and the destructor are now virtual, and a new virtual function <b>g(&nbsp;)</b>
is added to the interface. Now each of the derived classes in the original
library must be re-created, mixing in the new interface with MI. The functions <b>Paste1::v(&nbsp;)</b>
and <b>Paste1::f(&nbsp;) </b>need to call only the original base-class versions
of their functions. But now, if you upcast to <b>MyBase</b> as in <b>main(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>MyBase* mp = p1p; <font color=#dd0000>// Upcast</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>any function calls made through <b>mp</b> will be
polymorphic, including <b>delete</b>. Also, the new interface function <b>g(&nbsp;)</b>
can be called through <b>mp</b>. Here’s the output of the program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>calling f()</div>
<div class=CC1>Paste1::f()</div>
<div class=CC1>Vendor1::f()</div>
<div class=CC1>calling g()</div>
<div class=CC1>Paste1::g()</div>
<div class=CC1>calling A(p1p)</div>
<div class=CC1><span lang=SV>Paste1::v()</span></div>
<div class=CC1><span lang=SV>Vendor1::v()</span></div>
<div class=CC1><span lang=SV>Vendor::f()</span></div>
<div class=CC1><span lang=SV>calling B(p1p)</span></div>
<div class=CC1><span lang=SV>Paste1::v()</span></div>
<div class=CC1><span lang=SV>Vendor1::v()</span></div>
<div class=CC1><span lang=SV>Vendor::f()</span></div>
<div class=CC1><span lang=SV><font color=#ff7700>delete</font> mp</span></div>
<div class=CC1><span lang=SV>~Paste1()</span></div>
<div class=CC1><span lang=SV>~Vendor1()</span></div>
<div class=CC1><span lang=SV>~Vendor()</span></div>
<div class=CC1>~MyBase()</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The original library functions <b>A(&nbsp;)</b> and <b>B(&nbsp;)</b>
still work the same (assuming the new <b>v(&nbsp;)</b> calls its base-class
version). The destructor is now <b>virtual</b> and exhibits the correct
behavior.</p>

<p class=MsoNormal>Although this is a messy example, it does occur in practice,
and it’s a good demonstration of where multiple inheritance is clearly
necessary: You must be able to upcast to both base classes.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef305593293" name="_Toc305593293">Summary</a></h2>

<p class=MsoNormal>One reason MI exists in C++ is that it is a hybrid language
and couldn’t enforce a single monolithic class hierarchy the way Smalltalk and
Java do. Instead, C++ allows many inheritance trees to be formed, so sometimes
you may need to combine the interfaces from two or more trees into a new class.</p>

<p class=MsoNormal>If no “diamonds” appear in your class hierarchy, MI is
fairly simple (although identical function signatures in base classes must
still be resolved). If a diamond appears, you may want to eliminate duplicate
subobjects by introducing virtual base classes. This not only adds confusion,
but the underlying representation becomes more complex and less efficient.</p>

<p class=MsoNormal>Multiple inheritance has been called the “goto of the ’90s.”<a href="#_ftn132" name="_ftnref132"><span
class=MsoFootnoteReference>[132]</span></a> This seems
appropriate because, like a goto, MI is best avoided in normal programming, but
can occasionally be very useful. It’s a “minor” but more advanced feature of
C++, designed to solve problems that arise in special situations. If you find
yourself using it often, you might want to take a look at your reasoning. Ask
yourself, “Must I upcast to all the base classes?” If not, your life will be
easier if you embed instances of all the classes you <i>don’t</i> need to
upcast to.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef312374109" name="_Toc312374109">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a base class <b>X</b> with a single constructor that takes
an <b>int</b> argument and a member function <b>f(&nbsp;)</b>, which takes no
arguments and returns <b>void</b>. Now derive <b>Y</b> and <b>Z</b> from <b>X</b>,
creating constructors for each of them that take a single <b>int</b> argument.
Next, derive <b>A</b> from <b>Y</b> and <b>Z</b>. Create an object of class <b>A</b>,
and call <b>f(&nbsp;)</b> for that object. Fix the problem with explicit
disambiguation.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Starting with the results of Exercise 1, create a pointer to an <b>X</b>
called <b>px</b> and assign to it the address of the object of type <b>A</b>
you created before. Fix the problem using a virtual base class. Now fix <b>X</b>
so you no longer have to call the constructor for <b>X</b> inside <b>A</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Starting with the results of Exercise 2, remove the explicit
disambiguation for <b>f(&nbsp;)</b> and see if you can call <b>f(&nbsp;)</b>
through <b>px</b>. Trace it to see which function gets called. Fix the problem
so the correct function will be called in a class hierarchy.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Make an <b>Animal</b> interface class with a <b>makeNoise(&nbsp;)</b>
function declaration. Make a <b>SuperHero</b> interface class with a <b>savePersonFromFire(&nbsp;)</b>
function declaration. Place a <b>move(&nbsp;)</b> function declaration in both
interface classes. (Remember to make your interface methods pure virtual.) Now
define three separate classes: <b>SuperlativeMan</b>, <b>Amoeba</b> (a
superhero of uncertain gender), and <b>TarantulaWoman</b>; <b>SuperlativeMan</b>
implements the <b>SuperHero</b> interface while <b>Amoeba</b> and <b>TarantulaWoman</b>
implement both <b>Animal</b> and <b>SuperHero</b>. Define two global functions <b>animalSound(Animal*)</b>
and <b>saveFromFire(SuperHero*)</b>. Invoke all the methods that are callable
from each interface in both of these functions.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Repeat the previous exercise, but use templates instead of
inheritance to implement the interfaces, as we did in <b>Interfaces2.cpp</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Define some concrete mixin classes that represent superhero
capabilities (such as <b>StopTrain</b>, <b>BendSteel</b>, <b>ClimbBuilding</b>,
etc.). Redo exercise 4 so that your derived <b>SuperHero</b> classes derive
from these mixins and call their member functions.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Repeat the previous exercise using templates by making your
superhero powers mixin template parameters. Use these powers to do some good in
the community.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Dropping the <b>Animal</b> interface from exercise 4, redefine <b>Amoeba</b>
to only implement <b>SuperHero</b>. Now define a <b>SuperlativeAmoeba</b> class
that inherits from both <b>SuperlativeMan</b> and <b>Amoeba</b>. Try to pass a <b>SuperlativeAmoeba</b>
object to <b>saveFromFire(&nbsp;)</b>. What do you have to do to make this
legal? How does using virtual inheritance change the size of your objects?</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Continuing with the previous exercise, add an integer <b>strengthFactor</b>
data member to <b>SuperHero</b> from exercise 4, along with a constructor to
initialize it. Add constructors in the three derived classes to initialize <b>strengthFactor</b>
as well. What must you do differently in <b>SuperlativeAmoeba</b>?</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Continuing with the previous exercise, add an <b>eatFood(&nbsp;)</b>
member function to both <b>SuperlativeMan</b> and <b>Amoeba</b> (but not <b>SuperlativeAmoeba</b>),
such that the two versions of <b>eatFood(&nbsp;)</b> take different types of
food objects (so the signatures of the two functions differ). What must you do
in <b>SuperlativeAmoeba</b> to call either <b>eatFood(&nbsp;)</b> function?
Why?</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Define a well-behaved output stream inserter and assignment
operator for <b>SuperlativeAmoeba</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>12.&nbsp;&nbsp;&nbsp;&nbsp;</span>Remove <b>SuperlativeAmoeba</b> from your hierarchy and modify <b>Amoeba</b>
to derive from both <b>SuperlativeMan</b> (which still derives from <b>SuperHero</b>)
and <b>SuperHero</b>. Implement a virtual <b>workout(&nbsp;)</b> function in
both <b>SuperHero</b> and <b>SuperlativeMan</b> (with identical signatures),
and call it with a <b>Amoeba</b> object. Which function gets called?</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>13.&nbsp;&nbsp;&nbsp;&nbsp;</span>Redefine <b>SuperlativeAmoeba</b> to use composition instead of
inheritance to act as a <b>SuperlativeMan</b> or <b>Amoeba</b>. Use conversion
operators to provide implicit upcasting. Compare this approach to the
inheritance approach.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>14.&nbsp;&nbsp;&nbsp;&nbsp;</span>Suppose you are given a pre-compiled <b>Person</b> class (you
only have the header and compiled object file). Suppose also that <b>Person</b>
has a non-virtual <b>work(&nbsp;)</b> function. Have <b>SuperHero</b> be able
to act as a mild-mannered ordinary <b>Person</b> by deriving from <b>Person</b>
and using the implementation of <b>Person::work(&nbsp;)</b>, but make <b>SuperHero::work(&nbsp;)</b>
virtual.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>15.&nbsp;&nbsp;&nbsp;&nbsp;</span>Define a reference-counted error logging mixin class, <b>ErrorLog</b>,
that holds a static file stream to which you can send messages. The class opens
the stream when its reference count exceeds 0 and closes the stream when the
count returns to 0 (and always appends to the file). Have objects of multiple
classes send messages to the static log stream. Watch the stream open and close
via trace statements in <b>ErrorLog</b>.</p>

<p class=ExercisesCharCharCharCharChar style='margin-left:.95in'><span
style='font-family:Verdana'>16.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>BreakTie.cpp</b> by adding a class named <b>VeryBottom</b>
that derives (non-virtually) from <b>Bottom</b>. <b>VeryBottom</b> should look
just like <b>Bottom</b> except change “Left” to “Right” in the <b>using</b>
declaration for <b>f</b>. Change <b>main(&nbsp;)</b> to instantiate a <b>VeryBottom</b>
instead of a <b>Bottom</b> object. Which <b>f(&nbsp;)</b> gets called?</p>

<p class=ExercisesCharCharCharCharChar>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section20>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985831" name="_Toc53985831">10: Design Patterns</a></h1>

<p class=Intro style='margin-left:.25in'>“… describe a problem which occurs
over and over again in our environment, and then describe the core of the
solution to that problem, in such a way that you can use this solution a
million times over, without ever doing it the same way twice”—Christopher
Alexander</p>

<p class=Intro style='margin-left:.25in'>This chapter introduces the important
and yet nontraditional “patterns” approach to program design.</p>

<p class=MsoNormal>The most important recent step forward in object-oriented
design is probably the “design patterns” movement, initially chronicled in <i>Design Patterns</i>, by Gamma, Helm, Johnson &amp; Vlissides (Addison Wesley,
1995),<a href="#_ftn133" name="_ftnref133"><span
class=MsoFootnoteReference>[133]</span></a> which is
commonly called the “Gang of Four” book (GoF). GoF shows 23 solutions to
particular classes of problems. In this chapter, we discuss the basic concepts
of design patterns and provide code examples that illustrate selected patterns.
This should whet your appetite for reading more about design patterns, a source
of what has now become an essential, almost mandatory vocabulary for
object-oriented programming.<a href="#_ftn134" name="_ftnref134"><span
class=MsoFootnoteReference>[134]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef408018794" name="_Toc408018794">The pattern concept</a></h2>

<p class=MsoNormal>Initially, you can think of a pattern as an especially
clever and insightful way to solve a particular class of problem. It appears
that a team of people have worked out all the angles of a problem and have come
up with the most general, flexible solution for that type of problem. This
problem could be one that you have seen and solved before, but your solution
probably didn’t have the kind of completeness you’ll see embodied in a pattern.
Furthermore, the pattern exists independently of any particular implementation
and it can be implemented in a number of ways.</p>

<p class=MsoNormal>Although they’re called “design patterns,” they really
aren’t tied to the realm of design. A pattern seems to stand apart from the
traditional way of thinking about analysis, design, and implementation.
Instead, a pattern embodies a complete idea within a program, and thus it might
also span the analysis phase and high-level design phase. However, because a
pattern often has a direct implementation in code, it might not show up until
low-level design or implementation (and you might not realize that you need a
particular pattern until you get to those phases).</p>

<p class=MsoNormal>The basic concept of a pattern can also be seen as the basic
concept of program design in general: adding layers of abstraction. Whenever you abstract something, you’re isolating particular details, and one of the most
compelling motivations for this is to <i>separate things that change from
things that stay the same</i>. Another way to put this is that once you find
some part of your program that’s likely to change, you’ll want to keep those
changes from propagating side effects throughout your code. If you achieve
this, your code will not only be easier to read and understand, but also easier
to maintain—which invariably results in lowered costs over time.</p>

<p class=MsoNormal>The most difficult part of developing an elegant and
maintainable design is often discovering what we call “the vector of change.” (Here, “vector” refers to the maximum gradient as understood in the sciences,
and not a container class.) This means finding the most important thing that
changes in your system or, put another way, discovering where your greatest
cost is. Once you discover the vector of change, you have the focal point
around which to structure your design.</p>

<p class=MsoNormal>So the goal of design patterns is to <i>encapsulate change</i>.
If you look at it this way, you’ve been seeing some design patterns already in
this book. For example, inheritance could be thought of as a design pattern
(albeit one implemented by the compiler). It expresses differences in behavior
(that’s the thing that changes) in objects that all have the same interface
(that’s what stays the same). Composition could also be considered a pattern,
since you can change—dynamically or statically—the objects that implement your
class, and thus the way that class works. Normally, however, features that are
directly supported by a programming language have not been classified as design
patterns.</p>

<p class=MsoNormal>You’ve also already seen another pattern that appears in
GoF: the <i>iterator</i>. This is the fundamental tool used in the design of
the STL, described earlier in this book. The iterator hides the particular
implementation of the container as you’re stepping through and selecting the
elements one by one. Iterators allow you to write generic code that performs an
operation on all the elements in a range without regard to the container that
holds the range. Thus, your generic code can be used with any container that
can produce iterators.</p>

<h3><a href="#_TocRef53985833" name="_Toc53985833">Prefer composition to inheritance</a></h3>

<p class=MsoNormal>The most important contribution of GoF may not be a pattern,
but rather a maxim that they introduce in Chapter 1: “Favor object composition
over class inheritance.” Understanding inheritance and polymorphism is such a
challenge that you may begin to assign undue importance to these techniques. We
see many over-complicated designs (our own included) that result from
“inheritance indulgence”— for example, many multiple inheritance designs evolve
by insisting that inheritance be used everywhere.</p>

<p class=MsoNormal>One of the guidelines in <i>Extreme Programming</i> is “Do the simplest thing that could possibly work.” A design that seems to want
inheritance can often be dramatically simplified by using composition instead,
and you will also discover that the result is more flexible, as you will
understand by studying some of the design patterns in this chapter. So when
pondering a design, ask yourself: “Could this be simpler using composition? Do
I really need inheritance here, and what is it buying me?”</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef408018796" name="_Toc408018796">Classifying patterns</a></h2>

<p class=MsoNormal>GoF discusses 23 patterns, classified under three purposes
(all of which revolve around the particular aspect that can vary):</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Creational</b>: How an object can be created. This often
involves isolating the details of object creation so your code isn’t dependent
on what types of objects there are and thus doesn’t have to be changed when you
add a new type of object. This chapter introduces Singleton, Factories, and
Builder.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Structural</b>: These affect the way objects are connected
with other objects to ensure that changes in the system don’t require changes
to those connections. Structural patterns are often dictated by project
constraints. In this chapter you’ll see Proxy and Adapter.</p>

<p class=Numbered><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Behavioral</b>: Objects that handle particular types of
actions within a program. These encapsulate processes that you want to perform,
such as interpreting a language, fulfilling a request, moving through a
sequence (as in an iterator), or implementing an algorithm. This chapter
contains examples of Command, Template Method, State, Strategy, Chain of
Responsibility, Observer, Multiple Dispatching, and Visitor.</p>

<p class=MsoNormal>GoF includes a section on each of its 23 patterns along with
one or more examples of each, typically in C++ but sometimes in Smalltalk. This
book will not repeat the details of the patterns shown in GoF since that book
stands on its own and should be studied separately. The description and
examples provided here are intended to give you a grasp of the patterns, so you
can get a feel for what patterns are about and why they are important.</p>

<h3><a href="#_TocRef11818297" name="_Toc11818297">Features, idioms,
patterns</a></h3>

<p class=MsoNormal>Work continues beyond what is in the GoF book. Since its
publication, there are more patterns and a more refined process for defining
design patterns.<a href="#_ftn135" name="_ftnref135"><span
class=MsoFootnoteReference>[135]</span></a> This
is important because it is not easy to identify new patterns or to properly
describe them. There is some confusion in the popular literature on what a
design pattern is, for example. Patterns are not trivial, nor are they
typically represented by features that are built into a programming language. Constructors and destructors, for example, could be called the “guaranteed
initialization and cleanup design pattern.” These are important and essential
constructs, but they’re routine language features and are not rich enough to be
considered design patterns.</p>

<p class=MsoNormal>Another non-example comes from various forms of aggregation. Aggregation is a completely fundamental principle in object-oriented
programming: you make objects out of other objects. Yet sometimes this idea is
erroneously classified as a pattern. This is unfortunate because it pollutes
the idea of the design pattern and suggests that anything that surprises you
the first time you see it should be made into a design pattern.</p>

<p class=MsoNormal>The Java language provides another misguided example: The
designers of the JavaBeans specification decided to refer to the simple
“get/set” naming convention as a design pattern (for example, <b>getInfo(&nbsp;)</b>
returns an <b>Info</b> property and <b>setInfo(&nbsp;)</b> changes it). This is
just a commonplace naming convention and in no way constitutes a design
pattern.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985836" name="_Toc53985836">Simplifying
Idioms</a></h2>

<p class=MsoNormal>Before getting into more complex techniques, it’s helpful to
look at some basic ways to keep code simple and straightforward.</p>

<h3><a href="#_TocRef53985837" name="_Toc53985837">Messenger</a></h3>

<p class=MsoNormal>The most trivial of these is the messenger,<a href="#_ftn136" name="_ftnref136"><span
class=MsoFootnoteReference>[136]</span></a> which
packages information into an object which is passed around, instead of passing
all the pieces around separately. Note that without the messenger, the code for
<b>translate(&nbsp;)</b> would be much more confusing to read:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:MessengerDemo.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Point { <font color=#dd0000>// A messenger</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>int</font> x, y, z; <font color=#dd0000>// Since it's just a carrier</font></div>
<div class=CC1>  Point(<font color=#ff7700>int</font> xi, <font color=#ff7700>int</font> yi, <font color=#ff7700>int</font> zi) : x(xi), y(yi), z(zi)
{}</div>
<div class=CC1>  Point(<font color=#ff7700>const</font> Point&amp; p) :  x(p.x), y(p.y), z(p.z)
{}</div>
<div class=CC1>  Point&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> Point&amp; rhs) {</div>
<div class=CC1>    x = rhs.x;</div>
<div class=CC1>    y = rhs.y;</div>
<div class=CC1>    z = rhs.z;</div>
<div class=CC1>    <font color=#ff7700>return</font> *<font color=#ff7700>this</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Point&amp; p)
{</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;x=&quot;</font> &lt;&lt; p.x
&lt;&lt; <font color=#007f00>&quot; y=&quot;</font> &lt;&lt; p.y</div>
<div class=CC1>              &lt;&lt; <font color=#007f00>&quot; z=&quot;</font> &lt;&lt; p.z;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Vector { <font color=#dd0000>// Mathematical vector</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>int</font> magnitude, direction;</div>
<div class=CC1>  Vector(<font color=#ff7700>int</font> m, <font color=#ff7700>int</font> d) : magnitude(m), direction(d) {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Space {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> Point translate(Point p, Vector v) {</div>
<div class=CC1>    <font color=#dd0000>// Copy-constructor prevents modifying the
original.</font></div>
<div class=CC1>    <font color=#dd0000>// A dummy calculation:</font></div>
<div class=CC1>    p.x += v.magnitude + v.direction;</div>
<div class=CC1>    p.y += v.magnitude + v.direction;</div>
<div class=CC1>    p.z += v.magnitude + v.direction;</div>
<div class=CC1>    <font color=#ff7700>return</font> p;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Point p1(1, 2, 3);</div>
<div class=CC1>  Point p2 = Space::translate(p1, Vector(11, 47));</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;p1: &quot;</font> &lt;&lt; p1 &lt;&lt;
<font color=#007f00>&quot; p2: &quot;</font> &lt;&lt; p2 &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The code here is trivialized to prevent distractions.</p>

<p class=MsoNormal>Since the goal of a messenger is only to carry data, that
data is made public for easy access. However, you may also have reasons to make
the fields private.</p>

<h3><a href="#_TocRef53985838" name="_Toc53985838">Collecting Parameter</a></h3>

<p class=MsoNormal>Messenger’s big brother is the collecting parameter, whose job is to capture information from the function to which it is passed.
Generally, this is used when the collecting parameter is passed to multiple
functions, so it’s like a bee collecting pollen.</p>

<p class=MsoNormal>A container makes an especially useful collecting parameter,
since it is already set up to dynamically add objects:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:CollectingParameterDemo.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> CollectingParameter : <font color=#ff7700>public</font> vector&lt;string&gt;
{};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Filler {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f(CollectingParameter&amp; cp) {</div>
<div class=CC1>    cp.push_back(<font color=#007f00>&quot;accumulating&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> g(CollectingParameter&amp; cp) {</div>
<div class=CC1>    cp.push_back(<font color=#007f00>&quot;items&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> h(CollectingParameter&amp; cp) {</div>
<div class=CC1>    cp.push_back(<font color=#007f00>&quot;as we go&quot;</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Filler filler;</div>
<div class=CC1>  CollectingParameter cp;</div>
<div class=CC1>  filler.f(cp);</div>
<div class=CC1>  filler.g(cp);</div>
<div class=CC1>  filler.h(cp);</div>
<div class=CC1>  vector&lt;string&gt;::iterator it = cp.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != cp.end())</div>
<div class=CC1>    cout &lt;&lt; *it++ &lt;&lt; <font color=#007f00>&quot; &quot;</font>;</div>
<div class=CC1>  cout &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The collecting parameter must have some way to set or insert
values. Note that by this definition, a messenger could be used as a collecting
parameter. The key is that a collecting parameter is passed about and modified
by the functions that receive it.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985839" name="_Toc53985839">Singleton</a></h2>

<p class=MsoNormal>Possibly the simplest GoF design pattern is the <i>Singleton</i>, which is a way to allow one and only one instance of a class. The
following program shows how to implement a Singleton in C++:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:SingletonPattern.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Singleton {</div>
<div class=CC1>  <font color=#ff7700>static</font> Singleton s;</div>
<div class=CC1>  <span lang=SV><font color=#ff7700>int</font> i;</span></div>
<div class=CC1><span lang=SV>  Singleton(<font color=#ff7700>int</font> x) : i(x) { }</span></div>
<div class=CC1><span lang=SV>  </span>Singleton&amp;
<font color=#ff7700>operator</font>=(Singleton&amp;);  <font color=#dd0000>// Disallowed</font></div>
<div class=CC1>  Singleton(<font color=#ff7700>const</font> Singleton&amp;);       <font color=#dd0000>// Disallowed</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> Singleton&amp; instance() { <font color=#ff7700>return</font> s; }</div>
<div class=CC1>  <font color=#ff7700>int</font> getValue() { <font color=#ff7700>return</font> i; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setValue(<font color=#ff7700>int</font> x) { i = x; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Singleton Singleton::s(47);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Singleton&amp; s = Singleton::instance();</div>
<div class=CC1>  cout &lt;&lt; s.getValue() &lt;&lt; endl;</div>
<div class=CC1>  Singleton&amp; s2 = Singleton::instance();</div>
<div class=CC1>  s2.setValue(9);</div>
<div class=CC1>  cout &lt;&lt; s.getValue() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The key to creating a Singleton is to prevent the client
programmer from having any control over the lifetime of the object. To do this,
declare all constructors <b>private</b>, and prevent the compiler from
implicitly generating any constructors. Note that the copy constructor and assignment operator (which intentionally have no implementations, since they
will never be called) are declared private to prevent any sort of copies being
made.</p>

<p class=MsoNormal>You must also decide how you’re going to create the object.
Here, it’s created statically, but you can also wait until the client
programmer asks for one and create it on demand. This is called <i>lazy initialization</i>, and it only makes sense if it is expensive to create your object,
and if you don’t always need it.</p>

<p class=MsoNormal>If you return a pointer instead of a reference, the user
could inadvertently delete the pointer, so the implementation above is
considered safest (the destructor can also be declared private or protected to
alleviate that problem). In any case, the object should be stored privately.</p>

<p class=MsoNormal>You provide access through public member functions. Here, <b>instance(&nbsp;)</b>
produces a reference to the <b>Singleton</b> object. The rest of the interface
(<b>getValue(&nbsp;)</b> and <b>setValue(&nbsp;)</b>) is the regular class
interface.</p>

<p class=MsoNormal>Note that you aren’t restricted to creating only one object.
This technique also supports the creation of a limited pool of objects. In that
case, however, you can be confronted with the problem of sharing objects in the
pool. If this is an issue, you can create a solution involving a check-out and
check-in of the shared objects.</p>

<h3><a href="#_TocRef53985840" name="_Toc53985840">Variations on Singleton</a></h3>

<p class=MsoNormal>Any <b>static</b> member object inside a class is an
expression of Singleton: one and only one will be made. So in a sense, the
language has direct support for the idea; we certainly use it on a regular
basis. However, there’s a problem with <b>static</b> objects (member or not):
the order of initialization, as described in Volume 1 of this book. If one <b>static</b>
object depends on another, it’s important that the objects are initialized in
the correct order.</p>

<p class=MsoNormal>In Volume 1, you were shown how to control initialization order by defining a static object inside a function. This delays the initialization
of the object until the first time the function is called. If the function
returns a reference to the static object, it gives you the effect of a
Singleton while removing much of the worry of static initialization. For
example, suppose you want to create a log file upon the first call to a
function that returns a reference to that log file. This header file will do
the trick:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:LogFile.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef LOGFILE_H</font></div>
<div class=CC1><font color=#7F7F00>#define LOGFILE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1>std::ofstream&amp; logfile();</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// LOGFILE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The implementation <i>must not be inlined</i> because that
would mean that the whole function, including the static object definition
within, could be duplicated in any translation unit where it’s included, which
violates C++’s one-definition rule.<a href="#_ftn137" name="_ftnref137"><span
class=MsoFootnoteReference>[137]</span></a> This
would most certainly foil the attempts to control the order of initialization
(but potentially in a subtle and hard-to-detect fashion). So the implementation
must be separate:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:LogFile.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LogFile.h&quot;</font></div>
<div class=CC1>std::ofstream&amp; logfile() {</div>
<div class=CC1>  <font color=#ff7700>static</font> std::ofstream log(<font color=#007f00>&quot;Logfile.log&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>return</font> log;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now the <b>log</b> object will not be initialized until the
first time <b>logfile(&nbsp;)</b> is called. So if you create a function:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:UseLog1.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef USELOG1_H</font></div>
<div class=CC1><font color=#7F7F00>#define USELOG1_H</font></div>
<div class=CC1><font color=#ff7700>void</font> f();</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// USELOG1_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>that uses <b>logfile(&nbsp;)</b> in its implementation:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:UseLog1.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;UseLog1.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LogFile.h&quot;</font></div>
<div class=CC1><font color=#ff7700>void</font> f() {</div>
<div class=CC1>  logfile() &lt;&lt; __FILE__ &lt;&lt; std::endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>And you use <b>logfile(&nbsp;) </b>again in another file:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:UseLog2.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} LogFile UseLog1</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;UseLog1.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LogFile.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#ff7700>void</font> g() {</div>
<div class=CC1>  logfile() &lt;&lt; __FILE__ &lt;&lt; endl;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  f();</div>
<div class=CC1>  g();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>the <b>log </b>object doesn’t get created until the first
call to <b>f(&nbsp;)</b>.</p>

<p class=MsoNormal>You can easily combine the creation of the static object
inside a member function with the Singleton class. <b>SingletonPattern.cpp</b> can be modified to use this approach:<a href="#_ftn138" name="_ftnref138"><span
class=MsoFootnoteReference>[138]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:SingletonPattern2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Meyers’ Singleton.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Singleton {</div>
<div class=CC1>  <font color=#ff7700>int</font> i;</div>
<div class=CC1>  Singleton(<font color=#ff7700>int</font> x) : i(x) { }</div>
<div class=CC1>  <font color=#ff7700>void</font> <font color=#ff7700>operator</font>=(Singleton&amp;);</div>
<div class=CC1>  Singleton(<font color=#ff7700>const</font> Singleton&amp;);</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> Singleton&amp; instance() {</div>
<div class=CC1>    <font color=#ff7700>static</font> Singleton s(47);</div>
<div class=CC1>    <font color=#ff7700>return</font> s;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> getValue() { <font color=#ff7700>return</font> i; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setValue(<font color=#ff7700>int</font> x) { i = x; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Singleton&amp; s = Singleton::instance();</div>
<div class=CC1>  cout &lt;&lt; s.getValue() &lt;&lt; endl;</div>
<div class=CC1>  Singleton&amp; s2 = Singleton::instance();</div>
<div class=CC1>  s2.setValue(9);</div>
<div class=CC1>  cout &lt;&lt; s.getValue() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>An especially interesting case occurs if two Singletons
depend on each other, like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:FunctionStaticSingleton.cpp</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Singleton1 {</div>
<div class=CC1>  Singleton1() {}</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> Singleton1&amp; ref() {</div>
<div class=CC1>    <font color=#ff7700>static</font> Singleton1 single;</div>
<div class=CC1>    <font color=#ff7700>return</font> single;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Singleton2 {</div>
<div class=CC1>  Singleton1&amp; s1;</div>
<div class=CC1>  Singleton2(Singleton1&amp; s) : s1(s) {}</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> Singleton2&amp; ref() {</div>
<div class=CC1>    <font color=#ff7700>static</font> Singleton2 single(Singleton1::ref());</div>
<div class=CC1>    <font color=#ff7700>return</font> single;</div>
<div class=CC1>  }</div>
<div class=CC1>  Singleton1&amp; f() { <font color=#ff7700>return</font> s1; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Singleton1&amp; s1 = Singleton2::ref().f();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When <b>Singleton2::ref(&nbsp;)</b> is called, it causes its
sole <b>Singleton2</b> object to be created. In the process of this creation, <b>Singleton1::ref(&nbsp;)</b>
is called, and that causes the sole <b>Singleton1</b> object to be created.
Because this technique doesn’t rely on the order of linking or loading, the
programmer has much better control over initialization, leading to fewer
problems.</p>

<p class=MsoNormal>Yet another variation on Singleton separates the
“Singleton-ness” of an object from its implementation. This is achieved using
the Curiously Recurring Template Pattern mentioned in Chapter 5:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:CuriousSingleton.cpp</font></div>
<div class=CC1><font color=#dd0000>// Separates a class from its Singleton-ness (almost).</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> Singleton {</div>
<div class=CC1>  Singleton(<font color=#ff7700>const</font> Singleton&amp;);</div>
<div class=CC1>  Singleton&amp; <font color=#ff7700>operator</font>=(<font color=#ff7700>const</font> Singleton&amp;);</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  Singleton() {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Singleton() {}</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> T&amp; instance() {</div>
<div class=CC1>    <font color=#ff7700>static</font> T theInstance;</div>
<div class=CC1>    <font color=#ff7700>return</font> theInstance;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// A sample class to be made into a Singleton</font></div>
<div class=CC1><font color=#ff7700>class</font> MyClass : <font color=#ff7700>public</font> Singleton&lt;MyClass&gt; {</div>
<div class=CC1>  <font color=#ff7700>int</font> x;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Singleton&lt;MyClass&gt;;</div>
<div class=CC1>  MyClass() { x = 0; }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> setValue(<font color=#ff7700>int</font> n) { x = n; }</div>
<div class=CC1>  <font color=#ff7700>int</font> getValue() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> x; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  MyClass&amp; m = MyClass::instance();</div>
<div class=CC1>  cout &lt;&lt; m.getValue() &lt;&lt; endl;</div>
<div class=CC1>  m.setValue(1);</div>
<div class=CC1>  cout &lt;&lt; m.getValue() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>MyClass</b> is made a Singleton by:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;Making
its constructor private or protected.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;Making
<b>Singleton&lt;MyClass&gt;</b> a friend.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.&nbsp;&nbsp;Deriving
<b>MyClass</b> from <b>Singleton&lt;MyClass&gt;</b>.</p>

<p class=MsoNormal>The self-referencing in step 3 may sound implausible, but as
we explained in Chapter 5, it works because there is only a static dependency
on the template argument in the <b>Singleton</b> template. In other words, the
code for the class <b>Singleton&lt;MyClass&gt;</b> can be instantiated by the
compiler because it is not dependent on the size of <b>MyClass</b>. It’s only
later, when <b>Singleton&lt;MyClass&gt;::instance(&nbsp;)</b> is first called,
that the size of <b>MyClass</b> is needed, and by then <b>MyClass</b> has been
compiled and its size is known.<a href="#_ftn139" name="_ftnref139"><span
class=MsoFootnoteReference>[139]</span></a></p>

<p class=MsoNormal>It’s interesting how intricate such a simple pattern as
Singleton can be, and we haven’t even addressed issues of thread safety. Finally,
Singleton should be used sparingly. True Singleton objects arise rarely, and
the last thing a Singleton should be used for is to replace a global variable.<a href="#_ftn140" name="_ftnref140"><span
class=MsoFootnoteReference>[140]</span></a></p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985841" name="_Toc53985841">Command:
choosing the operation</a></h2>

<p class=MsoNormal>The Command pattern is structurally very simple, but can
have an important impact on decoupling—and thus cleaning up—your code.</p>

<p class=MsoNormal>In <i>Advanced C++: Programming Styles And Idioms (Addison Wesley,
1992)</i>, Jim Coplien coins the term <i>functor</i> which is an object whose
sole purpose is to encapsulate a function (since “functor” has a meaning in
mathematics, we shall use the more explicit term <i>function object</i>). The point is to decouple the choice of function to be called from the site
where that function is called.</p>

<p class=MsoNormal>This term is mentioned but not used in GoF. However, the
theme of the function object is repeated in a number of patterns in that book.</p>

<p class=MsoNormal>A Command is a function object in its purest sense: a
function that’s an object. By wrapping a function in an object, you can pass it
to other functions or objects as a parameter, to tell them to perform this
particular operation in the process of fulfilling your request. You could say
that a <i>Command</i> is a Messenger that carries behavior.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:CommandPattern.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Command {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> execute() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Hello : <font color=#ff7700>public</font> Command {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> execute() { cout &lt;&lt; <font color=#007f00>&quot;Hello &quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> World : <font color=#ff7700>public</font> Command {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> execute() { cout &lt;&lt; <font color=#007f00>&quot;World! &quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> IAm : <font color=#ff7700>public</font> Command {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> execute() { cout &lt;&lt; <font color=#007f00>&quot;I'm the command
pattern!&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// An object that holds commands:</font></div>
<div class=CC1><font color=#ff7700>class</font> Macro {</div>
<div class=CC1>  vector&lt;Command*&gt; commands;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> add(Command* c) { commands.push_back(c); }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    vector&lt;Command*&gt;::iterator it =
commands.begin();</div>
<div class=CC1>    <font color=#ff7700>while</font>(it != commands.end())</div>
<div class=CC1>      (*it++)-&gt;execute();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Macro macro;</div>
<div class=CC1>  macro.add(<font color=#ff7700>new</font> Hello);</div>
<div class=CC1>  macro.add(<font color=#ff7700>new</font> World);</div>
<div class=CC1>  macro.add(<font color=#ff7700>new</font> IAm);</div>
<div class=CC1>  macro.run();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The primary point of Command is to allow you to hand a
desired action to a function or object. In the above example, this provides a
way to queue a set of actions to be performed collectively. Here, you can dynamically
create new behavior, something you can normally only do by writing new code but
in the above example could be done by interpreting a script (see the Interpreter
pattern if what you need to do gets very complex).</p>

<p class=MsoNormal>GoF says that “Commands are an object-oriented replacement
for callbacks.”<a href="#_ftn141" name="_ftnref141"><span
class=MsoFootnoteReference>[141]</span></a> However,
we think that the word “back” is an essential part of the concept of
callbacks—a callback reaches back to the creator of the callback. On the other
hand, with a Command object you typically just create it and hand it to some function
or object, and you are not otherwise connected over time to the Command object.</p>

<p class=MsoNormal>A common example of Command is the implementation of “undo”
functionality in an application. Each time the user performs an operation, the
corresponding “undo” Command object is placed into a queue. Each Command object
that is executed backs up the state of the program by one step.</p>

<h3><a href="#_TocRef53985842" name="_Toc53985842">Decoupling event handling with Command</a></h3>

<p class=MsoNormal>As you shall see in the next chapter, one of the reasons for
employing <i>concurrency</i> techniques is to more easily manage <i>event-driven programming</i>, where the events can appear unpredictably in your
program. For example, a user pressing a “quit” button while you’re performing
an operation expects the program to respond quickly.</p>

<p class=MsoNormal>An argument for using concurrency is that it prevents
coupling across the pieces of your code. That is, if you’re running a separate
thread to watch the quit button, your program’s “normal” operations don’t need
to know about the quit button or any of the other operations that need to be
watched.</p>

<p class=MsoNormal>However, once you understand that coupling is the issue, you
can avoid it using the Command pattern. Each “normal” operation must
periodically call a function to check the state of the events, but with the
Command pattern these normal operations don’t need to know anything about what
they are checking, and thus are decoupled from the event-handling code:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:MulticastCommand.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Decoupling event management with the Command
pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Framework for running tasks:</font></div>
<div class=CC1><font color=#ff7700>class</font> Task {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> operation() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TaskRunner {</div>
<div class=CC1>  <font color=#ff7700>static</font> vector&lt;Task*&gt; tasks;</div>
<div class=CC1>  TaskRunner() {} <font color=#dd0000>// Make it a Singleton</font></div>
<div class=CC1>  TaskRunner&amp; <font color=#ff7700>operator</font>=(TaskRunner&amp;); <font color=#dd0000>//
Disallowed</font></div>
<div class=CC1>  TaskRunner(<font color=#ff7700>const</font> TaskRunner&amp;); <font color=#dd0000>// Disallowed</font></div>
<div class=CC1>  <font color=#ff7700>static</font> TaskRunner tr;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> add(Task&amp; t) {
tasks.push_back(&amp;t); }</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    vector&lt;Task*&gt;::iterator it = tasks.begin();</div>
<div class=CC1>    <font color=#ff7700>while</font>(it != tasks.end())</div>
<div class=CC1>      (*it++)-&gt;operation();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>TaskRunner TaskRunner::tr;</div>
<div class=CC1>vector&lt;Task*&gt; TaskRunner::tasks;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> EventSimulator {</div>
<div class=CC1>  clock_t creation;</div>
<div class=CC1>  clock_t delay;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  EventSimulator() : creation(clock()) {</div>
<div class=CC1>    delay = CLOCKS_PER_SEC/4 * (rand() % 20 + 1);</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;delay = &quot;</font> &lt;&lt; delay
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> fired() {</div>
<div class=CC1>    <font color=#ff7700>return</font> clock() &gt; creation + delay;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Something that can produce asynchronous events:</font></div>
<div class=CC1><font color=#ff7700>class</font> Button {</div>
<div class=CC1>  <font color=#ff7700>bool</font> pressed;</div>
<div class=CC1>  string id;</div>
<div class=CC1>  EventSimulator e; <font color=#dd0000>// For demonstration</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Button(string name) : pressed(<font color=#ff7700>false</font>), id(name) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> press() { pressed = <font color=#ff7700>true</font>; }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isPressed() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(e.fired()) press(); <font color=#dd0000>// Simulate the event</font></div>
<div class=CC1>    <font color=#ff7700>return</font> pressed;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Button&amp;
b) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; b.id;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The Command object</font></div>
<div class=CC1><font color=#ff7700>class</font> CheckButton : <font color=#ff7700>public</font> Task {</div>
<div class=CC1>  Button&amp; button;</div>
<div class=CC1>  <font color=#ff7700>bool</font> handled;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  CheckButton(Button &amp; b) : button(b),
handled(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> operation() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(button.isPressed() &amp;&amp; !handled) {</div>
<div class=CC1>      cout &lt;&lt; button &lt;&lt; <font color=#007f00>&quot;
pressed&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>      handled = <font color=#ff7700>true</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The procedures that perform the main processing.
These</font></div>
<div class=CC1><font color=#dd0000>// need to be occasionally &quot;interrupted&quot; in
order to</font></div>
<div class=CC1><font color=#dd0000>// check the state of the buttons or other events:</font></div>
<div class=CC1><font color=#ff7700>void</font> procedure1() {</div>
<div class=CC1>  <font color=#dd0000>// Perform procedure1 operations here.</font></div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>  TaskRunner::run(); <font color=#dd0000>// Check all events</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> procedure2() {</div>
<div class=CC1>  <font color=#dd0000>// Perform procedure2 operations here.</font></div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>  TaskRunner::run(); <font color=#dd0000>// Check all events</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> procedure3() {</div>
<div class=CC1>  <font color=#dd0000>// Perform procedure3 operations here.</font></div>
<div class=CC1>  <font color=#dd0000>// ...</font></div>
<div class=CC1>  TaskRunner::run(); <font color=#dd0000>// Check all events</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Randomize</font></div>
<div class=CC1>  Button b1(<font color=#007f00>&quot;Button 1&quot;</font>), b2(<font color=#007f00>&quot;Button
2&quot;</font>), b3(<font color=#007f00>&quot;Button 3&quot;</font>);</div>
<div class=CC1>  CheckButton cb1(b1), cb2(b2), cb3(b3);</div>
<div class=CC1>  TaskRunner::add(cb1);</div>
<div class=CC1>  TaskRunner::add(cb2);</div>
<div class=CC1>  TaskRunner::add(cb3);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Control-C to exit&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  <font color=#ff7700>while</font>(<font color=#ff7700>true</font>) {</div>
<div class=CC1>    procedure1();</div>
<div class=CC1>    procedure2();</div>
<div class=CC1>    procedure3();</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here, the Command object is represented by <b>Task</b>s
executed by the Singleton <b>TaskRunner</b>. <b>EventSimulator</b> creates a
random delay time, so if you periodically call <b>fired(&nbsp;)</b> the result
will change from <b>false</b> to <b>true</b> at some random time. <b>EventSimulator</b>
objects are used inside <b>Button</b>s to simulate the act of a user event
occurring at some unpredictable time. <b>CheckButton</b> is the implementation
of the <b>Task</b> that is periodically checked by all the “normal” code in the
program—you can see this happening at the end of <b>procedure1(&nbsp;)</b>, <b>procedure2(&nbsp;)</b>
and <b>procedure3(&nbsp;)</b>.</p>

<p class=MsoNormal>Although this requires a little bit of extra thought to set
up, you’ll see in Chapter 11 that threading requires a <i>lot</i> of thought
and care to prevent the various difficulties inherent to concurrent
programming, so the simpler solution may be preferable. You can also create a
very simple threading scheme by moving the <b>TaskRunner::run(&nbsp;)</b> calls
into a multithreaded “timer” object. By doing this, you eliminate all coupling
between the “normal operations” (procedures, in the above example) and the
event code.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef41169699" name="_Toc41169699">Object decoupling</a></h2>

<p class=MsoNormal>Both Proxy and State provide a surrogate class. Your code talks to this surrogate class, and the real class that does the work is
hidden behind this surrogate class. When you call a function in the surrogate,
it simply turns around and calls the function in the implementing class. These
two patterns are so similar that, structurally, Proxy is simply a special case
of State. One is tempted to just lump the two together into a pattern called Surrogate,
but the <i>intent</i> of the two patterns is different. It can be easy to fall
into the trap of thinking that if the structure is the same, the patterns are
the same. You must always look to the intent of the pattern in order to be
clear about what it does.</p>

<p class=MsoNormal>The basic idea is simple: from a base class, the surrogate
is derived along with the class or classes that provide the actual
implementation:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=479
height=185 src="TicV2_files/image021.gif"></p>

<p class=MsoNormal>When a surrogate object is created, it is given an
implementation to which it sends the function calls.</p>

<p class=MsoNormal>Structurally, the difference between Proxy and State is
simple: a Proxy has only one implementation, while State has more than one. The
application of the patterns is considered (in GoF) to be distinct: Proxy
controls access to its implementation, while State changes the implementation
dynamically. However, if you expand your notion of “controlling access to
implementation” then the two seem to be part of a continuum.</p>

<h3><a href="#_TocRef476705899" name="_Toc476705899">Proxy</a>: fronting for another object</h3>

<p class=MsoNormal>If we implement Proxy using the above diagram, it looks like
this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:ProxyDemo.cpp</font></div>
<div class=CC1><font color=#dd0000>// Simple demonstration of the Proxy pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> ProxyBase {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> f() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> g() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> h() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~ProxyBase() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Implementation : <font color=#ff7700>public</font> ProxyBase {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() { cout &lt;&lt;
<font color=#007f00>&quot;Implementation.f()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> g() { cout &lt;&lt;
<font color=#007f00>&quot;Implementation.g()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> h() { cout &lt;&lt;
<font color=#007f00>&quot;Implementation.h()&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Proxy : <font color=#ff7700>public</font> ProxyBase {</div>
<div class=CC1>  ProxyBase* implementation;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Proxy() { implementation = <font color=#ff7700>new</font> Implementation(); }</div>
<div class=CC1>  ~Proxy() { <font color=#ff7700>delete</font> implementation; }</div>
<div class=CC1>  <font color=#dd0000>// Forward calls to the implementation:</font></div>
<div class=CC1>  <font color=#ff7700>void</font> f() { implementation-&gt;f(); }</div>
<div class=CC1>  <font color=#ff7700>void</font> g() { implementation-&gt;g(); }</div>
<div class=CC1>  <font color=#ff7700>void</font> h() { implementation-&gt;h(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main()  {</div>
<div class=CC1>  Proxy p;</div>
<div class=CC1>  p.f();</div>
<div class=CC1>  p.g();</div>
<div class=CC1>  p.h();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In some cases, <b>Implementation</b> doesn’t need the same
interface as <b>Proxy</b>—as long as <b>Proxy</b> is somehow “speaking for” the
<b>Implementation </b>class and referring function calls to it, then the basic
idea is satisfied (note that this statement is at odds with the definition for
Proxy in GoF). However, with a common interface you are able to do a drop-in
replacement of the proxy into the client code—the client code is written to
talk to the original object, and it doesn’t need to be changed in order to
accept the proxy (This is probably the key issue with Proxy). In addition, <b>Implementation</b>
is forced, through the common interface, to fulfill all the functions that <b>Proxy</b>
needs to call.</p>

<p class=MsoNormal>The difference between Proxy and State is in the problems
that are solved. The common uses for Proxy as described in GoF are:</p>

<p class=Numbered style='line-height:14.0pt'><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Remote proxy</b>. This proxies for an object in a different
address space. This is implemented by some remote object technologies.</p>

<p class=Numbered style='line-height:14.0pt'><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Virtual proxy</b>. This provides “lazy initialization” to create expensive objects on demand.</p>

<p class=Numbered style='line-height:14.0pt'><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Protection proxy</b>. Used when you don’t want the client
programmer to have full access to the proxied object.</p>

<p class=Numbered style='line-height:14.0pt'><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>Smart reference</b>. To add additional actions when the
proxied object is accessed. <i>Reference counting</i> is an example: this keeps
track of the number of references that are held for a particular object, in
order to implement the <i>copy-on-write</i> idiom and prevent object aliasing.<a href="#_ftn142" name="_ftnref142"><span
class=MsoFootnoteReference>[142]</span></a> A simpler
example is counting the calls to a particular function.</p>

<h3><a href="#_TocRef476705900" name="_Toc476705900">State</a>: changing object behavior</h3>

<p class=MsoNormal>The State pattern produces an object that appears to change
its class, and is useful when you discover that you have conditional code in
most or all functions. Like Proxy, State is created by having a front-end
object that uses a back-end implementation object to fulfill its duties.
However, the State pattern switches from one implementation to another during
the lifetime of the front-end object, in order to produce different behavior
for the same function call(s). It’s a way to improve the implementation of your
code when you seem to be doing a lot of testing inside each of your functions
before deciding what to do for that function. For example, the fairy tale of
the frog-prince contains an object (the creature) that behaves differently
depending on what state it’s in. You could implement this by testing a <b>bool</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:KissingPrincess.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Creature {</div>
<div class=CC1>  <font color=#ff7700>bool</font> isFrog;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Creature() : isFrog(<font color=#ff7700>true</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> greet() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(isFrog)</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Ribbet!&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    <span lang=SV>else</span></div>
<div class=CC1><span lang=SV>      cout &lt;&lt; <font color=#007f00>&quot;Darling!&quot;</font>
&lt;&lt; endl;</span></div>
<div class=CC1><span lang=SV>  }</span></div>
<div class=CC1><span lang=SV>  <font color=#ff7700>void</font> kiss() { isFrog = <font color=#ff7700>false</font>; }</span></div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Creature creature;</div>
<div class=CC1>  creature.greet();</div>
<div class=CC1>  creature.kiss();</div>
<div class=CC1>  creature.greet();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>However, the <b>greet(&nbsp;)</b> function, and any other
functions that must test <b>isFrog</b> before they perform their operations,
end up with awkward code, especially if you find yourself adding additional
states to the system. By delegating the operations to a State object that can
be changed, this code is simplified.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:KissingPrincess2.cpp</font></div>
<div class=CC1><font color=#dd0000>// The State pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Creature {</div>
<div class=CC1>  <font color=#ff7700>class</font> State {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    <font color=#ff7700>virtual</font> string response() = 0;</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#ff7700>class</font> Frog : <font color=#ff7700>public</font> State {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    string response() { <font color=#ff7700>return</font> <font color=#007f00>&quot;Ribbet!&quot;</font>; }</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#ff7700>class</font> Prince : <font color=#ff7700>public</font> State {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    string response() { <font color=#ff7700>return</font> <font color=#007f00>&quot;Darling!&quot;</font>; }</div>
<div class=CC1>  };</div>
<div class=CC1>  State* state;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Creature() : state(<font color=#ff7700>new</font> Frog()) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> greet() {</div>
<div class=CC1>    cout &lt;&lt; state-&gt;response() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> kiss() {</div>
<div class=CC1>    <font color=#ff7700>delete</font> state;</div>
<div class=CC1>    state = <font color=#ff7700>new</font> Prince();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Creature creature;</div>
<div class=CC1>  creature.greet();</div>
<div class=CC1>  creature.kiss();</div>
<div class=CC1>  creature.greet();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>It is not necessary to make the implementing classes nested
or private, but if you can it creates cleaner code.</p>

<p class=MsoNormal>Note that changes to the State classes are automatically
propagated throughout your code, rather than requiring an edit across the
classes in order to effect changes.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef476705910" name="_Toc476705910">Adapter</a></h2>

<p class=MsoNormal>Adapter takes one type and produces an interface to some
other type. This is useful when you’re given a library or piece of code that
has a particular interface, and you’ve got a second library or piece of code
that uses the same basic ideas as the first piece, but expresses itself
differently. If you adapt the forms of expression to each other, you can
rapidly produce a solution.</p>

<p class=MsoNormal>Suppose you have a generator class that produces Fibonacci numbers:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=IT><font color=#dd0000>//: C10:FibonacciGenerator.h</span></font></div>
<div class=CC1><span lang=IT>#ifndef FIBONACCIGENERATOR_H</span></div>
<div class=CC1><span lang=IT>#define FIBONACCIGENERATOR_H</span></div>
<div class=CC1><span lang=IT>&nbsp;</span></div>
<div class=CC1><span lang=IT><font color=#ff7700>class</font> FibonacciGenerator {</span></div>
<div class=CC1><span lang=IT>  <font color=#ff7700>int</font> n;</span></div>
<div class=CC1><span lang=IT>  <font color=#ff7700>int</font> val[2];</span></div>
<div class=CC1><span lang=IT><font color=#ff7700>public</font>:</span></div>
<div class=CC1><span lang=IT>  FibonacciGenerator() : n(0) { val[0] =
val[1] = 0; }</span></div>
<div class=CC1><span lang=IT>  <font color=#ff7700>int</font> <font color=#ff7700>operator</font>()() {</span></div>
<div class=CC1><span lang=IT>    <font color=#ff7700>int</font> result = n &gt; 2 ? val[0] +
val[1] : n &gt; 0 ? 1 : 0;</span></div>
<div class=CC1><span lang=IT>    ++n;</span></div>
<div class=CC1><span lang=IT>    val[0] = val[1];</span></div>
<div class=CC1><span lang=IT>    </span>val[1] = result;</div>
<div class=CC1>    <font color=#ff7700>return</font> result;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> count() { <font color=#ff7700>return</font> n; }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// FIBONACCIGENERATOR_H
///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since it’s a generator, you use it by calling the <b>operator(&nbsp;)</b>,
like this:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><span lang=IT><font color=#dd0000>//: C10:FibonacciGeneratorTest.cpp</span></font></div>
<div class=CC1><span lang=IT>#include &lt;iostream&gt;</span></div>
<div class=CC1><font color=#7F7F00>#include &quot;FibonacciGenerator.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  FibonacciGenerator f;</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i =0; i &lt; 20; i++)</div>
<div class=CC1>    cout &lt;&lt; f.count() &lt;&lt; <font color=#007f00>&quot;: &quot;</font>
&lt;&lt; f() &lt;&lt; endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Perhaps you would like to take this generator and perform
STL numeric algorithm operations with it. Unfortunately, the STL algorithms
only work with iterators, so you have an interface mismatch. The solution is to
create an adapter that will take the <b>FibonacciGenerator</b> and produce an iterator for the STL algorithms to use. Since the numeric algorithms only require an
input iterator, the Adapter is fairly straightforward (for something that
produces an STL iterator, that is):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:FibonacciAdapter.cpp</font></div>
<div class=CC1><font color=#dd0000>// Adapting an interface to something you already have.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;numeric&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;FibonacciGenerator.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../C06/PrintSequence.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> FibonacciAdapter { <font color=#dd0000>// Produce an iterator</font></div>
<div class=CC1>  FibonacciGenerator f;</div>
<div class=CC1>  <font color=#ff7700>int</font> length;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  FibonacciAdapter(<font color=#ff7700>int</font> size) : length(size) {}</div>
<div class=CC1>  <font color=#ff7700>class</font> iterator;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> iterator;</div>
<div class=CC1>  <font color=#ff7700>class</font> iterator : <font color=#ff7700>public</font> std::iterator&lt;</div>
<div class=CC1>    std::input_iterator_tag, FibonacciAdapter,
ptrdiff_t&gt; {</div>
<div class=CC1>    FibonacciAdapter&amp; ap;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    <font color=#ff7700>typedef</font> <font color=#ff7700>int</font> value_type;</div>
<div class=CC1>    iterator(FibonacciAdapter&amp; a) : ap(a) {}</div>
<div class=CC1>    <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> iterator&amp;) <font color=#ff7700>const</font> {</div>
<div class=CC1>      <font color=#ff7700>return</font> ap.f.count() == ap.length;</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font> iterator&amp; x) <font color=#ff7700>const</font> {</div>
<div class=CC1>      <font color=#ff7700>return</font> !(*<font color=#ff7700>this</font> == x);</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>int</font> <font color=#ff7700>operator</font>*() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> ap.f(); }</div>
<div class=CC1>    iterator&amp; <font color=#ff7700>operator</font>++() { <font color=#ff7700>return</font> *<font color=#ff7700>this</font>; }</div>
<div class=CC1>    iterator <font color=#ff7700>operator</font>++(<font color=#ff7700>int</font>) { <font color=#ff7700>return</font> *<font color=#ff7700>this</font>; }</div>
<div class=CC1>  };</div>
<div class=CC1>  iterator begin() { <font color=#ff7700>return</font> iterator(*<font color=#ff7700>this</font>); }</div>
<div class=CC1>  iterator end() { <font color=#ff7700>return</font> iterator(*<font color=#ff7700>this</font>); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 20;</div>
<div class=CC1>  FibonacciAdapter a1(SZ);</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;accumulate: &quot;</font></div>
<div class=CC1>    &lt;&lt; accumulate(a1.begin(), a1.end(), 0)
&lt;&lt; endl;</div>
<div class=CC1>  <span lang=IT>FibonacciAdapter a2(SZ), a3(SZ);</span></div>
<div class=CC1><span lang=IT>  </span>cout &lt;&lt; <font color=#007f00>&quot;inner
product: &quot;</font></div>
<div class=CC1>    &lt;&lt; inner_product(a2.begin(), a2.end(),
a3.begin(), 0)</div>
<div class=CC1>    &lt;&lt; endl;</div>
<div class=CC1>  FibonacciAdapter a4(SZ);</div>
<div class=CC1>  <font color=#ff7700>int</font> r1[SZ] = {0};</div>
<div class=CC1>  <font color=#ff7700>int</font>* end = partial_sum(a4.begin(), a4.end(), r1);</div>
<div class=CC1>  print(r1, end, <font color=#007f00>&quot;partial_sum&quot;</font>, <font color=#007f00>&quot;
&quot;</font>);</div>
<div class=CC1>  FibonacciAdapter a5(SZ);</div>
<div class=CC1>  <font color=#ff7700>int</font> r2[SZ] = {0};</div>
<div class=CC1>  end = adjacent_difference(a5.begin(), a5.end(), r2);</div>
<div class=CC1>  print(r2, end, <font color=#007f00>&quot;adjacent_difference&quot;</font>,
<font color=#007f00>&quot; &quot;</font>);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You initialize a <b>FibonacciAdapter</b> by telling it how
long the Fibonacci sequence can be. When an <b>iterator</b> is created, it
simply captures a reference to the containing <b>FibonacciAdapter</b> so that
it can access the <b>FibonacciGenerator</b> and <b>length</b>. Note that the
equivalence comparison ignores the right-hand value because the only important
issue is whether the generator has reached its length. In addition, the <b>operator++(&nbsp;)</b>
doesn’t modify the iterator; the only operation that changes the state of the <b>FibonacciAdapter</b>
is calling the generator function <b>operator(&nbsp;)</b> on the <b>FibonacciGenerator</b>.
We can get away with this extremely simple version of the iterator because the
constraints on an Input Iterator are so strong; in particular, you can only
read each value in the sequence once.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, you can see that all four different
types of numeric algorithms are successfully tested with the <b>FibonacciAdapter</b>.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985847" name="_Toc53985847">Template
Method</a></h2>

<p class=MsoNormal>An application framework allows you to inherit from a class
or set of classes and create a new application, reusing most of the code in the
existing classes and overriding one or more functions in order to customize the
application to your needs. A fundamental concept in the application framework
is the Template Method, which is typically hidden beneath the covers and drives
the application by calling the various functions in the base class (some of
which you have overridden in order to create the application).</p>

<p class=MsoNormal>An important characteristic of the Template Method is that
it is defined in the base class (sometimes as a private member function) and
cannot be changed—the Template Method is the “thing that stays the same.” It
calls other base-class functions (the ones you override) in order to do its
job, but the client programmer isn’t necessarily able to call it directly, as
you can see here:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:TemplateMethod.cpp</font></div>
<div class=CC1><font color=#dd0000>// Simple demonstration of Template Method.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> ApplicationFramework {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> customize1() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> customize2() = 0;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> templateMethod() {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++) {</div>
<div class=CC1>      customize1();</div>
<div class=CC1>      customize2();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Create a new &quot;application&quot;:</font></div>
<div class=CC1><font color=#ff7700>class</font> MyApp : <font color=#ff7700>public</font> ApplicationFramework {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> customize1() { cout &lt;&lt; <font color=#007f00>&quot;Hello &quot;</font>;
}</div>
<div class=CC1>  <font color=#ff7700>void</font> customize2() { cout &lt;&lt; <font color=#007f00>&quot;World!&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  MyApp app;</div>
<div class=CC1>  app.templateMethod();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The “engine” that runs the application is the Template
Method. In a GUI application, this “engine” would be the main event loop. The
client programmer simply provides definitions for <b>customize1(&nbsp;)</b> and
<b>customize2(&nbsp;)</b> and the “application” is ready to run.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985848" name="_Toc53985848">Strategy:
choosing the algorithm at runtime</a></h2>

<p class=MsoNormal>Note that the Template Method is the “code that stays the
same,” and the functions that you override are the “code that changes.”
However, this change is fixed at compile time via inheritance. Following the
maxim of “prefer composition to inheritance,” we can use composition to
approach the problem of separating code that changes from code that stays the
same, and produce the Strategy pattern. This approach has a distinct benefit:
at runtime, you can plug in the code that changes. Strategy also adds a
“Context” which can be a surrogate class that controls the selection and use of
the particular strategy object—just like State!</p>

<p class=MsoNormal>“Strategy” means just that: you can solve a problem in a number
of ways. Consider the situation where you’ve forgotten someone’s name. Here are
the different ways you can cope:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:Strategy.cpp</font></div>
<div class=CC1><font color=#dd0000>// The Strategy design pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> NameStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> greet() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> SayHi : <font color=#ff7700>public</font> NameStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> greet() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Hi! How's it going?&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Ignore : <font color=#ff7700>public</font> NameStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> greet() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;(Pretend I don't see you)&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Admission : <font color=#ff7700>public</font> NameStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> greet() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;I'm sorry. I forgot your
name.&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The &quot;Context&quot; controls the strategy:</font></div>
<div class=CC1><font color=#ff7700>class</font> Context {</div>
<div class=CC1>  NameStrategy&amp; strategy;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Context(NameStrategy&amp; strat) : strategy(strat) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> greet() { strategy.greet(); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  SayHi sayhi;</div>
<div class=CC1>  Ignore ignore;</div>
<div class=CC1>  Admission admission;</div>
<div class=CC1>  Context c1(sayhi), c2(ignore), c3(admission);</div>
<div class=CC1>  c1.greet();</div>
<div class=CC1>  c2.greet();</div>
<div class=CC1>  c3.greet();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Context::greet(&nbsp;)</b> would normally be more complex;
it’s the analog of the Template Method because it contains the code that
doesn’t change. But you can see in <b>main(&nbsp;)</b> that the choice of
strategy can be made at runtime. If you go one step further you can combine
this with the State pattern and change the Strategy during the lifetime of the <b>Context</b>
object.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985849" name="_Toc53985849">Chain
of Responsibility: trying a sequence of strategies</a></h2>

<p class=MsoNormal>Chain of Responsibility might be thought of as a “dynamic
generalization of recursion” using Strategy objects. You make a call, and each Strategy
in a linked sequence tries to satisfy the call. The process ends when one of
the strategies is successful or the chain ends. In recursion, one function calls
itself over and over until a termination condition is reached; with Chain of
Responsibility, a function calls itself, which (by moving down the chain of Strategies)
calls a different implementation of the function, etc., until a termination
condition is reached. The termination condition is either that the bottom of
the chain is reached (this returns a default object; you may or may not be able
to provide a default result so you must be able to determine the success or
failure of the chain) or one of the Strategies is successful.</p>

<p class=MsoNormal>Instead of calling a single function to satisfy a request,
multiple functions in the chain have a chance to satisfy the request, so it has
the flavor of an expert system. Since the chain is effectively a list, it can
be dynamically created, so you could also think of it as a more general,
dynamically-built <b>switch</b> statement.</p>

<p class=MsoNormal>In GoF, there’s a fair amount of discussion of how to create
the chain of responsibility as a linked list. However, when you look at the
pattern it really shouldn’t matter how the chain is created; that’s an
implementation detail. Since GoF was written before the STL containers were
available in most C++ compilers, the reason for this is most likely (1) there
was no built-in list and thus they had to create one and (2) data structures
are often taught as a fundamental skill in academia, and the idea that data
structures should be standard tools available with the programming language may
not have occurred to the GoF authors. We maintain that the details of the container
used to implement Chain of Responsibility as a chain (in GoF, a linked list)
adds nothing to the solution and can just as easily be implemented using an STL
container, as shown below.</p>

<p class=MsoNormal>Here you can see Chain of Responsibility automatically
finding a solution using a mechanism to automatically recurse through each
Strategy in the chain:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:ChainOfReponsibility.cpp</font></div>
<div class=CC1><font color=#dd0000>// The approach of the five-year-old.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>enum</font> Answer { NO, YES };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> GimmeStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Answer canIHave() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~GimmeStrategy() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> AskMom : <font color=#ff7700>public</font> GimmeStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Answer canIHave() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Mooom? Can I have this?&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> NO;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> AskDad : <font color=#ff7700>public</font> GimmeStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Answer canIHave() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Dad, I really need this!&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> NO;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> AskGrandpa : <font color=#ff7700>public</font> GimmeStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Answer canIHave() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Grandpa, is it my birthday
yet?&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> NO;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> AskGrandma : <font color=#ff7700>public</font> GimmeStrategy {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Answer canIHave() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Grandma, I really love
you!&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> YES;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Gimme : <font color=#ff7700>public</font> GimmeStrategy {</div>
<div class=CC1>  vector&lt;GimmeStrategy*&gt; chain;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Gimme() {</div>
<div class=CC1>    chain.push_back(<font color=#ff7700>new</font> AskMom());</div>
<div class=CC1>    chain.push_back(<font color=#ff7700>new</font> AskDad());</div>
<div class=CC1>    chain.push_back(<font color=#ff7700>new</font> AskGrandpa());</div>
<div class=CC1>    chain.push_back(<font color=#ff7700>new</font> AskGrandma());</div>
<div class=CC1>  }</div>
<div class=CC1>  Answer canIHave() {</div>
<div class=CC1>    vector&lt;GimmeStrategy*&gt;::iterator it =
chain.begin();</div>
<div class=CC1>    <font color=#ff7700>while</font>(it != chain.end())</div>
<div class=CC1>      <font color=#ff7700>if</font>((*it++)-&gt;canIHave() == YES)</div>
<div class=CC1>        <font color=#ff7700>return</font> YES;</div>
<div class=CC1>    <font color=#dd0000>// Reached end without success...</font></div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Whiiiiinnne!&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> NO;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~Gimme() { purge(chain); }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Gimme chain;</div>
<div class=CC1>  chain.canIHave();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Notice that the “Context” class <b>Gimme</b> and all the
Strategy classes are all derived from the same base class, <b>GimmeStrategy</b>.</p>

<p class=MsoNormal>If you study the section on Chain of Responsibility in GoF,
you’ll find that the structure differs significantly from the one above because
they focus on creating their own linked list. However, if you keep in mind that
the essence of Chain of Responsibility is to try a number of solutions until
you find one that works, you’ll realize that the implementation of the
sequencing mechanism is not an essential part of the pattern.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985850" name="_Toc53985850">Factories:
encapsulating object creation</a></h2>

<p class=MsoNormal>When you discover that you need to add new types to a
system, the most sensible first step is to use polymorphism to create a common
interface to those new types. This separates the rest of the code in your
system from the knowledge of the specific types that you are adding. New types
can be added without disturbing existing code … or so it seems. At first it
would appear that you need to change the code only in the place where you inherit
a new type, but this is not quite true. You must still create an object of your
new type, and at the point of creation you must specify the exact constructor
to use. Thus, if the code that creates objects is distributed throughout your
application, you have the same problem when adding new types—you must still
chase down all the points of your code where type matters. It is the <i>creation</i>
of the type that matters here, rather than the <i>use</i> of the type (which is
taken care of by polymorphism), but the effect is the same: adding a new type
can cause problems.</p>

<p class=MsoNormal>The solution is to force the creation of objects to occur
through a common <i>factory</i> rather than to allow the creational code to be
spread throughout your system. If all the code in your program must go to this
factory whenever it needs to create one of your objects, all you must do when
you add a new object is modify the factory. This design is a variation of the
pattern commonly known as Factory Method. Since every object-oriented program
creates objects, and since it’s likely you will extend your program by adding
new types, factories may be the most useful of all design patterns.</p>

<p class=MsoNormal>As an example, consider the commonly-used <b>Shape</b>
example. One approach to implementing a factory is to define a <b>static</b>
member function in the base class:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:ShapeFactory1.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> erase() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Shape() {}</div>
<div class=CC1>  <font color=#ff7700>class</font> BadShapeCreation : <font color=#ff7700>public</font> logic_error {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    BadShapeCreation(string type)</div>
<div class=CC1>    : logic_error(<font color=#007f00>&quot;Cannot create type &quot;</font> +
type) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#ff7700>static</font> Shape* factory(<font color=#ff7700>const</font> string&amp; type)</div>
<div class=CC1>    <font color=#ff7700>throw</font>(BadShapeCreation);</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Circle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1>  Circle() {} <font color=#dd0000>// Private constructor</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Shape;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Circle::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> erase() { cout &lt;&lt; &quot;Circle::erase”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Circle() { cout &lt;&lt; &quot;Circle::~Circle”
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Square : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1>  Square() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Shape;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Square::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> erase() { cout &lt;&lt; &quot;Square::erase”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Square() { cout &lt;&lt; &quot;Square::~Square”
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Shape* Shape::factory(<font color=#ff7700>const</font> string&amp; type)</div>
<div class=CC1>  <font color=#ff7700>throw</font>(Shape::BadShapeCreation) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(type == <font color=#007f00>&quot;Circle&quot;</font>) <font color=#ff7700>return</font> <font color=#ff7700>new</font> Circle;</div>
<div class=CC1>  <font color=#ff7700>if</font>(type == <font color=#007f00>&quot;Square&quot;</font>) <font color=#ff7700>return</font> <font color=#ff7700>new</font> Square;</div>
<div class=CC1>  <font color=#ff7700>throw</font> BadShapeCreation(type);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>char</font>* sl[] = { <font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Square&quot;</font>,
<font color=#007f00>&quot;Square&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Circle&quot;</font>,
<font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Square&quot;</font> };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Shape*&gt; shapes;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; <font color=#ff7700>sizeof</font> sl / <font color=#ff7700>sizeof</font> sl[0];
i++)</div>
<div class=CC1>      shapes.push_back(Shape::factory(sl[i]));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Shape::BadShapeCreation e) {</div>
<div class=CC1>    cout &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>    purge(shapes);</div>
<div class=CC1>    <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; shapes.size(); i++) {</div>
<div class=CC1>    shapes[i]-&gt;draw();</div>
<div class=CC1>    shapes[i]-&gt;erase();</div>
<div class=CC1>  }</div>
<div class=CC1>  purge(shapes);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>factory(&nbsp;)</b> function takes an argument that
allows it to determine what type of <b>Shape</b> to create. Here, the argument is
a <b>string</b>, but it could be any set of data. The <b>factory(&nbsp;)</b> is
now the only other code in the system that needs to be changed when a new type
of <b>Shape </b>is added. (The initialization data for the objects will
presumably come from somewhere outside the system and will not be a hard-coded
array as in this example.)</p>

<p class=MsoNormal>To ensure that the creation can only happen in the <b>factory(&nbsp;)</b>,
the constructors for the specific types of <b>Shape</b> are made <b>private</b>,
and <b>Shape</b> is declared a <b>friend</b> so that <b>factory(&nbsp;)</b> has
access to the constructors. (You could also declare only <b>Shape::factory(&nbsp;)</b>
to be a <b>friend</b>, but it seems reasonably harmless to declare the entire
base class as a <b>friend</b>.) There is another important implication of this
design—the base class, <b>Shape</b>, must now know the details about every
derived class—a property that object-oriented designs try to avoid. For
frameworks or any class library that should support extension, this can quickly
become unwieldy, as the base class must be updated as soon as a new type is
added to the hierarchy. Polymorphic factories, described in the next
subsection, can be used to avoid this unfortunate circular dependency.</p>

<h3><a href="#_TocRef11818301" name="_Toc11818301">Polymorphic factories</a></h3>

<p class=MsoNormal>The <b>static factory(&nbsp;)</b> member function in the
previous example forces all the creation operations to be focused in one spot,
so that’s the only place you need to change the code. This is certainly a
reasonable solution, as it nicely encapsulates the process of creating objects.
However, GoF emphasizes that the reason for the Factory Method pattern is so
that different types of factories can be derived from the basic factory.
Factory Method is in fact a special type of polymorphic factory. Here is <b>ShapeFactory1.cpp</b>
modified so the Factory Methods are in a separate class as virtual functions:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:ShapeFactory2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Polymorphic Factory Methods.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Shape {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> erase() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Shape() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> ShapeFactory {</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Shape* create() = 0;</div>
<div class=CC1>  <font color=#ff7700>static</font> map&lt;string, ShapeFactory*&gt; factories;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~ShapeFactory() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> ShapeFactoryInitializer;</div>
<div class=CC1>  <font color=#ff7700>class</font> BadShapeCreation : <font color=#ff7700>public</font> logic_error {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    BadShapeCreation(string type)</div>
<div class=CC1>    : logic_error(<font color=#007f00>&quot;Cannot create type &quot;</font> +
type) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#ff7700>static</font> Shape*</div>
<div class=CC1>  createShape(<font color=#ff7700>const</font> string&amp; id) <font color=#ff7700>throw</font>(BadShapeCreation)
{</div>
<div class=CC1>    <font color=#ff7700>if</font>(factories.find(id) != factories.end())</div>
<div class=CC1>      <font color=#ff7700>return</font> factories[id]-&gt;create();</div>
<div class=CC1>    <font color=#ff7700>else</font></div>
<div class=CC1>      <font color=#ff7700>throw</font> BadShapeCreation(id);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Define the static object:</font></div>
<div class=CC1>map&lt;string, ShapeFactory*&gt;
ShapeFactory::factories;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Circle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1>  Circle() {} <font color=#dd0000>// Private constructor</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> ShapeFactoryInitializer;</div>
<div class=CC1>  <font color=#ff7700>class</font> Factory;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Factory;</div>
<div class=CC1>  <font color=#ff7700>class</font> Factory : <font color=#ff7700>public</font> ShapeFactory {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    Shape* create() { <font color=#ff7700>return</font> <font color=#ff7700>new</font> Circle; }</div>
<div class=CC1>    <font color=#ff7700>friend</font> <font color=#ff7700>class</font> ShapeFactoryInitializer;</div>
<div class=CC1>  };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Circle::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> erase() { cout &lt;&lt; &quot;Circle::erase”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Circle() { cout &lt;&lt; &quot;Circle::~Circle”
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Square : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1>  Square() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> ShapeFactoryInitializer;</div>
<div class=CC1>  <font color=#ff7700>class</font> Factory;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Factory;</div>
<div class=CC1>  <font color=#ff7700>class</font> Factory : <font color=#ff7700>public</font> ShapeFactory {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    Shape* create() { <font color=#ff7700>return</font> <font color=#ff7700>new</font> Square; }</div>
<div class=CC1>    <font color=#ff7700>friend</font> <font color=#ff7700>class</font> ShapeFactoryInitializer;</div>
<div class=CC1>  };</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; &quot;Square::draw”
&lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> erase() { cout &lt;&lt; &quot;Square::erase”
&lt;&lt; endl; }</div>
<div class=CC1>  ~Square() { cout &lt;&lt; &quot;Square::~Square”
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Singleton to initialize the ShapeFactory:</font></div>
<div class=CC1><font color=#ff7700>class</font> ShapeFactoryInitializer {</div>
<div class=CC1>  <font color=#ff7700>static</font> ShapeFactoryInitializer si;</div>
<div class=CC1>  ShapeFactoryInitializer() {</div>
<div class=CC1>    ShapeFactory::factories[<font color=#007f00>&quot;Circle&quot;</font>]= <font color=#ff7700>new</font>
Circle::Factory;</div>
<div class=CC1>    ShapeFactory::factories[<font color=#007f00>&quot;Square&quot;</font>]= <font color=#ff7700>new</font>
Square::Factory;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~ShapeFactoryInitializer() {</div>
<div class=CC1>    map&lt;string, ShapeFactory*&gt;::iterator it =</div>
<div class=CC1>      ShapeFactory::factories.begin();</div>
<div class=CC1>    <font color=#ff7700>while</font>(it != ShapeFactory::factories.end())</div>
<div class=CC1>      <font color=#ff7700>delete</font> it++-&gt;second;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Static member definition:</font></div>
<div class=CC1>ShapeFactoryInitializer ShapeFactoryInitializer::si;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>char</font>* sl[] = { <font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Square&quot;</font>,
<font color=#007f00>&quot;Square&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Circle&quot;</font>,
<font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Square&quot;</font> };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Shape*&gt; shapes;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; <font color=#ff7700>sizeof</font> sl / <font color=#ff7700>sizeof</font> sl[0];
i++)</div>
<div class=CC1>     
shapes.push_back(ShapeFactory::createShape(sl[i]));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(ShapeFactory::BadShapeCreation e) {</div>
<div class=CC1>    cout &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; shapes.size(); i++) {</div>
<div class=CC1>    shapes[i]-&gt;draw();</div>
<div class=CC1>    shapes[i]-&gt;erase();</div>
<div class=CC1>  }</div>
<div class=CC1>  purge(shapes);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now the Factory Method appears in its own class, <b>ShapeFactory</b>,
as <b>virtual create(&nbsp;)</b>. This is a private member function, which
means it cannot be called directly but can be overridden. The subclasses of <b>Shape</b>
must each create their own subclasses of <b>ShapeFactory</b> and override the <b>create(&nbsp;)</b>
member function to create an object of their own type. These factories are
private, so that they are only accessible from the main Factory Method. This
way, all client code must go through the Factory Method in order to create
objects.</p>

<p class=MsoNormal>The actual creation of shapes is performed by calling <b>ShapeFactory::createShape(&nbsp;)</b>,
which is a static member function that uses the <b>map</b> in <b>ShapeFactory</b>
to find the appropriate factory object based on an identifier that you pass it.
The factory creates the shape object directly, but you could imagine a more
complex problem where the appropriate factory object is returned and then used
by the caller to create an object in a more sophisticated way. However, it
seems that much of the time you don’t need the intricacies of the polymorphic
Factory Method, and a single static member function in the base class (as shown
in <b>ShapeFactory1.cpp</b>) will work fine.</p>

<p class=MsoNormal>Notice that the <b>ShapeFactory</b> must be initialized by
loading its <b>map</b> with factory objects, which takes place in the Singleton
<b>ShapeFactoryInitializer</b>. So to add a new type to this design you must
define the type, create a factory, and modify <b>ShapeFactoryInitializer</b> so
that an instance of your factory is inserted in the map. This extra complexity
again suggests the use of a <b>static</b> Factory Method if you don’t need to
create individual factory objects.</p>

<h3><a href="#_TocRef11818302" name="_Toc11818302">Abstract
factories</a></h3>

<p class=MsoNormal>The Abstract Factory pattern looks like the factories we’ve
seen previously, but with several Factory Methods. Each of the Factory Methods
creates a different kind of object. When you create the factory object, you
decide how all the objects created by that factory will be used. The example in
GoF implements portability across various graphical user interfaces (GUIs): you
create a factory object appropriate to the GUI that you’re working with, and
from then on when you ask it for a menu, a button, a slider, and so on, it will
automatically create the appropriate version of that item for the GUI. Thus,
you’re able to isolate, in one place, the effect of changing from one GUI to
another.</p>

<p class=MsoNormal>As another example, suppose you are creating a
general-purpose gaming environment and you want to be able to support different
types of games. Here’s how it might look using an Abstract Factory:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:AbstractFactory.cpp</font></div>
<div class=CC1><font color=#dd0000>// A gaming environment.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Obstacle {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> action() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Player {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> interactWith(Obstacle*) = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Kitty: <font color=#ff7700>public</font> Player {</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> interactWith(Obstacle* ob) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Kitty has encountered a &quot;</font>;</div>
<div class=CC1>    ob-&gt;action();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> KungFuGuy: <font color=#ff7700>public</font> Player {</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> interactWith(Obstacle* ob) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;KungFuGuy now battles against a
&quot;</font>;</div>
<div class=CC1>    ob-&gt;action();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Puzzle: <font color=#ff7700>public</font> Obstacle {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> action() { cout &lt;&lt; <font color=#007f00>&quot;Puzzle&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> NastyWeapon: <font color=#ff7700>public</font> Obstacle {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> action() { cout &lt;&lt; <font color=#007f00>&quot;NastyWeapon&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// The abstract factory:</font></div>
<div class=CC1><font color=#ff7700>class</font> GameElementFactory {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Player* makePlayer() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Obstacle* makeObstacle() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Concrete factories:</font></div>
<div class=CC1><font color=#ff7700>class</font> KittiesAndPuzzles : <font color=#ff7700>public</font> GameElementFactory {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Player* makePlayer() { <font color=#ff7700>return</font> <font color=#ff7700>new</font> Kitty; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Obstacle* makeObstacle() { <font color=#ff7700>return</font> <font color=#ff7700>new</font> Puzzle;
}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> KillAndDismember : <font color=#ff7700>public</font> GameElementFactory {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Player* makePlayer() { <font color=#ff7700>return</font> <font color=#ff7700>new</font> KungFuGuy;
}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Obstacle* makeObstacle() {</div>
<div class=CC1>    <font color=#ff7700>return</font> <font color=#ff7700>new</font> NastyWeapon;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> GameEnvironment {</div>
<div class=CC1>  GameElementFactory* gef;</div>
<div class=CC1>  Player* p;</div>
<div class=CC1>  Obstacle* ob;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  GameEnvironment(GameElementFactory* factory)</div>
<div class=CC1>  : gef(factory), p(factory-&gt;makePlayer()),</div>
<div class=CC1>    ob(factory-&gt;makeObstacle()) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> play() { p-&gt;interactWith(ob); }</div>
<div class=CC1>  ~GameEnvironment() {</div>
<div class=CC1>    <font color=#ff7700>delete</font> p;</div>
<div class=CC1>    <font color=#ff7700>delete</font> ob;</div>
<div class=CC1>    <font color=#ff7700>delete</font> gef;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  GameEnvironment</div>
<div class=CC1>    g1(<font color=#ff7700>new</font> KittiesAndPuzzles),</div>
<div class=CC1>    g2(<font color=#ff7700>new</font> KillAndDismember);</div>
<div class=CC1>  g1.play();</div>
<div class=CC1>  g2.play();</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F7F>/* Output:</div>
<div class=CC1>Kitty has encountered a Puzzle</div>
<div class=CC1>KungFuGuy now battles against a
NastyWeapon */</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this environment, <b>Player</b> objects interact with <b>Obstacle</b>
objects, but the types of players and obstacles depend on the game. You
determine the kind of game by choosing a particular <b>GameElementFactory</b>,
and then the <b>GameEnvironment</b> controls the setup and play of the game. In
this example, the setup and play are simple, but those activities (the <i>initial
conditions</i> and the <i>state change</i>) can determine much of the game’s
outcome. Here, <b>GameEnvironment</b> is not designed to be inherited, although
it could possibly make sense to do that.</p>

<p class=MsoNormal>This example also illustrates <i>double dispatching</i>,
which will be explained later.</p>

<h3><a href="#_TocRef11818303" name="_Toc11818303">Virtual constructors</a></h3>

<p class=MsoNormal>One of the primary goals of using a factory is to  organize your code so you don’t need to select the exact constructor type when
creating an object. That is, you can tell a factory: “I don’t know precisely
what kind of object I need, but here’s the information. Create the appropriate
type.”</p>

<p class=MsoNormal>In addition, during a constructor call the virtual mechanism
does not operate (early binding occurs). Sometimes this is awkward. For
example, in the <b>Shape </b>program it seems logical that inside the
constructor for a <b>Shape</b> object, you would want to set everything up and
then <b>draw(&nbsp;)</b> the <b>Shape</b>. The <b>draw(&nbsp;)</b> function
should be a virtual function, a message to the <b>Shape</b> that it should draw
itself appropriately, depending on whether it is a <b>Circle</b>, a <b>Square</b>,
a <b>Line</b>, and so on. However, this doesn’t work inside the constructor
because virtual functions resolve to the “local” function bodies when called in constructors.</p>

<p class=MsoNormal>If you want to be able to call a virtual function inside the
constructor and have it do the right thing, you must use a technique to <i>simulate</i>
a virtual constructor. This is a conundrum. Remember, the idea of a virtual
function is that you send a message to an object and let the object figure out
the right thing to do. But a constructor builds an object. So a virtual
constructor would be like saying, “I don’t know exactly what kind of object you
are, but build the right type anyway.” In an ordinary constructor, the compiler
must know which VTABLE address to bind to the VPTR, and even if it existed, a
virtual constructor couldn’t do this because it doesn’t know all the type
information at compile time. It makes sense that a constructor can’t be virtual
because it is the one function that absolutely must know everything about the
type of the object.</p>

<p class=MsoNormal>And yet there are times when you want something
approximating the behavior of a virtual constructor.</p>

<p class=MsoNormal>In the <b>Shape</b> example, it would be nice to hand the <b>Shape</b>
constructor some specific information in the argument list and let the
constructor create a specific type of <b>Shape</b> (a <b>Circle</b> or a <b>Square</b>)
with no further intervention. Ordinarily, you’d have to make an explicit call
to the <b>Circle</b> or <b>Square</b> constructor yourself.</p>

<p class=MsoNormal>Coplien<a href="#_ftn143" name="_ftnref143"><span
class=MsoFootnoteReference>[143]</span></a> calls
his solution to this problem “envelope and letter classes.” The “envelope” class is the base class, a shell that contains a pointer to an object,
also of the base class type. The constructor for the “envelope” determines (at
runtime, when the constructor is called, not at compile time, when the type
checking is normally done) what specific type to make, creates an object of
that specific type (on the heap), and then assigns the object to its pointer.
All the function calls are then handled by the base class through its pointer.
It’s really just a slight variation of the State pattern, where the base class
is acting as a surrogate for the derived class, and the derived class provides
the variation in behavior:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:VirtualConstructor.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Shape {</div>
<div class=CC1>  Shape* s;</div>
<div class=CC1>  <font color=#dd0000>// Prevent copy-construction &amp; operator=</font></div>
<div class=CC1>  Shape(Shape&amp;);</div>
<div class=CC1>  Shape <font color=#ff7700>operator</font>=(Shape&amp;);</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  Shape() { s = 0; }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> draw() { s-&gt;draw(); }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> erase() { s-&gt;erase(); }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> test() { s-&gt;test(); }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Shape() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;~Shape&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    <font color=#ff7700>if</font>(s) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Making virtual call: &quot;</font>;</div>
<div class=CC1>      s-&gt;erase(); <font color=#dd0000>// Virtual call</font></div>
<div class=CC1>    }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;delete s: &quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>delete</font> s; <font color=#dd0000>// The polymorphic deletion</font></div>
<div class=CC1>    <font color=#dd0000>// (delete 0 is legal; it produces a no-op)</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>class</font> BadShapeCreation : <font color=#ff7700>public</font> logic_error {</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    BadShapeCreation(string type)</div>
<div class=CC1>    : logic_error(<font color=#007f00>&quot;Cannot create type &quot;</font> +
type) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  Shape(string type) <font color=#ff7700>throw</font>(BadShapeCreation);</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Circle : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1>  Circle(Circle&amp;);</div>
<div class=CC1>  Circle <font color=#ff7700>operator</font>=(Circle&amp;);</div>
<div class=CC1>  Circle() {} <font color=#dd0000>// Private constructor</font></div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Shape;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; <font color=#007f00>&quot;Circle::draw&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> erase() { cout &lt;&lt;
<font color=#007f00>&quot;Circle::erase&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> test() { draw(); }</div>
<div class=CC1>  ~Circle() { cout &lt;&lt; <font color=#007f00>&quot;Circle::~Circle&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Square : <font color=#ff7700>public</font> Shape {</div>
<div class=CC1>  Square(Square&amp;);</div>
<div class=CC1>  Square <font color=#ff7700>operator</font>=(Square&amp;);</div>
<div class=CC1>  Square() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Shape;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> draw() { cout &lt;&lt; <font color=#007f00>&quot;Square::draw&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> erase() { cout &lt;&lt;
<font color=#007f00>&quot;Square::erase&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>void</font> test() { draw(); }</div>
<div class=CC1>  ~Square() { cout &lt;&lt; <font color=#007f00>&quot;Square::~Square&quot;</font>
&lt;&lt; endl; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Shape::Shape(string type)
<font color=#ff7700>throw</font>(Shape::BadShapeCreation) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(type == <font color=#007f00>&quot;Circle&quot;</font>)</div>
<div class=CC1>    s = <font color=#ff7700>new</font> Circle;</div>
<div class=CC1>  <font color=#ff7700>else</font> <font color=#ff7700>if</font>(type == <font color=#007f00>&quot;Square&quot;</font>)</div>
<div class=CC1>    s = <font color=#ff7700>new</font> Square;</div>
<div class=CC1>  <font color=#ff7700>else</font> <font color=#ff7700>throw</font> BadShapeCreation(type);</div>
<div class=CC1>  draw();  <font color=#dd0000>// Virtual call in the constructor</font></div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>char</font>* sl[] = { <font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Square&quot;</font>,
<font color=#007f00>&quot;Square&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Circle&quot;</font>,
<font color=#007f00>&quot;Circle&quot;</font>, <font color=#007f00>&quot;Square&quot;</font> };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  vector&lt;Shape*&gt; shapes;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;virtual constructor calls:&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; <font color=#ff7700>sizeof</font> sl / <font color=#ff7700>sizeof</font> sl[0];
i++)</div>
<div class=CC1>      shapes.push_back(<font color=#ff7700>new</font> Shape(sl[i]));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Shape::BadShapeCreation e) {</div>
<div class=CC1>    cout &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>    purge(shapes);</div>
<div class=CC1>    <font color=#ff7700>return</font> EXIT_FAILURE;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; shapes.size(); i++) {</div>
<div class=CC1>    shapes[i]-&gt;draw();</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;test&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    shapes[i]-&gt;test();</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;end test&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    shapes[i]-&gt;erase();</div>
<div class=CC1>  }</div>
<div class=CC1>  Shape c(<font color=#007f00>&quot;Circle&quot;</font>); <font color=#dd0000>// Create on the stack</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;destructor calls:&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  purge(shapes);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The base class <b>Shape</b> contains a pointer to an object
of type <b>Shape</b> as its only data member. (When you create a “virtual
constructor” scheme, exercise special care to ensure this pointer is always
initialized to a live object.) This base class is effectively a proxy because
it is the only thing the client code sees and interacts with.</p>

<p class=MsoNormal>Each time you derive a new subtype from <b>Shape</b>, you
must go back and add the creation for that type in one place, inside the
“virtual constructor” in the <b>Shape</b> base class. This is not too onerous a
task, but the disadvantage is you now have a dependency between the <b>Shape</b>
class and all classes derived from it.</p>

<p class=MsoNormal>In this example, the information you must hand the virtual
constructor about what type to create is explicit: it’s a <b>string</b> that
names the type. However, your scheme can use other information—for example, in
a parser the output of the scanner can be handed to the virtual constructor,
which then uses that information to determine which token to create.</p>

<p class=MsoNormal>The virtual constructor <b>Shape(type)</b> cannot be defined
until after all the derived classes have been declared. However, the default
constructor can be defined inside <b>class Shape</b>, but it should be made <b>protected</b>
so temporary <b>Shape</b> objects cannot be created. This default constructor
is only called by the constructors of derived-class objects. You are forced to
explicitly create a default constructor because the compiler will create one
for you automatically only if there are <i>no</i> constructors defined. Because
you must define <b>Shape(type)</b>, you must also define <b>Shape(&nbsp;)</b>.</p>

<p class=MsoNormal>The default constructor in this scheme has at least one
important chore—it must set the value of the <b>s</b> pointer to zero. This may
sound strange at first, but remember that the default constructor will be
called as part of the construction of the <i>actual object</i>—in Coplien’s
terms, the “letter,” not the “envelope.” However, the “letter” is derived from
the “envelope,” so it also inherits the data member <b>s</b>. In the
“envelope,” <b>s</b> is important because it points to the actual object, but
in the “letter,” <b>s</b> is simply excess baggage. Even excess baggage should
be initialized, however, and if <b>s</b> is not set to zero by the default
constructor called for the “letter,” bad things happen (as you’ll see later).</p>

<p class=MsoNormal>The virtual constructor takes as its argument information
that completely determines the type of the object. Notice, though, that this
type information isn’t read and acted upon until runtime, whereas normally the
compiler must know the exact type at compile time (one other reason this system
effectively imitates virtual constructors).</p>

<p class=MsoNormal>The virtual constructor uses its argument to select the
actual (“letter”) object to construct, which is then assigned to the pointer
inside the “envelope.” At that point, the construction of the “letter” has been
completed, so any virtual calls will be properly redirected.</p>

<p class=MsoNormal>As an example, consider the call to <b>draw(&nbsp;)</b>
inside the virtual constructor. If you trace this call (either by hand or with
a debugger), you can see that it starts in the <b>draw(&nbsp;)</b> function in
the base class, <b>Shape</b>. This function calls <b>draw(&nbsp;)</b> for the
“envelope” <b>s</b> pointer to its “letter.” All types derived from <b>Shape</b>
share the same interface, so this virtual call is properly executed, even
though it seems to be in the constructor. (Actually, the constructor for the
“letter” has already completed.) As long as all virtual calls in the base class
simply make calls to identical virtual functions through the pointer to the
“letter,” the system operates properly.</p>

<p class=MsoNormal>To understand how it works, consider the code in <b>main(&nbsp;)</b>.
To fill the <b>vector shapes</b>, “virtual constructor” calls are made to <b>Shape</b>.
Ordinarily in a situation like this, you would call the constructor for the
actual type, and the VPTR for that type would be installed in the object. Here,
however, the VPTR used in each case is the one for <b>Shape</b>, not the one
for the specific <b>Circle</b>, <b>Square</b>, or <b>Triangle</b>.</p>

<p class=MsoNormal>In the <b>for</b> loop where the <b>draw(&nbsp;)</b> and <b>erase(&nbsp;)
</b>functions are called for each <b>Shape</b>, the virtual function call
resolves, through the VPTR, to the corresponding type. However, this is <b>Shape</b>
in each case. In fact, you might wonder why <b>draw(&nbsp;)</b> and <b>erase(&nbsp;)
</b>were made <b>virtual</b>. The reason shows up in the next step: the
base-class version of <b>draw(&nbsp;)</b> makes a call, through the “letter”
pointer <b>s</b>, to the <b>virtual</b> function <b>draw(&nbsp;)</b> for the
“letter.” This time the call resolves to the actual type of the object, not
just the base class <b>Shape</b>. Thus, the runtime cost of using virtual
constructors is one extra virtual indirection every time you make a virtual
function call.</p>

<p class=MsoNormal>To create any function that is overridden, such as <b>draw(&nbsp;)</b>,
<b>erase(&nbsp;)</b>, or <b>test(&nbsp;)</b>, you must forward all calls to the
<b>s</b> pointer in the base class implementation, as shown earlier. This is
because, when the call is made, the call to the envelope’s member function will
resolve as being to <b>Shape</b>, and not to a derived type of <b>Shape</b>.
Only when you forward the call to <b>s</b> will the virtual behavior take
place. In <b>main(&nbsp;)</b>, you can see that everything works correctly,
even when calls are made inside constructors and destructors.</p>

<h4>Destructor operation</h4>

<p class=MsoNormal>The activities of destruction in this scheme are also
tricky. To understand, let’s verbally walk through what happens when you call <b>delete</b>
for a pointer to a <b>Shape</b> object—specifically, a <b>Square</b>—created on
the heap. (This is more complicated than an object created on the stack.) This
will be a <b>delete</b> through the polymorphic interface, and will happen via
the call to <b>purge(&nbsp;)</b>.</p>

<p class=MsoNormal>The type of any pointer in <b>shapes</b> is of the base
class <b>Shape</b>, so the compiler makes the call through <b>Shape</b>. Normally,
you might say that it’s a virtual call, so <b>Square</b>’s destructor will be
called. But with the virtual constructor scheme, the compiler is creating
actual <b>Shape</b> objects, even though the constructor initializes the letter
pointer to a specific type of <b>Shape</b>. The virtual mechanism <i>is</i>
used, but the VPTR inside the <b>Shape</b> object is <b>Shape</b>’s VPTR, not <b>Square</b>’s.
This resolves to <b>Shape</b>’s destructor, which calls <b>delete</b> for the
letter pointer <b>s</b>, which actually points to a <b>Square</b> object. This
is again a virtual call, but this time it resolves to <b>Square</b>’s
destructor.</p>

<p class=MsoNormal>C++ guarantees, via the compiler, that all destructors in
the hierarchy are called. <b>Square</b>’s destructor is called first, followed
by any intermediate destructors, in order, until finally the base-class destructor
is called. This base-class destructor contains code that says <b>delete s</b>.
When this destructor was called originally, it was for the “envelope” <b>s</b>,
but now it’s for the “letter” <b>s</b>, which is there because the “letter” was
inherited from the “envelope,” and not because it contains anything. So <i>this</i>
call to <b>delete</b> should do nothing.</p>

<p class=MsoNormal>The solution to the problem is to make the “letter” <b>s</b>
pointer zero. Then when the “letter” base-class destructor is called, you get <b>delete
0</b>, which by definition does nothing. Because the default constructor is
protected, it will be called <i>only</i> during the construction of a “letter,”
so that’s the only situation where <b>s</b> is set to zero.</p>

<p class=MsoNormal>Although it’s interesting, you can see this is a complex
approach, and the most common tool for hiding construction will generally be
ordinary Factory Methods rather than something like this “virtual constructor”
scheme.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985854" name="_Toc53985854">Builder: creating complex objects</a></h2>

<p class=MsoNormal>The goal of Builder (which is a Creational pattern, like the
Factories we’ve just looked at) is to separate the construction of an object
from its “representation.” This means that the construction process stays the
same, but the resulting object has different possible representations. GoF
points out that the main difference between Builder and Abstract Factory is
that a Builder creates the object step-by-step, so the fact that the creation
process is spread out in time seems to be important. In addition, the
“director” gets a stream of pieces that it passes to the Builder, and each
piece is used to perform one of the steps in the build process.</p>

<p class=MsoNormal>The following example models a bicycle that can have a
choice of parts, according to its type (mountain bike, touring bike, or racing
bike). A Builder class is associated with each type of bicycle, and each Builder
implements the interface specified in the abstract class <b>BicycleBuilder</b>.
A separate class, <b>BicycleTechnician</b>, represents the “director” object
described in GoF, and uses a concrete <b>BicycleBuilder</b> object to construct
a <b>Bicycle</b> object.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:Bicycle.h</font></div>
<div class=CC1><font color=#dd0000>// Defines classes to build bicycles;</font></div>
<div class=CC1><font color=#dd0000>// Illustrates the Builder design pattern.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef BICYCLE_H</font></div>
<div class=CC1><font color=#7F7F00>#define BICYCLE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> std::size_t;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> BicyclePart {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>enum</font> BPart { FRAME, WHEEL, SEAT, DERAILLEUR,</div>
<div class=CC1>    HANDLEBAR, SPROCKET, RACK, SHOCK, NPARTS };</div>
<div class=CC1><font color=#ff7700>private</font>:</div>
<div class=CC1>  BPart id;</div>
<div class=CC1>  <font color=#ff7700>static</font> std::string names[NPARTS];</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BicyclePart(BPart bp) { id = bp; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(std::ostream&amp; os, <font color=#ff7700>const</font>
BicyclePart&amp; bp) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; bp.names[bp.id];</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bicycle {</div>
<div class=CC1>  std::vector&lt;BicyclePart*&gt; parts;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  ~Bicycle() { purge(parts); }</div>
<div class=CC1>  <font color=#ff7700>void</font> addPart(BicyclePart* bp) { parts.push_back(bp);
}</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(std::ostream&amp; os, <font color=#ff7700>const</font>
Bicycle&amp; b) {</div>
<div class=CC1>    os &lt;&lt; <font color=#007f00>&quot;{ &quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; b.parts.size(); ++i)</div>
<div class=CC1>      <span lang=SV>os &lt;&lt; *b.parts[i] &lt;&lt; '
';</span></div>
<div class=CC1><span lang=SV>    </span><font color=#ff7700>return</font> os &lt;&lt; '}';</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> BicycleBuilder {</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  Bicycle* product;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BicycleBuilder() { product = 0; }</div>
<div class=CC1>  <font color=#ff7700>void</font> createProduct() { product = <font color=#ff7700>new</font> Bicycle; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildFrame() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildWheel() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildSeat() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildDerailleur() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildHandlebar() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildSprocket() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildRack() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> buildShock() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> std::string getBikeName() <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  Bicycle* getProduct() {</div>
<div class=CC1>    Bicycle* temp = product;</div>
<div class=CC1>    product = 0;  <font color=#dd0000>// Relinquish product</font></div>
<div class=CC1>    <font color=#ff7700>return</font> temp;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MountainBikeBuilder : <font color=#ff7700>public</font> BicycleBuilder {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> buildFrame();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildWheel();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildSeat();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildDerailleur();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildHandlebar();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildSprocket();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildRack();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildShock();</div>
<div class=CC1>  std::string getBikeName() <font color=#ff7700>const</font> { <font color=#ff7700>return</font>
<font color=#007f00>&quot;MountainBike&quot;</font>;}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TouringBikeBuilder : <font color=#ff7700>public</font> BicycleBuilder {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> buildFrame();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildWheel();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildSeat();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildDerailleur();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildHandlebar();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildSprocket();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildRack();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildShock();</div>
<div class=CC1>  std::string getBikeName() <font color=#ff7700>const</font> { <font color=#ff7700>return</font>
<font color=#007f00>&quot;TouringBike&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> RacingBikeBuilder : <font color=#ff7700>public</font> BicycleBuilder {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> buildFrame();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildWheel();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildSeat();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildDerailleur();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildHandlebar();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildSprocket();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildRack();</div>
<div class=CC1>  <font color=#ff7700>void</font> buildShock();</div>
<div class=CC1>  std::string getBikeName() <font color=#ff7700>const</font> { <font color=#ff7700>return</font>
<font color=#007f00>&quot;RacingBike&quot;</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> BicycleTechnician {</div>
<div class=CC1>  BicycleBuilder* builder;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BicycleTechnician() { builder = 0; }</div>
<div class=CC1>  <font color=#ff7700>void</font> setBuilder(BicycleBuilder* b) { builder = b; }</div>
<div class=CC1>  <font color=#ff7700>void</font> construct();</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// BICYCLE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A <b>Bicycle</b> holds a <b>vector</b> of pointers to <b>BicyclePart</b>,
representing the parts used to construct the bicycle. To initiate the construction
of a bicycle, a <b>BicycleTechnician</b> (the “director” in this example) calls
<b>BicycleBuilder::createproduct(&nbsp;)</b> on a derived <b>BicycleBuilder</b>
object. The <b>BicycleTechnician::construct(&nbsp;)</b> function calls all the
functions in the <b>BicycleBuilder</b> interface (since it doesn’t know what
type of concrete builder it has). The concrete builder classes omit (via empty
function bodies) those actions that do not apply to the type of bicycle they
build, as you can see in the following implementation file:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:Bicycle.cpp {O} {-mwcc}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Bicycle.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>std::string BicyclePart::names[NPARTS] = {</div>
<div class=CC1>  <font color=#007f00>&quot;Frame&quot;</font>, <font color=#007f00>&quot;Wheel&quot;</font>,
<font color=#007f00>&quot;Seat&quot;</font>, <font color=#007f00>&quot;Derailleur&quot;</font>,</div>
<div class=CC1>  <font color=#007f00>&quot;Handlebar&quot;</font>, <font color=#007f00>&quot;Sprocket&quot;</font>,
<font color=#007f00>&quot;Rack&quot;</font>, <font color=#007f00>&quot;Shock&quot;</font> };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// MountainBikeBuilder implementation</font></div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildFrame() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::FRAME));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildWheel() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::WHEEL));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildSeat() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::SEAT));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildDerailleur() {</div>
<div class=CC1>  product-&gt;addPart(</div>
<div class=CC1>    <font color=#ff7700>new</font> BicyclePart(BicyclePart::DERAILLEUR));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildHandlebar() {</div>
<div class=CC1>  product-&gt;addPart(</div>
<div class=CC1>    <font color=#ff7700>new</font> BicyclePart(BicyclePart::HANDLEBAR));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildSprocket() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::SPROCKET));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildRack() {}</div>
<div class=CC1><font color=#ff7700>void</font> MountainBikeBuilder::buildShock() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font> BicyclePart(BicyclePart::SHOCK));</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// TouringBikeBuilder implementation</font></div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildFrame() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::FRAME));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildWheel() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::WHEEL));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildSeat() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::SEAT));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildDerailleur() {</div>
<div class=CC1>  product-&gt;addPart(</div>
<div class=CC1>    <font color=#ff7700>new</font> BicyclePart(BicyclePart::DERAILLEUR));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildHandlebar() {</div>
<div class=CC1>  product-&gt;addPart(</div>
<div class=CC1>    <font color=#ff7700>new</font> BicyclePart(BicyclePart::HANDLEBAR));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildSprocket() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::SPROCKET));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildRack() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font> BicyclePart(BicyclePart::RACK));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> TouringBikeBuilder::buildShock() {}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// RacingBikeBuilder implementation</font></div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildFrame() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::FRAME));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildWheel() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font> BicyclePart(BicyclePart::WHEEL));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildSeat() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::SEAT));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildDerailleur() {}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildHandlebar() {</div>
<div class=CC1>  product-&gt;addPart(</div>
<div class=CC1>    <font color=#ff7700>new</font> BicyclePart(BicyclePart::HANDLEBAR));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildSprocket() {</div>
<div class=CC1>  product-&gt;addPart(<font color=#ff7700>new</font>
BicyclePart(BicyclePart::SPROCKET));</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildRack() {}</div>
<div class=CC1><font color=#ff7700>void</font> RacingBikeBuilder::buildShock() {}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// BicycleTechnician implementation</font></div>
<div class=CC1><font color=#ff7700>void</font> BicycleTechnician::construct() {</div>
<div class=CC1>  assert(builder);</div>
<div class=CC1>  builder-&gt;createProduct();</div>
<div class=CC1>  builder-&gt;buildFrame();</div>
<div class=CC1>  builder-&gt;buildWheel();</div>
<div class=CC1>  builder-&gt;buildSeat();</div>
<div class=CC1>  builder-&gt;buildDerailleur();</div>
<div class=CC1>  builder-&gt;buildHandlebar();</div>
<div class=CC1>  builder-&gt;buildSprocket();</div>
<div class=CC1>  builder-&gt;buildRack();</div>
<div class=CC1>  builder-&gt;buildShock();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Bicycle</b> stream inserter calls the corresponding
inserter for each <b>BicyclePart</b>, and that prints its type name so that you
can see what a <b>Bicycle</b> contains. Here is a sample program:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:BuildBicycles.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} Bicycle</font></div>
<div class=CC1><font color=#dd0000>// The Builder design pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstddef&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;map&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Bicycle.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Constructs a bike via a concrete builder</font></div>
<div class=CC1>Bicycle* buildMeABike(</div>
<div class=CC1>  BicycleTechnician&amp; t, BicycleBuilder* builder) {</div>
<div class=CC1>  t.setBuilder(builder);</div>
<div class=CC1>  t.construct();</div>
<div class=CC1>  Bicycle* b = builder-&gt;getProduct();</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Built a &quot;</font> &lt;&lt;
builder-&gt;getBikeName() &lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>return</font> b;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#dd0000>// Create an order for some bicycles</font></div>
<div class=CC1>  map &lt;string, size_t&gt; order;</div>
<div class=CC1>  order[<font color=#007f00>&quot;mountain&quot;</font>] = 2;</div>
<div class=CC1>  order[<font color=#007f00>&quot;touring&quot;</font>] = 1;</div>
<div class=CC1>  order[<font color=#007f00>&quot;racing&quot;</font>] = 3;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Build bikes</font></div>
<div class=CC1>  vector&lt;Bicycle*&gt; bikes;</div>
<div class=CC1>  BicycleBuilder* m = <font color=#ff7700>new</font> MountainBikeBuilder;</div>
<div class=CC1>  BicycleBuilder* t = <font color=#ff7700>new</font> TouringBikeBuilder;</div>
<div class=CC1>  BicycleBuilder* r = <font color=#ff7700>new</font> RacingBikeBuilder;</div>
<div class=CC1>  BicycleTechnician tech;</div>
<div class=CC1>  map&lt;string, size_t&gt;::iterator it =
order.begin();</div>
<div class=CC1>  <font color=#ff7700>while</font>(it != order.end()) {</div>
<div class=CC1>    BicycleBuilder* builder;</div>
<div class=CC1>    <font color=#ff7700>if</font>(it-&gt;first == <font color=#007f00>&quot;mountain&quot;</font>)</div>
<div class=CC1>      builder = m;</div>
<div class=CC1>    <font color=#ff7700>else</font> <font color=#ff7700>if</font>(it-&gt;first == <font color=#007f00>&quot;touring&quot;</font>)</div>
<div class=CC1>      builder = t;</div>
<div class=CC1>    <font color=#ff7700>else</font> <font color=#ff7700>if</font>(it-&gt;first == <font color=#007f00>&quot;racing&quot;</font>)</div>
<div class=CC1>      builder = r;</div>
<div class=CC1>    <font color=#ff7700>for</font>(size_t i = 0; i &lt; it-&gt;second; ++i)</div>
<div class=CC1>      bikes.push_back(buildMeABike(tech, builder));</div>
<div class=CC1>    <span lang=IT>++it;</span></div>
<div class=CC1><span lang=IT>  }</span></div>
<div class=CC1><span lang=IT>  <font color=#ff7700>delete</font> m;</span></div>
<div class=CC1><span lang=IT>  <font color=#ff7700>delete</font> t;</span></div>
<div class=CC1><span lang=IT>  <font color=#ff7700>delete</font> r;</span></div>
<div class=CC1><span lang=IT>&nbsp;</span></div>
<div class=CC1><span lang=IT>  </span><font color=#dd0000>// Display inventory</font></div>
<div class=CC1>  <font color=#ff7700>for</font>(size_t i = 0; i &lt; bikes.size(); ++i)</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Bicycle: &quot;</font> &lt;&lt;
*bikes[i] &lt;&lt; endl;</div>
<div class=CC1>  purge(bikes);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#7F7F7F>/* Output:</div>
<div class=CC1>Built a MountainBike</div>
<div class=CC1>Built a MountainBike</div>
<div class=CC1>Built a RacingBike</div>
<div class=CC1>Built a RacingBike</div>
<div class=CC1>Built a RacingBike</div>
<div class=CC1>Built a TouringBike</div>
<div class=CC1>Bicycle: {</div>
<div class=CC1>  Frame Wheel Seat Derailleur Handlebar Sprocket Shock
}</div>
<div class=CC1>Bicycle: {</div>
<div class=CC1>  Frame Wheel Seat Derailleur Handlebar Sprocket Shock
}</div>
<div class=CC1>Bicycle: { Frame Wheel Seat Handlebar Sprocket }</div>
<div class=CC1>Bicycle: { Frame Wheel Seat Handlebar Sprocket }</div>
<div class=CC1>Bicycle: { Frame Wheel Seat Handlebar Sprocket }</div>
<div class=CC1>Bicycle: {</div>
<div class=CC1>  Frame Wheel Seat Derailleur Handlebar Sprocket Rack }</div>
<div class=CC1>*/</font> <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The power of this pattern is that it separates the algorithm
for assembling parts into a complete product from the parts themselves and
allows different algorithms for different products via different implementations
of a common interface.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985855" name="_Toc53985855">Observer</a></h2>

<p class=MsoNormal>The Observer pattern solves a fairly common problem: what if
a group of objects needs to update themselves when some other object changes
state? This can be seen in the “model-view” aspect of Smalltalk’s MVC (model-view-controller) or the almost-equivalent “Document-View Architecture.” Suppose that you have some data (the “document”) and two views: a plot view
and a textual view. When you change the data, the views must be told to update
themselves, and that’s what the observer facilitates.</p>

<p class=MsoNormal>Two types of objects are used to implement the observer
pattern in the following code. The <b>Observable</b> class keeps track of the
objects that want to be informed when a change happens. The <b>Observable</b>
class calls the <b>notifyObservers(&nbsp;)</b> member function for each
observer on the list. The <b>notifyObservers(&nbsp;)</b> member function is
part of the base class <b>Observable</b>.</p>

<p class=MsoNormal>There are <i>two</i> “things that change” in the observer
pattern: the quantity of observing objects and the way an update occurs. That
is, the observer pattern allows you to modify both of these without affecting
the surrounding code.</p>

<p class=MsoNormal>You can implement the observer pattern in a number of ways,
but the code shown here will create a framework from which you can build your
own observer code, by following the example. First, this interface describes
what an observer looks like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:Observer.h</font></div>
<div class=CC1><font color=#dd0000>// The Observer interface.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef OBSERVER_H</font></div>
<div class=CC1><font color=#7F7F00>#define OBSERVER_H</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Observable;</div>
<div class=CC1><font color=#ff7700>class</font> Argument {};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Observer {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// Called by the observed object, whenever</font></div>
<div class=CC1>  <font color=#dd0000>// the observed object is changed:</font></div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> update(Observable* o, Argument* arg) =
0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Observer() {}</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// OBSERVER_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Since <b>Observer</b> interacts with <b>Observable</b> in
this approach, <b>Observable</b> must be declared first. In addition, the <b>Argument</b>
class is empty and only acts as a base class for any type of argument you want
to pass during an update. If you want, you can simply pass the extra argument
as a <b>void*</b>. You’ll have to downcast in either case.</p>

<p class=MsoNormal>The<b> Observer</b> type is an “interface” class that only
has one member function, <b>update(&nbsp;)</b>. This function is called by the
object that’s being observed, when that object decides it’s time to update all
its observers. The arguments are optional; you could have an <b>update(&nbsp;)</b>
with no arguments, and that would still fit the observer pattern. However this
is more general—it allows the observed object to pass the object that caused
the update (since an <b>Observer </b>may be registered with more than one
observed object) and any extra information if that’s helpful, rather than
forcing the <b>Observer</b> object to hunt around to see who is updating and to
fetch any other information it needs.</p>

<p class=MsoNormal>The “observed object” will be of type <b>Observable</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:Observable.h</font></div>
<div class=CC1><font color=#dd0000>// The Observable class.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef OBSERVABLE_H</font></div>
<div class=CC1><font color=#7F7F00>#define OBSERVABLE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;set&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Observer.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Observable {</div>
<div class=CC1>  <font color=#ff7700>bool</font> changed;</div>
<div class=CC1>  std::set&lt;Observer*&gt; observers;</div>
<div class=CC1><font color=#ff7700>protected</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> setChanged() { changed = <font color=#ff7700>true</font>; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> clearChanged() { changed = <font color=#ff7700>false</font>; }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> addObserver(Observer&amp; o) {</div>
<div class=CC1>    observers.insert(&amp;o);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> deleteObserver(Observer&amp; o) {</div>
<div class=CC1>    observers.erase(&amp;o);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> deleteObservers() {</div>
<div class=CC1>    observers.clear();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>int</font> countObservers() {</div>
<div class=CC1>    <font color=#ff7700>return</font> observers.size();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>bool</font> hasChanged() { <font color=#ff7700>return</font> changed; }</div>
<div class=CC1>  <font color=#dd0000>// If this object has changed, notify all</font></div>
<div class=CC1>  <font color=#dd0000>// of its observers:</font></div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> notifyObservers(Argument* arg = 0) {</div>
<div class=CC1>    <font color=#ff7700>if</font>(!hasChanged()) <font color=#ff7700>return</font>;</div>
<div class=CC1>    clearChanged(); <font color=#dd0000>// Not &quot;changed&quot; anymore</font></div>
<div class=CC1>    std::set&lt;Observer*&gt;::iterator it;</div>
<div class=CC1>    <font color=#ff7700>for</font>(it = observers.begin();it != observers.end(); it++)</div>
<div class=CC1>      (*it)-&gt;update(<font color=#ff7700>this</font>, arg);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Observable() {}</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// OBSERVABLE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Again, the design here is more elaborate than is necessary. As
long as there’s a way to register an <b>Observer</b> with an <b>Observable</b>
and a way for the <b>Observable</b> to update its <b>Observer</b>s, the set of
member functions doesn’t matter. However, this design is intended to be
reusable. (It was lifted from the design used in the Java standard library.)<a href="#_ftn144" name="_ftnref144"><span
class=MsoFootnoteReference>[144]</span></a></p>

<p class=MsoNormal>The<b> Observable</b> object has a flag to indicate whether
it’s been changed. In a simpler design, there would be no flag; if something
happened, everyone would be notified. Notice, however, that the control of the
flag’s state is <b>protected</b> so that only an inheritor can decide what
constitutes a change, and not the end user of the resulting derived <b>Observer</b>
class.</p>

<p class=MsoNormal>The collection of <b>Observer</b> objects is kept in a <b>set&lt;Observer*&gt;</b>
to prevent duplicates; the <b>set insert(&nbsp;)</b>, <b>erase(&nbsp;)</b>, <b>clear(&nbsp;)</b>,
and <b>size(&nbsp;)</b> functions are exposed to allow <b>Observer</b>s to be
added and removed at any time, thus providing runtime flexibility.</p>

<p class=MsoNormal>Most of the work is done in <b>notifyObservers(&nbsp;)</b>.
If the <b>changed</b> flag has not been set, this does nothing. Otherwise, it
first clears the <b>changed</b> flag so that repeated calls to <b>notifyObservers(&nbsp;)</b>
won’t waste time. This is done before notifying the observers in case the calls
to <b>update(&nbsp;)</b> do anything that causes a change back to this <b>Observable</b>
object. It then moves through the <b>set</b> and calls back to the <b>update(&nbsp;)</b>
member function of each <b>Observer</b>.</p>

<p class=MsoNormal>At first it may appear that you can use an ordinary <b>Observable</b>
object to manage the updates. But this doesn’t work; to get any effect, you <i>must</i>
derive from <b>Observable</b> and somewhere in your derived-class code call <b>setChanged(&nbsp;)</b>.
This is the member function that sets the “changed” flag, which means that when
you call <b>notifyObservers(&nbsp;)</b> all the observers will, in fact, get
notified. <i>Where</i> you call <b>setChanged(&nbsp;)</b> depends on the logic
of your program.</p>

<p class=MsoNormal>Now we encounter a dilemma. Objects that are being observed
may have more than one such item of interest. For example, if you’re dealing
with a GUI item—a button, say—the items of interest might be the mouse clicked
the button, the mouse moved over the button, and (for some reason) the button
changed its color. So we’d like to be able to report all these events to
different observers, each of which is interested in a different type of event.</p>

<p class=MsoNormal>The problem is that we would normally reach for multiple
inheritance in such a situation: “I’ll inherit from <b>Observable</b> to deal
with mouse clicks, and I’ll … er … inherit from <b>Observable</b> to deal with
mouse-overs, and, well, … hmm, that doesn’t work.”</p>

<h3><a href="#_TocRef53985856" name="_Toc53985856">The “inner class” idiom</a></h3>

<p class=MsoNormal>Here’s a situation where we must (in effect) upcast to more
than one type, but in this case we need to provide several <i>different</i>
implementations of the same base type. The solution is something we’ve lifted
from Java, which takes C++’s nested class one step further. Java has a built-in
feature called an <i>inner class</i>, which is like a nested class in C++, but
it has access to the nonstatic data of its containing class by implicitly using
the “this” pointer of the class object it was created within.<a href="#_ftn145" name="_ftnref145"><span
class=MsoFootnoteReference>[145]</span></a></p>

<p class=MsoNormal>To implement the inner class idiom in C++, we must obtain
and use a pointer to the containing object explicitly. Here’s an example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:InnerClassIdiom.cpp</font></div>
<div class=CC1><font color=#dd0000>// Example of the &quot;inner class&quot; idiom.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Poingable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> poing() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> callPoing(Poingable&amp; p) {</div>
<div class=CC1>  p.poing();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bingable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> bing() = 0;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>void</font> callBing(Bingable&amp; b) {</div>
<div class=CC1>  b.bing();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Outer {</div>
<div class=CC1>  string name;</div>
<div class=CC1>  <font color=#dd0000>// Define one inner class:</font></div>
<div class=CC1>  <font color=#ff7700>class</font> Inner1;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Outer::Inner1;</div>
<div class=CC1>  <font color=#ff7700>class</font> Inner1 : <font color=#ff7700>public</font> Poingable {</div>
<div class=CC1>    Outer* parent;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    Inner1(Outer* p) : parent(p) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> poing() {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;poing called for &quot;</font></div>
<div class=CC1>        &lt;&lt; parent-&gt;name &lt;&lt; endl;</div>
<div class=CC1>      <font color=#dd0000>// Accesses data in the outer class object</font></div>
<div class=CC1>    }</div>
<div class=CC1>  } inner1;</div>
<div class=CC1>  <font color=#dd0000>// Define a second inner class:</font></div>
<div class=CC1>  <font color=#ff7700>class</font> Inner2;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Outer::Inner2;</div>
<div class=CC1>  <font color=#ff7700>class</font> Inner2 : <font color=#ff7700>public</font> Bingable {</div>
<div class=CC1>    Outer* parent;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    Inner2(Outer* p) : parent(p) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> bing() {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;bing called for &quot;</font></div>
<div class=CC1>        &lt;&lt; parent-&gt;name &lt;&lt; endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  } inner2;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Outer(<font color=#ff7700>const</font> string&amp; nm)</div>
<div class=CC1>  : name(nm), inner1(<font color=#ff7700>this</font>), inner2(<font color=#ff7700>this</font>) {}</div>
<div class=CC1>  <font color=#dd0000>// Return reference to interfaces</font></div>
<div class=CC1>  <font color=#dd0000>// implemented by the inner classes:</font></div>
<div class=CC1>  <font color=#ff7700>operator</font> Poingable&amp;() { <font color=#ff7700>return</font> inner1; }</div>
<div class=CC1>  <font color=#ff7700>operator</font> Bingable&amp;() { <font color=#ff7700>return</font> inner2; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Outer x(<font color=#007f00>&quot;Ping Pong&quot;</font>);</div>
<div class=CC1>  <font color=#dd0000>// Like upcasting to multiple base types!:</font></div>
<div class=CC1>  callPoing(x);</div>
<div class=CC1>  callBing(x);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The example (intended to show the simplest syntax for the
idiom; you’ll see a real use shortly) begins with the <b>Poingable</b> and <b>Bingable
</b>interfaces, each containing a single member function. The services provided
by <b>callPoing(&nbsp;)</b> and <b>callBing(&nbsp;) </b>require that the object
they receive implements the <b>Poingable</b> and <b>Bingable </b>interfaces,
respectively, but they put no other requirements on that object so as to
maximize the flexibility of using <b>callPoing(&nbsp;)</b> and <b>callBing(&nbsp;)</b>.
Note the lack of <b>virtual</b> destructors in either interface—the intent is
that you never perform object destruction via the interface.</p>

<p class=MsoNormal>The<b> Outer</b> constructor contains some private data (<b>name</b>),
and it wants to provide both a <b>Poingable</b> interface and a <b>Bingable </b>interface
so it can be used with <b>callPoing(&nbsp;) </b>and <b>callBing(&nbsp;)</b>. (In
this situation we <i>could</i> simply use multiple inheritance, but it is kept simple for clarity.) To provide a <b>Poingable</b> object without deriving <b>Outer</b>
from <b>Poingable</b>, the inner class idiom is used. First, the declaration <b>class
Inner</b> says that, somewhere, there is a nested class of this name. This
allows the <b>friend</b> declaration for the class, which follows. Finally, now
that the nested class has been granted access to all the private elements of <b>Outer</b>,
the class can be defined. Notice that it keeps a pointer to the <b>Outer</b>
which created it, and this pointer must be initialized in the constructor.
Finally, the <b>poing(&nbsp;)</b> function from <b>Poingable</b> is
implemented. The same process occurs for the second inner class which
implements <b>Bingable</b>. Each inner class has a single <b>private</b>
instance created, which is initialized in the <b>Outer</b> constructor. By
creating the member objects and returning references to them, issues of object
lifetime are eliminated.</p>

<p class=MsoNormal>Notice that both inner class definitions are <b>private</b>,
and in fact the client code doesn’t have any access to details of the
implementation, since the two access functions <b>operator Poingable&amp;(&nbsp;)</b>
and <b>operator Bingable&amp;(&nbsp;)</b> only return a reference to the upcast
interface, not to the object that implements it. In fact, since the two inner
classes are <b>private</b>, the client code cannot even downcast to the
implementation classes, thus providing complete isolation between interface and
implementation.</p>

<p class=MsoNormal>We’ve taken the extra liberty here of defining the automatic
type conversion functions <b>operator Poingable&amp;(&nbsp;)</b> and <b>operator
Bingable&amp;(&nbsp;)</b>. In <b>main(&nbsp;)</b>, you can see that these allow
a syntax that looks as if <b>Outer</b> multiply inherits from <b>Poingable</b>
and <b>Bingable</b>. The difference is that the “casts” in this case are one-way.
You can get the effect of an upcast to <b>Poingable</b> or <b>Bingable</b>, but
you cannot downcast back to an <b>Outer</b>. In the following example of <b>observer</b>,
you’ll see the more typical approach: you provide access to the inner class
objects using ordinary member functions, not automatic type conversion
functions.</p>

<h3><a href="#_TocRef53985857" name="_Toc53985857">The observer example</a></h3>

<p class=MsoNormal>Armed with the <b>Observer</b> and <b>Observable </b>header
files and the inner class idiom, we can look at an example of the Observer
pattern:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:ObservedFlower.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstration of &quot;observer&quot; pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Observable.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Flower {</div>
<div class=CC1>  <font color=#ff7700>bool</font> isOpen;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Flower() : isOpen(<font color=#ff7700>false</font>),</div>
<div class=CC1>    openNotifier(<font color=#ff7700>this</font>), closeNotifier(<font color=#ff7700>this</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> open() { <font color=#dd0000>// Opens its petals</font></div>
<div class=CC1>    isOpen = <font color=#ff7700>true</font>;</div>
<div class=CC1>    openNotifier.notifyObservers();</div>
<div class=CC1>    closeNotifier.open();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> close() { <font color=#dd0000>// Closes its petals</font></div>
<div class=CC1>    isOpen = <font color=#ff7700>false</font>;</div>
<div class=CC1>    closeNotifier.notifyObservers();</div>
<div class=CC1>    openNotifier.close();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Using the &quot;inner class&quot; idiom:</font></div>
<div class=CC1>  <font color=#ff7700>class</font> OpenNotifier;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Flower::OpenNotifier;</div>
<div class=CC1>  <font color=#ff7700>class</font> OpenNotifier : <font color=#ff7700>public</font> Observable {</div>
<div class=CC1>    Flower* parent;</div>
<div class=CC1>    <font color=#ff7700>bool</font> alreadyOpen;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    OpenNotifier(Flower* f) : parent(f),</div>
<div class=CC1>      alreadyOpen(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> notifyObservers(Argument* arg = 0) {</div>
<div class=CC1>      <font color=#ff7700>if</font>(parent-&gt;isOpen &amp;&amp; !alreadyOpen) {</div>
<div class=CC1>        setChanged();</div>
<div class=CC1>        Observable::notifyObservers();</div>
<div class=CC1>        alreadyOpen = <font color=#ff7700>true</font>;</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>void</font> close() { alreadyOpen = <font color=#ff7700>false</font>; }</div>
<div class=CC1>  } openNotifier;</div>
<div class=CC1>  <font color=#ff7700>class</font> CloseNotifier;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Flower::CloseNotifier;</div>
<div class=CC1>  <font color=#ff7700>class</font> CloseNotifier : <font color=#ff7700>public</font> Observable {</div>
<div class=CC1>    Flower* parent;</div>
<div class=CC1>    <font color=#ff7700>bool</font> alreadyClosed;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    CloseNotifier(Flower* f) : parent(f),</div>
<div class=CC1>      alreadyClosed(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> notifyObservers(Argument* arg = 0) {</div>
<div class=CC1>      <font color=#ff7700>if</font>(!parent-&gt;isOpen &amp;&amp; !alreadyClosed)
{</div>
<div class=CC1>        setChanged();</div>
<div class=CC1>        Observable::notifyObservers();</div>
<div class=CC1>        alreadyClosed = <font color=#ff7700>true</font>;</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#ff7700>void</font> open() { alreadyClosed = <font color=#ff7700>false</font>; }</div>
<div class=CC1>  } closeNotifier;</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Bee {</div>
<div class=CC1>  string name;</div>
<div class=CC1>  <font color=#dd0000>// An &quot;inner class&quot; for observing openings:</font></div>
<div class=CC1>  <font color=#ff7700>class</font> OpenObserver;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Bee::OpenObserver;</div>
<div class=CC1>  <font color=#ff7700>class</font> OpenObserver : <font color=#ff7700>public</font> Observer {</div>
<div class=CC1>    Bee* parent;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    OpenObserver(Bee* b) : parent(b) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> update(Observable*, Argument *) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Bee &quot;</font> &lt;&lt;
parent-&gt;name</div>
<div class=CC1>        &lt;&lt; &quot;'s breakfast time!” &lt;&lt;
endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  } openObsrv;</div>
<div class=CC1>  <font color=#dd0000>// Another &quot;inner class&quot; for closings:</font></div>
<div class=CC1>  <font color=#ff7700>class</font> CloseObserver;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Bee::CloseObserver;</div>
<div class=CC1>  <font color=#ff7700>class</font> CloseObserver : <font color=#ff7700>public</font> Observer {</div>
<div class=CC1>    Bee* parent;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    CloseObserver(Bee* b) : parent(b) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> update(Observable*, Argument *) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Bee &quot;</font> &lt;&lt;
parent-&gt;name</div>
<div class=CC1>        &lt;&lt; &quot;'s bed time!” &lt;&lt; endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  } closeObsrv;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Bee(string nm) : name(nm),</div>
<div class=CC1>    openObsrv(<font color=#ff7700>this</font>), closeObsrv(<font color=#ff7700>this</font>) {}</div>
<div class=CC1>  Observer&amp; openObserver() { <font color=#ff7700>return</font> openObsrv; }</div>
<div class=CC1>  Observer&amp; closeObserver() { <font color=#ff7700>return</font> closeObsrv;}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Hummingbird {</div>
<div class=CC1>  string name;</div>
<div class=CC1>  <font color=#ff7700>class</font> OpenObserver;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Hummingbird::OpenObserver;</div>
<div class=CC1>  <font color=#ff7700>class</font> OpenObserver : <font color=#ff7700>public</font> Observer {</div>
<div class=CC1>    Hummingbird* parent;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    OpenObserver(Hummingbird* h) : parent(h) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> update(Observable*, Argument *) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Hummingbird &quot;</font> &lt;&lt;
parent-&gt;name</div>
<div class=CC1>        &lt;&lt; &quot;'s breakfast time!” &lt;&lt;
endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  } openObsrv;</div>
<div class=CC1>  <font color=#ff7700>class</font> CloseObserver;</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>class</font> Hummingbird::CloseObserver;</div>
<div class=CC1>  <font color=#ff7700>class</font> CloseObserver : <font color=#ff7700>public</font> Observer {</div>
<div class=CC1>    Hummingbird* parent;</div>
<div class=CC1>  <font color=#ff7700>public</font>:</div>
<div class=CC1>    CloseObserver(Hummingbird* h) : parent(h) {}</div>
<div class=CC1>    <font color=#ff7700>void</font> update(Observable*, Argument *) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Hummingbird &quot;</font> &lt;&lt;
parent-&gt;name</div>
<div class=CC1>        &lt;&lt; &quot;'s bed time!” &lt;&lt; endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  } closeObsrv;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Hummingbird(string nm) : name(nm),</div>
<div class=CC1>    openObsrv(<font color=#ff7700>this</font>), closeObsrv(<font color=#ff7700>this</font>) {}</div>
<div class=CC1>  Observer&amp; openObserver() { <font color=#ff7700>return</font> openObsrv; }</div>
<div class=CC1>  Observer&amp; closeObserver() { <font color=#ff7700>return</font> closeObsrv;}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  Flower f;</div>
<div class=CC1>  Bee ba(<font color=#007f00>&quot;A&quot;</font>), bb(<font color=#007f00>&quot;B&quot;</font>);</div>
<div class=CC1>  Hummingbird ha(<font color=#007f00>&quot;A&quot;</font>), hb(<font color=#007f00>&quot;B&quot;</font>);</div>
<div class=CC1>  f.openNotifier.addObserver(ha.openObserver());</div>
<div class=CC1>  f.openNotifier.addObserver(hb.openObserver());</div>
<div class=CC1>  f.openNotifier.addObserver(ba.openObserver());</div>
<div class=CC1>  f.openNotifier.addObserver(bb.openObserver());</div>
<div class=CC1>  f.closeNotifier.addObserver(ha.closeObserver());</div>
<div class=CC1>  f.closeNotifier.addObserver(hb.closeObserver());</div>
<div class=CC1>  f.closeNotifier.addObserver(ba.closeObserver());</div>
<div class=CC1>  f.closeNotifier.addObserver(bb.closeObserver());</div>
<div class=CC1>  <font color=#dd0000>// Hummingbird B decides to sleep in:</font></div>
<div class=CC1>  f.openNotifier.deleteObserver(hb.openObserver());</div>
<div class=CC1>  <font color=#dd0000>// Something changes that interests observers:</font></div>
<div class=CC1>  f.open();</div>
<div class=CC1>  f.open(); <font color=#dd0000>// It's already open, no change.</font></div>
<div class=CC1>  <font color=#dd0000>// Bee A doesn't want to go to bed:</font></div>
<div class=CC1>  f.closeNotifier.deleteObserver(</div>
<div class=CC1>    ba.closeObserver());</div>
<div class=CC1>  f.close();</div>
<div class=CC1>  f.close(); <font color=#dd0000>// It's already closed; no change</font></div>
<div class=CC1>  f.openNotifier.deleteObservers();</div>
<div class=CC1>  f.open();</div>
<div class=CC1>  f.close();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The events of interest are that a <b>Flower</b> can open or
close. Because of the use of the inner class idiom, both these events can be
separately observable phenomena. The <b>OpenNotifier</b> and <b>CloseNotifier</b>
classes both derive from <b>Observable</b>, so they have access to <b>setChanged(&nbsp;)</b>
and can be handed to anything that needs an <b>Observable</b>. You’ll notice
that, contrary to <b>InnerClassIdiom.cpp</b>, the <b>Observable</b> descendants
are <b>public</b>. This is because some of their member functions must be
available to the client programmer. There’s nothing that says that an inner
class must be <b>private</b>; in <b>InnerClassIdiom.cpp</b> we were simply
following the design guideline “make things as private as possible.” You could
make the classes <b>private</b> and expose the appropriate member functions by
proxy in <b>Flower</b>, but it wouldn’t gain much.</p>

<p class=MsoNormal>The inner class idiom also comes in handy to define more
than one kind of <b>Observer</b> in <b>Bee</b> and <b>Hummingbird</b>, since
both those classes may want to independently observe <b>Flower</b> openings and
closings. Notice how the inner class idiom provides something that has most of
the benefits of inheritance (the ability to access the private data in the
outer class, for example).</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, you can see one of the primary
benefits of the Observer pattern: the ability to change behavior at runtime by
dynamically registering and unregistering <b>Observer</b>s with <b>Observable</b>s.
This flexibility is achieved at the cost of significant additional code—you
will often see this kind of tradeoff in design patterns: more complexity in one
place in exchange for increased flexibility and/or lowered complexity in
another place.</p>

<p class=MsoNormal>If you study the previous example, you’ll see that <b>OpenNotifier
</b>and <b>CloseNotifier</b> use the basic <b>Observable</b> interface. This
means that you could derive from other completely different <b>Observer</b>
classes; the only connection the <b>Observer</b>s have with <b>Flower</b>s is
the <b>Observer</b> interface.</p>

<p class=MsoNormal>Another way to accomplish this fine granularity of
observable phenomena is to use some form of tags for the phenomena, for example
empty classes, strings, or enumerations that denote different types of
observable behavior. This approach can be implemented using aggregation rather
than inheritance, and the differences are mainly tradeoffs between time and
space efficiency. For the client, the differences are negligible.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef11818308" name="_Toc11818308">Multiple dispatching</a></h2>

<p class=MsoNormal>When dealing with multiple interacting types, a program can
get particularly messy. For example, consider a system that parses and executes
mathematical expressions. You want to be able to say <b>Number + Number</b>, <b>Number
* Number</b>, and so on, where <b>Number</b> is the base class for a family of
numerical objects. But when you say <b>a + b</b>, and you don’t know the exact
type of either <b>a</b> or <b>b</b>, how can you get them to interact properly?</p>

<p class=MsoNormal>The answer starts with something you probably don’t think
about: C++ performs only single dispatching. That is, if you are performing an
operation on more than one object whose type is unknown, C++ can invoke the
dynamic binding mechanism on only one of those types. This doesn’t solve the
problem described here, so you end up detecting some types manually and
effectively producing your own dynamic binding behavior.</p>

<p class=MsoNormal>The solution is called <i>multiple dispatching</i> (described in GoF in the context of the Visitor pattern, shown in the next section). Here,
there will be only two dispatches, which is referred to as <i>double dispatching.</i> Remember that polymorphism can occur only via virtual function calls,
so if you want multiple dispatching to occur, there must be a virtual function
call to determine each unknown type. Thus, if you are working with two
different type hierarchies that are interacting, you’ll need a virtual call in
each hierarchy. Generally, you’ll set up a configuration such that a single
member function call generates more than one virtual member function call and
thus determines more than one type in the process: you’ll need a virtual
function call for each dispatch. The virtual functions in the following example
are called <b>compete(&nbsp;) </b>and <b>eval(&nbsp;)</b> and are both members
of the same type (this is not a requirement for multiple dispatching):<a href="#_ftn146" name="_ftnref146"><span
class=MsoFootnoteReference>[146]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:PaperScissorsRock.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstration of multiple dispatching.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iterator&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Paper;</div>
<div class=CC1><font color=#ff7700>class</font> Scissors;</div>
<div class=CC1><font color=#ff7700>class</font> Rock;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>enum</font> Outcome { WIN, LOSE, DRAW };</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
Outcome out) {</div>
<div class=CC1>  <font color=#ff7700>switch</font>(out) {</div>
<div class=CC1>    <font color=#ff7700>default</font>:</div>
<div class=CC1>    <font color=#ff7700>case</font> WIN: <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;win&quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>case</font> LOSE: <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;lose&quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>case</font> DRAW: <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;draw&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Item {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Outcome compete(<font color=#ff7700>const</font> Item*) = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Outcome eval(<font color=#ff7700>const</font> Paper*) <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Outcome eval(<font color=#ff7700>const</font> Scissors*) <font color=#ff7700>const</font>= 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> Outcome eval(<font color=#ff7700>const</font> Rock*) <font color=#ff7700>const</font> = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ostream&amp; print(ostream&amp; os) <font color=#ff7700>const</font> =
0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Item() {}</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Item* it) {</div>
<div class=CC1>    <font color=#ff7700>return</font> it-&gt;print(os);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Paper : <font color=#ff7700>public</font> Item {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Outcome compete(<font color=#ff7700>const</font> Item* it) { <font color=#ff7700>return</font>
it-&gt;eval(<font color=#ff7700>this</font>);}</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Paper*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> DRAW; }</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Scissors*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> WIN; }</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Rock*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> LOSE; }</div>
<div class=CC1>  ostream&amp; print(ostream&amp; os) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Paper   &quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Scissors : <font color=#ff7700>public</font> Item {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Outcome compete(<font color=#ff7700>const</font> Item* it) { <font color=#ff7700>return</font>
it-&gt;eval(<font color=#ff7700>this</font>);}</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Paper*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> LOSE; }</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Scissors*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> DRAW; }</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Rock*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> WIN; }</div>
<div class=CC1>  ostream&amp; print(ostream&amp; os) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Scissors&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Rock : <font color=#ff7700>public</font> Item {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Outcome compete(<font color=#ff7700>const</font> Item* it) { <font color=#ff7700>return</font>
it-&gt;eval(<font color=#ff7700>this</font>);}</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Paper*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> WIN; }</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Scissors*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> LOSE; }</div>
<div class=CC1>  Outcome eval(<font color=#ff7700>const</font> Rock*) <font color=#ff7700>const</font> { <font color=#ff7700>return</font> DRAW; }</div>
<div class=CC1>  ostream&amp; print(ostream&amp; os) <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Rock    &quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> ItemGen {</div>
<div class=CC1>  Item* <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>switch</font>(rand() % 3) {</div>
<div class=CC1>      <font color=#ff7700>default</font>:</div>
<div class=CC1>      <font color=#ff7700>case</font> 0: <font color=#ff7700>return</font> <font color=#ff7700>new</font> Scissors;</div>
<div class=CC1>      <font color=#ff7700>case</font> 1: <font color=#ff7700>return</font> <font color=#ff7700>new</font> Paper;</div>
<div class=CC1>      <font color=#ff7700>case</font> 2: <font color=#ff7700>return</font> <font color=#ff7700>new</font> Rock;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> Compete {</div>
<div class=CC1>  Outcome <font color=#ff7700>operator</font>()(Item* a, Item* b) {</div>
<div class=CC1>    cout &lt;&lt; a &lt;&lt; <font color=#007f00>&quot;\t&quot;</font> &lt;&lt; b
&lt;&lt; <font color=#007f00>&quot;\t&quot;</font>;</div>
<div class=CC1>    <font color=#ff7700>return</font> a-&gt;compete(b);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> sz = 20;</div>
<div class=CC1>  vector&lt;Item*&gt; v(sz*2);</div>
<div class=CC1>  generate(v.begin(), v.end(), ItemGen());</div>
<div class=CC1>  transform(v.begin(), v.begin() + sz,</div>
<div class=CC1>    v.begin() + sz,</div>
<div class=CC1>    ostream_iterator&lt;Outcome&gt;(cout,
<font color=#007f00>&quot;\n&quot;</font>),</div>
<div class=CC1>    Compete());</div>
<div class=CC1>  purge(v);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Outcome</b> categorizes the different possible results of
a <b>compete(&nbsp;)</b>, and the <b>operator&lt;&lt;</b> simplifies the
process of displaying a particular <b>Outcome</b>.</p>

<p class=MsoNormal><b>Item</b> is the base class for the types that will be
multiply-dispatched. <b>Compete::operator(&nbsp;) </b>takes two <b>Item</b>*
(the exact type of both are unknown) and begins the double-dispatching process
by calling the <b>virtual</b> <b>Item::compete(&nbsp;)</b> function. The virtual
mechanism determines the type <b>a</b>, so it wakes up inside the <b>compete(&nbsp;)</b>
function of <b>a</b>’s concrete type. The <b>compete(&nbsp;)</b> function
performs the second dispatch by calling <b>eval(&nbsp;)</b> on the remaining
type. Passing itself (<b>this</b>) as an argument to <b>eval(&nbsp;) </b>produces
a call to the overloaded <b>eval(&nbsp;)</b> function, thus preserving the type
information of the first dispatch. When the second dispatch is completed, you
know the exact types of both <b>Item</b> objects.</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>,<b> </b>the STL algorithm <b>generate(&nbsp;)</b>
populates the <b>vector v</b>, then <b>transform(&nbsp;)</b> applies <b>Compete::operator(&nbsp;)</b>
to the two ranges. This version of <b>transform(&nbsp;)</b> takes the start and
end point of the first range (containing the left-hand <b>Item</b>s used in the
double dispatch); the starting point of the second range, which holds the
right-hand <b>Item</b>s; the destination iterator, which in this case is
standard output; and the function object (a temporary of type <b>Compete</b>)<b>
</b>to call for each object.</p>

<p class=MsoNormal>It requires a lot of ceremony to set up multiple
dispatching, but keep in mind that the benefit is the syntactic elegance
achieved when making the call—instead of writing awkward code to determine the
type of one or more objects during a call, you simply say: “You two! I don’t
care what types you are, interact properly with each other!” Make sure this
kind of elegance is important to you before embarking on multiple dispatching,
however.</p>

<p class=MsoNormal>Note that multiple dispatching is, in effect, performing a
table lookup. Here, the lookup is performed using virtual functions, but you
could instead perform a literal table lookup. With more than a few dispatches
(and if you are prone to making additions and changes), a table lookup may be a
better solution to the problem.</p>

<h3><a href="#_TocRef11818309" name="_Toc11818309">Multiple dispatching</a>
with Visitor</h3>

<p class=MsoNormal>The goal of Visitor (the final, and arguably most complex,
pattern in GoF) is to separate the operations on a class hierarchy from the
hierarchy itself. This is quite an odd motivation because most of what we do in
object-oriented programming is to combine data and operations into objects, and
to use polymorphism to automatically select the correct variation of an
operation, depending on the exact type of an object.</p>

<p class=MsoNormal>With Visitor you extract the operations from inside your
class hierarchy into a separate, external hierarchy. The “main” hierarchy then
contains a <b>visit(&nbsp;)</b> function that accepts any object from your
hierarchy of operations. As a result, you get two class hierarchies instead of
one. In addition, you’ll see that your “main” hierarchy becomes very brittle—if
you add a new class, you will force changes throughout the second hierarchy. GoF
says that the main hierarchy should thus “rarely change.” This constraint is
very limiting, and it further reduces the applicability of this pattern.</p>

<p class=MsoNormal>For the sake of argument, then, assume that you have a
primary class hierarchy that is fixed; perhaps it’s from another vendor and you
can’t make changes to that hierarchy. If you had the source code for the
library, you could add new virtual functions in the base class, but this is,
for some reason, not feasible. A more likely scenario is that adding new
virtual functions is somehow awkward, ugly or otherwise difficult to maintain. GoF
argues that “distributing all these operations across the various node classes
leads to a system that’s hard to understand, maintain, and change.” (As you’ll
see, Visitor can be much harder to understand, maintain and change.) Another
GoF argument is that you want to avoid “polluting” the interface of the main
hierarchy with too many operations (but if your interface is too “fat,” you
might ask whether the object is trying to do too many things).</p>

<p class=MsoNormal>The library creator must have foreseen, however, that you
will want to add new operations to that hierarchy, so that they can know to include
the <b>visit(&nbsp;) </b>function.</p>

<p class=MsoNormal>So (assuming you really need to do this) the dilemma is that
you need to add member functions to the base class, but for some reason you
can’t touch the base class. How do you get around this?</p>

<p class=MsoNormal>Visitor builds on the double-dispatching scheme shown in the
previous section. The Visitor pattern allows you to effectively extend the
interface of the primary type by creating a separate class hierarchy of type <b>Visitor
</b>to “virtualize” the operations performed on the primary type. The objects
of the primary type simply “accept” the visitor and then call the visitor’s
dynamically bound member function. Thus, you create a visitor, pass it into the
primary hierarchy, and you get the effect of a virtual function. Here’s a
simple example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C10:BeeAndFlowers.cpp</font></div>
<div class=CC1><font color=#dd0000>// Demonstration of &quot;visitor&quot; pattern.</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;../purge.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Gladiolus;</div>
<div class=CC1><font color=#ff7700>class</font> Renuculus;</div>
<div class=CC1><font color=#ff7700>class</font> Chrysanthemum;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Visitor {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Gladiolus* f) = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Renuculus* f) = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Chrysanthemum* f) = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Visitor() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Flower {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> accept(Visitor&amp;) = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Flower() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Gladiolus : <font color=#ff7700>public</font> Flower {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> accept(Visitor&amp; v) {</div>
<div class=CC1>    v.visit(<font color=#ff7700>this</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Renuculus : <font color=#ff7700>public</font> Flower {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> accept(Visitor&amp; v) {</div>
<div class=CC1>    v.visit(<font color=#ff7700>this</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Chrysanthemum : <font color=#ff7700>public</font> Flower {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> accept(Visitor&amp; v) {</div>
<div class=CC1>    v.visit(<font color=#ff7700>this</font>);</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Add the ability to produce a string:</font></div>
<div class=CC1><font color=#ff7700>class</font> StringVal : <font color=#ff7700>public</font> Visitor {</div>
<div class=CC1>  string s;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>operator</font> <font color=#ff7700>const</font> string&amp;() { <font color=#ff7700>return</font> s; }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Gladiolus*) {</div>
<div class=CC1>    s = <font color=#007f00>&quot;Gladiolus&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Renuculus*) {</div>
<div class=CC1>    s = <font color=#007f00>&quot;Renuculus&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Chrysanthemum*) {</div>
<div class=CC1>    s = <font color=#007f00>&quot;Chrysanthemum&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Add the ability to do &quot;Bee&quot; activities:</font></div>
<div class=CC1><font color=#ff7700>class</font> Bee : <font color=#ff7700>public</font> Visitor {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Gladiolus*) {</div>
<div class=CC1>    cout &lt;&lt; &quot;Bee <font color=#ff7700>and</font> Gladiolus” &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Renuculus*) {</div>
<div class=CC1>    cout &lt;&lt; &quot;Bee <font color=#ff7700>and</font> Renuculus” &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> visit(Chrysanthemum*) {</div>
<div class=CC1>    cout &lt;&lt; &quot;Bee <font color=#ff7700>and</font> Chrysanthemum” &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>struct</font> FlowerGen {</div>
<div class=CC1>  Flower* <font color=#ff7700>operator</font>()() {</div>
<div class=CC1>    <font color=#ff7700>switch</font>(rand() % 3) {</div>
<div class=CC1>      <font color=#ff7700>default</font>:</div>
<div class=CC1>      <font color=#ff7700>case</font> 0: <font color=#ff7700>return</font> <font color=#ff7700>new</font> Gladiolus;</div>
<div class=CC1>      <font color=#ff7700>case</font> 1: <font color=#ff7700>return</font> <font color=#ff7700>new</font> Renuculus;</div>
<div class=CC1>      <font color=#ff7700>case</font> 2: <font color=#ff7700>return</font> <font color=#ff7700>new</font> Chrysanthemum;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  vector&lt;Flower*&gt; v(10);</div>
<div class=CC1>  generate(v.begin(), v.end(), FlowerGen());</div>
<div class=CC1>  vector&lt;Flower*&gt;::iterator it;</div>
<div class=CC1>  <font color=#dd0000>// It's almost as if I added a virtual function</font></div>
<div class=CC1>  <font color=#dd0000>// to produce a Flower string representation:</font></div>
<div class=CC1>  StringVal sval;</div>
<div class=CC1>  <font color=#ff7700>for</font>(it = v.begin(); it != v.end(); it++) {</div>
<div class=CC1>    (*it)-&gt;accept(sval);</div>
<div class=CC1>    cout &lt;&lt; string(sval) &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Perform &quot;Bee&quot; operation on all Flowers:</font></div>
<div class=CC1>  Bee bee;</div>
<div class=CC1>  <font color=#ff7700>for</font>(it = v.begin(); it != v.end(); it++)</div>
<div class=CC1>    (*it)-&gt;accept(bee);</div>
<div class=CC1>  purge(v);</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Flower</b> is the primary hierarchy, and each subtype of <b>Flower</b>
can <b>accept(&nbsp;)</b> a <b>Visitor</b>. The <b>Flower</b> hierarchy has no
operations other than <b>accept(&nbsp;)</b>, so all the functionality of the <b>Flower</b>
hierarchy is contained in the <b>Visitor</b> hierarchy. Note that the <b>Visitor</b>
classes must know about all the specific types of <b>Flower</b>, and if you add
a new type of <b>Flower</b> the entire <b>Visitor</b> hierarchy must be
reworked.</p>

<p class=MsoNormal>The <b>accept(&nbsp;) </b>function in each <b>Flower</b>
begins a double dispatch as described in the previous section. The first
dispatch determines the exact type of <b>Flower</b> and the second determines
the exact type of <b>Visitor</b>. Once you know the exact types you can perform
an operation appropriate to both.</p>

<p class=MsoNormal>It’s very unlikely that you’ll use Visitor because its
motivation is unusual and its constraints are stultifying. The GoF examples are
not convincing—the first is a compiler (not many people write compilers, and it
seems quite rare that Visitor is used within these compilers), and they
apologize for the other examples, saying you wouldn’t actually use Visitor for
anything like this. You would need a stronger compulsion than that presented in
GoF to abandon an ordinary OO structure for Visitor—what benefit does it really
buy you in exchange for much greater complexity and constraint? Why can’t you
simply add more virtual functions in the base class when you discover you need
them? Or, if you really need to paste new functions into an existing hierarchy
and you are unable to modify that hierarchy, why not try multiple inheritance
first? (Even then, the likelihood of “saving” the existing hierarchy this way
is slim). Consider also that, to use Visitor, the existing hierarchy must
incorporate a <b>visit(&nbsp;)</b> function from the beginning, because to add
it later would mean that you had permission to modify the hierarchy, so you
could just add ordinary virtual functions as you need them. No, Visitor must be
part of the architecture from the beginning, and to use it requires a
motivation greater than that in GoF.<a href="#_ftn147" name="_ftnref147"><span
class=MsoFootnoteReference>[147]</span></a></p>

<p class=MsoNormal>We present Visitor here because we have seen it used when it
shouldn’t be, just as multiple inheritance and any number of other approaches
have been used inappropriately. If you find yourself using Visitor, ask why.
Are you <i>really</i> unable to add new virtual functions in the base class? Do
you <i>really</i> want to be restricted from adding new types in your primary
hierarchy?</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985860" name="_Toc53985860">Summary</a></h2>

<p class=MsoNormal>The point of design patterns, like the point of any
abstraction, is to make your life easier. Usually something in your system is
changing—this could be code during the lifetime of the project, or objects
during the lifetime of one program execution. Discover what is changing, and a
design pattern may help you encapsulate that change, and thus bring it under
control.</p>

<p class=MsoNormal>It’s easy to get infatuated with a particular design, and to
create trouble for yourself by applying it just because you know how. What’s
hard, ironically, is to follow the XP maxim of “do the simplest thing that
could possibly work.” But by doing the simplest thing, you not only get a
design that’s faster to implement, but also easier to maintain. And if the
simplest thing doesn’t do the job, you’ll find out a lot sooner than if you
spend the time implementing something complex, and then find out <i>that</i>
doesn’t work.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef375545420" name="_Toc375545420">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a variation of <b>SingletonPattern.cpp</b> where all
functions are static. Is the <b>instance(&nbsp;)</b> function still necessary
in this case?</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Starting with <b>SingletonPattern.cpp</b>, create a class that
provides a connection to a service that stores and retrieves data from a
configuration file.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Using <b>SingletonPattern.cpp</b> as a starting point, create a
class that manages a fixed number of its own objects. Assume the objects are
database connections and you only have a license to use a fixed quantity of
these at any one time.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>KissingPrincess2.cpp</b> by adding another state to the
system, so that each kiss cycles the creature to the next state.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Find <b>C16:TStack.h</b> from <i>Thinking in C++, Volume 1, 2<sup>nd</sup>
Edition</i> (downloadable from www. BruceEckel.com). Create an Adapter for this
class such that you can apply the STL algorithm <b>for_each(&nbsp;)</b> to the
elements of the <b>TStack</b>, using your adapter. Create a <b>TStack</b> of <b>string</b>,
fill it with strings and use <b>for_each(&nbsp;)</b> to count all the letters
in all the strings in the <b>TStack</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a framework (that is, use the Template Method pattern)
that takes a list of file names on the command line. It opens each file except
the last for reading, and the last file it opens for writing. The framework
will process each input file using an undetermined policy and write the output
to the last file. Inherit to customize this framework to create two separate
applications:<br>
1) Converts all the letters in each file to uppercase.<br>
2) Searches the files for words given in the first file.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify Exercise 6 to use Strategy instead of Template Method.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>Strategy.cpp</b> to include State behavior, so that the
Strategy can be changed during the lifetime of the <b>Context</b> object.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>Strategy.cpp</b> to use a Chain of Responsibility
approach, where you keep trying different ways to get someone to say their name
without admitting you’ve forgotten it.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>10.&nbsp;&nbsp;&nbsp;&nbsp;</span>Add a class <b>Triangle</b> to <b>ShapeFactory1.cpp</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>11.&nbsp;&nbsp;&nbsp;&nbsp;</span>Add a class <b>Triangle</b> to <b>ShapeFactory2.cpp</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>12.&nbsp;&nbsp;&nbsp;&nbsp;</span>Add a new type of <b>GameEnvironment</b> called <b>GnomesAndFairies</b>
to <b>AbstractFactory.cpp</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>13.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>ShapeFactory2.cpp</b> so that it uses an Abstract
Factory to create different sets of shapes (for example, one particular type of
factory object creates “thick shapes,” another creates “thin shapes,” but each
factory object can create all the shapes: circles, squares, triangles, and so
on).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>14.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>VirtualConstructor.cpp</b> to use a <b>map</b> instead
of <b>if-else</b> statements inside <b>Shape::Shape(string type)</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>15.&nbsp;&nbsp;&nbsp;&nbsp;</span>Break a text file up into an input stream of words (keep it
simple: just break the input stream on white space). Create one Builder that
puts the words into a <b>set</b>, and another that produces a <b>map</b>
containing words and occurrences of those words (that is, it does a word
count).</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a minimal Observer-Observable design in two classes,
without base classes and without the extra arguments in <b>Observer.h</b> and
the member functions in <b>Observable.h</b>. Just create the bare minimum in
the two classes, and then demonstrate your design by creating one <b>Observable</b>
and many <b>Observer</b>s and cause the <b>Observable</b> to update the <b>Observer</b>s.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Change <b>InnerClassIdiom.cpp</b> so that <b>Outer</b> uses
multiple inheritance instead of the inner class idiom.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>18.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>PaperScissorsRock.java</b> to replace the double
dispatch with a table lookup. The easiest way to do this is to create a <b>map </b>of
<b>map</b>s, with the key of each <b>map </b>the <b>typeid(obj).name(&nbsp;)</b>
information of each object. Then you can do the lookup by saying: <b>map[typeid(obj1).name(&nbsp;)][typeid(obj2).name(&nbsp;)]</b>.<br>
Notice how much easier it is to reconfigure the system. When is it more
appropriate to use this approach vs. hard-coding the dynamic dispatches? Can
you create a system that has the syntactic simplicity of use of the dynamic
dispatch but uses a table lookup?</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>19.&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a business-modeling environment with three types of <b>Inhabitant</b>:
<b>Dwarf</b> (for engineers), <b>Elf</b> (for marketers), and <b>Troll</b> (for
managers). Now create a class called <b>Project</b> that instantiates the different
inhabitants and causes them to <b>interact(&nbsp;)</b> with each other using
multiple dispatching.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>20.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify the previous exercise to make the interactions more
detailed. Each <b>Inhabitant</b> can randomly produce a <b>Weapon</b> using <b>getWeapon(&nbsp;)</b>:
a <b>Dwarf</b> uses <b>Jargon</b> or <b>Play</b>, an <b>Elf</b> uses <b>InventFeature</b>
or <b>SellImaginaryProduct</b>, and a <b>Troll</b> uses <b>Edict</b> and <b>Schedule</b>.
You decide which weapons “win” and “lose” in each interaction (as in <b>PaperScissorsRock.cpp</b>).
Add a <b>battle(&nbsp;)</b> member function to <b>Project</b> that takes two <b>Inhabitant</b>s
and matches them against each other. Now create a <b>meeting(&nbsp;)</b> member
function for <b>Project</b> that creates groups of <b>Dwarf</b>, <b>Elf</b>,
and <b>Manager</b> and battles the groups against each other until only members
of one group are left standing. These are the “winners.”</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>21.&nbsp;&nbsp;&nbsp;&nbsp;</span>Add a <b>Hummingbird</b> <b>Visitor</b> to <b>BeeAndFlowers.cpp</b>.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>22.&nbsp;&nbsp;&nbsp;&nbsp;</span>Add a <b>Sunflower</b> type to <b>BeeAndFlowers.cpp</b> and
notice what you need to change to accommodate this new type.</p>

<p class=ExercisesCharCharCharCharChar><span style='font-family:Verdana'>23.&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>BeeAndFlowers.cpp</b> so that it does <i>not</i> use
Visitor, but “reverts” to a regular class hierarchy instead. Turn <b>Bee</b>
into a collecting parameter.</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section21>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985862" name="_Toc53985862">11: Concurrency</a></h1>

<p class=Intro style='margin-left:.25in'>Objects provide a way to divide a program into independent
sections. Often, you also need to partition a program into separate,
independently running subtasks.</p>

<p class=MsoNormal>Using <i>multithreading</i>, each of these independent
subtasks is driven by a <i>thread of execution</i>, and you program as if each
thread has the CPU to itself. An underlying mechanism is dividing up the CPU
time for you, but in general, you don’t need to think about it, which helps to
simplify programming with multiple threads.</p>

<p class=MsoNormal>A <i>process</i> is a self-contained program running within
its own address space. A <i>multitasking</i> operating system can run more than
one process (program) at a time, while making it look as if each one is
chugging along on its own, by periodically switching the CPU from one task to
another. A <i>thread</i> is a single sequential flow of control <i>within</i> a
process. A single process can thus have multiple concurrently executing
threads. Since the threads run within a single process, they share memory and
other resources. The fundamental difficulty in writing multithreaded programs
is coordinating the use of those resources between different threads.</p>

<p class=MsoNormal>There are many possible uses for multithreading, but you’ll
most often want to use it when you have some part of your program tied to a
particular event or resource. To keep from holding up the rest of your program,
you create a thread associated with that event or resource and let it run
independently of the main program.</p>

<p class=MsoNormal>Concurrent programming is like stepping into an entirely new
world and learning a new programming language, or at least a new set of language
concepts. With the appearance of thread support in most microcomputer operating
systems, extensions for threads have also been appearing in programming
languages or libraries. In all cases, thread programming:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;Seems mysterious and requires a shift in the way you think about
programming.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;Looks similar to thread support in other languages. When you understand
threads, you understand a common tongue.</p>

<p class=MsoNormal>Understanding concurrent programming is on the same order of
difficulty as understanding polymorphism. If you apply some effort, you can
fathom the basic mechanism, but it generally takes deep study and understanding
to develop a true grasp of the subject. The goal of this chapter is to give you
a solid foundation in the basics of concurrency so that you can understand the
concepts and write reasonable multithreaded programs. Be aware that you can
easily become overconfident. If you are writing anything complex, you will need
to study dedicated books on the topic.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef24775836" name="_Toc24775836">Motivation</a></h2>

<p class=MsoNormal>One of the most compelling reasons for using concurrency is
to produce a responsive user interface. Consider a program that performs some CPU-intensive operation and thus ends up ignoring user input and being
unresponsive. The program needs to continue performing its operations, and at
the same time it needs to return control to the user interface so that the
program can respond to the user. If you have a “quit” button, you don’t want to
be forced to poll it in every piece of code you write in your program. (This
would couple your quit button across the program and be a maintenance
headache.) Yet you want the quit button to be responsive, as if you <i>were</i>
checking it regularly.</p>

<p class=MsoNormal>A conventional function cannot continue performing its
operations and at the same time return control to the rest of the program. In
fact, this sounds like an impossibility, as if the CPU must be in two places at
once, but this is precisely the illusion that concurrency provides (in the case
of multiprocessor systems, this may be more than an illusion).</p>

<p class=MsoNormal>You can also use concurrency to optimize throughput. For example, you might be able to do important work while you’re stuck waiting for
input to arrive on an I/O port. Without threading, the only reasonable solution
is to poll the I/O port, which is awkward and can be difficult.</p>

<p class=MsoNormal>If you have a multiprocessor machine, multiple threads can be distributed across multiple processors, which can dramatically improve
throughput. This is often the case with powerful multiprocessor web servers, which can distribute large numbers of user requests across CPUs in a
program that allocates one thread per request.</p>

<p class=MsoNormal>A program that uses threads on a single-CPU machine is still
just doing one thing at a time, so it must be theoretically possible to write
the same program without using any threads. However, multithreading provides an
important organizational benefit: The design of your program can be greatly
simplified. Some types of problems, such as simulation—a video game, for
example—are difficult to solve without support for concurrency.</p>

<p class=MsoNormal>The threading model is a programming convenience to simplify
juggling several operations at the same time within a single program: The CPU
will pop around and give each thread some of its time.<a href="#_ftn148" name="_ftnref148"><span
class=MsoFootnoteReference>[148]</span></a> Each thread
has the consciousness of constantly having the CPU to itself, but the CPU’s
time is actually sliced among all the threads. The exception is a program that
is running on multiple CPU. But one of the great things about threading is that
you are abstracted away from this layer, so your code does not need to know
whether it is running on a single CPU or many.<a href="#_ftn149" name="_ftnref149"><span
class=MsoFootnoteReference>[149]</span></a> Thus, using
threads is a way to create transparently scalable programs—if a program is
running too slowly, you can easily speed it up by adding CPUs to your computer.
Multitasking and multithreading tend to be the most reasonable ways to utilize
multiprocessor systems.</p>

<p class=MsoNormal>Threading can reduce computing efficiency somewhat, but the
net improvement in program design, resource balancing, and user convenience is
often quite valuable. In general, threads enable you to create a more loosely
coupled design; otherwise, parts of your code would be forced to pay explicit
attention to tasks that would normally be handled by threads.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef40780395" name="_Toc40780395">Concurrency in C++</a></h2>

<p class=MsoNormal>When the C++ Standards Committee was creating the initial C++
Standard, a concurrency mechanism was explicitly excluded because C didn’t have
one and also because there were a number of competing approaches to
implementing concurrency. It seemed too much of a constraint to force
programmers to use only one of these.</p>

<p class=MsoNormal>The alternative turned out to be worse, however. To use
concurrency, you had to find and learn a library and deal with its
idiosyncrasies and the uncertainties of working with a particular vendor. In
addition, there was no guarantee that such a library would work on different
compilers or across different platforms. Also, since concurrency was not part
of the standard language, it was more difficult to find C++ programmers who
also understood concurrent programming.</p>

<p class=MsoNormal>Another influence may have been the Java language, which
included concurrency in the core language. Although multithreading is still
complicated, Java programmers tend to start learning and using it from the
beginning.</p>

<p class=MsoNormal>The C++ Standards Committee is considering the addition of
concurrency support to the next iteration of C++, but at the time of this
writing it is unclear what the library will look like. We decided to use the ZThread library as the basis for this chapter. We preferred the design, and it is
open-source and freely available at <i>http://zthread.sourceforge.net</i>. Eric Crahen of IBM, the author of the ZThread library, was instrumental in creating
this chapter.<a href="#_ftn150" name="_ftnref150"><span
class=MsoFootnoteReference>[150]</span></a></p>

<p class=MsoNormal>This chapter uses only a subset of the ZThread library, in
order to convey the fundamental ideas of threading. The ZThread library
contains significantly more sophisticated thread support than is shown here,
and you should study that library further in order to fully understand its
capabilities.</p>

<h3><a href="#_TocRef40780396" name="_Toc40780396">Installing ZThreads</a></h3>

<p class=MsoNormal>Please note that the ZThread library is an independent
project and is not supported by the authors of this book; we are simply using
the library in this chapter and cannot provide technical support for
installation issues. See the ZThread web site for installation support and
error reports.</p>

<p class=MsoNormal>The ZThread library is distributed as source code. After
downloading it (version 2.3 or greater) from the ZThread web site, you must
first compile the library, and then configure your project to use the library.</p>

<p class=MsoNormal>The preferred method for compiling ZThreads for most flavors
of UNIX (Linux, SunOS, Cygwin, etc.) is to use the configure script. After unpacking
the files (using <b>tar</b>),<b> </b>simply execute:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>./configure &amp;&amp; make
install</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>from the main directory of the ZThreads archive to compile
and install a copy of the library in the <i>/usr/local</i> directory. You can
customize a number of options when using this script, including the locations
of files. For details, use this command:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>./configure –help</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The ZThreads code is structured to simplify compilation for
other platforms and compilers (such as Borland, Microsoft, and Metrowerks). To
do this, create a new project and add all the <i>.cxx </i>files in the <i>src</i>
directory of the ZThreads archive to the list of files to be compiled. Also, be
sure to include the <i>include</i> directory of the archive in the header
search path for your project. The exact details will vary from compiler to
compiler so you’ll need to be somewhat familiar with your toolset to be able to
use this option.</p>

<p class=MsoNormal>Once the compilation has succeeded, the next step is to
create a project that uses the newly compiled library. First, let the compiler
know where the headers are located so that your <b>#include</b> statements will
work properly. Typically, you will add an option such as the following to your
project:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>-I/path/to/installation/include</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you used the <i>configure</i> script, the installation
path will be whatever you selected for the prefix (which defaults to <i>/usr/local</i>).
If you used one of the project files in the <i>build</i> directory, the
installation path would simply be the path to the main directory of the
ZThreads archive.</p>

<p class=MsoNormal>Next, you’ll need to add an option to your project that will
let the linker know where to find the library. If you used the configure
script, this will look like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>-L/path/to/installation/lib
–lZThread</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>If you used one of the project files provided, this will
look like:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1>-L/path/to/installation/Debug
ZThread.lib</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Again, if you used the <i>configure</i> script, the
installation path will be whatever you selected for the prefix. If you used a
provided project file, the path will be the path to the main directory of the
ZThreads archive.</p>

<p class=MsoNormal>Note that if you’re using Linux, or if you are using Cygwin (www.cygwin.com) under Windows, you may not need to modify your
include or library path; the installation process and defaults will often take
care of everything for you.</p>

<p class=MsoNormal>Under Linux, you will probably need to add the following to
your <b>.bashrc</b> so that the runtime system can find the shared library file
<b>LibZThread-x.x.so.O </b>when it executes the programs in this chapter:</p>

<p class=MsoNormal><b><span style='font-size:10.0pt'>export
LD_LIBRARY_PATH=/usr/local/lib:${LD_LIBRARY_PATH}</span></b></p>

<p class=MsoNormal>(Assuming you used the default installation process and the
shared library ended up in /user/local/lib; otherwise, change the path to your
location).</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef40780397" name="_Toc40780397">Defining Tasks</a></h2>

<p class=MsoNormal>A thread carries out a task, so you need a way to describe that task. The <b>Runnable</b> class provides a common interface to
execute any arbitrary task. Here is the core of the ZThread <b>Runnable</b>
class, which you will find in <b>Runnable.h</b> in the <i>include</i>
directory, after installing the ZThread library:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#ff7700>class</font> Runnable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> run() = 0;</div>
<div class=CC1>  <font color=#ff7700>virtual</font> ~Runnable() {}</div>
<div class=CC1>};</div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>By making this an abstract base class, <b>Runnable</b> is easily
combinable with a base class and other classes.</p>

<p class=MsoNormal>To define a task, simply inherit from the <b>Runnable</b>
class and override <b>run(&nbsp;)</b> to make the task do your bidding.</p>

<p class=MsoNormal>For example, the following <b>LiftOff</b> task displays the
countdown before liftoff:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:LiftOff.h</font></div>
<div class=CC1><font color=#dd0000>// Demonstration of the Runnable interface.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef LIFTOFF_H</font></div>
<div class=CC1><font color=#7F7F00>#define LIFTOFF_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Runnable.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> LiftOff : <font color=#ff7700>public</font> ZThread::Runnable {</div>
<div class=CC1>  <font color=#ff7700>int</font> countDown;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  LiftOff(<font color=#ff7700>int</font> count, <font color=#ff7700>int</font> ident = 0) :</div>
<div class=CC1>    countDown(count), id(ident) {}</div>
<div class=CC1>  ~LiftOff() {</div>
<div class=CC1>    std::cout &lt;&lt; id &lt;&lt; <font color=#007f00>&quot;
completed&quot;</font> &lt;&lt; std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(countDown--)</div>
<div class=CC1>      std::cout &lt;&lt; id &lt;&lt; <font color=#007f00>&quot;:&quot;</font>
&lt;&lt; countDown &lt;&lt; std::endl;</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;Liftoff!&quot;</font> &lt;&lt;
std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// LIFTOFF_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The identifier <b>id </b>distinguishes between multiple
instances of the task. If you only make a single instance, you can use the
default value for <b>ident</b>. The destructor will allow you to see that a
task is properly destroyed.</p>

<p class=MsoNormal>In the following example, the task’s <b>run(&nbsp;)</b> is
not driven by a separate thread; it is simply called directly in <b>main(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:NoThread.cpp</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  LiftOff launch(10);</div>
<div class=CC1>  launch.run();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When a class is derived from <b>Runnable</b>, it must have a
<b>run(&nbsp;)</b> function, but that’s nothing special—it doesn’t produce any
innate threading abilities.</p>

<p class=MsoNormal>To achieve threading behavior, you must use the <b>Thread</b>
class.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef40780398" name="_Toc40780398">Using Threads</a></h2>

<p class=MsoNormal>To drive a <b>Runnable</b> object with a thread, you create
a separate <b>Thread</b> object and hand a <b>Runnable</b> pointer to the <b>Thread</b>’s<b>
</b>constructor. This performs the thread initialization and then calls the <b>Runnable</b>’s<b>
run(&nbsp;)</b> as an interruptible thread. By driving <b>LiftOff</b> with a <b>Thread</b>,
the example below shows how any task can be run in the context of another
thread:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:BasicThreads.cpp</font></div>
<div class=CC1><font color=#dd0000>// The most basic use of the Thread class.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread t(<font color=#ff7700>new</font> LiftOff(10));</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Waiting for LiftOff&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Synchronization_Exception</b> is part of the ZThread library and is the base class for all ZThread exceptions. It will be
thrown if there is an error starting or using a thread.</p>

<p class=MsoNormal>A <b>Thread</b> constructor only needs a pointer to a <b>Runnable</b>
object. Creating a <b>Thread </b>object will perform the necessary
initialization for the thread and then call that <b>Runnable</b>’s <b>run(&nbsp;)</b>
member function to start the task. Even though the <b>Thread</b> constructor
is, in effect, making a call to a long-running function, that constructor
quickly returns. In effect, you have made a member function call to <b>LiftOff::run(&nbsp;)</b>,
and that function has not yet finished, but because <b>LiftOff::run(&nbsp;) </b>is
being executed by a different thread, you can still perform other operations in
the <b>main(&nbsp;)</b> thread. (This ability is not restricted to the <b>main(&nbsp;)</b>
thread—any thread can start another thread.) You can see this by running the
program. Even though <b>LiftOff::run(&nbsp;)</b> has been called, the “Waiting
for LiftOff” message will appear before the countdown has completed. Thus, the
program is running two functions at once—<b>LiftOff::run(&nbsp;)</b> and <b>main(&nbsp;)</b>.</p>

<p class=MsoNormal>You can easily add more threads to drive more tasks. Here,
you can see how all the threads run in concert with one another:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:MoreBasicThreads.cpp</font></div>
<div class=CC1><font color=#dd0000>// Adding more threads.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 5;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++)</div>
<div class=CC1>      Thread t(<font color=#ff7700>new</font> LiftOff(10, i));</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Waiting for LiftOff&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The second argument for the <b>LiftOff</b> constructor
identifies each task. When you run the program, you’ll see that the execution
of the different tasks is mixed together as the threads are swapped in and out.
This swapping is automatically controlled by the thread scheduler. If you have
multiple processors on your machine, the thread scheduler will quietly
distribute the threads among the processors.</p>

<p class=MsoNormal>The <b>for</b> loop can seem a little strange at first
because <b>t</b> is being created locally inside the <b>for</b> loop and then
immediately goes out of scope and is destroyed. This makes it appear that the thread
itself might be immediately lost, but you can see from the output that the
threads are indeed running to conclusion. When you create a <b>Thread</b>
object, the associated thread is registered with the threading system, which
keeps it alive. Even though the stack-based <b>Thread</b> object is lost, the
thread itself lives on until its associated task completes. Although this may
be counterintuitive from a C++ standpoint, the concept of threads is a
departure from the norm: a thread creates a separate thread of execution that
persists after the function call ends. This departure is reflected in the
persistence of the underlying thread after the object vanishes.</p>

<h3><a href="#_TocRef53985868" name="_Toc53985868">Creating responsive user interfaces</a></h3>

<p class=MsoNormal>As stated earlier, one of the motivations for using
threading is to create a responsive user interface. Although we don’t cover <i>graphical
</i>user interfaces in this book, you can still see a simple example of a console-based
user interface.</p>

<p class=MsoNormal>The following example reads lines from a file and prints
them to the console, <i>sleeping</i> (suspending the current thread) for a
second after each line is displayed. (You’ll learn more about sleeping later in
the chapter.) During this process, the program doesn’t look for user input, so
the UI is unresponsive:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:UnresponsiveUI.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Lack of threading produces an unresponsive UI.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Enter&gt; to
quit:&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  ifstream file(<font color=#007f00>&quot;UnresponsiveUI.cpp&quot;</font>);</div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>while</font>(getline(file, line)) {</div>
<div class=CC1>    cout &lt;&lt; line &lt;&lt; endl;</div>
<div class=CC1>    Thread::sleep(1000); <font color=#dd0000>// Time in milliseconds</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Read input from the console</font></div>
<div class=CC1>  cin.get();</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Shutting down...&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>To make the program responsive, you can execute a task that
displays the file in a separate thread. The main thread can then watch for user
input so the program becomes responsive:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:ResponsiveUI.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Threading for a responsive user interface.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DisplayTask : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  ifstream in;</div>
<div class=CC1>  string line;</div>
<div class=CC1>  <font color=#ff7700>bool</font> quitFlag;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DisplayTask(<font color=#ff7700>const</font> string&amp; file) : quitFlag(<font color=#ff7700>false</font>)
{</div>
<div class=CC1>    in.open(file.c_str());</div>
<div class=CC1>  }</div>
<div class=CC1>  ~DisplayTask() { in.close(); }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(getline(in, line) &amp;&amp; !quitFlag) {</div>
<div class=CC1>      cout &lt;&lt; line &lt;&lt; endl;</div>
<div class=CC1>      Thread::sleep(1000);</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> quit() { quitFlag = <font color=#ff7700>true</font>; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Enter&gt; to
quit:&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    DisplayTask* dt = <font color=#ff7700>new</font>
DisplayTask(<font color=#007f00>&quot;ResponsiveUI.cpp&quot;</font>);</div>
<div class=CC1>    Thread t(dt);</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    dt-&gt;quit();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Shutting down...&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Now the <b>main(&nbsp;)</b> thread can respond immediately
when you press &lt;Return&gt; and call <b>quit(&nbsp;)</b> on the <b>DisplayTask</b>.</p>

<p class=MsoNormal>This example also shows the need for communication between
tasks—the task in the <b>main(&nbsp;)</b> thread needs to tell the <b>DisplayTask</b>
to shut down. Since we have a pointer to the <b>DisplayTask</b>, you might
think of just calling <b>delete</b> on that pointer to kill the task, but this
produces unreliable programs. The problem is that the task could be in the
middle of something important when you destroy it, and so you are likely to put
the program in an unstable state. Here, the task itself decides when it’s safe
to shut down. The easiest way to do this is by simply notifying the task that
you’d like it to stop by setting a Boolean flag. When the task gets to a stable
point it can check that flag and do whatever is necessary to clean up before
returning from <b>run(&nbsp;)</b>. When the task returns from <b>run(&nbsp;)</b>,
the <b>Thread</b> knows that the task has completed.</p>

<p class=MsoNormal>Although this program is simple enough that it should not
have any problems, there are some small flaws regarding inter-task
communication. This is an important topic that will be covered later in this
chapter.</p>

<h3><a href="#_TocRef40780406" name="_Toc40780406">Simplifying with Executors</a></h3>

<p class=MsoNormal>You can simplify your coding overhead by using ZThread <i>Executors</i>. Executors provide a layer of indirection between a client
and the execution of a task; instead of a client executing a task directly, an
intermediate object executes the task.</p>

<p class=MsoNormal>We can show this by using an <b>Executor</b> instead of
explicitly creating <b>Thread</b> objects in <b>MoreBasicThreads.cpp</b>. A <b>LiftOff</b>
object knows how to run a specific task; like the Command Pattern, it exposes a
single function to be executed. An <b>Executor</b> object knows how build the
appropriate context to execute <b>Runnable</b> objects. In the following
example, the <b>ThreadedExecutor</b> creates one thread per task:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: c11:ThreadedExecutor.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      executor.execute(<font color=#ff7700>new</font> LiftOff(10, i));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that in some cases a single <b>Executor</b> can be used
to create and manage all the threads in your system. You must still place the
threading code inside a <b>try</b> block because an <b>Executor</b>’s <b>execute(&nbsp;)</b>
function may throw a <b>Synchronization_Exception</b> if something goes wrong. This is true for any function that involves changing the state of a
synchronization object (starting threads, acquiring mutexes, waiting on
conditions, etc.), as you will learn later in this chapter.</p>

<p class=MsoNormal>The program will exit as soon as all the tasks in the <b>Executor</b>
complete.</p>

<p class=MsoNormal>In the previous example, the <b>ThreadedExecutor</b> creates
a thread for each task that you want to run, but you can easily change the way
these tasks are executed by replacing the <b>ThreadedExecutor</b> with a
different type of <b>Executor</b>. In this chapter, using a <b>ThreadedExecutor</b>
is fine, but in production code it might result in excessive costs from the
creation of too many threads. In that case, you can replace it with a <b>PoolExecutor</b>, which will use a limited set of threads to execute the
submitted tasks in parallel:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:PoolExecutor.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/PoolExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    <font color=#dd0000>// Constructor argument is minimum number of
threads:</font></div>
<div class=CC1>    PoolExecutor executor(5);</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      executor.execute(<font color=#ff7700>new</font> LiftOff(10, i));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>With the <b>PoolExecutor</b>, you do expensive thread
allocation once, up front, and the threads are reused when possible. This saves
time because you aren’t constantly paying for thread creation overhead for
every single task. Also, in an event-driven system, events that require threads
to handle them can be generated as quickly as you want by simply fetching them
from the pool. You don’t overrun the available resources because the <b>PoolExecutor</b>
uses a bounded number of <b>Thread</b> objects. Thus, although this book will
use <b>ThreadedExecutor</b>s, consider using <b>PoolExecutor</b>s in production
code.</p>

<p class=MsoNormal>A <b>ConcurrentExecutor</b> is like a <b>PoolExecutor</b>
with a fixed size of one thread. This is useful for anything you want to run in
another thread continually (a long-lived task), such as a task that listens to
incoming socket connections. It is also handy for short tasks that you want to
run in a thread, for example, small tasks that update a local or remote log, or
for an event-dispatching thread.</p>

<p class=MsoNormal>If more than one task is submitted to a <b>ConcurrentExecutor</b>,
each task will run to completion before the next task is begun, all using the
same thread. In the following example, you’ll see each task completed, in the
order that it was submitted, before the next one is begun. Thus, a <b>ConcurrentExecutor</b>
serializes the tasks that are submitted to it.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:ConcurrentExecutor.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ConcurrentExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    ConcurrentExecutor executor;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      executor.execute(<font color=#ff7700>new</font> LiftOff(10, i));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Like a <b>ConcurrentExecutor</b>, a <b>SynchronousExecutor</b> is used when you want only one task at a time to run, serially instead of concurrently.
Unlike <b>ConcurrentExecutor</b>, a <b>SynchronousExecutor</b> doesn’t create
or manage threads on it own. It uses the thread that submits the task and thus
only acts as a focal point for synchronization. If you have <b>n</b> threads
submitting tasks to a <b>SynchronousExecutor</b>, no two tasks are ever run at
once. Instead, each one is run to completion, then the next one in the queue is
begun.</p>

<p class=MsoNormal>For example, suppose you have a number of threads running
tasks that use the file system, but you are writing portable code so you don’t
want to use <b>flock(&nbsp;)</b> or another OS-specific call to lock a file. You can run these tasks with a <b>SynchronousExecutor</b> to ensure
that only one task at a time is running from any thread. This way, you don’t
need to deal with synchronizing on the shared resource (and you won’t clobber
the file system in the meantime). A better solution is to synchronize on the
resource (which you’ll learn about later in this chapter), but a <b>SynchronousExecutor</b>
lets you skip the trouble of getting coordinated properly just to prototype
something.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:SynchronousExecutor.cpp</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/SynchronousExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    SynchronousExecutor executor;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      executor.execute(<font color=#ff7700>new</font> LiftOff(10, i));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you run the program, you’ll see that the tasks are
executed in the order they are submitted, and each task runs to completion
before the next one starts. What you don’t see is that no new threads are
created—the <b>main(&nbsp;) </b>thread is used for each task, since in this
example, that’s the thread that submits all the tasks. Because <b>SynchronousExecutor</b>
is primarily for prototyping, you may not use it much in production code.</p>

<h3><a href="#_TocRef44493771" name="_Toc44493771">Yielding</a></h3>

<p class=MsoNormal>If you know that you’ve accomplished what you need to during
one pass through a loop in your <b>run(&nbsp;)</b> function (most <b>run(&nbsp;)</b>
functions involve a long-running loop), you can give a hint to the thread
scheduling mechanism that you’ve done enough and that some other thread might
as well have the CPU. This hint (and it <i>is</i> a hint—there’s no guarantee
your implementation will listen to it) takes the form of the <b>yield(&nbsp;)</b> function.</p>

<p class=MsoNormal>We can make a modified version of the <b>LiftOff</b>
examples by yielding after each loop:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:YieldingTask.cpp</font></div>
<div class=CC1><font color=#dd0000>// Suggesting when to switch threads with yield().</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> YieldingTask : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  <font color=#ff7700>int</font> countDown;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  YieldingTask(<font color=#ff7700>int</font> ident = 0) : countDown(5), id(ident)
{}</div>
<div class=CC1>  ~YieldingTask() {</div>
<div class=CC1>    cout &lt;&lt; id &lt;&lt; <font color=#007f00>&quot; completed&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
YieldingTask&amp; yt) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;#&quot;</font> &lt;&lt; yt.id
&lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; yt.countDown;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(<font color=#ff7700>true</font>) {</div>
<div class=CC1>      cout &lt;&lt; *<font color=#ff7700>this</font> &lt;&lt; endl;</div>
<div class=CC1>      <font color=#ff7700>if</font>(--countDown == 0) <font color=#ff7700>return</font>;</div>
<div class=CC1>      Thread::yield();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      executor.execute(<font color=#ff7700>new</font> YieldingTask(i));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that the task’s <b>run(&nbsp;) </b>member
function consists entirely of an infinite loop. By using <b>yield(&nbsp;)</b>,
the output is evened up quite a bit over that without yielding. Try commenting
out the call to <b>Thread::yield(&nbsp;)</b> to see the difference. In general,
however, <b>yield(&nbsp;) </b>is useful only in rare situations, and you can’t
rely on it to do any serious tuning of your application.</p>

<h3><a href="#_TocRef24775839" name="_Toc24775839">Sleeping</a></h3>

<p class=MsoNormal>Another way you can control the behavior of your threads is
by calling <b>sleep(&nbsp;)</b> to cease execution of a thread for a given
number of milliseconds. In the preceding example, if you replace the call to <b>yield(&nbsp;)</b>
with a call to <b>sleep(&nbsp;)</b>, you get the following:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:SleepingTask.cpp</font></div>
<div class=CC1><font color=#dd0000>// Calling sleep() to pause for awhile.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> SleepingTask : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  <font color=#ff7700>int</font> countDown;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  SleepingTask(<font color=#ff7700>int</font> ident = 0) : countDown(5), id(ident)
{}</div>
<div class=CC1>  ~SleepingTask() {</div>
<div class=CC1>    cout &lt;&lt; id &lt;&lt; <font color=#007f00>&quot; completed&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
SleepingTask&amp; st) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;#&quot;</font> &lt;&lt; st.id
&lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; st.countDown;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(<font color=#ff7700>true</font>) {</div>
<div class=CC1>      <font color=#ff7700>try</font> {</div>
<div class=CC1>        cout &lt;&lt; *<font color=#ff7700>this</font> &lt;&lt; endl;</div>
<div class=CC1>        <font color=#ff7700>if</font>(--countDown == 0) <font color=#ff7700>return</font>;</div>
<div class=CC1>        Thread::sleep(100);</div>
<div class=CC1>      } <font color=#ff7700>catch</font>(Interrupted_Exception&amp; e) {</div>
<div class=CC1>        cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      executor.execute(<font color=#ff7700>new</font> SleepingTask(i));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Thread::sleep(&nbsp;)</b> can throw an <b>Interrupted_Exception</b>
(you’ll learn about interrupts later), and you can see that this is caught in <b>run(&nbsp;)</b>.
But the task is created and executed inside a <b>try</b> block in <b>main(&nbsp;)</b>
that catches <b>Synchronization_Exception</b> (the base class for all ZThread
exceptions), so wouldn’t it be possible to just ignore the exception in <b>run(&nbsp;)</b>
and assume that it will propagate to the handler in <b>main(&nbsp;)</b>? This
won’t work because exceptions won’t propagate across threads back to <b>main(&nbsp;)</b>.
Thus, you must handle any exceptions locally that may arise within a task.</p>

<p class=MsoNormal>You’ll notice that the threads tend to run in any order,
which means that <b>sleep(&nbsp;)</b> is also not a way for you to control the order of thread execution. It just stops the execution of the thread for awhile. The
only guarantee that you have is that the thread will sleep at least 100
milliseconds (in this example), but it may take longer before the thread
resumes execution because the thread scheduler still has to get back to it
after the sleep interval expires.</p>

<p class=MsoNormal>If you must control the order of execution of threads, your
best bet is to use synchronization controls (described later) or, in some
cases, not to use threads at all, but instead to write your own cooperative
routines that hand control to each other in a specified order.</p>

<h3><a href="#_TocRef40780405" name="_Toc40780405">Priority</a></h3>

<p class=MsoNormal>The <i>priority</i> of a thread conveys the importance of a
thread to the scheduler. Although the order that the CPU runs a set of threads
is indeterminate, the scheduler will <i>lean</i> toward running the waiting
thread with the highest priority first. However, this doesn’t mean that threads
with lower priority aren’t run (that is, you can’t get deadlocked because of priorities). Lower priority threads just tend to run less often.</p>

<p class=MsoNormal>Here’s <b>MoreBasicThreads.cpp</b> modified so that the
priority levels are demonstrated. The priorities are adjusting by using <b>Thread</b>’s
<b>setPriority(&nbsp;)</b> function.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:SimplePriorities.cpp</font></div>
<div class=CC1><font color=#dd0000>// Shows the use of thread priorities.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>double</font> pi = 3.14159265358979323846;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>double</font> e = 2.7182818284590452354;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> SimplePriorities : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  <font color=#ff7700>int</font> countDown;</div>
<div class=CC1>  <font color=#ff7700>volatile</font> <font color=#ff7700>double</font> d; <font color=#dd0000>// No optimization</font></div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  SimplePriorities(<font color=#ff7700>int</font> ident=0): countDown(5),
id(ident) {}</div>
<div class=CC1>  ~SimplePriorities() {</div>
<div class=CC1>    cout &lt;&lt; id &lt;&lt; <font color=#007f00>&quot; completed&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
SimplePriorities&amp; sp) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;#&quot;</font> &lt;&lt; sp.id
&lt;&lt; <font color=#007f00>&quot; priority: &quot;</font></div>
<div class=CC1>      &lt;&lt; Thread().getPriority()</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot; count: &quot;</font>&lt;&lt;
sp.countDown;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(<font color=#ff7700>true</font>) {</div>
<div class=CC1>      <font color=#dd0000>// An expensive, interruptable operation:</font></div>
<div class=CC1>      <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 1; i &lt; 100000; i++)</div>
<div class=CC1>        d = d + (pi + e) / <font color=#ff7700>double</font>(i);</div>
<div class=CC1>      cout &lt;&lt; *<font color=#ff7700>this</font> &lt;&lt; endl;</div>
<div class=CC1>      <font color=#ff7700>if</font>(--countDown == 0) <font color=#ff7700>return</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread high(<font color=#ff7700>new</font> SimplePriorities);</div>
<div class=CC1>    high.setPriority(High);</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++) {</div>
<div class=CC1>      Thread low(<font color=#ff7700>new</font> SimplePriorities(i));</div>
<div class=CC1>      low.setPriority(Low);</div>
<div class=CC1>    }</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Here, <b>operator&lt;&lt;(&nbsp;)</b> is overridden to
display the identifier, priority, and <b>countDown</b> value of the task.</p>

<p class=MsoNormal>You can see that the priority level of thread <b>high</b> is
at the highest level, and all the rest of the threads are at the lowest level.
We are not using an <b>Executor</b> in this example because we need direct
access to the threads in order to set their priorities.</p>

<p class=MsoNormal>Inside <b>SimplePriorities::run(&nbsp;)</b>, 100,000
repetitions of a rather expensive floating-point calculation are performed,
involving <b>double</b> addition and division. The variable <b>d</b> is <b>volatile</b>
to try to ensure that no compilers optimizations are performed. Without this
calculation, you don’t see the effect of setting the priority levels. (Try it:
comment out the <b>for</b> loop containing the <b>double</b> calculations.)
With the calculation, you see that thread <b>high</b> is given a higher
preference by the thread scheduler. (At least, this was the behavior on a
Windows machine.) The calculation takes long enough that the thread scheduling
mechanism jumps in, changes threads, and pays attention to the priorities so
that thread <b>high</b> gets preference.</p>

<p class=MsoNormal>You can also read the priority of an existing thread with <b>getPriority(&nbsp;) </b>and change it at any time (not just before the thread is
run, as in <b>SimplePriorities.cpp</b>)
with <b>setPriority(&nbsp;)</b>.</p>

<p class=MsoNormal>Mapping priorities to operating systems is problematic. For
example, Windows 2000 has seven priority levels, while Sun’s Solaris has 2<sup>31
</sup>levels. The only portable approach is to stick to very large priority
granulations, such as the <b>Low</b>, <b>Medium</b>, and <b>High</b> used in
the ZThread library.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef375545478" name="_Toc375545478">Sharing limited resources</a></h2>

<p class=MsoNormal>You can think of a single-threaded program as one lonely
entity moving around through your problem space and doing one thing at a time.
Because there’s only one entity, you never have to think about the problem of
two entities trying to use the same resource at the same time: problems such as
two people trying to park in the same space, walk through a door at the same
time, or even talk at the same time.</p>

<p class=MsoNormal>With multithreading things aren’t lonely anymore, but you
now have the possibility of two or more threads trying to use the same resource
at once. This can cause two different kinds of problems. The first is that the
necessary resources may not exist. In C++, the programmer has complete control
over the lifetime of objects, and it’s easy to create threads that try to use
objects that get destroyed before those threads complete.</p>

<p class=MsoNormal>The second problem is that two or more threads may collide
when they try to access the same resource at the same time. If you don’t
prevent such a collision, you’ll have two threads trying to access the same
bank account at the same time, print to the same printer, adjust the same
valve, and so on.</p>

<p class=MsoNormal>This section introduces the problem of objects that vanish
while tasks are still using them and the problem of tasks colliding over shared
resources. You’ll learn about the tools that are used to solve these problems.</p>

<h3><a href="#_TocRef53985874" name="_Toc53985874">Ensuring the existence of
objects</a></h3>

<p class=MsoNormal>Memory and resource management are major concerns in C++.
When you create any C++ program, you have the option of creating objects on the
stack or on the heap (using <b>new</b>). In a single-threaded program, it’s
usually easy to keep track of object lifetimes so that you don’t try to use
objects that are already destroyed.</p>

<p class=MsoNormal>The examples shown in this chapter create <b>Runnable</b>
objects on the heap using <b>new</b>, but you’ll notice that these objects are
never <i>explicitly</i> deleted. However, you can see from the output when you
run the programs that the thread library keeps track of each task and
eventually deletes it, because the destructors for the tasks are called. This
happens when the <b>Runnable::run(&nbsp;) </b>member function
completes—returning from <b>run(&nbsp;)</b> indicates that the task is
finished.</p>

<p class=MsoNormal>Burdening the thread with deleting a task is a problem. That
thread doesn’t necessarily know if another thread still needs to make a
reference to that <b>Runnable</b>, and so the <b>Runnable</b> may be
prematurely destroyed. To deal with this problem, tasks in ZThreads are
automatically reference-counted by the ZThread library mechanism. A task is
maintained until the reference count for that task goes to zero, at which point
the task is deleted. This means that tasks must always be deleted dynamically,
and so they cannot be created on the stack. Instead, tasks must always be
created using <b>new</b>, as you see in all the examples in this chapter.</p>

<p class=MsoNormal>Often you must also ensure that non-task objects stay alive
as long as tasks need them. Otherwise, it’s easy for objects that are used by
tasks to go out of scope before those tasks are completed. If this happens, the
tasks will try to access illegal storage and will cause program faults. Here’s
a simple example:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:Incrementer.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Destroying objects while threads are still</font></div>
<div class=CC1><font color=#dd0000>// running will cause serious problems.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Count {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { SZ = 100 };</div>
<div class=CC1>  <font color=#ff7700>int</font> n[SZ];</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> increment() {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++)</div>
<div class=CC1>      n[i]++;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Incrementer : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  Count* count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Incrementer(Count* c) : count(c) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> n = 100; n &gt; 0; n--) {</div>
<div class=CC1>      Thread::sleep(250);</div>
<div class=CC1>      count-&gt;increment();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;This will cause a segmentation
fault!&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  Count count;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread t0(<font color=#ff7700>new</font> Incrementer(&amp;count));</div>
<div class=CC1>    Thread t1(<font color=#ff7700>new</font> Incrementer(&amp;count));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Count</b> class may seem like overkill at first, but
if <b>n</b> is only a single <b>int</b> (rather than an array), the compiler
can put it into a register and that storage will still be available (albeit
technically illegal) after the <b>Count</b> object goes out of scope. It’s
difficult to detect the memory violation in that case. Your results may vary
depending on your compiler and operating system, but try making it <b>n</b> a single
<b>int</b> and see what happens. In any event, if <b>Count</b> contains an
array of <b>int</b>s as above, the compiler is forced to put it on the stack
and not in a register.</p>

<p class=MsoNormal><b>Incrementer</b> is a simple task that uses a <b>Count</b>
object. In <b>main(&nbsp;)</b>, you can see that the <b>Incrementer</b> tasks
are running for long enough that the<b> Count</b> object will go out of scope,
and so the tasks try to access an object that no longer exists. This produces a
program fault.</p>

<p class=MsoNormal>To fix the problem, we must guarantee that any objects
shared between tasks will be around as long as those tasks need them. (If the
objects were not shared, they could be composed directly into the task’s<b> </b>class
and thus tie their lifetime to that task.) Since we don’t want the static
program scope to control the lifetime of the object, we put the object on the
heap. And to make sure that the object is not destroyed until there are no
other objects (tasks, in this case) using it, we use reference counting.</p>

<p class=MsoNormal>Reference counting was explained thoroughly in volume one of
this book and further revisited in this volume. The ZThread library includes a
template called <b>CountedPtr</b> that automatically performs reference counting and <b>delete</b>s an object when the reference count goes to zero. Here’s the
above program modified to use <b>CountedPtr</b> to prevent the fault:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:ReferenceCounting.cpp</font></div>
<div class=CC1><font color=#dd0000>// A CountedPtr prevents too-early destruction.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/CountedPtr.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Count {</div>
<div class=CC1>  <font color=#ff7700>enum</font> { SZ = 100 };</div>
<div class=CC1>  <font color=#ff7700>int</font> n[SZ];</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> increment() {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++)</div>
<div class=CC1>      n[i]++;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Incrementer : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CountedPtr&lt;Count&gt; count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Incrementer(<font color=#ff7700>const</font> CountedPtr&lt;Count&gt;&amp; c ) : count(c)
{}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> n = 100; n &gt; 0; n--) {</div>
<div class=CC1>      Thread::sleep(250);</div>
<div class=CC1>      count-&gt;increment();</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  CountedPtr&lt;Count&gt; count(<font color=#ff7700>new</font> Count);</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread t0(<font color=#ff7700>new</font> Incrementer(count));</div>
<div class=CC1>    Thread t1(<font color=#ff7700>new</font> Incrementer(count));</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Incrementer</b> now contains a <b>CountedPtr</b> object,
which manages a <b>Count</b>. In <b>main(&nbsp;)</b>, the <b>CountedPtr</b>
objects are passed into the two <b>Incrementer</b> objects by value, so the
copy-constructor is called, increasing the reference count. As long as the
tasks are still running, the reference count will be nonzero, and so the <b>Count</b>
object managed by the <b>CountedPtr</b> will not be destroyed. Only when all
the tasks using the <b>Count</b> are completed will <b>delete</b> be called
(automatically) on the <b>Count</b> object by the <b>CountedPtr</b>.</p>

<p class=MsoNormal>Whenever you have objects that are used by more than one
task, you’ll almost always need to manage those objects using the <b>CountedPtr</b>
template in order to prevent problems arising from object lifetime issues.</p>

<h3><a href="#_TocRef53985875" name="_Toc53985875">Improperly accessing resources</a></h3>

<p class=MsoNormal>Consider the following example where one task generates even numbers and other tasks consume those numbers. Here, the only job of the
consumer threads is to check the validity of the even numbers.</p>

<p class=MsoNormal>We’ll first define <b>EvenChecker</b>,<b> </b>the consumer
thread, since it will be reused in all the subsequent examples. To decouple <b>EvenChecker</b>
from the various types of generators that we will experiment with, we’ll create
an interface called <b>Generator</b>, which contains the minimum necessary
functions that <b>EvenChecker</b> must know about: that it has a <b>nextValue(&nbsp;)</b>
function and that it can be canceled.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:EvenChecker.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef EVENCHECKER_H</font></div>
<div class=CC1><font color=#7F7F00>#define EVENCHECKER_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/CountedPtr.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Cancelable.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Generator : <font color=#ff7700>public</font> ZThread::Cancelable {</div>
<div class=CC1>  <font color=#ff7700>bool</font> canceled;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Generator() : canceled(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>int</font> nextValue() = 0;</div>
<div class=CC1>  <font color=#ff7700>void</font> cancel() { canceled = <font color=#ff7700>true</font>; }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isCanceled() { <font color=#ff7700>return</font> canceled; }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> EvenChecker : <font color=#ff7700>public</font> ZThread::Runnable {</div>
<div class=CC1>  ZThread::CountedPtr&lt;Generator&gt; generator;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  EvenChecker(ZThread::CountedPtr&lt;Generator&gt;&amp;
g, <font color=#ff7700>int</font> ident)</div>
<div class=CC1>  : generator(g), id(ident) {}</div>
<div class=CC1>  ~EvenChecker() {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;~EvenChecker &quot;</font>
&lt;&lt; id &lt;&lt; std::endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(!generator-&gt;isCanceled()) {</div>
<div class=CC1>      <font color=#ff7700>int</font> val = generator-&gt;nextValue();</div>
<div class=CC1>      <font color=#ff7700>if</font>(val % 2 != 0) {</div>
<div class=CC1>        std::cout &lt;&lt; val &lt;&lt; <font color=#007f00>&quot; not
even!&quot;</font> &lt;&lt; std::endl;</div>
<div class=CC1>        generator-&gt;cancel(); <font color=#dd0000>// Cancels all
EvenCheckers</font></div>
<div class=CC1>      }</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Test any type of generator:</font></div>
<div class=CC1>  <font color=#ff7700>template</font>&lt;<font color=#ff7700>typename</font> GenType&gt; <font color=#ff7700>static</font> <font color=#ff7700>void</font> test(<font color=#ff7700>int</font>
n = 10) {</div>
<div class=CC1>    std::cout &lt;&lt; <font color=#007f00>&quot;Press Control-C to
exit&quot;</font> &lt;&lt; std::endl;</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      ZThread::ThreadedExecutor executor;</div>
<div class=CC1>      ZThread::CountedPtr&lt;Generator&gt; gp(<font color=#ff7700>new</font>
GenType);</div>
<div class=CC1>      <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; n; i++)</span></div>
<div class=CC1><span lang=SV>        </span>executor.execute(<font color=#ff7700>new</font>
EvenChecker(gp, i));</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(ZThread::Synchronization_Exception&amp; e)
{</div>
<div class=CC1>      std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// EVENCHECKER_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Generator</b> class introduces the abstract <b>Cancelable</b> class, which is part of the ZThread library. The goal of <b>Cancelable
</b>is to provide a consistent interface to change the state of an object via
the <b>cancel(&nbsp;)</b> function and to see whether the object has been
canceled with the <b>isCanceled(&nbsp;)</b> function. Here, we use the simple
approach of a <b>bool </b>canceled flag, similar to the <b>quitFlag</b>
previously seen in <b>ResponsiveUI.cpp</b>. Note that in this example the class
that is <b>Cancelable</b> is not <b>Runnable</b>. Instead, all the <b>EvenChecker</b>
tasks that depend on the <b>Cancelable</b> object (the <b>Generator</b>) test
it to see if it’s been canceled, as you can see in <b>run(&nbsp;)</b>. This
way, the tasks that share the common resource (the <b>Cancelable Generator</b>)
watch that resource for the signal to terminate. This eliminates the so-called <i>race condition</i>, where two or more tasks race to respond to a condition and
thus collide or otherwise produce inconsistent results. You must be careful to
think about and protect against all the possible ways a concurrent system can
fail. For example, a task cannot depend on another task because task shutdown
order is not guaranteed. Here, by making tasks depend on non-task objects
(which are reference counted using <b>CountedPtr</b>) we eliminate the
potential race condition.</p>

<p class=MsoNormal>In later sections, you’ll see that the ZThread library
contains more general mechanisms for termination of threads.</p>

<p class=MsoNormal>Since multiple <b>EvenChecker </b>objects may end up sharing
a <b>Generator</b>, the <b>CountedPtr </b>template is used to reference count
the <b>Generator </b>objects.</p>

<p class=MsoNormal>The last member function in <b>EvenChecker</b> is a <b>static
</b>member template that sets up and performs a test of any type of <b>Generator</b>
by creating one inside a <b>CountedPtr</b> and then starting a number of <b>EvenChecker</b>s
that use that <b>Generator</b>. If the <b>Generator</b> causes a failure, <b>test(&nbsp;)</b>
will report it and return; otherwise, you must press Control-C to terminate it.</p>

<p class=MsoNormal><b>EvenChecker</b> tasks constantly read and test the values
from their associated <b>Generator</b>. Note that if <b>generator-&gt;isCanceled(&nbsp;)</b>
is true, <b>run(&nbsp;)</b> returns, which tells the <b>Executor</b> in <b>EvenChecker::test(&nbsp;)
</b>that the task is complete. Any <b>EvenChecker</b> task can call <b>cancel(&nbsp;)
</b>on its associated <b>Generator</b>, which will cause all other <b>EvenChecker</b>s
using that <b>Generator </b>to gracefully shut down.</p>

<p class=MsoNormal>The <b>EvenGenerator</b> is simple—<b>nextValue(&nbsp;)</b>
produces the next even value:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:EvenGenerator.cpp</font></div>
<div class=CC1><font color=#dd0000>// When threads collide.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;EvenChecker.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> EvenGenerator : <font color=#ff7700>public</font> Generator {</div>
<div class=CC1>  <font color=#ff7700>unsigned</font> <font color=#ff7700>int</font> currentEvenValue; <font color=#dd0000>// Unsigned can’t
overflow</font></div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  EvenGenerator() { currentEvenValue = 0; }</div>
<div class=CC1>  ~EvenGenerator() { cout &lt;&lt;
<font color=#007f00>&quot;~EvenGenerator&quot;</font> &lt;&lt; endl; }</div>
<div class=CC1>  <font color=#ff7700>int</font> nextValue() {</div>
<div class=CC1>    ++currentEvenValue; <font color=#dd0000>// Danger point here!</font></div>
<div class=CC1>    ++currentEvenValue;</div>
<div class=CC1>    <font color=#ff7700>return</font> currentEvenValue;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  EvenChecker::test&lt;EvenGenerator&gt;();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>It’s possible for one thread to call <b>nextValue(&nbsp;)</b>
after the first increment of <b>currentEvenValue</b> and before the second (at
the place in the code commented “Danger point here!”), which puts the value into
an “incorrect” state. To prove that this can happen, <b>EvenChecker::test(&nbsp;)</b>
creates a group of <b>EvenChecker</b> objects to continually read the output of
an <b>EvenGenerator</b> and test to see if each one is even. If not, the error
is reported and the program is shut down.</p>

<p class=MsoNormal>This program may not detect the problem until the <b>EvenGenerator</b>
has completed many cycles, depending on the particulars of your operating
system and other implementation details. If you want to see it fail much
faster, try putting a call to <b>yield(&nbsp;)</b> between the first and second
increments. In any event, it <i>will</i> eventually fail because the <b>EvenChecker</b>
threads are able to access the information in <b>EvenGenerator</b> while it’s
in an “incorrect” state.</p>

<h3><a href="#_TocRef44493777" name="_Toc44493777">Controlling access</a></h3>

<p class=MsoNormal>The previous example shows a fundamental problem when using
threads: You never know when a thread might be run. Imagine sitting at a table
with a fork, about to spear the last piece of food on a platter, and as your
fork reaches for it, the food suddenly vanishes (because your thread was
suspended and another diner came in and ate the food). That’s the problem
you’re dealing with when writing concurrent programs. </p>

<p class=MsoNormal>Occasionally you don’t care if a resource is being accessed
at the same time you’re trying to use it. But in most cases you do care, and
for multithreading to work, you need some way to prevent two threads from
accessing the same resource, at least during critical periods.</p>

<p class=MsoNormal>Preventing this kind of collision is simply a matter of
putting a lock on a resource when one thread is using it. The first thread that
accesses a resource locks it, and then the other threads cannot access that
resource until it is unlocked, at which time another thread locks and uses it,
and so on. If the front seat of the car is the limited resource, the child who
shouts “Dibs!” acquires the lock.</p>

<p class=MsoNormal>Thus, we need to be able to prevent any other tasks from
accessing the storage when that storage is not in a proper state. That is, we
need to have a mechanism that <i>excludes</i> a second task from accessing the
storage when a first task is already using it. This idea is fundamental to all
multithreading systems and is called <i>mutual exclusion</i>; the mechanism used abbreviates this to <i>mutex</i>. The ZThread library contains a
mutex mechanism declared in the header <b>Mutex.h</b>.</p>

<p class=MsoNormal>To solve the problem in the above program, we identify the <i>critical sections</i> where mutual exclusion must apply; then we <i>acquire</i>
the mutex before entering the critical section and <i>release</i> it at the end
of the critical section. Only one thread can acquire the mutex at any time, so
mutual exclusion is achieved:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:MutexEvenGenerator.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Preventing thread collisions with mutexes.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;EvenChecker.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MutexEvenGenerator : <font color=#ff7700>public</font> Generator {</div>
<div class=CC1>  <font color=#ff7700>unsigned</font> <font color=#ff7700>int</font> currentEvenValue;</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  MutexEvenGenerator() { currentEvenValue = 0; }</div>
<div class=CC1>  ~MutexEvenGenerator() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;~MutexEvenGenerator&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> nextValue() {</div>
<div class=CC1>    lock.acquire();</div>
<div class=CC1>    ++currentEvenValue;</div>
<div class=CC1>    Thread::yield(); <font color=#dd0000>// Cause failure faster</font></div>
<div class=CC1>    ++currentEvenValue;</div>
<div class=CC1>    <font color=#ff7700>int</font> rval = currentEvenValue;</div>
<div class=CC1>    lock.release();</div>
<div class=CC1>    <font color=#ff7700>return</font> rval;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  EvenChecker::test&lt;MutexEvenGenerator&gt;();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>MutexEvenGenerator</b> adds a <b>Mutex</b> called <b>lock</b>
and uses <b>acquire(&nbsp;)</b> and <b>release(&nbsp;)</b> to create a critical
section within <b>nextValue(&nbsp;)</b>. In addition, a call to <b>Thread::yield(&nbsp;)
</b>is inserted between the two increments, to raise the likelihood of a
context switch while <b>currentEvenValue</b> is in an odd state. Because the
mutex prevents more than one thread at a time in the critical section, this
will not produce a failure, but calling <b>yield(&nbsp;)</b> is a helpful way
to promote a failure if it’s going to happen.</p>

<p class=MsoNormal>Note that <b>nextValue(&nbsp;)</b> must capture the return
value inside the critical section because if you return from inside the
critical section, you won’t release the lock and will thus prevent it from
being acquired again. (This usually leads to <i>deadlock</i>, which you’ll
learn about at the end of this chapter.)</p>

<p class=MsoNormal>The first thread that enters <b>nextValue(&nbsp;)</b>
acquires the lock, and any further threads that try to acquire the lock are
blocked from doing so until the first thread releases the lock. At that point,
the scheduling mechanism selects another thread that is waiting on the lock.
This way, only one thread at a time can pass through the code that is guarded
by the mutex.</p>

<h3><a href="#_TocRef44493778" name="_Toc44493778">Simplified coding with
Guards</a></h3>

<p class=MsoNormal>The use of mutexes rapidly becomes complicated when
exceptions are introduced. To make sure that the mutex is always released, you must ensure that each possible exception path includes a call to <b>release(&nbsp;)</b>.
In addition, any function that has multiple return paths must carefully ensure
that it calls <b>release(&nbsp;)</b> at the appropriate points.</p>

<p class=MsoNormal>These problems can be easily solved by using the fact that a
stack-based (auto) object has a destructor that is always called regardless of
how you exit from a function scope. In the ZThread library, this is implemented
as the <b>Guard</b> template. The <b>Guard</b> template creates objects that <b>acquire(&nbsp;)
</b>a <b>Lockable</b> object when constructed and <b>release(&nbsp;)</b> that
lock when destroyed. <b>Guard</b> objects created on the local stack will
automatically be destroyed regardless of how the function exits and will always
unlock the <b>Lockable</b> object. Here’s the above example reimplemented using
<b>Guard</b>s:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:GuardedEvenGenerator.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Simplifying mutexes with the Guard template.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;EvenChecker.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> GuardedEvenGenerator : <font color=#ff7700>public</font> Generator {</div>
<div class=CC1>  <font color=#ff7700>unsigned</font> <font color=#ff7700>int</font> currentEvenValue;</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  GuardedEvenGenerator() { currentEvenValue = 0; }</div>
<div class=CC1>  ~GuardedEvenGenerator() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;~GuardedEvenGenerator&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> nextValue() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    ++currentEvenValue;</div>
<div class=CC1>    Thread::yield();</div>
<div class=CC1>    ++currentEvenValue;</div>
<div class=CC1>    <font color=#ff7700>return</font> currentEvenValue;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  EvenChecker::test&lt;GuardedEvenGenerator&gt;();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that the temporary return value is no longer necessary
in <b>nextValue(&nbsp;)</b>. In general, there is less code to write, and the
opportunity for user error is greatly reduced.</p>

<p class=MsoNormal>An interesting feature of the <b>Guard</b> template is that
it can be used to manipulate other guards safely. For example, a second <b>Guard</b>
can be used to temporarily unlock a guard:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:TemporaryUnlocking.cpp</font></div>
<div class=CC1><font color=#dd0000>// Temporarily unlocking another guard.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TemporaryUnlocking {</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#dd0000>// lock is acquired</font></div>
<div class=CC1>    <font color=#dd0000>// ...</font></div>
<div class=CC1>    {</div>
<div class=CC1>      Guard&lt;Mutex, UnlockedScope&gt; h(g);</div>
<div class=CC1>      <font color=#dd0000>// lock is released</font></div>
<div class=CC1>      <font color=#dd0000>// ...</font></div>
<div class=CC1>      <font color=#dd0000>// lock is acquired</font></div>
<div class=CC1>    }</div>
<div class=CC1>    <font color=#dd0000>// ...</font></div>
<div class=CC1>    <font color=#dd0000>// lock is released</font></div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  TemporaryUnlocking t;</div>
<div class=CC1>  t.f();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>A Guard can also be used to try to acquire a lock for a
certain amount of time and then give up:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:TimedLocking.cpp</font></div>
<div class=CC1><font color=#dd0000>// Limited time locking.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> TimedLocking {</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {</div>
<div class=CC1>    Guard&lt;Mutex, TimedLockedScope&lt;500&gt; &gt;
g(lock);</div>
<div class=CC1>    <font color=#dd0000>// ...</font></div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  TimedLocking t;</div>
<div class=CC1>  t.f();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In this example, a <b>Timeout_Exception</b> will be thrown
if the lock cannot be acquired within 500 milliseconds.</p>

<h4>Synchronizing entire
classes</a></h4>

<p class=MsoNormal>The ZThread library also provides a <b>GuardedClass</b>
template to automatically create a synchronized wrapper for an entire class. This means that every member function in the class will automatically be guarded:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:SynchronizedClass.cpp {-dmc}</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/GuardedClass.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> MyClass {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> func1() {}</div>
<div class=CC1>  <font color=#ff7700>void</font> func2() {}</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  MyClass a;</div>
<div class=CC1>  a.func1(); <font color=#dd0000>// Not synchronized</font></div>
<div class=CC1>  a.func2(); <font color=#dd0000>// Not synchronized</font></div>
<div class=CC1>  GuardedClass&lt;MyClass&gt; b(<font color=#ff7700>new</font> MyClass);</div>
<div class=CC1>  <font color=#dd0000>// Synchronized calls, only one thread at a time
allowed:</font></div>
<div class=CC1>  b-&gt;func1();</div>
<div class=CC1>  b-&gt;func2();</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Object <b>a</b> is a not synchronized, so <b>func1(&nbsp;)</b>
and <b>func2(&nbsp;)</b> can be called at any time by any number of threads.
Object <b>b</b> is protected by the <b>GuardedClass</b> wrapper, so each member
function is automatically synchronized and only one function per object can be
called any time.</p>

<p class=MsoNormal>The wrapper locks at a class level of granularity, which may
affect performance.<a href="#_ftn151" name="_ftnref151"><span
class=MsoFootnoteReference>[151]</span></a> If
a class contains some unrelated functions, it may be better to synchronize
those functions internally with two different locks. However, if you find
yourself doing this, it means that one class contains groups of data that may
not be strongly associated. Consider breaking the class into two classes.</p>

<p class=MsoNormal>Guarding all member functions of a class with a mutex does
not automatically make that class thread-safe. You must carefully consider all
threading issues in order to guarantee thread safety.</p>

<h3><a href="#_TocRef53985878" name="_Toc53985878">Thread local storage</a></h3>

<p class=MsoNormal>A second way to eliminate the problem of tasks colliding
over shared resources is to eliminate the sharing of variables, which can be
done by creating different storage for the same variable, for each different
thread that uses an object. Thus, if you have five threads using an object with
a variable <b>x</b>, <i>thread local storage</i> automatically generates five
different pieces of storage for <b>x</b>. Fortunately, the creation and
management of thread local storage is taken care of automatically by ZThread’s <b>ThreadLocal</b>
template, as seen here:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:ThreadLocalVariables.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Automatically giving each thread its own storage.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Cancelable.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadLocal.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/CountedPtr.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> ThreadLocalVariables : <font color=#ff7700>public</font> Cancelable {</div>
<div class=CC1>  ThreadLocal&lt;<font color=#ff7700>int</font>&gt; value;</div>
<div class=CC1>  <font color=#ff7700>bool</font> canceled;</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  ThreadLocalVariables() : canceled(<font color=#ff7700>false</font>) {</div>
<div class=CC1>    value.set(0);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> increment() { value.set(value.get() + 1); }</div>
<div class=CC1>  <font color=#ff7700>int</font> get() { <font color=#ff7700>return</font> value.get(); }</div>
<div class=CC1>  <font color=#ff7700>void</font> cancel() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    canceled = <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isCanceled() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>return</font> canceled;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Accessor : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1>  CountedPtr&lt;ThreadLocalVariables&gt; tlv;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Accessor(CountedPtr&lt;ThreadLocalVariables&gt;&amp;
tl, <font color=#ff7700>int</font> idn)</div>
<div class=CC1>  : id(idn), tlv(tl) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(!tlv-&gt;isCanceled()) {</div>
<div class=CC1>      tlv-&gt;increment();</div>
<div class=CC1>      cout &lt;&lt; *<font color=#ff7700>this</font> &lt;&lt; endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>    <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, Accessor&amp; a)
{</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;#&quot;</font> &lt;&lt; a.id
&lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; a.tlv-&gt;get();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Enter&gt; to quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    CountedPtr&lt;ThreadLocalVariables&gt;</div>
<div class=CC1>      tlv(<font color=#ff7700>new</font> ThreadLocalVariables);</div>
<div class=CC1>    <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 5;</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++)</span></div>
<div class=CC1><span lang=SV>      </span>executor.execute(<font color=#ff7700>new</font>
Accessor(tlv, i));</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    tlv-&gt;cancel(); <font color=#dd0000>// All Accessors will quit</font></div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>When you create a <b>ThreadLocal</b> object by instantiating
the template, you are only able to access the contents of the object using the <b>get(&nbsp;)</b>
and <b>set(&nbsp;)</b> member functions. The <b>get(&nbsp;) </b>function
returns a copy of the object that is associated with that thread, and <b>set(&nbsp;)</b>
inserts its argument into the object stored for that thread, returning the old
object that was in storage. You can see this is use in <b>increment(&nbsp;)</b>
and <b>get(&nbsp;)</b> in <b>ThreadLocalVariables</b>.</p>

<p class=MsoNormal>Since <b>tlv</b> is shared by multiple <b>Accessor</b>
objects, it is written as <b>Cancelable</b> so that the <b>Accessor</b>s can be
signaled when we want to shut the system down.</p>

<p class=MsoNormal>When you run this program, you’ll see evidence that the
individual threads are each allocated their own storage.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985879" name="_Toc53985879">Terminating tasks</a></h2>

<p class=MsoNormal>In previous examples, we have seen the use of a “quit flag”
or the <b>Cancelable</b> interface in order to terminate a task. This is a
reasonable approach to the problem. However, in some situations the task must
be terminated more abruptly. In this section, you’ll learn about the issues and
problems of such termination.</p>

<p class=MsoNormal>First, let’s look at an example that not only demonstrates
the termination problem but is also an additional example of resource sharing.
To present this example, we’ll first need to solve the problem of iostream
collision</p>

<h3><a href="#_TocRef53985880" name="_Toc53985880">Preventing iostream collision</a></h3>

<p class=MsoNormal>You may have noticed in previous examples that the output is
sometimes garbled. C++ iostreams were not created with threading in mind, so
there’s nothing to keep one thread’s output from interfering with another
thread’s output. Thus, you must write your applications so that they
synchronize the use of iostreams.</p>

<p class=MsoNormal>To solve the problem, we need to create the entire output
packet first and then explicitly decide when to try to send it to the console.
One simple solution is to write the information to an <b>ostringstream</b> and
then use a single object with a mutex as the point of output among all threads,
to prevent more than one thread from writing at the same time:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:Display.h</font></div>
<div class=CC1><font color=#dd0000>// Prevents ostream collisions.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DISPLAY_H</font></div>
<div class=CC1><font color=#7F7F00>#define DISPLAY_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Display { <font color=#dd0000>// Share one of these among all threads</font></div>
<div class=CC1>  ZThread::Mutex iolock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> output(std::ostringstream&amp; os) {</div>
<div class=CC1>    ZThread::Guard&lt;ZThread::Mutex&gt; g(iolock);</div>
<div class=CC1>    std::cout &lt;&lt; os.str();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DISPLAY_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This way, the standard <b>operator&lt;&lt;(&nbsp;)</b>
functions are predefined for us and the object can be built in memory using
familiar <b>ostream</b> operators. When a task wants to display output, it
creates a temporary <b>ostringstream </b>object that it uses to build up the
desired output message. When it calls <b>output(&nbsp;)</b>, the mutex prevents
multiple threads from writing to this <b>Display</b> object. (You must use only
one <b>Display</b> object in your program, as you’ll see in the following
examples.)</p>

<p class=MsoNormal>This just shows the basic idea, but if necessary, you can
build a more elaborate framework. For example, you could enforce the
requirement that there be only one <b>Display</b> object in a program by making
it a Singleton. (The ZThread library has a <b>Singleton</b> template to support
Singletons.)</p>

<h3><a href="#_TocRef53985881" name="_Toc53985881">The ornamental garden</a></h3>

<p class=MsoNormal>In this simulation, the garden committee would like to know
how many people enter the garden each day through its multiple gates. Each gate
has a turnstile or some other kind of counter, and after the turnstile count is
incremented, a shared count is incremented that represents the total number of
people in the garden.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:OrnamentalGarden.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;vector&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Display.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/FastMutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/CountedPtr.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Count : <font color=#ff7700>public</font> Cancelable {</div>
<div class=CC1>  FastMutex lock;</div>
<div class=CC1>  <font color=#ff7700>int</font> count;</div>
<div class=CC1>  <font color=#ff7700>bool</font> paused, canceled;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Count() : count(0), paused(<font color=#ff7700>false</font>), canceled(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#ff7700>int</font> increment() {</div>
<div class=CC1>    <font color=#dd0000>// Comment the following line to see counting fail:</font></div>
<div class=CC1>    Guard&lt;FastMutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>int</font> temp = count ;</div>
<div class=CC1>    <font color=#ff7700>if</font>(rand() % 2 == 0) <font color=#dd0000>// Yield half the time</font></div>
<div class=CC1>      Thread::yield();</div>
<div class=CC1>    <font color=#ff7700>return</font> (count  = ++temp);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> value() {</div>
<div class=CC1>    Guard&lt;FastMutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>return</font> count;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> cancel() {</div>
<div class=CC1>    Guard&lt;FastMutex&gt; g(lock);</div>
<div class=CC1>    canceled = <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isCanceled() {</div>
<div class=CC1>    Guard&lt;FastMutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>return</font> canceled;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> pause() {</div>
<div class=CC1>    Guard&lt;FastMutex&gt; g(lock);</div>
<div class=CC1>    paused = <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>bool</font> isPaused() {</div>
<div class=CC1>    Guard&lt;FastMutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>return</font> paused;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Entrance : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CountedPtr&lt;Count&gt; count;</div>
<div class=CC1>  CountedPtr&lt;Display&gt; display;</div>
<div class=CC1>  <font color=#ff7700>int</font> number;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1>  <font color=#ff7700>bool</font> waitingForCancel;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Entrance(CountedPtr&lt;Count&gt;&amp; cnt,</div>
<div class=CC1>    CountedPtr&lt;Display&gt;&amp; disp, <font color=#ff7700>int</font> idn)</div>
<div class=CC1>  : count(cnt), display(disp), number(0), id(idn),</div>
<div class=CC1>    waitingForCancel(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(!count-&gt;isPaused()) {</div>
<div class=CC1>      ++number;</div>
<div class=CC1>      {</div>
<div class=CC1>        ostringstream os;</div>
<div class=CC1>        os &lt;&lt; *<font color=#ff7700>this</font> &lt;&lt; <font color=#007f00>&quot; Total: &quot;</font></div>
<div class=CC1>           &lt;&lt; count-&gt;increment() &lt;&lt;
endl;</div>
<div class=CC1>        display-&gt;output(os);</div>
<div class=CC1>      }</div>
<div class=CC1>      Thread::sleep(100);</div>
<div class=CC1>    }</div>
<div class=CC1>    waitingForCancel = <font color=#ff7700>true</font>;</div>
<div class=CC1>    <font color=#ff7700>while</font>(!count-&gt;isCanceled()) <font color=#dd0000>// Hold here...</font></div>
<div class=CC1>      Thread::sleep(100);</div>
<div class=CC1>    ostringstream os;</div>
<div class=CC1>    os &lt;&lt; <font color=#007f00>&quot;Terminating &quot;</font> &lt;&lt; *<font color=#ff7700>this</font>
&lt;&lt; endl;</div>
<div class=CC1>    display-&gt;output(os);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> getValue() {</div>
<div class=CC1>    <font color=#ff7700>while</font>(count-&gt;isPaused() &amp;&amp;
!waitingForCancel)</div>
<div class=CC1>      Thread::sleep(100);</div>
<div class=CC1>    <font color=#ff7700>return</font> number;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font> Entrance&amp;
e) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Entrance &quot;</font> &lt;&lt;
e.id &lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; e.number;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;ENTER&gt; to quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  CountedPtr&lt;Count&gt; count(<font color=#ff7700>new</font> Count);</div>
<div class=CC1>  vector&lt;Entrance*&gt; v;</div>
<div class=CC1>  CountedPtr&lt;Display&gt; display(<font color=#ff7700>new</font> Display);</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> SZ = 5;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++) {</span></div>
<div class=CC1><span lang=SV>      </span>Entrance* task = <font color=#ff7700>new</font>
Entrance(count, display, i);</div>
<div class=CC1>      executor.execute(task);</div>
<div class=CC1>      <font color=#dd0000>// Save the pointer to the task:</font></div>
<div class=CC1>      v.push_back(task);</div>
<div class=CC1>    }</div>
<div class=CC1>    cin.get(); <font color=#dd0000>// Wait for user to press &lt;Enter&gt;</font></div>
<div class=CC1>    count-&gt;pause(); <font color=#dd0000>// Causes tasks to stop counting</font></div>
<div class=CC1>    <font color=#ff7700>int</font> sum = 0;</div>
<div class=CC1>    vector&lt;Entrance*&gt;::iterator it = v.begin();</div>
<div class=CC1>    <font color=#ff7700>while</font>(it != v.end()) {</div>
<div class=CC1>      sum += (*it)-&gt;getValue();</div>
<div class=CC1>      ++it;</div>
<div class=CC1>    }</div>
<div class=CC1>    ostringstream os;</div>
<div class=CC1>    os &lt;&lt; <font color=#007f00>&quot;Total: &quot;</font> &lt;&lt;
count-&gt;value() &lt;&lt; endl</div>
<div class=CC1>       &lt;&lt; <font color=#007f00>&quot;Sum of Entrances: &quot;</font> &lt;&lt;
sum &lt;&lt; endl;</div>
<div class=CC1>    display-&gt;output(os);</div>
<div class=CC1>    count-&gt;cancel(); <font color=#dd0000>// Causes threads to quit</font></div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal><b>Count</b> is the class that keeps the master count of
garden visitors. The single <b>Count</b> object defined in <b>main(&nbsp;)</b>
as <b>count </b>is held as a <b>CountedPtr</b> in <b>Entrance</b> and thus is
shared by all <b>Entrance</b> objects. A <b>FastMutex</b> called <b>lock </b>is used in this example instead of an ordinary <b>Mutex</b> because a <b>FastMutex</b> uses
the native operating system mutex and will thus yield more interesting results.</p>

<p class=MsoNormal>A <b>Guard</b> is used with <b>lock</b> in <b>increment(&nbsp;)</b>
to synchronize access to <b>count</b>. This function uses <b>rand(&nbsp;)</b>
to cause a <b>yield(&nbsp;)</b> roughly half the time, in between fetching <b>count</b>
into <b>temp </b>and incrementing and storing <b>temp </b>back into <b>count</b>.
Because of this, if you comment out the <b>Guard</b> object definition, you
will rapidly see the program break because multiple threads will be accessing
and modifying <b>count</b> simultaneously.</p>

<p class=MsoNormal>The <b>Entrance</b> class also keeps a local <b>number</b>
with the number of visitors that have passed through this particular entrance.
This provides a double-check against the <b>count</b> object to make sure that
the proper number of visitors is being recorded. <b>Entrance</b><b>::run(&nbsp;)</b>
simply increments <b>number</b> and the <b>count</b> object and sleeps for 100
milliseconds.</p>

<p class=MsoNormal>In main, a <b>vector&lt;Entrance*&gt;</b> is loaded with
each <b>Entrance</b> that is created. After the user presses <b>&lt;Enter&gt;</b>,
this <b>vector </b>is used to iterate over all the individual <b>Entrance</b>
values and total them.</p>

<p class=MsoNormal>This program goes to quite a bit of extra trouble to shut
everything down in a stable fashion. Part of the reason for this is to show
just how careful you must be when terminating a multithreaded program, and part
of the reason is to demonstrate the value of <b>interrupt(&nbsp;)</b>, which
you will learn about shortly.</p>

<p class=MsoNormal>All the communication between the <b>Entrance</b> objects
takes place through the single <b>Count</b> object. When the user presses &lt;Enter&gt;,
<b>main(&nbsp;)</b> sends the <b>pause(&nbsp;)</b> message to <b>count</b>.
Since each <b>Entrance::run(&nbsp;)</b> is watching the <b>count</b> object to
see whether it is paused, this causes each <b>Entrance</b> to move into the <b>waitingForCancel</b>
state, where it is no longer counting, but it is still alive. This is essential
because <b>main(&nbsp;)</b> must still be able to safely iterate over the objects
in the <b>vector&lt;Entrance*&gt;</b>. Note that because there is a slight
possibility that the iteration might occur before an <b>Entrance</b> has
finished counting and moved into the <b>waitingForCancel</b> state, the <b>getValue(&nbsp;)</b>
function cycles through calls to <b>sleep(&nbsp;)</b> until the object moves
into <b>waitingForCancel</b>. (This is one form of what is called a <i>busy wait</i>, which is undesirable. You’ll see the preferred approach of using <b>wait(&nbsp;)</b>
later in the chapter.) Once <b>main(&nbsp;)</b> completes its iteration through
the <b>vector&lt;Entrance*&gt;</b>, the <b>cancel(&nbsp;)</b> message is sent
to the <b>count</b> object, and once again all the <b>Entrance</b> objects are
watching for this state change. At this point, they print a termination message
and exit from <b>run(&nbsp;)</b>, which causes each task to be destroyed by the
threading mechanism.</p>

<p class=MsoNormal>As this program runs, you will see the total count and the count at each entrance displayed as people walk through a turnstile. If
you comment out the <b>Guard</b> object in <b>Count::increment(&nbsp;)</b>,<b> </b>you’ll
notice that the total number of people is not what you expect it to be. The
number of people counted by each turnstile will be different from the value in <b>count</b>. As long as the <b>Mutex</b> is there to synchronize
access to the <b>Counter</b>, things work correctly. Keep in mind that <b>Count::increment(&nbsp;)</b>
exaggerates the potential for failure by using <b>temp</b> and <b>yield(&nbsp;)</b>.
In real threading problems, the possibility for failure may be statistically
small, so you can easily fall into the trap of believing that things are
working correctly. Just as in the example above, there are likely to be hidden
problems that haven’t occurred to you, so be exceptionally diligent when
reviewing concurrent code.</a></p>

<h4>Atomic operations</h4>

<p class=MsoNormal>Note that <b>Count::value(&nbsp;)</b> returns the value of <b>count
</b>using a <b>Guard</b> object for synchronization. This brings up an
interesting point because this code will <i>probably</i> work fine with most
compilers and systems without synchronization. The reason is that, in general,
a simple operation such as returning an <b>int</b> will be an <i>atomic operation</i>, which means that it will probably happen in a single microprocessor
instruction that will not get interrupted. (The multithreading mechanism is
unable to stop a thread in the middle of a microprocessor instruction.) That
is, atomic operations are not interruptible by the threading mechanism and thus
do not need to be guarded.<a href="#_ftn152" name="_ftnref152"><span
class=MsoFootnoteReference>[152]</span></a> In
fact, if we removed the fetch of <b>count</b> into <b>temp</b> and removed the <b>yield(&nbsp;)</b>,
and instead simply incremented <b>count</b> directly, we probably wouldn’t need
a lock because the increment operation is <i>usually</i> atomic, as well.<a href="#_ftn153" name="_ftnref153"><span
class=MsoFootnoteReference>[153]</span></a></p>

<p class=MsoNormal>The problem is that the C++ Standard doesn’t guarantee
atomicity for any of these operations. Although operations such as returning an
<b>int</b> and incrementing an <b>int</b> are almost certainly atomic on most
machines, there’s no guarantee. And because there’s no guarantee, you have to
assume the worst. Sometimes you might investigate the atomicity behavior on a
particular machine (usually by looking at assembly language) and write code
based on those assumptions. That’s always dangerous and ill-advised. It’s too
easy for that information to be lost or hidden, and the next person that comes
along may assume that this code can be ported to another machine and then go
mad tracking down the occasional glitch caused by thread collisions.</p>

<p class=MsoNormal>So, while removing the guard on <b>Count::value(&nbsp;)</b>
seems to work, it’s not airtight, and thus on some machines you may see
aberrant behavior.</p>

<h3><a href="#_TocRef53985882" name="_Toc53985882">Terminating when blocked</a></h3>

<p class=MsoNormal><a name=AAA></a><b>Entrance::run(&nbsp;)</b> in the previous
example includes a call to <b>sleep(&nbsp;)</b> in the main loop. We know that <b>sleep(&nbsp;)</b>
will eventually wake up and the task will reach the top of the loop where it
has an opportunity to break out of that loop by checking the <b>isPaused(&nbsp;)</b>
status. However, <b>sleep(&nbsp;)</b> is just one situation where a thread is <i>blocked</i>
from executing, and sometimes you must terminate a task that’s blocked.</p>

<h4>Thread states</h4>

<p class=MsoNormal>A thread can be in any one of four states:</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i>New</i>: A thread remains in this state only momentarily, as
it is being created. It allocates any necessary system resources and performs
initialization. At this point it becomes eligible to receive CPU time. The
scheduler will then transition this thread to the <i>runnable</i> or <i>blocked</i>
state.</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i>Runnable</i>: This means that a thread <i>can</i> be run when
the time-slicing mechanism has CPU cycles available for the thread. Thus, the
thread might or might not be running at any moment, but there’s nothing to
prevent it from being run if the scheduler can arrange it; it’s not dead or
blocked.</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i>Blocked</i>: The thread could be run, but something prevents
it. (It might be waiting for I/O to complete, for example.) While a thread is
in the blocked state, the scheduler will simply skip it and not give it any CPU
time. Until a thread reenters the <i>runnable</i> state, it won’t perform any
operations.</p>

<p class=MsoNormal style='margin-left:.95in;text-indent:-.45in'><span
style='font-family:Verdana'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i>Dead</i>: A thread in the dead state is no longer schedulable
and will not receive any CPU time. Its task is completed, and it is no longer <i>runnable</i>.
The normal way for a thread to die is by returning from its <b>run(&nbsp;) </b>function.</p>

<h4>Becoming blocked</a></h4>

<p class=MsoNormal>A thread is blocked when it cannot continue running. A
thread can become blocked for the following reasons: </p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You’ve put the thread to sleep by calling <b>sleep(milliseconds)</b>,
in which case it will not be run for the specified time.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>You’ve suspended the execution of the thread with <b>wait(&nbsp;)</b>.
It will not become runnable again until the thread gets the <b>signal(&nbsp;)</b>
or <b>broadcast(&nbsp;)</b> message. We’ll examine these in a later section.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The thread is waiting for some I/O to complete.</p>

<p class=Numbered style='margin-left:.5in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>The thread is trying to enter a block of code that is guarded by
a mutex, and that mutex has already been acquired by another thread.</p>

<p class=MsoNormal>The problem we need to look at now is
this: sometimes you want to </a>terminate a thread that is in a blocked state.
If you can’t wait for it to get to a point in the code where it can check a
state value and decide to terminate on its own, you have to force the thread
out of its blocked state.</p>

<h3><a href="#_TocRef53985883" name="_Toc53985883">Interruption</a></h3>

<p class=MsoNormal>As you might imagine, it’s much messier to break out of the
middle of a <b>Runnable::run(&nbsp;)</b> function than it is to wait for that
function to get to a test of <b>isCanceled(&nbsp;)</b> (or some other place
where the programmer is ready to leave the function). When you break out of a
blocked task, you might need to destroy objects and clean up resources. Because
of this, breaking out of the middle of a task’s <b>run(&nbsp;)</b> is more like
throwing an exception than anything else, so in ZThreads, exceptions are used
for this kind of abort. (This walks the fine edge of being an inappropriate use
of exceptions, because it means you are often using them for control flow.)<a href="#_ftn154" name="_ftnref154"><span
class=MsoFootnoteReference>[154]</span></a> To return to
a known good state when terminating a task this way, carefully consider the
execution paths of your code and properly clean up everything inside the <b>catch</b>
clause. We’ll look at these issues in this section.</p>

<p class=MsoNormal>To terminate a blocked thread, the ZThread library provides
the <b>Thread</b>::<b>interrupt(&nbsp;)</b> function. This sets the <i>interrupted
status</i> for that thread. A thread with its interrupted status set will throw
an <b>Interrupted_Exception</b> if it is already blocked or it attempts a
blocking operation. The interrupted status will be reset when the exception is
thrown or if the task calls <b>Thread::interrupted(&nbsp;)</b>. As you’ll see, <b>Thread::interrupted(&nbsp;)</b>
provides a second way to leave your <b>run(&nbsp;)</b> loop, without throwing
an exception.</p>

<p class=MsoNormal>Here’s an example that shows the basics of <b>interrupt(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:Interrupting.cpp</font></div>
<div class=CC1><font color=#dd0000>// Interrupting a blocked thread.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Blocked : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      Thread::sleep(1000);</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Waiting for get() in
run():&quot;</font>;</div>
<div class=CC1>      cin.get();</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Caught
Interrupted_Exception&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>      <font color=#dd0000>// Exit the task</font></div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread t(<font color=#ff7700>new</font> Blocked);</div>
<div class=CC1>    <font color=#ff7700>if</font>(argc &gt; 1)</div>
<div class=CC1>      Thread::sleep(1100);</div>
<div class=CC1>    t.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You can see that, in addition to the insertion into <b>cout</b>,
<b>run(&nbsp;)</b> contains two other points where blocking can occur: the call
to <b>Thread::sleep(1000)</b> and the call to <b>cin.get(&nbsp;)</b>. By giving
the program any command-line argument, you tell <b>main(&nbsp;)</b> to sleep
long enough that the task will finish its <b>sleep(&nbsp;)</b> and call <b>cin.get(&nbsp;)</b>.<a href="#_ftn155" name="_ftnref155"><span
class=MsoFootnoteReference>[155]</span></a> If you don’t
give the program an argument, the <b>sleep(&nbsp;)</b> in <b>main(&nbsp;)</b>
is skipped. Here, the call to <b>interrupt(&nbsp;)</b> will occur while the
task is sleeping, and you’ll see that this will cause <b>Interrupted_Exception</b>
to be thrown. If you give the program a command-line argument, you’ll discover
that a task cannot be interrupted if it is blocked on IO. That is, you can
interrupt out of any blocking operation <i>except</i> IO.<a href="#_ftn156" name="_ftnref156"><span
class=MsoFootnoteReference>[156]</span></a></p>

<p class=MsoNormal>This is a little disconcerting if you’re creating a thread
that performs IO because it means that I/O has the potential of locking your
multithreaded program. The problem is that, again, C++ was not designed with
threading in mind; quite the opposite, it effectively pretends that threading
doesn’t exist. Thus, the iostream library is not thread-friendly. If the new C++
Standard decides to add thread support, the iostream library may need to be
reconsidered in the process.</p>

<h4>Blocked by a mutex</h4>

<p class=MsoNormal>If you try to call a function whose mutex has already been
acquired, the calling task will be suspended until the mutex becomes available.
The following example tests whether this kind of blocking is interruptible:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:Interrupting2.cpp</font></div>
<div class=CC1><font color=#dd0000>// Interrupting a thread blocked</font></div>
<div class=CC1><font color=#dd0000>// with a synchronization guard.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> BlockedMutex {</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  BlockedMutex() {</div>
<div class=CC1>    lock.acquire();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> f() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#dd0000>// This will never be available</font></div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Blocked2 : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  BlockedMutex blocked;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Waiting for f() in
BlockedMutex&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>      blocked.f();</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp; e) {</div>
<div class=CC1>      cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>      <font color=#dd0000>// Exit the task</font></div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread t(<font color=#ff7700>new</font> Blocked2);</div>
<div class=CC1>    t.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The class <b>BlockedMutex</b> has a constructor that
acquires the object’s own <b>Mutex</b> and never releases it. For that reason,
if you try to call <b>f(&nbsp;)</b>, you will always be blocked because the <b>Mutex</b>
cannot be acquired. In <b>Blocked2</b>, the <b>run(&nbsp;)</b> function will be
stopped at the call to <b>blocked.f(&nbsp;)</b>. When you run the program
you’ll see that, unlike the iostream call, <b>interrupt(&nbsp;)</b> can break
out of a call that’s blocked by a mutex.<a href="#_ftn157" name="_ftnref157"><span
class=MsoFootnoteReference>[157]</span></a></p>

<h4>Checking for an interrupt</h4>

<p class=MsoNormal>Note that when you call <b>interrupt(&nbsp;) </b>on a
thread, the only time that the interrupt occurs is when the task enters, or is
already inside, a blocking operation (except, as you’ve seen, in the case of
IO, where you’re just stuck). But what if you’ve written code that may or may
not make such a blocking call, depending on the conditions in which it is run?
If you can only exit by throwing an exception on a blocking call, you won’t
always be able to leave the <b>run(&nbsp;) </b>loop. Thus, if you call <b>interrupt(&nbsp;)</b>
to stop a task, your task needs a <i>second</i> opportunity to exit in the
event that your <b>run(&nbsp;)</b> loop doesn’t happen to be making any
blocking calls.</p>

<p class=MsoNormal>This opportunity is presented by the <i>interrupted status</i>, which is set by the call to <b>interrupt(&nbsp;)</b>. You check for the
interrupted status by calling <b>interrupted(&nbsp;)</b>. This not only tells
you whether <b>interrupt(&nbsp;)</b> has been called, it also clears the
interrupted status. Clearing the interrupted status ensures that the framework
will not notify you twice about a task being interrupted. You will be notified
via either a single <b>Interrupted_Exception</b>, or a single successful <b>Thread::interrupted(&nbsp;)</b>
test. If you want to check again to see whether you were interrupted, you can
store the result when you call <b>Thread::interrupted(&nbsp;)</b>.</p>

<p class=MsoNormal>The following example shows the typical idiom that you
should use in your <b>run(&nbsp;)</b> function to handle both blocked and
non-blocked possibilities when the interrupted status is set:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:Interrupting3.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// General idiom for interrupting a task.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>double</font> PI = 3.14159265358979323846;</div>
<div class=CC1><font color=#ff7700>const</font> <font color=#ff7700>double</font> E = 2.7182818284590452354;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> NeedsCleanup {</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  NeedsCleanup(<font color=#ff7700>int</font> ident) : id(ident) {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;NeedsCleanup &quot;</font> &lt;&lt; id
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>  ~NeedsCleanup() {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;~NeedsCleanup &quot;</font> &lt;&lt;
id &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Blocked3 : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  <font color=#ff7700>volatile</font> <font color=#ff7700>double</font> d;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Blocked3() : d(0.0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        point1:</div>
<div class=CC1>        NeedsCleanup n1(1);</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Sleeping&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>        Thread::sleep(1000);</div>
<div class=CC1>        point2:</div>
<div class=CC1>        NeedsCleanup n2(2);</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Calculating&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>        <font color=#dd0000>// A time-consuming, non-blocking operation:</font></div>
<div class=CC1>        <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 1; i &lt; 100000; i++)</div>
<div class=CC1>          d = d + (PI + E) / (<font color=#ff7700>double</font>)i;</div>
<div class=CC1>      }</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Exiting via while() test&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) {</div>
<div class=CC1>      cout &lt;&lt; <font color=#007f00>&quot;Exiting via
Interrupted_Exception&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc != 2) {</div>
<div class=CC1>    cerr &lt;&lt; <font color=#007f00>&quot;usage: &quot;</font> &lt;&lt; argv[0]</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot; delay-in-milliseconds&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>    exit(1);</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> delay = atoi(argv[1]);</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    Thread t(<font color=#ff7700>new</font> Blocked3);</div>
<div class=CC1>    Thread::sleep(delay);</div>
<div class=CC1>    t.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>NeedsCleanup</b> class emphasizes the necessity of
proper resource cleanup if you leave the loop via an exception. Note that no
pointers are defined in <b>Blocked3::run(&nbsp;)</b> because, for exception
safety, all resources must be enclosed in stack-based objects so that the
exception handler can automatically clean them up by calling the destructor.</p>

<p class=MsoNormal>You must give the program a command-line argument which is
the delay time in milliseconds before it calls <b>interrupt(&nbsp;)</b>. By
using different delays, you can exit <b>Blocked3::run(&nbsp;)</b> at different
points in the loop: in the blocking <b>sleep(&nbsp;)</b> call, and in the
non-blocking mathematical calculation. You’ll see that if <b>interrupt(&nbsp;)</b>
is called after the label <b>point2 </b>(during the non-blocking operation),
first the loop is completed, then all the local objects are destructed, and finally
the loop is exited at the top via the <b>while</b> statement. However, if <b>interrupt(&nbsp;)</b>
is called between <b>point1 </b>and <b>point2 </b>(after the <b>while</b>
statement but before or during the blocking operation <b>sleep(&nbsp;)</b>),
the task exits via the <b>Interrupted_Exception</b>. In that case, only the
stack objects that have been created up to the point where the exception is
thrown are cleaned up, and you have the opportunity to perform any other
cleanup in the <b>catch</b> clause.</p>

<p class=MsoNormal>A class designed to respond to an <b>interrupt(&nbsp;) </b>must
establish a policy that ensures it will remain in a consistent state. This
generally means that all resource acquisition should be wrapped inside
stack-based objects so that the destructors will be called regardless of how
the <b>run(&nbsp;) </b>loop exits. Correctly done, code like this can be
elegant. Components can be created that completely encapsulate their
synchronization mechanisms but are still responsive to an external stimulus
(via <b>interrupt(&nbsp;)</b>) without adding any special functions to an
object’s interface.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef44493784" name="_Toc44493784">Cooperation between threads</a></h2>

<p class=MsoNormal>As you’ve seen, when you use threads to run more than one
task at a time, you can keep one task from interfering with another task’s
resources by using a mutex to synchronize the behavior of the two tasks. That
is, if two tasks are stepping on each other over a shared resource (usually
memory), you use a mutex to allow only one task at a time to access that
resource.</p>

<p class=MsoNormal>With that problem solved, you can move on to the issue of
getting threads to cooperate, so that multiple threads can work together to solve a problem. Now the issue is not about interfering with one another, but
rather about working in unison, since portions of such problems must be solved
before other portions can be solved. It’s much like project planning: the
footings for the house must be dug first, but the steel can be laid and the
concrete forms can be built in parallel, and both of those tasks must be
finished before the concrete foundation can be poured. The plumbing must be in
place before the concrete slab can be poured, the concrete slab must be in
place before you start framing, and so on. Some of these tasks can be done in
parallel, but certain steps require all tasks to be completed before you can
move ahead.</p>

<p class=MsoNormal>The key issue when tasks are cooperating is handshaking between those tasks. To accomplish this handshaking, we use the same
foundation: the mutex, which in this case guarantees that only one task can
respond to a signal. This eliminates any possible race conditions. On top of
the mutex, we add a way for a task to suspend itself until some external state
changes (“the plumbing is now in place”), indicating that it’s time for that
task to move forward. In this section, we’ll look at the issues of handshaking
between tasks, the problems that can arise, and their solutions.</p>

<h3><a href="#_TocRef24775853" name="_Toc24775853">Wait and signal</a></h3>

<p class=MsoNormal>In ZThreads, the basic class that uses a mutex and allows
task suspension is the <b>Condition</b>, and you can suspend a task by calling <b>wait(&nbsp;)</b> on a <b>Condition</b>. When external state changes take place that
might mean that a task should continue processing, you notify the task by
calling <b>signal(&nbsp;)</b>, to wake up one task, or <b>broadcast(&nbsp;)</b>, to wake up all tasks that have suspended themselves on that <b>Condition</b> object.</p>

<p class=MsoNormal>There are two forms of <b>wait(&nbsp;)</b>. The first form takes
an argument in milliseconds that has the same meaning as in <b>sleep(&nbsp;)</b>:
“pause for this period of time.” The second form takes no arguments; this
version is more commonly used. Both forms of <b>wait(&nbsp;)</b> release the <b>Mutex</b>
that is controlled by the <b>Condition</b> object and suspends the thread until
that <b>Condition</b> object receives a <b>signal(&nbsp;)</b> or <b>broadcast(&nbsp;)</b>.
The first form may also terminate if it times out before a <b>signal(&nbsp;)</b>
or <b>broadcast(&nbsp;)</b> is received.</p>

<p class=MsoNormal>Because <b>wait(&nbsp;)</b> releases the <b>Mutex</b>, it
means that the <b>Mutex</b> can be acquired by another thread. Thus, when you
call <b>wait(&nbsp;)</b> you’re saying “I’ve done all I can right now so I’m
going to wait right here, but I want to allow other synchronized operations to
take place if they can.”</p>

<p class=MsoNormal>Typically, you use <b>wait(&nbsp;)</b> when you’re waiting
for some condition to change that is under the control of forces outside the
current function. (Often, this condition will be changed by another thread.)
You don’t want to idly loop while testing the condition inside your thread;
this is called a “busy wait,” and it’s usually a bad use of CPU cycles. Thus, <b>wait(&nbsp;)</b>
suspends the thread while waiting for the world to change, and only when a <b>signal(&nbsp;)</b>
or <b>broadcast(&nbsp;) </b>occurs (suggesting that something of interest may
have happened), does the thread wake up and check for changes. So <b>wait(&nbsp;)</b>
provides a way to synchronize activities between threads.</p>

<p class=MsoNormal>Let’s look at a simple example. <b>WaxOMatic.cpp</b> has two
processes: one to apply wax to a <b>Car </b>and one to polish it. The polishing
process cannot do its job until the application process is finished, and the
application process must wait until the polishing process is finished before it
can put on another coat of wax. Both <b>WaxOn</b> and <b>WaxOff</b> use the <b>Car</b>
object, which contains a <b>Condition</b> that it uses to suspend a thread
inside <b>waitForWaxing(&nbsp;)</b> or <b>waitForBuffing(&nbsp;)</b>:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:WaxOMatic.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Basic thread cooperation.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Condition.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Car {</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1>  Condition condition;</div>
<div class=CC1>  <font color=#ff7700>bool</font> waxOn;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Car() : condition(lock), waxOn(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> waxed() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    waxOn = <font color=#ff7700>true</font>; <font color=#dd0000>// Ready to buff</font></div>
<div class=CC1>    condition.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> buffed() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    waxOn = <font color=#ff7700>false</font>; <font color=#dd0000>// Ready for another coat of wax</font></div>
<div class=CC1>    condition.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> waitForWaxing() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(waxOn == <font color=#ff7700>false</font>)</div>
<div class=CC1>      condition.wait();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> waitForBuffing() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(waxOn == <font color=#ff7700>true</font>)</div>
<div class=CC1>      condition.wait();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> WaxOn : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CountedPtr&lt;Car&gt; car;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  WaxOn(CountedPtr&lt;Car&gt;&amp; c) : car(c) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Wax On!&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>        Thread::sleep(200);</div>
<div class=CC1>        car-&gt;waxed();</div>
<div class=CC1>        car-&gt;waitForBuffing();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Ending Wax On process&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> WaxOff : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CountedPtr&lt;Car&gt; car;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  WaxOff(CountedPtr&lt;Car&gt;&amp; c) : car(c) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        car-&gt;waitForWaxing();</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Wax Off!&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>        Thread::sleep(200);</div>
<div class=CC1>        car-&gt;buffed();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Ending Wax Off process&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Enter&gt; to quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    CountedPtr&lt;Car&gt; car(<font color=#ff7700>new</font> Car);</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    executor.execute(<font color=#ff7700>new</font> WaxOff(car));</div>
<div class=CC1>    executor.execute(<font color=#ff7700>new</font> WaxOn(car));</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    executor.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>In <b>Car</b>’s constructor, a single <b>Mutex</b> is
wrapped in a <b>Condition</b> object so that it can be used to manage
inter-task communication. However, the <b>Condition</b> object contains no
information about the state of your process, so you need to manage additional
information to indicate process state. Here, <b>Car</b> has a single <b>bool
waxOn</b>, which indicates the state of the waxing-polishing process.</p>

<p class=MsoNormal>In <b>waitForWaxing(&nbsp;)</b>, the <b>waxOn</b> flag is
checked, and if it is <b>false</b>, the calling thread is suspended by calling <b>wait(&nbsp;)</b>
on the <b>Condition</b> object. It’s important that this occur inside a guarded
clause, where the thread has acquired the lock (here, by creating a <b>Guard</b>
object). When you call <b>wait(&nbsp;)</b>, the thread is suspended and <i>the
lock is released</i>. It is essential that the lock be released because, to
safely change the state of the object (for example, to change <b>waxOn</b> to <b>true</b>,
which must happen if the suspended thread is to ever continue), that lock must
be available to be acquired by some other task. In this example, when another
thread calls <b>waxed(&nbsp;)</b> to tell it that it’s time to do something,
the mutex must be acquired in order to change <b>waxOn</b> to <b>true</b>.
Afterward, <b>waxed(&nbsp;) </b>sends a <b>signal(&nbsp;)</b> to the <b>Condition</b>
object, which wakes up the thread suspended in the call to <b>wait(&nbsp;)</b>.
Although <b>signal(&nbsp;)</b> may be called inside a guarded clause—as it is
here—you are not required to do this.<a href="#_ftn158" name="_ftnref158"><span
class=MsoFootnoteReference>[158]</span></a></p>

<p class=MsoNormal>In order for a thread to wake up from a <b>wait(&nbsp;)</b>,
it must first reacquire the mutex that it released when it entered the <b>wait(&nbsp;)</b>.
The thread will not wake up until that mutex becomes available.</p>

<p class=MsoNormal>The call to <b>wait(&nbsp;)</b> is placed inside a <b>while</b>
loop that checks the condition of interest. This is important for two reasons:<a href="#_ftn159" name="_ftnref159"><span
class=MsoFootnoteReference>[159]</span></a></p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>It is possible that when the thread gets a <b>signal(&nbsp;)</b>,
some other condition has changed that is not associated with the reason that we
called <b>wait(&nbsp;)</b> here. If that is the case, this thread should be
suspended again until its condition of interest changes.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>By the time this thread awakens from its <b>wait(&nbsp;)</b>,
it’s possible that some other task has changed things such that this thread is
unable or uninterested in performing its operation at this time. Again, it
should be re-suspended by calling <b>wait(&nbsp;)</b> again.</p>

<p class=MsoNormal>Because these two reasons are always present when you are
calling <b>wait(&nbsp;)</b>, always write your call to <b>wait(&nbsp;)</b>
inside a <b>while</b> loop that tests for your condition(s) of interest.</p>

<p class=MsoNormal><b>WaxOn::run(&nbsp;)</b> represents the first step in the
process of waxing the car, so it performs its operation (a call to <b>sleep(&nbsp;)</b>
to simulate the time necessary for waxing). It then tells the car that waxing
is complete, and calls <b>waitForBuffing(&nbsp;)</b>, which suspends this
thread with a <b>wait(&nbsp;) </b>until the <b>WaxOff</b> process calls <b>buffed(&nbsp;)</b>
for the car, changing the state and calling <b>notify(&nbsp;)</b>. <b>WaxOff::run(&nbsp;)</b>,
on the other hand, immediately moves into <b>waitForWaxing(&nbsp;)</b> and is
thus suspended until the wax has been applied by <b>WaxOn</b> and <b>waxed(&nbsp;)</b>
is called. When you run this program, you can watch this two-step process
repeat itself as control is handed back and forth between the two threads. When
you press the &lt;Enter&gt; key, <b>interrupt(&nbsp;)</b> halts both
threads—when you call <b>interrupt(&nbsp;)</b> for an <b>Executor</b>, it calls
<b>interrupt(&nbsp;)</b> for all the threads it is controlling.</p>

<h3><a href="#_TocRef53985886" name="_Toc53985886">Producer–consumer relationships</a></h3>

<p class=MsoNormal>A common situation in threading problems is the <i>producer-consumer</i> relationship, where one task is creating objects and other
tasks are consuming them. In such a situation, make sure that (among other
things) the consuming tasks do not accidentally skip any of the produced
objects.</p>

<p class=MsoNormal>To show this problem, consider a machine that has three
tasks: one to make toast, one to butter the toast, and one to put jam on the
buttered toast.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:ToastOMatic.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Problems with thread cooperation.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Condition.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Apply jam to buttered toast:</font></div>
<div class=CC1><font color=#ff7700>class</font> Jammer : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1>  Condition butteredToastReady;</div>
<div class=CC1>  <font color=#ff7700>bool</font> gotButteredToast;</div>
<div class=CC1>  <font color=#ff7700>int</font> jammed;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Jammer() : butteredToastReady(lock) {</div>
<div class=CC1>    gotButteredToast = <font color=#ff7700>false</font>;</div>
<div class=CC1>    jammed = 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> moreButteredToastReady() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    gotButteredToast = <font color=#ff7700>true</font>;</div>
<div class=CC1>    butteredToastReady.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        {</div>
<div class=CC1>          Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>          <font color=#ff7700>while</font>(!gotButteredToast)</div>
<div class=CC1>            butteredToastReady.wait();</div>
<div class=CC1>          ++jammed;</div>
<div class=CC1>        }</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Putting jam on toast &quot;</font>
&lt;&lt; jammed &lt;&lt; endl;</div>
<div class=CC1>        {</div>
<div class=CC1>          Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>          gotButteredToast = <font color=#ff7700>false</font>;</div>
<div class=CC1>        }</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Jammer off&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Apply butter to toast:</font></div>
<div class=CC1><font color=#ff7700>class</font> Butterer : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  Mutex lock;</div>
<div class=CC1>  Condition toastReady;</div>
<div class=CC1>  CountedPtr&lt;Jammer&gt; jammer;</div>
<div class=CC1>  <font color=#ff7700>bool</font> gotToast;</div>
<div class=CC1>  <font color=#ff7700>int</font> buttered;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Butterer(CountedPtr&lt;Jammer&gt;&amp; j)</div>
<div class=CC1>  : toastReady(lock), jammer(j) {</div>
<div class=CC1>    gotToast = <font color=#ff7700>false</font>;</div>
<div class=CC1>    buttered = 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> moreToastReady() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>    gotToast = <font color=#ff7700>true</font>;</div>
<div class=CC1>    toastReady.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        {</div>
<div class=CC1>          Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>          <font color=#ff7700>while</font>(!gotToast)</div>
<div class=CC1>            toastReady.wait();</div>
<div class=CC1>          ++buttered;</div>
<div class=CC1>        }</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Buttering toast &quot;</font>
&lt;&lt; buttered &lt;&lt; endl;</div>
<div class=CC1>        jammer-&gt;moreButteredToastReady();</div>
<div class=CC1>        {</div>
<div class=CC1>          Guard&lt;Mutex&gt; g(lock);</div>
<div class=CC1>          gotToast = <font color=#ff7700>false</font>;</div>
<div class=CC1>        }</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Butterer off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Toaster : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CountedPtr&lt;Butterer&gt; butterer;</div>
<div class=CC1>  <font color=#ff7700>int</font> toasted;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Toaster(CountedPtr&lt;Butterer&gt;&amp; b) :
butterer(b) {</div>
<div class=CC1>    toasted = 0;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        Thread::sleep(rand()/(RAND_MAX/5)*100);</div>
<div class=CC1>        <font color=#dd0000>// ...</font></div>
<div class=CC1>        <font color=#dd0000>// Create new toast</font></div>
<div class=CC1>        <font color=#dd0000>// ...</font></div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;New toast &quot;</font> &lt;&lt;
++toasted &lt;&lt; endl;</div>
<div class=CC1>        butterer-&gt;moreToastReady();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Toaster off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Return&gt; to
quit&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    CountedPtr&lt;Jammer&gt; jammer(<font color=#ff7700>new</font> Jammer);</div>
<div class=CC1>    CountedPtr&lt;Butterer&gt; butterer(<font color=#ff7700>new</font>
Butterer(jammer));</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    executor.execute(<font color=#ff7700>new</font> Toaster(butterer));</div>
<div class=CC1>    executor.execute(butterer);</div>
<div class=CC1>    executor.execute(jammer);</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    executor.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The classes are defined in the reverse order that they
operate to simplify forward-referencing issues.</p>

<p class=MsoNormal><b>Jammer</b> and <b>Butterer</b> both contain a <b>Mutex</b>,
a <b>Condition</b>, and some kind of internal state information that changes to
indicate that the process should suspend or resume. (<b>Toaster</b> doesn’t
need these since it is the producer and doesn’t have to wait on anything.) The
two <b>run(&nbsp;)</b> functions perform an operation, set a state flag, and
then call <b>wait(&nbsp;)</b> to suspend the task. The <b>moreToastReady(&nbsp;)</b>
and <b>moreButteredToastReady(&nbsp;)</b> functions change their respective
state flags to indicate that something has changed and the process should
consider resuming and then call <b>signal(&nbsp;)</b> to wake up the thread.</p>

<p class=MsoNormal>The difference between this example and the previous one is
that, at least conceptually, something is being produced here: toast. The rate
of toast production is randomized a bit, to add some uncertainty. And you’ll
see that when you run the program, things aren’t going right because many
pieces of toast appear to be getting dropped on the floor—not buttered, not
jammed.</p>

<h3><a href="#_TocRef53985887" name="_Toc53985887">Solving threading problems with queues</a></h3>

<p class=MsoNormal>Often, threading problems are based on the need for tasks to
be serialized—that is, to take care of things in order. <b>ToastOMatic.cpp</b>
must not only take care of things in order, it must be able to work on one
piece of toast without worrying that toast is falling on the floor in the
meantime. You can solve many threading problems by using a queue that
synchronizes access to the elements within:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:TQueue.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef TQUEUE_H</font></div>
<div class=CC1><font color=#7F7F00>#define TQUEUE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;deque&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Condition.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>template</font>&lt;<font color=#ff7700>class</font> T&gt; <font color=#ff7700>class</font> TQueue {</div>
<div class=CC1>  ZThread::Mutex lock;</div>
<div class=CC1>  ZThread::Condition cond;</div>
<div class=CC1>  std::deque&lt;T&gt; data;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  TQueue() : cond(lock) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> put(T item) {</div>
<div class=CC1>    ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</div>
<div class=CC1>    data.push_back(item);</div>
<div class=CC1>    cond.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>  T get() {</div>
<div class=CC1>    ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(data.empty())</div>
<div class=CC1>      cond.wait();</div>
<div class=CC1>    T returnVal = data.front();</div>
<div class=CC1>    data.pop_front();</div>
<div class=CC1>    <font color=#ff7700>return</font> returnVal;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// TQUEUE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>This builds on the Standard C++ Library <b>deque</b> by
adding:</p>

<p class=Numbered><span style='font-family:Verdana'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Synchronization to ensure that no two threads add objects at the
same time.</p>

<p class=Numbered><span style='font-family:Verdana'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>wait(&nbsp;)</b> and <b>signal(&nbsp;)</b> so that a consumer
thread will automatically suspend if the queue is empty, and resume when more
elements become available.</p>

<p class=MsoNormal>This relatively small amount of code can solve a remarkable
number of problems.<a href="#_ftn160" name="_ftnref160"><span
class=MsoFootnoteReference>[160]</span></a></p>

<p class=MsoNormal>Here’s a simple test that serializes the execution of <b>LiftOff</b>
objects. The consumer is <b>LiftOffRunner</b>, which pulls each <b>LiftOff</b>
object off the <b>TQueue</b> and runs it directly. (That is, it uses its own
thread by calling <b>run(&nbsp;)</b> explicitly rather than starting up a new
thread for each task.)</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:TestTQueue.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;TQueue.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;LiftOff.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> LiftOffRunner : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  TQueue&lt;LiftOff*&gt; rockets;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#ff7700>void</font> add(LiftOff* lo) { rockets.put(lo); }</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        LiftOff* rocket = rockets.get();</div>
<div class=CC1>        rocket-&gt;run();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Exiting LiftOffRunner&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    LiftOffRunner* lor = <font color=#ff7700>new</font> LiftOffRunner;</div>
<div class=CC1>    Thread t(lor);</div>
<div class=CC1>    <font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; 5; i++)</div>
<div class=CC1>      lor-&gt;add(<font color=#ff7700>new</font> LiftOff(10, i));</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    lor-&gt;add(<font color=#ff7700>new</font> LiftOff(10, 99));</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    t.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The tasks are placed on the <b>TQueue</b> by <b>main(&nbsp;)</b>
and are taken off the <b>TQueue</b> by the <b>LiftOffRunner</b>. Notice that <b>LiftOffRunner</b>
can ignore the synchronization issues because they are solved by the <b>TQueue</b>.</p>

<h4>Proper toasting</h4>

<p class=MsoNormal>To solve the <b>ToastOMatic.cpp</b> problem, we can run the
toast through <b>TQueue</b>s between processes. And to do this, we will need
actual toast objects, which maintain and display their state:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:ToastOMaticMarkII.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Solving the problems using TQueues.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Condition.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;TQueue.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Toast {</div>
<div class=CC1>  <font color=#ff7700>enum</font> Status { DRY, BUTTERED, JAMMED };</div>
<div class=CC1>  Status status;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Toast(<font color=#ff7700>int</font> idn) : status(DRY), id(idn) {}</div>
<div class=CC1><font color=#7F7F00>  #ifdef __DMC__ </font><font color=#dd0000>// Incorrectly requires default</font></div>
<div class=CC1>  Toast() { assert(0); } <font color=#dd0000>// Should never be called</font></div>
<div class=CC1><font color=#7F7F00>  #endif</font></div>
<div class=CC1>  <font color=#ff7700>void</font> butter() { status = BUTTERED; }</div>
<div class=CC1>  <font color=#ff7700>void</font> jam() { status = JAMMED; }</div>
<div class=CC1>  string getStatus() <font color=#ff7700>const</font> {</div>
<div class=CC1>    <font color=#ff7700>switch</font>(status) {</div>
<div class=CC1>      <font color=#ff7700>case</font> DRY: <font color=#ff7700>return</font> <font color=#007f00>&quot;dry&quot;</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> BUTTERED: <font color=#ff7700>return</font> <font color=#007f00>&quot;buttered&quot;</font>;</div>
<div class=CC1>      <font color=#ff7700>case</font> JAMMED: <font color=#ff7700>return</font> <font color=#007f00>&quot;jammed&quot;</font>;</div>
<div class=CC1>      <font color=#ff7700>default</font>: <font color=#ff7700>return</font> <font color=#007f00>&quot;error&quot;</font>;</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>int</font> getId() { <font color=#ff7700>return</font> id; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Toast&amp; t) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Toast &quot;</font> &lt;&lt; t.id
&lt;&lt; <font color=#007f00>&quot;: &quot;</font> &lt;&lt; t.getStatus();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> CountedPtr&lt; TQueue&lt;Toast&gt; &gt;
ToastQueue;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Toaster : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  ToastQueue toastQueue;</div>
<div class=CC1>  <font color=#ff7700>int</font> count;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Toaster(ToastQueue&amp; tq) : toastQueue(tq),
count(0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#ff7700>int</font> delay = rand()/(RAND_MAX/5)*100;</div>
<div class=CC1>        Thread::sleep(delay);</div>
<div class=CC1>        <font color=#dd0000>// Make toast</font></div>
<div class=CC1>        Toast t(count++);</div>
<div class=CC1>        cout &lt;&lt; t &lt;&lt; endl;</div>
<div class=CC1>        <font color=#dd0000>// Insert into queue</font></div>
<div class=CC1>        toastQueue-&gt;put(t);</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Toaster off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Apply butter to toast:</font></div>
<div class=CC1><font color=#ff7700>class</font> Butterer : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  ToastQueue dryQueue, butteredQueue;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Butterer(ToastQueue&amp; dry, ToastQueue&amp;
buttered)</div>
<div class=CC1>  : dryQueue(dry), butteredQueue(buttered) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until next piece of toast is
available:</font></div>
<div class=CC1>        Toast t = dryQueue-&gt;get();</div>
<div class=CC1>        t.butter();</div>
<div class=CC1>        cout &lt;&lt; t &lt;&lt; endl;</div>
<div class=CC1>        butteredQueue-&gt;put(t);</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Butterer off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Apply jam to buttered toast:</font></div>
<div class=CC1><font color=#ff7700>class</font> Jammer : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  ToastQueue butteredQueue, finishedQueue;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Jammer(ToastQueue&amp; buttered, ToastQueue&amp;
finished)</div>
<div class=CC1>  : butteredQueue(buttered), finishedQueue(finished) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until next piece of toast is
available:</font></div>
<div class=CC1>        Toast t = butteredQueue-&gt;get();</div>
<div class=CC1>        t.jam();</div>
<div class=CC1>        cout &lt;&lt; t &lt;&lt; endl;</div>
<div class=CC1>        finishedQueue-&gt;put(t);</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Jammer off&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#dd0000>// Consume the toast:</font></div>
<div class=CC1><font color=#ff7700>class</font> Eater : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  ToastQueue finishedQueue;</div>
<div class=CC1>  <font color=#ff7700>int</font> counter;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Eater(ToastQueue&amp; finished)</div>
<div class=CC1>  : finishedQueue(finished), counter(0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until next piece of toast is
available:</font></div>
<div class=CC1>        Toast t = finishedQueue-&gt;get();</div>
<div class=CC1>        <font color=#dd0000>// Verify that the toast is coming in order,</font></div>
<div class=CC1>        <font color=#dd0000>// and that all pieces are getting jammed:</font></div>
<div class=CC1>        <font color=#ff7700>if</font>(t.getId() != counter++ ||</div>
<div class=CC1>           t.getStatus() != <font color=#007f00>&quot;jammed&quot;</font>) {</div>
<div class=CC1>          cout &lt;&lt; <font color=#007f00>&quot;&gt;&gt;&gt;&gt; Error:
&quot;</font> &lt;&lt; t &lt;&lt; endl;</div>
<div class=CC1>          exit(1);</div>
<div class=CC1>        } <font color=#ff7700>else</font></div>
<div class=CC1>          cout &lt;&lt; <font color=#007f00>&quot;Chomp! &quot;</font> &lt;&lt; t
&lt;&lt; endl;</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Eater off&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    ToastQueue dryQueue(<font color=#ff7700>new</font> TQueue&lt;Toast&gt;),</div>
<div class=CC1>               butteredQueue(<font color=#ff7700>new</font> TQueue&lt;Toast&gt;),</div>
<div class=CC1>               finishedQueue(<font color=#ff7700>new</font> TQueue&lt;Toast&gt;);</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Return&gt; to
quit&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    executor.execute(<font color=#ff7700>new</font> Toaster(dryQueue));</div>
<div class=CC1>    executor.execute(<font color=#ff7700>new</font>
Butterer(dryQueue,butteredQueue));</div>
<div class=CC1>    executor.execute(</div>
<div class=CC1>      <font color=#ff7700>new</font> Jammer(butteredQueue, finishedQueue));</div>
<div class=CC1>    executor.execute(<font color=#ff7700>new</font> Eater(finishedQueue));</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    executor.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Two things are immediately apparent in this solution: first,
the amount and complexity of code within each <b>Runnable</b> class is
dramatically reduced by the use of the <b>TQueue</b> because the guarding,
communication, and <b>wait(&nbsp;)/signal(&nbsp;)</b> operations are now taken
care of by the <b>TQueue</b>. The <b>Runnable</b> classes don’t have <b>Mutex</b>es
or <b>Condition</b> objects anymore. Second, the coupling between the classes
is eliminated because each class communicates only with its <b>TQueue</b>s.
Notice that the definition order of the classes is now independent. Less code
and less coupling are always good things, which suggests that the use of the <b>TQueue</b>
has a positive effect here, as it does on most problems.</p>

<h3><a href="#_TocRef53985888" name="_Toc53985888">Broadcast</a></h3>

<p class=MsoNormal>The <b>signal(&nbsp;)</b> function wakes up one thread that
is waiting on a <b>Condition</b> object. However, multiple threads may be
waiting on the same condition object, and in that case you might want to wake
them all up using <b>broadcast(&nbsp;)</b> instead of <b>signal(&nbsp;)</b>.</p>

<p class=MsoNormal>As an example that brings together many of the concepts in
this chapter, consider a hypothetical robotic assembly line for automobiles.
Each <b>Car</b> will be built in several stages, and in this example we’ll look
at a single stage: after the chassis has been created, at the time when the
engine, drive train, and wheels are attached. The <b>Car</b>s are transported
from one place to another via a <b>CarQueue</b>, which is a type of <b>TQueue</b>.
A <b>Director</b> takes each <b>Car</b> (as a raw chassis) from the incoming <b>CarQueue</b>
and places it in a <b>Cradle</b>, which is where all the work is done. At this
point, the <b>Director</b> tells all the waiting robots (using <b>broadcast(&nbsp;)</b>)
that the <b>Car</b> is in the <b>Cradle</b> ready for the robots to work on it.
The three types of robots go to work, sending a message to the <b>Cradle</b>
when they finish their tasks. The <b>Director</b> waits until all the tasks are
complete and then puts the <b>Car</b> onto the outgoing <b>CarQueue</b> to be transported
to the next operation. Here, the consumer of the outgoing <b>CarQueue</b> is a <b>Reporter</b>
object, which just prints the <b>Car</b> to show that the tasks have been
properly completed.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:CarBuilder.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// How broadcast() works.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Condition.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;TQueue.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Car {</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1>  <font color=#ff7700>bool</font> engine, driveTrain, wheels;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Car(<font color=#ff7700>int</font> idn) : id(idn), engine(<font color=#ff7700>false</font>),</div>
<div class=CC1>  driveTrain(<font color=#ff7700>false</font>), wheels(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#dd0000>// Empty Car object:</font></div>
<div class=CC1>  Car() : id(-1), engine(<font color=#ff7700>false</font>),</div>
<div class=CC1>  driveTrain(<font color=#ff7700>false</font>), wheels(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#dd0000>// Unsynchronized -- assumes atomic bool operations:</font></div>
<div class=CC1>  <font color=#ff7700>int</font> getId() { <font color=#ff7700>return</font> id; }</div>
<div class=CC1>  <font color=#ff7700>void</font> addEngine() { engine = <font color=#ff7700>true</font>; }</div>
<div class=CC1>  <font color=#ff7700>bool</font> engineInstalled() { <font color=#ff7700>return</font> engine; }</div>
<div class=CC1>  <font color=#ff7700>void</font> addDriveTrain() { driveTrain = <font color=#ff7700>true</font>; }</div>
<div class=CC1>  <font color=#ff7700>bool</font> driveTrainInstalled() { <font color=#ff7700>return</font> driveTrain; }</div>
<div class=CC1>  <font color=#ff7700>void</font> addWheels() { wheels = <font color=#ff7700>true</font>; }</div>
<div class=CC1>  <font color=#ff7700>bool</font> wheelsInstalled() { <font color=#ff7700>return</font> wheels; }</div>
<div class=CC1>  <font color=#ff7700>friend</font> ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os,
<font color=#ff7700>const</font> Car&amp; c) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Car &quot;</font> &lt;&lt; c.id
&lt;&lt; <font color=#007f00>&quot; [&quot;</font></div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot; engine: &quot;</font> &lt;&lt; c.engine</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot; driveTrain: &quot;</font> &lt;&lt;
c.driveTrain</div>
<div class=CC1>      &lt;&lt; <font color=#007f00>&quot; wheels: &quot;</font> &lt;&lt; c.wheels
&lt;&lt; <font color=#007f00>&quot; ]&quot;</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> CountedPtr&lt; TQueue&lt;Car&gt; &gt; CarQueue;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> ChassisBuilder : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CarQueue carQueue;</div>
<div class=CC1>  <font color=#ff7700>int</font> counter;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  ChassisBuilder(CarQueue&amp; cq) :
carQueue(cq),counter(0) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        Thread::sleep(1000);</div>
<div class=CC1>        <font color=#dd0000>// Make chassis:</font></div>
<div class=CC1>        Car c(counter++);</div>
<div class=CC1>        cout &lt;&lt; c &lt;&lt; endl;</div>
<div class=CC1>        <font color=#dd0000>// Insert into queue</font></div>
<div class=CC1>        carQueue-&gt;put(c);</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;ChassisBuilder off&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Cradle {</div>
<div class=CC1>  Car c; <font color=#dd0000>// Holds current car being worked on</font></div>
<div class=CC1>  <font color=#ff7700>bool</font> occupied;</div>
<div class=CC1>  Mutex workLock, readyLock;</div>
<div class=CC1>  Condition workCondition, readyCondition;</div>
<div class=CC1>  <font color=#ff7700>bool</font> engineBotHired, wheelBotHired,
driveTrainBotHired;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Cradle()</div>
<div class=CC1>  : workCondition(workLock), readyCondition(readyLock)
{</div>
<div class=CC1>    occupied = <font color=#ff7700>false</font>;</div>
<div class=CC1>    engineBotHired = <font color=#ff7700>true</font>;</div>
<div class=CC1>    wheelBotHired = <font color=#ff7700>true</font>;</div>
<div class=CC1>    driveTrainBotHired = <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> insertCar(Car chassis) {</div>
<div class=CC1>    c = chassis;</div>
<div class=CC1>    occupied = <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  Car getCar() { <font color=#dd0000>// Can only extract car once</font></div>
<div class=CC1>    <font color=#ff7700>if</font>(!occupied) {</div>
<div class=CC1>      cerr &lt;&lt; <font color=#007f00>&quot;No Car in Cradle for
getCar()&quot;</font> &lt;&lt; endl;</div>
<div class=CC1>      <font color=#ff7700>return</font> Car(); <font color=#dd0000>// &quot;Null&quot; Car object</font></div>
<div class=CC1>    }</div>
<div class=CC1>    occupied = <font color=#ff7700>false</font>;</div>
<div class=CC1>    <font color=#ff7700>return</font> c;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Access car while in cradle:</font></div>
<div class=CC1>  Car* <font color=#ff7700>operator</font>-&gt;() { <font color=#ff7700>return</font> &amp;c; }</div>
<div class=CC1>  <font color=#dd0000>// Allow robots to offer services to this cradle:</font></div>
<div class=CC1>  <font color=#ff7700>void</font> offerEngineBotServices() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(workLock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(engineBotHired)</div>
<div class=CC1>      workCondition.wait();</div>
<div class=CC1>    engineBotHired = <font color=#ff7700>true</font>; <font color=#dd0000>// Accept the job</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> offerWheelBotServices() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(workLock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(wheelBotHired)</div>
<div class=CC1>      workCondition.wait();</div>
<div class=CC1>    wheelBotHired = <font color=#ff7700>true</font>; <font color=#dd0000>// Accept the job</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> offerDriveTrainBotServices() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(workLock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(driveTrainBotHired)</div>
<div class=CC1>      workCondition.wait();</div>
<div class=CC1>    driveTrainBotHired = <font color=#ff7700>true</font>; <font color=#dd0000>// Accept the job</font></div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Tell waiting robots that work is ready:</font></div>
<div class=CC1>  <font color=#ff7700>void</font> startWork() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(workLock);</div>
<div class=CC1>    engineBotHired = <font color=#ff7700>false</font>;</div>
<div class=CC1>    wheelBotHired = <font color=#ff7700>false</font>;</div>
<div class=CC1>    driveTrainBotHired = <font color=#ff7700>false</font>;</div>
<div class=CC1>    workCondition.broadcast();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Each robot reports when their job is done:</font></div>
<div class=CC1>  <font color=#ff7700>void</font> taskFinished() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(readyLock);</div>
<div class=CC1>    readyCondition.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#dd0000>// Director waits until all jobs are done:</font></div>
<div class=CC1>  <font color=#ff7700>void</font> waitUntilWorkFinished() {</div>
<div class=CC1>    Guard&lt;Mutex&gt; g(readyLock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(!(c.engineInstalled() &amp;&amp;
c.driveTrainInstalled()</div>
<div class=CC1>            &amp;&amp; c.wheelsInstalled()))</div>
<div class=CC1>      readyCondition.wait();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>typedef</font> CountedPtr&lt;Cradle&gt; CradlePtr;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Director : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CarQueue chassisQueue, finishingQueue;</div>
<div class=CC1>  CradlePtr cradle;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Director(CarQueue&amp; cq, CarQueue&amp; fq,
CradlePtr cr)</div>
<div class=CC1>  : chassisQueue(cq), finishingQueue(fq), cradle(cr) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until chassis is available:</font></div>
<div class=CC1>        cradle-&gt;insertCar(chassisQueue-&gt;get());</div>
<div class=CC1>        <font color=#dd0000>// Notify robots car is ready for work</font></div>
<div class=CC1>        cradle-&gt;startWork();</div>
<div class=CC1>        <font color=#dd0000>// Wait until work completes</font></div>
<div class=CC1>        cradle-&gt;waitUntilWorkFinished();</div>
<div class=CC1>        <font color=#dd0000>// Put car into queue for further work</font></div>
<div class=CC1>        finishingQueue-&gt;put(cradle-&gt;getCar());</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Director off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> EngineRobot : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CradlePtr cradle;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  EngineRobot(CradlePtr cr) : cradle(cr) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until job is offered/accepted:</font></div>
<div class=CC1>        cradle-&gt;offerEngineBotServices();</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Installing engine&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>        (*cradle)-&gt;addEngine();</div>
<div class=CC1>        cradle-&gt;taskFinished();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;EngineRobot off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> DriveTrainRobot : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CradlePtr cradle;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  DriveTrainRobot(CradlePtr cr) : cradle(cr) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until job is offered/accepted:</font></div>
<div class=CC1>        cradle-&gt;offerDriveTrainBotServices();</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Installing DriveTrain&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>        (*cradle)-&gt;addDriveTrain();</div>
<div class=CC1>        cradle-&gt;taskFinished();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;DriveTrainRobot off&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> WheelRobot : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CradlePtr cradle;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  WheelRobot(CradlePtr cr) : cradle(cr) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        <font color=#dd0000>// Blocks until job is offered/accepted:</font></div>
<div class=CC1>        cradle-&gt;offerWheelBotServices();</div>
<div class=CC1>        cout &lt;&lt; <font color=#007f00>&quot;Installing Wheels&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>        (*cradle)-&gt;addWheels();</div>
<div class=CC1>        cradle-&gt;taskFinished();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;WheelRobot off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Reporter : <font color=#ff7700>public</font> Runnable {</div>
<div class=CC1>  CarQueue carQueue;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Reporter(CarQueue&amp; cq) : carQueue(cq) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!Thread::interrupted()) {</div>
<div class=CC1>        cout &lt;&lt; carQueue-&gt;get() &lt;&lt; endl;</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(Interrupted_Exception&amp;) { <font color=#7F7F7F>/* Exit */</font> }</div>
<div class=CC1>    cout &lt;&lt; <font color=#007f00>&quot;Reporter off&quot;</font> &lt;&lt;
endl;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main() {</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;Enter&gt; to quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    CarQueue chassisQueue(<font color=#ff7700>new</font> TQueue&lt;Car&gt;),</div>
<div class=CC1>             finishingQueue(<font color=#ff7700>new</font> TQueue&lt;Car&gt;);</div>
<div class=CC1>    CradlePtr cradle(<font color=#ff7700>new</font> Cradle);</div>
<div class=CC1>    ThreadedExecutor assemblyLine;</div>
<div class=CC1>    assemblyLine.execute(<font color=#ff7700>new</font> EngineRobot(cradle));</div>
<div class=CC1>    assemblyLine.execute(<font color=#ff7700>new</font> DriveTrainRobot(cradle));</div>
<div class=CC1>    assemblyLine.execute(<font color=#ff7700>new</font> WheelRobot(cradle));</div>
<div class=CC1>    assemblyLine.execute(</div>
<div class=CC1>      <font color=#ff7700>new</font> Director(chassisQueue, finishingQueue,
cradle));</div>
<div class=CC1>    assemblyLine.execute(<font color=#ff7700>new</font> Reporter(finishingQueue));</div>
<div class=CC1>    <font color=#dd0000>// Start everything running by producing chassis:</font></div>
<div class=CC1>    assemblyLine.execute(<font color=#ff7700>new</font>
ChassisBuilder(chassisQueue));</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    assemblyLine.interrupt();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>You’ll notice that <b>Car </b>takes a shortcut: it assumes
that <b>bool</b> operations are atomic, which, as previously discussed, is sometimes
a safe assumption but requires careful thought.<a href="#_ftn161" name="_ftnref161"><span
class=MsoFootnoteReference>[161]</span></a> Each <b>Car</b>
begins as an unadorned chassis, and different robots will attach different
parts to it, calling the appropriate “add” function when they do.</p>

<p class=MsoNormal>A <b>ChassisBuilder</b> simply creates a new <b>Car</b>
every second and places it into the <b>chassisQueue</b>. A <b>Director</b>
manages the build process by taking the next <b>Car</b> off the <b>chassisQueue</b>,
putting it into the <b>Cradle</b>, telling all the robots to <b>startWork(&nbsp;)</b>,
and suspending itself by calling <b>waitUntilWorkFinished(&nbsp;)</b>. When the
work is done, the <b>Director</b> takes the <b>Car</b> out of the <b>Cradle</b>
and puts in into the <b>finishingQueue</b>.</p>

<p class=MsoNormal>The <b>Cradle</b> is the crux of the signaling operations. A
<b>Mutex</b> and a <b>Condition</b> object control both the working of the
robots and indicate whether all the operations are finished. A particular type
of robot can offer its services to the <b>Cradle</b> by calling the “offer”
function appropriate to its type. At this point, that robot thread is suspended
until the <b>Director</b> calls <b>startWork(&nbsp;)</b>, which changes the
hiring flags and calls <b>broadcast(&nbsp;)</b> to tell all the robots to show
up for work. Although this system allows any number of robots to offer their
services, each one of those robots has its thread suspended by doing so. You
could imagine a more sophisticated system where the robots register themselves
with many different <b>Cradle</b>s without being suspended by that registration
process and then reside in a pool waiting for the first <b>Cradle</b> that
needs a task completed.</p>

<p class=MsoNormal>After each robot finishes its task (changing the state of
the <b>Car</b> in the process), it calls <b>taskFinished(&nbsp;)</b>, which
sends a <b>signal(&nbsp;)</b> to the <b>readyCondition</b>, which is what the <b>Director</b>
is waiting on in <b>waitUntilWorkFinished(&nbsp;)</b>. Each time the director
thread awakens, the state of the <b>Car</b> is checked, and if it still isn’t
finished, that thread is suspended again.</p>

<p class=MsoNormal>When the <b>Director </b>inserts a <b>Car</b> into the <b>Cradle</b>,
you can perform operations on that <b>Car</b> via the <b>operator-&gt;(&nbsp;)</b>.
To prevent multiple extractions of the same car, a flag causes an error report
to be generated. (Exceptions don’t propagate across threads in the ZThread
library.)</p>

<p class=MsoNormal>In <b>main(&nbsp;)</b>, all the necessary objects are
created and the tasks are initialized, with the <b>ChassisBuilder</b> begun
last to start the process. (However, because of the behavior of the <b>TQueue</b>,
it wouldn’t matter if it were started first.) Note that this program follows
all the guidelines regarding object and task lifetime presented in this
chapter, and so the shutdown process is safe.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef375545483" name="_Toc375545483">Deadlock</a></h2>

<p class=MsoNormal>Because threads can become blocked <i>and</i> because
objects can have mutexes that prevent threads from accessing that object until
the mutex is released, it’s possible for one thread to get stuck waiting for
another thread, which in turn waits for another thread, and so on, until the
chain leads back to a thread waiting on the first one. You get a continuous
loop of threads waiting on each other, and no one can move. This is called <i>deadlock</i>.</p>

<p class=MsoNormal>If you try running a program and it deadlocks right away,
you immediately know you have a problem, and you can track it down. The real
problem is when your program seems to be working fine but has the hidden
potential to deadlock. In this case, you may get no indication that deadlocking
is a possibility, so it will be latent in your program until it unexpectedly
happens to a customer. (And you probably won’t be able to easily reproduce it.)
Thus, preventing deadlock through careful program design is a critical part of
developing concurrent programs.</p>

<p class=MsoNormal>Let’s look at the classic demonstration of deadlock,
invented by Edsger Dijkstra: the <i>dining philosophers</i> problem. The basic description specifies five philosophers (but the example shown here
will allow any number). These philosophers spend part of their time thinking
and part of their time eating. While they are thinking, they don’t need any
shared resources, but they eat using a limited number of utensils. In the
original problem description, the utensils are forks, and two forks are
required to get spaghetti from a bowl in the middle of the table, but it seems
to make more sense to say that the utensils are chopsticks. Clearly, each
philosopher will require two chopsticks in order to eat.</p>

<p class=MsoNormal>A difficulty is introduced into the problem: as
philosophers, they have very little money, so they can only afford five
chopsticks. These are spaced around the table between them. When a philosopher
wants to eat, they must pick up the chopstick to the left and the one to the
right. If the philosopher on either side is using a desired chopstick, our
philosopher must wait until the necessary chopsticks become available.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:DiningPhilosophers.h</font></div>
<div class=CC1><font color=#dd0000>// Classes for Dining Philosophers.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DININGPHILOSOPHERS_H</font></div>
<div class=CC1><font color=#7F7F00>#define DININGPHILOSOPHERS_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Condition.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Guard.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Mutex.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/Thread.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Display.h&quot;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Chopstick {</div>
<div class=CC1>  ZThread::Mutex lock;</div>
<div class=CC1>  ZThread::Condition notTaken;</div>
<div class=CC1>  <font color=#ff7700>bool</font> taken;</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Chopstick() : notTaken(lock), taken(<font color=#ff7700>false</font>) {}</div>
<div class=CC1>  <font color=#ff7700>void</font> take() {</div>
<div class=CC1>    ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</div>
<div class=CC1>    <font color=#ff7700>while</font>(taken)</div>
<div class=CC1>      notTaken.wait();</div>
<div class=CC1>    taken = <font color=#ff7700>true</font>;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> drop() {</div>
<div class=CC1>    ZThread::Guard&lt;ZThread::Mutex&gt; g(lock);</div>
<div class=CC1>    taken = <font color=#ff7700>false</font>;</div>
<div class=CC1>    notTaken.signal();</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Philosopher : <font color=#ff7700>public</font> ZThread::Runnable {</div>
<div class=CC1>  Chopstick&amp; left;</div>
<div class=CC1>  Chopstick&amp; right;</div>
<div class=CC1>  <font color=#ff7700>int</font> id;</div>
<div class=CC1>  <font color=#ff7700>int</font> ponderFactor;</div>
<div class=CC1>  ZThread::CountedPtr&lt;Display&gt; display;</div>
<div class=CC1>  <font color=#ff7700>int</font> randSleepTime() {</div>
<div class=CC1>    <font color=#ff7700>if</font>(ponderFactor == 0) <font color=#ff7700>return</font> 0;</div>
<div class=CC1>    <font color=#ff7700>return</font> rand()/(RAND_MAX/ponderFactor) * 250;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>void</font> output(std::string s) {</div>
<div class=CC1>    std::ostringstream os;</div>
<div class=CC1>    os &lt;&lt; *<font color=#ff7700>this</font> &lt;&lt; <font color=#007f00>&quot; &quot;</font> &lt;&lt; s
&lt;&lt; std::endl;</div>
<div class=CC1>    display-&gt;output(os);</div>
<div class=CC1>  }</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  Philosopher(Chopstick&amp; l, Chopstick&amp; r,</div>
<div class=CC1>  ZThread::CountedPtr&lt;Display&gt;&amp; disp, <font color=#ff7700>int</font>
ident,int ponder)</div>
<div class=CC1>  : left(l), right(r), id(ident), ponderFactor(ponder),</div>
<div class=CC1>    display(disp) {}</div>
<div class=CC1>  <font color=#ff7700>virtual</font> <font color=#ff7700>void</font> run() {</div>
<div class=CC1>    <font color=#ff7700>try</font> {</div>
<div class=CC1>      <font color=#ff7700>while</font>(!ZThread::Thread::interrupted()) {</div>
<div class=CC1>        output(<font color=#007f00>&quot;thinking&quot;</font>);</div>
<div class=CC1>        ZThread::Thread::sleep(randSleepTime());</div>
<div class=CC1>        <font color=#dd0000>// Hungry</font></div>
<div class=CC1>        output(<font color=#007f00>&quot;grabbing right&quot;</font>);</div>
<div class=CC1>        right.take();</div>
<div class=CC1>        output(<font color=#007f00>&quot;grabbing left&quot;</font>);</div>
<div class=CC1>        left.take();</div>
<div class=CC1>        output(<font color=#007f00>&quot;eating&quot;</font>);</div>
<div class=CC1>        ZThread::Thread::sleep(randSleepTime());</div>
<div class=CC1>        right.drop();</div>
<div class=CC1>        left.drop();</div>
<div class=CC1>      }</div>
<div class=CC1>    } <font color=#ff7700>catch</font>(ZThread::Synchronization_Exception&amp; e)
{</div>
<div class=CC1>      output(e.what());</div>
<div class=CC1>    }</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp;</div>
<div class=CC1>  <font color=#ff7700>operator</font>&lt;&lt;(std::ostream&amp; os, <font color=#ff7700>const</font>
Philosopher&amp; p) {</div>
<div class=CC1>    <font color=#ff7700>return</font> os &lt;&lt; <font color=#007f00>&quot;Philosopher &quot;</font> &lt;&lt;
p.id;</div>
<div class=CC1>  }</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DININGPHILOSOPHERS_H
///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>No two <b>Philosopher</b>s can <b>take(&nbsp;)</b> a <b>Chopstick</b>
at the same time, since <b>take(&nbsp;)</b> is synchronized with a <b>Mutex</b>.
In addition, if the chopstick has already been taken by one <b>Philosopher</b>,
another can <b>wait(&nbsp;)</b> on the <b>available Condition</b> until the <b>Chopstick</b>
becomes available when the current holder calls <b>drop(&nbsp;)</b> (which must
also be synchronized to prevent race conditions and ensure memory visibility in
multiprocessor systems).</p>

<p class=MsoNormal>Each <b>Philosopher</b> holds references to their left and
right <b>Chopstick</b> so they can attempt to pick those up. The goal of the <b>Philosopher</b>
is to think part of the time and eat part of the time, and this is expressed in
<b>main(&nbsp;)</b>. However, you will observe that if the <b>Philosopher</b>s
spend very little time thinking, they will all be competing for the <b>Chopstick</b>s
while they try to eat, and deadlock will happen much more quickly. So you can
experiment with this, the <b>ponderFactor</b> weights the length of time that a
<b>Philosopher</b> tends to spend thinking and eating. A smaller <b>ponderFactor</b>
will increase the probability of deadlock.</p>

<p class=MsoNormal>In <b>Philosopher::run(&nbsp;)</b>, each <b>Philosopher</b>
just thinks and eats continuously. You see the <b>Philosopher</b> thinking for
a randomized amount of time, then trying to <b>take(&nbsp;)</b> the <b>right</b>
and then the <b>left</b> <b>Chopstick</b>, eating for a randomized amount of
time, and then doing it again. Output to the console is synchronized as seen
earlier in this chapter.</p>

<p class=MsoNormal>This problem is interesting because it demonstrates that a
program can appear to run correctly but actually be deadlock prone. To show
this, the command-line argument adjusts a factor to affect the amount of time
each philosopher spends thinking. If you have lots of philosophers or they
spend a lot of time thinking, you may never see the deadlock even though it
remains a possibility. A command-line argument of zero tends to make it
deadlock fairly quickly:<a href="#_ftn162" name="_ftnref162"><span
class=MsoFootnoteReference>[162]</span></a></p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:DeadlockingDiningPhilosophers.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Dining Philosophers with Deadlock.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DiningPhilosophers.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  <font color=#ff7700>int</font> ponder = argc &gt; 1 ? atoi(argv[1]) : 5;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;ENTER&gt; to quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>enum</font> { SZ = 5 };</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    CountedPtr&lt;Display&gt; d(<font color=#ff7700>new</font> Display);</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    Chopstick c[SZ];</div>
<div class=CC1>    <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++) {</span></div>
<div class=CC1><span lang=SV>      </span>executor.execute(</div>
<div class=CC1>        <font color=#ff7700>new</font> Philosopher(c[i], c[(i+1) % SZ], d,
i,ponder));</div>
<div class=CC1>    }</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    executor.interrupt();</div>
<div class=CC1>    executor.wait();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>Note that the <b>Chopstick </b>objects do not need internal
identifiers; they are identified by their position in the array <b>c</b>.<b> </b>Each
<b>Philosopher</b> is given a reference to a left and right <b>Chopstick</b>
object when constructed; these are the utensils that must be picked up before
that <b>Philosopher</b> can eat. Every <b>Philosopher</b> except the last one
is initialized by situating that <b>Philosopher</b> between the next pair of <b>Chopstick</b>
objects. The last <b>Philosopher</b> is given the zeroth <b>Chopstick</b> for
its right <b>Chopstick</b>, so the round table is completed. That’s because the
last <b>Philosopher</b> is sitting right next to the first one, and they both
share that zeroth chopstick. With this arrangement, it’s possible at some point
for all the philosophers to be trying to eat and waiting on the philosopher
next to them to put down their chopstick, and the program will deadlock.</p>

<p class=MsoNormal>If your threads (philosophers) are spending more time on
other tasks (thinking) than eating, then they have a much lower probability of
requiring the shared resources (chopsticks), and thus you can convince yourself
that the program is deadlock free (using a nonzero <b>ponder</b> value), even
though it isn’t.</p>

<p class=MsoNormal>To repair the problem, you must understand that deadlock can occur if four conditions are simultaneously met:</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;Mutual exclusion. At least one resource used by the threads must not be
shareable. In this case, a chopstick can be used by only one philosopher at a
time.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;At least one process must be holding a resource and waiting to acquire a
resource currently held by another process. That is, for deadlock to occur, a
philosopher must be holding one chopstick and waiting for another one.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'>3.&nbsp;&nbsp;A resource cannot be preemptively taken away from a process. Processes
only release resources as a normal event. Our philosophers are polite and they
don’t grab chopsticks from other philosophers.</p>

<p class=MsoNormal style='margin-top:0in;margin-right:0in;margin-bottom:9.0pt;
margin-left:.75in;text-indent:-.25in'>4.&nbsp;&nbsp;A circular wait can happen, whereby a process waits on a resource held
by another process, which in turn is waiting on a resource held by another
process, and so on, until one of the processes is waiting on a resource held by
the first process, thus gridlocking everything. In <b>DeadlockingDiningPhilosophers.cpp</b>,
the circular wait happens because each philosopher tries to get the right
chopstick first and then the left.</p>

<p class=MsoNormal>Because all these conditions must be met to cause deadlock,
you need to stop only one of them from occurring to prevent deadlock. In this
program, the easiest way to prevent deadlock is to break condition four. This
condition happens because each philosopher is trying to pick up their
chopsticks in a particular sequence: first right, then left. Because of that,
it’s possible to get into a situation where each of them is holding their right
chopstick and waiting to get the left, causing the circular wait condition.
However, if the last philosopher is initialized to try to get the left
chopstick first and then the right, that philosopher will never prevent the
philosopher on the immediate right from picking up their left chopstick. In
this case, the circular wait is prevented. This is only one solution to the
problem, but you could also solve it by preventing one of the other conditions
(see advanced threading books for more details):</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C11:FixedDiningPhilosophers.cpp {RunByHand}</font></div>
<div class=CC1><font color=#dd0000>// Dining Philosophers without Deadlock.</font></div>
<div class=CC1><font color=#dd0000>//{L} ZThread</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;DiningPhilosophers.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;zthread/ThreadedExecutor.h&quot;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> ZThread;</div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> main(<font color=#ff7700>int</font> argc, <font color=#ff7700>char</font>* argv[]) {</div>
<div class=CC1>  srand(time(0)); <font color=#dd0000>// Seed the random number generator</font></div>
<div class=CC1>  <font color=#ff7700>int</font> ponder = argc &gt; 1 ? atoi(argv[1]) : 5;</div>
<div class=CC1>  cout &lt;&lt; <font color=#007f00>&quot;Press &lt;ENTER&gt; to quit&quot;</font>
&lt;&lt; endl;</div>
<div class=CC1>  <font color=#ff7700>enum</font> { SZ = 5 };</div>
<div class=CC1>  <font color=#ff7700>try</font> {</div>
<div class=CC1>    CountedPtr&lt;Display&gt; d(<font color=#ff7700>new</font> Display);</div>
<div class=CC1>    ThreadedExecutor executor;</div>
<div class=CC1>    Chopstick c[SZ];</div>
<div class=CC1>    <span lang=SV><font color=#ff7700>for</font>(<font color=#ff7700>int</font> i = 0; i &lt; SZ; i++) {</span></div>
<div class=CC1><span lang=SV>      </span><font color=#ff7700>if</font>(i &lt; (SZ-1))</div>
<div class=CC1>        executor.execute(</div>
<div class=CC1>          <font color=#ff7700>new</font> Philosopher(c[i], c[i + 1], d, i,
ponder));</div>
<div class=CC1>      <font color=#ff7700>else</font></div>
<div class=CC1>        executor.execute(</div>
<div class=CC1>          <font color=#ff7700>new</font> Philosopher(c[0], c[i], d, i, ponder));</div>
<div class=CC1>    }</div>
<div class=CC1>    cin.get();</div>
<div class=CC1>    executor.interrupt();</div>
<div class=CC1>    executor.wait();</div>
<div class=CC1>  } <font color=#ff7700>catch</font>(Synchronization_Exception&amp; e) {</div>
<div class=CC1>    cerr &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class=CC1>  }</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>By ensuring that the last philosopher picks up and puts down
their left chopstick before their right, the deadlock is removed, and the
program will run smoothly.</p>

<p class=MsoNormal>There is no language support to help prevent deadlock; it’s
up to you to avoid it by careful design. These are not comforting words to the
person who’s trying to debug a deadlocking program.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef375545489" name="_Toc375545489">Summary</a></h2>

<p class=MsoNormal>The goal of this chapter was to give you the foundations of
concurrent programming with threads:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>1.&nbsp;&nbsp;You
can run multiple independent tasks.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>2.&nbsp;&nbsp;You
must consider all the possible problems when these tasks shut down. Objects or
other tasks may disappear before tasks are finished with them.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>3.&nbsp;&nbsp;Tasks
can collide with each other over shared resources. The mutex is the basic tool
used to prevent these collisions.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'>4.&nbsp;&nbsp;Tasks
can deadlock if they are not carefully designed.</p>

<p class=MsoNormal>However, there are multiple additional facets of threading
and tools to help you solve threading problems. The ZThreads library contains a
number of these tools, such as <i>semaphores</i> and special types of queues,
similar to the one you saw in this chapter. Explore that library as well as
other resources on threading to gain more in-depth knowledge.</p>

<p class=MsoNormal>It is vital to learn when to use concurrency and when to avoid it. The main reasons to use it are:</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>To manage a number of tasks whose intermingling use the computer
more efficiently (including the ability to transparently distribute the tasks
across multiple CPUs).</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>To allow better code organization.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>To be more convenient for the user.</p>

<p class=MsoNormal>The classic example of resource balancing is to use the CPU
during I/O waits. The classic example of user convenience is to monitor a
“stop” button during long downloads.</p>

<p class=MsoNormal>An additional advantage to threads is that they provide
“light” execution context switches (on the order of 100 instructions) rather
than “heavy” process context switches (thousands of instructions). Since all
threads in a given process share the same memory space, a light context switch
changes only program execution and local variables. A process change—the heavy
context switch—must exchange the full memory space.</p>

<p class=MsoNormal>The main drawbacks to multithreading are: </p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Slowdown occurs while waiting for shared resources.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Additional CPU overhead is required to manage threads.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Unrewarded complexity arises from poor design decisions.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Opportunities are created for pathologies such as starving,
racing, deadlock, and livelock.</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Inconsistencies occur across platforms. When developing the
original material (in Java) for this chapter, we discovered race conditions
that quickly appeared on some computers but wouldn’t appear on others. The C++
examples in this chapter behaved differently (but usually acceptably) under
different operating systems. If you develop a program on a computer and things
seem to work right, you might get an unwelcome surprise when you distribute it.</p>

<p class=MsoNormal>One of the biggest difficulties with threads occurs because
more than one thread might be sharing a resource—such as the memory in an
object—and you must make sure that multiple threads don’t try to read and
change that resource at the same time. This requires judicious use of
synchronization tools, which must be thoroughly understood because they can
quietly introduce deadlock situations.</p>

<p class=MsoNormal>In addition, there’s a certain art to the application of
threads. C++ is designed to allow you to create as many objects as you need to
solve your problem—at least in theory. (Creating millions of objects for an
engineering finite-element analysis, for example, might not be practical.) However,
there is usually an upper bound to the number of threads you’ll want to create,
because at some number, threads may become balky. This critical point can be
difficult to detect and will often depend on the OS and thread library; it
could be fewer than a hundred or in the thousands. As you often create only a
handful of threads to solve a problem, this is typically not much of a limit;
but in a more general design it becomes a constraint.</p>

<p class=MsoNormal>Regardless of how simple threading can seem using a
particular language or library, consider it a black art. There’s always
something you haven’t considered that can bite you when you least expect it.
(For example, note that because the dining philosophers problem can be adjusted
so that deadlock rarely happens, you can get the impression that everything is
OK.) An appropriate quote comes from Guido van Rossum, creator of the Python
programming language:</p>

<p class=MsoNormal style='margin-left:.5in'><i>In any project that is multithreaded,
most bugs will come from threading issues. This is regardless of programming
language—it’s a deep, as yet un-understood property of threads.</i></p>

<p class=MsoNormal>For more advanced discussions of threading, see <i>Parallel
and Distributed Programming Using C++, </i>by Cameron Hughes and Tracey Hughes,
Addison Wesley 2004.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef375545490" name="_Toc375545490">Exercises</a></h2>

<p class=MsoNormal style='line-height:10.0pt'><span style='font-size:8.0pt'>Solutions
to selected exercises can be found in the electronic document <i>The Thinking
in C++ Volume 2 Annotated Solution Guide</i>, available for a small fee from <i>www.MindView.net</i>.</span></p>

<p class=ExercisesCharCharCharCharChar>1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Inherit a class from <b>Runnable</b> and override the <b>run(&nbsp;)</b>
function. Inside <b>run(&nbsp;)</b>, print a message, and then call <b>sleep(&nbsp;)</b>.
Repeat this three times, and then return from <b>run(&nbsp;)</b>. Put a
start-up message in the constructor and a shut-down message when the task
terminates. Make several thread objects of this type, and run them to see what
happens.</p>

<p class=ExercisesCharCharCharCharChar>2. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>BasicThreads.cpp</b> to make <b>LiftOff</b> threads
start other <b>LiftOff</b> threads.</p>

<p class=ExercisesCharCharCharCharChar>3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>ResponsiveUI.cpp</b> to eliminate any possible race
conditions. (Assume <b>bool</b> operations are not atomic.)</p>

<p class=ExercisesCharCharCharCharChar>4. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>In <b>Incrementer.cpp</b>, modify the <b>Count</b> class to use a
single <b>int</b> instead of an array of <b>int</b>. Explain the resulting
behavior.</p>

<p class=ExercisesCharCharCharCharChar>5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>In <b>EvenChecker.h</b>, correct the potential problem in the <b>Generator</b>
class. (Assume <b>bool</b> operations are not atomic.)</p>

<p class=ExercisesCharCharCharCharChar>6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>EvenGenerator.cpp</b> to use <b>interrupt(&nbsp;)</b>
instead of quit flags.</p>

<p class=ExercisesCharCharCharCharChar>7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>In <b>MutexEvenGenerator.cpp</b>, change the code in <b>MutexEvenGenerator::nextValue(&nbsp;)</b>
so that the return expression precedes the <b>release(&nbsp;)</b> statement and
explain what happens.</p>

<p class=ExercisesCharCharCharCharChar>8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>ResponsiveUI.cpp</b> to use <b>interrupt(&nbsp;)</b>
instead of the <b>quitFlag</b> approach.</p>

<p class=ExercisesCharCharCharCharChar>9. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Look up the <b>Singleton </b>documentation in the ZThreads
library. Modify <b>OrnamentalGarden.cpp</b> so that the <b>Display</b> object
is controlled by a <b>Singleton</b> to prevent more than one <b>Display</b>
from being accidentally created.</p>

<p class=ExercisesCharCharCharCharChar>10. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>In <b>OrnamentalGarden.cpp</b>, change the <b>Count::increment(&nbsp;)</b>
function so that it does a direct increment of <b>count</b> (that is, it just
does a <b>count++</b>). Now remove the guard and see if that causes a failure.
Is this safe and reliable?</p>

<p class=ExercisesCharCharCharCharChar>11. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>OrnamentalGarden.cpp</b> so that it uses <b>interrupt(&nbsp;)</b>
instead of the <b>pause(&nbsp;)</b> mechanism. Make sure that your solution
doesn’t prematurely destroy objects.</p>

<p class=ExercisesCharCharCharCharChar>12. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>WaxOMatic.cpp</b> by adding more instances of the <b>Process</b>
class so that it applies and polishes three coats of wax instead of just one.</p>

<p class=ExercisesCharCharCharCharChar>13. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create two <b>Runnable</b> subclasses, one with a <b>run(&nbsp;)</b>
that starts and calls <b>wait(&nbsp;)</b>. The other class’s <b>run(&nbsp;)</b>
should capture the reference of the first <b>Runnable </b>object. Its <b>run(&nbsp;)
</b>should call <b>signal(&nbsp;)</b> for the first thread after some number of
seconds have passed so that first thread can print a message.</p>

<p class=ExercisesCharCharCharCharChar>14. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create an example of a “busy wait.” One thread sleeps for awhile
and then sets a flag to <b>true</b>. The second thread watches that flag inside
a <b>while</b> loop (this is the “busy wait”) and, when the flag becomes <b>true</b>,
sets it back to <b>false</b> and reports the change to the console. Note how
much wasted time the program spends inside the “busy wait,” and create a second
version of the program that uses <b>wait(&nbsp;)</b> instead of the “busy
wait.” Extra: run a profiler to show the time used by the CPU in each case.</p>

<p class=ExercisesCharCharCharCharChar>15. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>TQueue.h</b> to add a maximum allowable element count.
If the count is reached, further writes should be blocked until the count drops
below the maximum. Write code to test this behavior.</p>

<p class=ExercisesCharCharCharCharChar>16. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>ToastOMaticMarkII.cpp</b> to create peanut-butter and
jelly on toast sandwiches using two separate assembly lines and an output <b>TQueue</b>
for the finished sandwiches. Use a <b>Reporter</b> object as in <b>CarBuilder.cpp</b>
to display the results.</p>

<p class=ExercisesCharCharCharCharChar>17. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Rewrite <b>C07:BankTeller.cpp</b> to use real threading instead
of simulated threading.</p>

<p class=ExercisesCharCharCharCharChar>18. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>CarBuilder.cpp</b> to give identifiers to the robots,
and add more instances of the different kinds of robots. Note whether all
robots get utilized.</p>

<p class=ExercisesCharCharCharCharChar>19. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>CarBuilder.cpp</b> to add another stage to the
car-building process, whereby you add the exhaust system, body, and fenders. As
with the first stage, assume these processes can be performed simultaneously by
robots.</p>

<p class=ExercisesCharCharCharCharChar>20. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Modify <b>CarBuilder.cpp</b> so that <b>Car</b> has synchronized
access to all the <b>bool</b> variables. Because <b>Mutex</b>es cannot be
copied, this will require significant changes throughout the program.</p>

<p class=ExercisesCharCharCharCharChar>21. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Using the approach in <b>CarBuilder.cpp</b>, model the
house-building story that was given in this chapter.</p>

<p class=ExercisesCharCharCharCharChar>22. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Create a <b>Timer</b> class with two options: (1) a one-shot
timer that only goes off once (2) a timer that goes off at regular intervals.
Use this class with <b>C10:MulticastCommand.cpp</b> to move the calls to <b>TaskRunner::run(&nbsp;)</b>
from the procedures into the timer.</p>

<p class=ExercisesCharCharCharCharChar>23. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Change both of the dining philosophers examples so that the
number of <b>Philosopher</b>s is controlled on the command line, in addition to
the ponder time. Try different values and explain the results.</p>

<p class=ExercisesCharCharCharCharChar>24. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>Change <b>DiningPhilosophers.cpp</b> so that the <b>Philosopher</b>s
just pick the next available chopstick. (When a <b>Philosopher</b> is done with
their chopsticks, they drop them into a bin. When a <b>Philosopher</b> wants to
eat, they take the next two available chopsticks from the bin.) Does this
eliminate the possibility of deadlock? Can you reintroduce deadlock by simply
reducing the number of available chopsticks?</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section22>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985892" name="_Toc53985892">A: Recommended Reading</a></h1>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985893" name="_Toc53985893">General
C++</a></h2>

<p class=MsoNormal><b>The C++ Programming Language, 3<sup>rd</sup> edition</b>,
by Bjarne Stroustrup (Addison Wesley 1997). To some degree, the goal of the
book that you’re currently holding is to allow you to use Bjarne’s book as a
reference. Since his book contains the description of the language by the
author of that language, it’s typically the place where you’ll go to resolve
any uncertainties about what C++ is or isn’t supposed to do. When you get the
knack of the language and are ready to get serious, you’ll need it.</p>

<p class=MsoNormal><b>C++ Primer, 3<sup>rd</sup> Edition</b>, by Stanley
Lippman and Josee Lajoie (Addison Wesley 1998). Not that much of a primer
anymore; it’s evolved into a thick book filled with lots of detail, and the one
that I reach for along with Stroustrup’s when trying to resolve an issue. <i>Thinking
in C++</i> should provide a basis for understanding the <i>C++ Primer </i>as
well as Stroustrup’s book.</p>

<p class=MsoNormal><b>Accelerated C++</b>, by Andrew Koenig and Barbara Moo (Addison
Wesley, 2000). Takes you through C++ by programming topic instead of language
feature. Excellent introductory book.</p>

<p class=MsoNormal><b>The C++ Standard Library</b>, by Nicolai Josuttis (Addison
Wesley, 1999).<br>
Readable tutorial and reference for the entire C++ library, including STL.
Assumes familiarity with language concepts.</p>

<p class=MsoNormal><b>STL Tutorial and Reference Guide, 2nd Edition</b>, by
David R. Musser et al (Addison Wesley, 2001). Gentle but thorough introduction
to the concepts underlying STL. Contains an STL reference manual.</p>

<p class=MsoNormal> <b>The C++ ANSI/ISO Standard</b>. This is <i>not</i> free,
unfortunately (I certainly didn’t get paid for my time and effort on the
Standards Committee—in fact, it cost me a lot of money). But at least you can
buy the electronic form in PDF for only $18 at http://www.ncits.org/cplusplus.htm.</p>

<h3><a href="#_TocRef53985894" name="_Toc53985894">Bruce’s books</a></h3>

<p class=MsoNormal>Listed in order of publication. Not all these are currently
available.</p>

<p class=MsoNormal><b>Computer Interfacing with Pascal &amp; C</b>,<b> </b>(Self-published
via the Eisys imprint, 1988. Only available via <i>www.MindView.net</i>). An
introduction to electronics from back when CP/M was still king and DOS was an
upstart. I used high-level languages and often the parallel port of the
computer to drive various electronic projects. Adapted from my columns in the
first and best magazine I wrote for, <i>Micro Cornucopia. </i>(To paraphrase
Larry O’Brien, long-time editor of <i>Software Development Magazine</i>: The
best computer magazine ever published—they even had plans for building a robot
in a flower pot!) Alas, Micro C became lost long before the Internet appeared.
Creating this book was an extremely satisfying publishing experience.</p>

<p class=MsoNormal><b>Using C++</b>,<b> </b>(Osborne/McGraw-Hill, 1989).
One of the first books out on C++. This is out of print and replaced by its
second edition, the renamed <i>C++ Inside &amp; Out</i>.</p>

<p class=MsoNormal><b>C++ Inside &amp; Out</b>,<b> </b>(Osborne/McGraw-Hill,
1993). As noted, this is actually the second edition of <b>Using C++</b>. The
C++ in this book is reasonably accurate, but it’s circa 1992 and <i>Thinking in
C++</i> is intended to replace it. You can find out more about this book and
download the source code at <i>www.MindView.net</i>.</p>

<p class=MsoNormal><b>Thinking in C++, 1<sup>st</sup> Edition</b>,
(Prentice Hall, 1995). Winner of the <i>Software Development Magazine Jolt
Award</i> for best book of 1995.</p>

<p class=MsoNormal><b>Thinking in C++, 2<sup>nd</sup> Edition, Volume 1</b>,
(Prentice Hall, 2000). Downloadable from <i>www.MindView.net</i>.</p>

<p class=MsoNormal><b>Black Belt C++: the Master’s Collection</b>, Bruce
Eckel, editor (M&amp;T Books, 1994). Out of print (often available through
out-of-print services on the Web). A collection of chapters by various C++
luminaries based on their presentations in the C++ track at the Software
Development Conference, which I chaired. The cover on this book stimulated me
to gain control over all future cover designs.</p>

<p class=MsoNormal><b>Thinking in Java, 1<sup>st</sup> Edition</b>,
(Prentice Hall, 1998). The first edition of this book won the <i>Software
Development Magazine </i><i>Productivity Award</i>, the <i>Java Developer’s
Journal </i>Editor’s Choice Award, and the <i>JavaWorld Reader’s Choice Award
for best book</i>. On the CD ROM in the back of this book, and downloadable
from <i>www.MindView.net</i>.</p>

<p class=MsoNormal><b>Thinking in Java, 2<sup>nd</sup> Edition</b>,
(Prentice Hall, 2000). This edition won the <i>JavaWorld Editor’s Choice Award
for best book</i>. On the CD ROM in the back of this book, and downloadable
from <i>www.MindView.net</i>.</p>

<p class=MsoNormal><b>Thinking in Java, 3<sup>rd</sup> Edition</b>,
(Prentice Hall, 2002). This edition won the <i>Software Development Magazine
Jolt Award</i> for best book of 2002, and the <i>Java Developer’s Journal </i>Editor’s
Choice Award. The new CD ROM in the back of this book now includes the first
seven lectures from the 2<sup>nd</sup> edition of the <i>Hands-On Java CD ROM</i>.</p>

<p class=MsoNormal><b>The Hands-On Java CD ROM</b>, 3<sup>rd</sup>
edition (MindView, 2004). Over 15 hours of Bruce’s lectures and slides covering
the basics of the Java language, based on <i>Thinking in Java, 3<sup>rd</sup>
Edition</i>. Available only at www.MindView.net.</p>

<h3><a href="#_TocRef53985895" name="_Toc53985895">Chuck’s books</a></h3>

<p class=MsoNormal><b>C &amp; C++ Code Capsules</b>, by Chuck Allison
(Prentice-Hall, 1998). An in-the-trenches guide for practical C and C++
programming. Thoroughly covers the 1998 ISO C++ standard, especially library
features, and serves as a bridge to more advanced topics. Based on Chuck’s
well-known column in the C/C++ Users Journal.</p>

<p class=MsoNormal><b>Thinking in C: Foundations for Java &amp; C++</b>, by
Chuck Allison (<i>not a book</i>, but a MindView, Inc. Seminar on CD ROM, 1999,
bundled with <i>Thinking in Java</i> and <i>Thinking in C++, Volume 1</i>). A
multimedia course including lectures and slides in the foundations of the C
Language, to prepare you to learn Java or C++. This is not an exhaustive course
in C; only the necessities for moving on to the other languages are included.
An extra section covering features for the C++ programmer is included.
Prerequisite: experience with a high-level programming language, such as Pascal,
BASIC, FORTRAN, or LISP.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985896" name="_Toc53985896">In–depth
C++</a></h2>

<p class=MsoNormal>Books that go more deeply into topics of the language, and
help you avoid the typical pitfalls inherent in developing C++ programs.</p>

<p class=MsoNormal><b>Large-Scale C++ Software Design</b>, by John Lakos (Addison
Wesley, 1996). Motivates and presents in-the-trenches techniques for large C++
projects.</p>

<p class=MsoNormal><b>Effective C++, 2nd Edition</b>, by Scott Meyers (Addison Wesley,
1997).<br>
Classic book of techniques to improve C++ designs. Codifies many of the things
that programmers have to learn the hard way.</p>

<p class=MsoNormal><b>More Effective C++</b>, by Scott Meyers (Addison Wesley,
1995)<br>
Continuation of <i>Effective C++</i> (above). Another C++ classic.</p>

<p class=MsoNormal><b>Effective STL</b>, by Scott Meyers (Addison Wesley, 2001).
Extremely practical, in-depth coverage of how to use the STL. Contains expert
advice found nowhere else.</p>

<p class=MsoNormal><b>Generic Programming and the STL</b>, by Matt Austern (Addison
Wesley, 1998). Explores the conceptual underpinnings of the design of the STL.
Heavy on theory, but imparts a visionary look into the design of generic
libraries.</p>

<p class=MsoNormal><b>Exceptional C++</b>, by Herb Sutter (Addison Wesley, 2000).
Leads the reader through a progression of problems and their solution. Gives
easy-to-remember advice for solid design of modern C++ programs.</p>

<p class=MsoNormal><b>More Exceptional C++</b>, by Herb Sutter (Addison Wesley,
2001).<br>
Continuation of <i>Exceptional C++</i> (above).</p>

<p class=MsoNormal><b>C++ FAQs, 2nd Edition</b>, by Marshall Cline, Greg Lomow,
and Mike Girou<br>
(Addison Wesley, 1998). Nicely-structured compendium of common C++ questions
and their answers. Covers a broad range of topics, from beginner to advanced.</p>

<p class=MsoNormal><b>C++ Gotchas</b>, by Stephen Dewhurst (Addison Wesley,
2002). Contemporary catalog of easy-to-discover but hard-to-remedy C++ quirks
by a widely-renowned recognized C++ expert.</p>

<p class=MsoNormal><b>C++ Templates, The Complete Guide</b>, by Daveed Vandevoorde
and Nicolai M. Josuttis (Addison Wesley, 2002). The first and only book devoted
completely to templates. The definitive reference.</p>

<p class=MsoNormal><b>Standard C++ iostreams and Locales</b>, by<b> </b>Angelika Langer and Klaus Kreft (Addison Wesley, 2000). The most in-depth coverage
of iostreams available. Plumbs the depths of streams implementation and
idiomatic use. A handy reference as well as tutorial.</p>

<p class=MsoNormal><b>Design &amp; Evolution of C++</b>, by Bjarne Stroustrup (Addison
Wesley, 1994). Traces the complete history of C++, documenting the design
decisions that were made along the way. If you want to know why C++ is the way
it is, this is the book with the answers, written by the designer of the
language.</p>

<p class=MsoNormal><b>Modern C++ Design</b>, by Andrei Alexandrescu (Addison Wesley,
2001). The standard text on policy-based design in C++. Filled with practical,
advanced uses of templates.</p>

<p class=MsoNormal><b>Parallel and Distributed Programming Using C++</b>,
Cameron Hughes and Tracey Hughes (Addison Wesley, 2004). Thorough and readable
coverage of all aspects of concurrency, including basic concepts, threads, and
multi-processing. For beginners and experts alike.</p>

<p class=MsoNormal><b>Generative Programming</b>, by Krzysztof Czarnecki and
Ulrich Eisencecker, (Addison Wesley, 2000). Ground-breaking book on
highly-advanced C++ techniques. Takes software automation to the next level.</p>

<p class=MsoNormal><b>Multi-Paradigm Design for C++</b>, by James O. Coplien (Addison
Wesley, 1998). Advanced text showing how to harmonize the use of procedural,
object-oriented, and generic programming for effective C++ designs.</p>

<h2 style='margin-left:-.1in !msorm;margin-left:0in'><a href="#_TocRef53985897" name="_Toc53985897">Design
Patterns</a></h2>

<p class=MsoNormal><b>Design Patterns</b>, by Erich Gamma et. al. (Addison Wesley,
1995).<br>
The revolutionary book that introduced design patterns to the industry.
Catalogs a selection of design patterns with motivation and examples (using C++
and a little SmallTalk).</p>

<p class=MsoNormal><b>Pattern-Oriented System Architecture, Volume 1: A System
of Patterns</b>, by Frank Buschmann et al (John Wiley &amp; Son, 1996).<br>
Another look at design patterns in practice. Introduces new design patterns.</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section23>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985898" name="_Toc53985898">B: Etc</a></h1>

<p class=Intro style='margin-left:.25in'>This appendix contains files that are required to build the examples
in Volume 2.</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: :require.h</font></div>
<div class=CC1><font color=#dd0000>// Test for error conditions in programs.</font></div>
<div class=CC1><font color=#7F7F00>#ifndef REQUIRE_H</font></div>
<div class=CC1><font color=#7F7F00>#define REQUIRE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdio&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;fstream&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> <font color=#ff7700>void</font> require(<font color=#ff7700>bool</font> requirement,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg = <font color=#007f00>&quot;Requirement failed&quot;</font>) {</div>
<div class=CC1>  <font color=#dd0000>// Local &quot;using namespace std&quot; for old
compilers:</font></div>
<div class=CC1>  <font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>  <font color=#ff7700>if</font>(!requirement) {</div>
<div class=CC1>    <span lang=SV>fputs(msg, stderr);</span></div>
<div class=CC1><span lang=SV>    fputs(<font color=#007f00>&quot;\n&quot;</font>, stderr);</span></div>
<div class=CC1><span lang=SV>    </span>exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> <font color=#ff7700>void</font> requireArgs(<font color=#ff7700>int</font> argc, <font color=#ff7700>int</font> args,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg = <font color=#007f00>&quot;Must use %d arguments&quot;</font>)
{</div>
<div class=CC1>  <font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc != args + 1) {</div>
<div class=CC1>    fprintf(stderr, msg, args);</div>
<div class=CC1>    fputs(<font color=#007f00>&quot;\n&quot;</font>, stderr);</div>
<div class=CC1>    exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> <font color=#ff7700>void</font> requireMinArgs(<font color=#ff7700>int</font> argc, <font color=#ff7700>int</font> minArgs,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* msg = <font color=#007f00>&quot;Must use at least %d
arguments&quot;</font>) {</div>
<div class=CC1>  <font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>  <font color=#ff7700>if</font>(argc &lt; minArgs + 1) {</div>
<div class=CC1>    <span lang=SV>fprintf(stderr, msg, minArgs);</span></div>
<div class=CC1><span lang=SV>    fputs(<font color=#007f00>&quot;\n&quot;</font>, stderr);</span></div>
<div class=CC1><span lang=SV>    </span>exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> <font color=#ff7700>void</font> assure(std::ifstream&amp; in,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* filename = <font color=#007f00>&quot;&quot;</font>) {</div>
<div class=CC1>  <font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>  <font color=#ff7700>if</font>(!in) {</div>
<div class=CC1>    fprintf(stderr, <font color=#007f00>&quot;Could not open file
%s\n&quot;</font>, filename);</div>
<div class=CC1>    exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> <font color=#ff7700>void</font> assure(std::ofstream&amp; in,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* filename = <font color=#007f00>&quot;&quot;</font>) {</div>
<div class=CC1>  <font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>  <font color=#ff7700>if</font>(!in) {</div>
<div class=CC1>    fprintf(stderr, <font color=#007f00>&quot;Could not open file
%s\n&quot;</font>, filename);</div>
<div class=CC1>    exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>inline</font> <font color=#ff7700>void</font> assure(std::fstream&amp; in,</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>char</font>* filename = <font color=#007f00>&quot;&quot;</font>) {</div>
<div class=CC1>  <font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>  <font color=#ff7700>if</font>(!in) {</div>
<div class=CC1>    fprintf(stderr, <font color=#007f00>&quot;Could not open file
%s\n&quot;</font>, filename);</div>
<div class=CC1>    exit(EXIT_FAILURE);</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// REQUIRE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C0B:Dummy.cpp</font></div>
<div class=CC1><font color=#dd0000>// To give the makefile at least</font></div>
<div class=CC1><font color=#dd0000>// one target for this directory.</font></div>
<div class=CC1><font color=#ff7700>int</font> main() {} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The <b>Date</b> class files:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:Date.h</font></div>
<div class=CC1><font color=#7F7F00>#ifndef DATE_H</font></div>
<div class=CC1><font color=#7F7F00>#define DATE_H</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;stdexcept&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iosfwd&gt;</font></div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>class</font> Date {</div>
<div class=CC1>  <font color=#ff7700>int</font> year, month, day;</div>
<div class=CC1>  <font color=#ff7700>int</font> compare(<font color=#ff7700>const</font> Date&amp;) <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>static</font> <font color=#ff7700>int</font> daysInPrevMonth(<font color=#ff7700>int</font> year, <font color=#ff7700>int</font> mon);</div>
<div class=CC1><font color=#ff7700>public</font>:</div>
<div class=CC1>  <font color=#dd0000>// A class for date calculations</font></div>
<div class=CC1>  <font color=#ff7700>struct</font> Duration {</div>
<div class=CC1>    <font color=#ff7700>int</font> years, months, days;</div>
<div class=CC1>    Duration(<font color=#ff7700>int</font> y, <font color=#ff7700>int</font> m, <font color=#ff7700>int</font> d)</div>
<div class=CC1>    : years(y), months(m) ,days(d) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#dd0000>// An exception class</font></div>
<div class=CC1>  <font color=#ff7700>struct</font> DateError : <font color=#ff7700>public</font> std::logic_error {</div>
<div class=CC1>    DateError(<font color=#ff7700>const</font> std::string&amp; msg =
<font color=#007f00>&quot;&quot;</font>)</div>
<div class=CC1>: std::logic_error(msg) {}</div>
<div class=CC1>  };</div>
<div class=CC1>  Date();</div>
<div class=CC1>  Date(<font color=#ff7700>int</font>, <font color=#ff7700>int</font>, <font color=#ff7700>int</font>) <font color=#ff7700>throw</font>(DateError);</div>
<div class=CC1>  Date(<font color=#ff7700>const</font> std::string&amp;) <font color=#ff7700>throw</font>(DateError);</div>
<div class=CC1>  <font color=#ff7700>int</font> getYear() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>int</font> getMonth() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>int</font> getDay() <font color=#ff7700>const</font>;</div>
<div class=CC1>  std::string toString() <font color=#ff7700>const</font>;</div>
<div class=CC1>  <font color=#ff7700>friend</font> Duration duration(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;=(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;=(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> <font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font> Date&amp;, <font color=#ff7700>const</font>
Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::ostream&amp;
<font color=#ff7700>operator</font>&lt;&lt;(std::ostream&amp;,</div>
<div class=CC1>                                  <font color=#ff7700>const</font> Date&amp;);</div>
<div class=CC1>  <font color=#ff7700>friend</font> std::istream&amp;
<font color=#ff7700>operator</font>&gt;&gt;(std::istream&amp;, Date&amp;);</div>
<div class=CC1>};</div>
<div class=CC1><font color=#7F7F00>#endif </font><font color=#dd0000>// DATE_H ///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C02:Date.cpp {O}</font></div>
<div class=CC1><font color=#7F7F00>#include &quot;Date.h&quot;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iostream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;sstream&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cstdlib&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;string&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;algorithm&gt; </font><font color=#dd0000>// For swap()</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;ctime&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;cassert&gt;</font></div>
<div class=CC1><font color=#7F7F00>#include &lt;iomanip&gt;</font></div>
<div class=CC1><font color=#ff7700>using</font> <font color=#ff7700>namespace</font> std;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>namespace</font> {</div>
<div class=CC1>  <font color=#ff7700>const</font> <font color=#ff7700>int</font> daysInMonth[][13] = {</div>
<div class=CC1>    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
},</div>
<div class=CC1>    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
}</div>
<div class=CC1>  };</div>
<div class=CC1>  <font color=#ff7700>inline</font> <font color=#ff7700>bool</font> isleap(<font color=#ff7700>int</font> y) {</div>
<div class=CC1>    <font color=#ff7700>return</font> y%4 == 0 &amp;&amp; y%100 != 0 || y%400 ==
0;</div>
<div class=CC1>  }</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Date::Date() {</div>
<div class=CC1>  <font color=#dd0000>// Get current date</font></div>
<div class=CC1>  time_t tval = time(0);</div>
<div class=CC1>  <font color=#ff7700>struct</font> tm *now = localtime(&amp;tval);</div>
<div class=CC1>  year = now-&gt;tm_year + 1900;</div>
<div class=CC1>  month = now-&gt;tm_mon + 1;</div>
<div class=CC1>  day = now-&gt;tm_mday;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Date::Date(<font color=#ff7700>int</font> yr,int mon,int dy)
<font color=#ff7700>throw</font>(Date::DateError) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(!(1 &lt;= mon &amp;&amp; mon &lt;= 12))</div>
<div class=CC1>    <font color=#ff7700>throw</font> DateError(<font color=#007f00>&quot;Bad month in Date
ctor&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>if</font>(!(1 &lt;= dy &amp;&amp; dy &lt;=
daysInMonth[isleap(year)][mon]))</div>
<div class=CC1>    <font color=#ff7700>throw</font> DateError(<font color=#007f00>&quot;Bad day in Date ctor&quot;</font>);</div>
<div class=CC1>  year = yr;</div>
<div class=CC1>  month = mon;</div>
<div class=CC1>  day = dy;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Date::Date(<font color=#ff7700>const</font> std::string&amp; s)
<font color=#ff7700>throw</font>(Date::DateError) {</div>
<div class=CC1>  <font color=#dd0000>// Assume YYYYMMDD format</font></div>
<div class=CC1>  <font color=#ff7700>if</font>(!(s.size() == 8))</div>
<div class=CC1>    <font color=#ff7700>throw</font> DateError(<font color=#007f00>&quot;Bad string in Date
ctor&quot;</font>);</div>
<div class=CC1>  <font color=#ff7700>for</font>(<font color=#ff7700>int</font> n = 8; --n &gt;= 0;)</div>
<div class=CC1>    <font color=#ff7700>if</font>(!isdigit(s[n]))</div>
<div class=CC1>      <font color=#ff7700>throw</font> DateError(<font color=#007f00>&quot;Bad string in Date
ctor&quot;</font>);</div>
<div class=CC1>  string buf = s.substr(0, 4);</div>
<div class=CC1>  year = atoi(buf.c_str());</div>
<div class=CC1>  buf = s.substr(4, 2);</div>
<div class=CC1>  month = atoi(buf.c_str());</div>
<div class=CC1>  buf = s.substr(6, 2);</div>
<div class=CC1>  day = atoi(buf.c_str());</div>
<div class=CC1>  <font color=#ff7700>if</font>(!(1 &lt;= month &amp;&amp; month &lt;= 12))</div>
<div class=CC1>    <font color=#ff7700>throw</font> DateError(<font color=#007f00>&quot;Bad month in Date
ctor&quot;</font>);</div>
<div class=CC1><font color=#ff7700>if</font>(!(1 &lt;= day &amp;&amp; day
&lt;=</div>
<div class=CC1>  daysInMonth[isleap(year)][month]))</div>
<div class=CC1>    <font color=#ff7700>throw</font> DateError(<font color=#007f00>&quot;Bad day in Date ctor&quot;</font>);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Date::getYear() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> year; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Date::getMonth() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> month; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Date::getDay() <font color=#ff7700>const</font> { <font color=#ff7700>return</font> day; }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>string Date::toString() <font color=#ff7700>const</font> {</div>
<div class=CC1>  ostringstream os;</div>
<div class=CC1>  os.fill('0');</div>
<div class=CC1>  os &lt;&lt; setw(4) &lt;&lt; year</div>
<div class=CC1>     &lt;&lt; setw(2) &lt;&lt; month</div>
<div class=CC1>     &lt;&lt; setw(2) &lt;&lt; day;</div>
<div class=CC1>  <font color=#ff7700>return</font> os.str();</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Date::compare(<font color=#ff7700>const</font> Date&amp; d2) <font color=#ff7700>const</font> {</div>
<div class=CC1>  <font color=#ff7700>int</font> result = year - d2.year;</div>
<div class=CC1>  <font color=#ff7700>if</font>(result == 0) {</div>
<div class=CC1>    result = month - d2.month;</div>
<div class=CC1>    <font color=#ff7700>if</font>(result == 0)</div>
<div class=CC1>      result = day - d2.day;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> result;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>int</font> Date::daysInPrevMonth(<font color=#ff7700>int</font> year, <font color=#ff7700>int</font> month) {</div>
<div class=CC1>  <font color=#ff7700>if</font>(month == 1) {</div>
<div class=CC1>    --year;</div>
<div class=CC1>    month = 12;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>else</font></div>
<div class=CC1>    --month;</div>
<div class=CC1>  <font color=#ff7700>return</font> daysInMonth[isleap(year)][month];</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;(<font color=#ff7700>const</font> Date&amp; d1, <font color=#ff7700>const</font> Date&amp;
d2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> d1.compare(d2) &lt; 0;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&lt;=(<font color=#ff7700>const</font> Date&amp; d1, <font color=#ff7700>const</font> Date&amp;
d2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> d1 &lt; d2 || d1 == d2;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;(<font color=#ff7700>const</font> Date&amp; d1, <font color=#ff7700>const</font> Date&amp;
d2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> !(d1 &lt; d2) &amp;&amp; !(d1 == d2);</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>&gt;=(<font color=#ff7700>const</font> Date&amp; d1, <font color=#ff7700>const</font> Date&amp;
d2) {</div>
<div class=CC1>  <font color=#ff7700>return</font> !(d1 &lt; d2);</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>==(<font color=#ff7700>const</font> Date&amp; d1, <font color=#ff7700>const</font> Date&amp; d2)
{</div>
<div class=CC1>  <font color=#ff7700>return</font> d1.compare(d2) == 0;</div>
<div class=CC1>}</div>
<div class=CC1><font color=#ff7700>bool</font> <font color=#ff7700>operator</font>!=(<font color=#ff7700>const</font> Date&amp; d1, <font color=#ff7700>const</font> Date&amp; d2)
{</div>
<div class=CC1>  <font color=#ff7700>return</font> !(d1 == d2);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>Date::Duration</div>
<div class=CC1>duration(<font color=#ff7700>const</font> Date&amp; date1, <font color=#ff7700>const</font> Date&amp; date2)
{</div>
<div class=CC1>  <font color=#ff7700>int</font> y1 = date1.year;</div>
<div class=CC1>  <font color=#ff7700>int</font> y2 = date2.year;</div>
<div class=CC1>  <font color=#ff7700>int</font> m1 = date1.month;</div>
<div class=CC1>  <font color=#ff7700>int</font> m2 = date2.month;</div>
<div class=CC1>  <font color=#ff7700>int</font> d1 = date1.day;</div>
<div class=CC1>  <font color=#ff7700>int</font> d2 = date2.day;</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Compute the compare</font></div>
<div class=CC1>  <font color=#ff7700>int</font> order = date1.compare(date2);</div>
<div class=CC1>  <font color=#ff7700>if</font>(order == 0)</div>
<div class=CC1>    <font color=#ff7700>return</font> Date::Duration(0,0,0);</div>
<div class=CC1>  <font color=#ff7700>else</font> <font color=#ff7700>if</font>(order &gt; 0) {</div>
<div class=CC1>    <font color=#dd0000>// Make date1 precede date2 locally</font></div>
<div class=CC1>    <font color=#ff7700>using</font> std::swap;</div>
<div class=CC1>    swap(y1, y2);</div>
<div class=CC1>    swap(m1, m2);</div>
<div class=CC1>    swap(d1, d2);</div>
<div class=CC1>  }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#ff7700>int</font> years = y2 - y1;</div>
<div class=CC1>  <font color=#ff7700>int</font> months = m2 - m1;</div>
<div class=CC1>  <font color=#ff7700>int</font> days = d2 - d1;</div>
<div class=CC1>  assert(years &gt; 0 ||</div>
<div class=CC1>     years == 0 &amp;&amp; months &gt; 0 ||</div>
<div class=CC1>     years == 0 &amp;&amp; months == 0 &amp;&amp; days
&gt; 0);</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#dd0000>// Do the obvious corrections (must adjust days</font></div>
<div class=CC1>  <font color=#dd0000>// before months!) - This is a loop in case the</font></div>
<div class=CC1>  <font color=#dd0000>// previous month is February, and days &lt; -28.</font></div>
<div class=CC1>  <font color=#ff7700>int</font> lastMonth = m2;</div>
<div class=CC1>  <font color=#ff7700>int</font> lastYear = y2;</div>
<div class=CC1>  <font color=#ff7700>while</font>(days &lt; 0) {</div>
<div class=CC1>    <font color=#dd0000>// Borrow from month</font></div>
<div class=CC1>    assert(months &gt; 0);</div>
<div class=CC1>    days += Date::daysInPrevMonth(</div>
<div class=CC1>      lastYear, lastMonth--);</div>
<div class=CC1>    --months;</div>
<div class=CC1>  }</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>  <font color=#ff7700>if</font>(months &lt; 0) {</div>
<div class=CC1>    <font color=#dd0000>// Borrow from year</font></div>
<div class=CC1>    assert(years &gt; 0);</div>
<div class=CC1>    months += 12;</div>
<div class=CC1>    --years;</div>
<div class=CC1>  }</div>
<div class=CC1>  <font color=#ff7700>return</font> Date::Duration(years, months, days);</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>ostream&amp; <font color=#ff7700>operator</font>&lt;&lt;(ostream&amp; os, <font color=#ff7700>const</font>
Date&amp; d) {</div>
<div class=CC1>  <font color=#ff7700>char</font> fillc = os.fill('0');</div>
<div class=CC1>  os &lt;&lt; setw(2) &lt;&lt; d.getMonth() &lt;&lt;
‘-‘</div>
<div class=CC1>     &lt;&lt; setw(2) &lt;&lt; d.getDay() &lt;&lt; ‘-‘</div>
<div class=CC1>     &lt;&lt; setw(4) &lt;&lt; setfill(fillc) &lt;&lt;
d.getYear();</div>
<div class=CC1>  <font color=#ff7700>return</font> os;</div>
<div class=CC1>}</div>
<div class=CC1>&nbsp;</div>
<div class=CC1>istream&amp; <font color=#ff7700>operator</font>&gt;&gt;(istream&amp; is,
Date&amp; d) {</div>
<div class=CC1>  is &gt;&gt; d.month;</div>
<div class=CC1>  <font color=#ff7700>char</font> dash;</div>
<div class=CC1>  is &gt;&gt; dash;</div>
<div class=CC1>  <font color=#ff7700>if</font>(dash != '-')</div>
<div class=CC1>    is.setstate(ios::failbit);</div>
<div class=CC1>  is &gt;&gt; d.day;</div>
<div class=CC1>  is &gt;&gt; dash;</div>
<div class=CC1>  <font color=#ff7700>if</font>(dash != '-')</div>
<div class=CC1>    is.setstate(ios::failbit);</div>
<div class=CC1>  is &gt;&gt; d.year;</div>
<div class=CC1>  <font color=#ff7700>return</font> is;</div>
<div class=CC1>} <font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>The file test.txt used in Chapter 6:</p>

<div style='border:none;border-left:solid windowtext 1.0pt;padding:0in 0in 0in 10.0pt;
margin-left:.25in;margin-right:0in'>
<div class=CC1><font color=#dd0000>//: C06:Test.txt</font></div>
<div class=CC1>f a f d A  G f d F a A F h f A d f f a a</div>
<div class=CC1><font color=#dd0000>///:~</font></div>

</div>

<div class=CC1>&nbsp;</div>

<p class=MsoNormal>&nbsp;</p>

</div>

<span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:right'>
</span>

<div class=Section24>

<h1 style='margin-left:-85.7pt'><a href="#_TocRef53985899" name="_Toc53985899">Index</a></h1>

<p class=MsoNormal></p>

</div>

<sup><span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:auto'>
</span></sup>

<div class=Section25>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>&lt;</p>

</div>

<p class=MsoIndex1><b>&lt;cctype&gt;</b> · 252</p>

<p class=MsoIndex1><b>&lt;cstdlib&gt;</b> · 215</p>

<p class=MsoIndex1><b>&lt;ctime&gt;</b> · 212</p>

<p class=MsoIndex1><b>&lt;exception&gt;</b> · 38</p>

<p class=MsoIndex1><b>&lt;fstream&gt;</b> · 169</p>

<p class=MsoIndex1><b>&lt;functional&gt;</b> · 338</p>

<p class=MsoIndex1>&lt;<b>iomanip&gt;</b> · 196</p>

<p class=MsoIndex1><b>&lt;iosfwd&gt;</b> · 163</p>

<p class=MsoIndex1><b>&lt;limits&gt;</b> · 181, 203, 285</p>

<p class=MsoIndex1><b>&lt;memory&gt;</b> · 35</p>

<p class=MsoIndex1><b>&lt;sstream&gt;</b> · 179</p>

<p class=MsoIndex1><b>&lt;stdexcept&gt;</b> · 38</p>

<p class=MsoIndex1><b>&lt;typeinfo&gt;</b> · 557</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>A</p>

</div>

<p class=MsoIndex1><b>abort(&nbsp;)</b> · 27</p>

<p class=MsoIndex1>Abstract Factory design pattern · 651</p>

<p class=MsoIndex1>abstraction, in program design · 614</p>

<p class=MsoIndex1><b>accumulate</b> algorithm · 413</p>

<p class=MsoIndex1>activation record instance · 58</p>

<p class=MsoIndex1>adaptable function object · 341</p>

<p class=MsoIndex1>Adapter design pattern · 636</p>

<p class=MsoIndex1>adaptor: container · 433, 487; function object · 338;
function pointer · 351; iterator · 487</p>

<p class=MsoIndex1><b>adjacent_difference</b> algorithm · 415</p>

<p class=MsoIndex1><b>adjacent_find</b> algorithm · 378</p>

<p class=MsoIndex1>aggregation, design patterns · 616</p>

<p class=MsoIndex1>Alexandrescu, Andrei · 294, 305</p>

<p class=MsoIndex1>algorithm: <b>accumulate</b> · 413; <b>adjacent_difference</b>
· 415; <b>adjacent_find</b> · 378; applicators · 405; <b>binary_search</b> ·
395; complexity · 333; <b>copy</b> · 326, 365; <b>copy_backward</b> · 372; <b>count</b>
· 370; <b>count_if</b> · 334, 371; counting · 370; creating your own · 419; <b>equal</b>
· 327, 385; <b>equal_range</b> · 396; <b>fill</b> · 369; <b>fill_n</b> · 369;
filling and generating · 368; <b>find</b> · 334, 377; <b>find_end</b> · 379; <b>find_first_of</b>
· 378; <b>find_if</b> · 378; <b>for_each</b> · 355, 405; general utilities ·
417; <b>generate</b> · 369; <b>generate_n</b> · 369; generic · 325; heap
operations · 403; <b>includes</b> · 400; <b>inner_product</b> · 414; <b>inplace_merge</b>
· 399; <b>iter_swap</b> · 419, 457; <b>lexicographical_compare</b> · 385; <b>lower_bound</b>
· 395; <b>make_heap</b> · 404; manipulating sequences · 372; <b>max</b> · 419; <b>max_element</b>
· 380; <b>merge</b> · 399; merging · 398; <b>min</b> · 418; <b>min_element</b>
· 379; <b>mismatch</b> · 386; <b>next_permutation</b> · 373; <b>nth_element</b>
· 394; numeric · 413; ordering · 393; <b>partial_sort</b> · 394; <b>partial_sort_copy</b>
· 394; <b>partial_sum</b> · 414; <b>partition</b> · 374; <b>pop_heap</b> · 404;
predicate · 329; <b>prev_permutation</b> · 373; <b>push_heap</b> · 404; <b>random_shuffle</b>
· 374; range of sequence in · 326; <b>remove</b> · 389; <b>remove_copy</b> ·
389; <b>remove_copy_if</b> · 329, 339, 350, 390; <b>remove_if</b> · 389;
removing elements · 389; <b>replace</b> · 380; <b>replace_copy</b> · 380; <b>replace_copy_if</b>
· 330, 380; <b>replace_if</b> · 330, 380; <b>reverse</b> · 372; <b>reverse_copy</b>
· 372; <b>rotate</b> · 373; <b>rotate_copy</b> · 373; <b>search</b> · 379; <b>search_n</b>
· 379; searching and replacing · 377; <b>set</b> operations · 400; <b>set_difference</b>
· 401; <b>set_intersection</b> · 401; <b>set_symmetric_difference</b> · 402; <b>set_union</b>
· 401; <b>sort</b> · 366, 393; <b>sort_heap</b> · 404; sorting · 393; <b>stable_partition</b>
· 374; <b>stable_sort</b> · 366, 393; <b>swap</b> · 419; <b>swap_ranges</b> ·
373; <b>transform</b> · 347, 349, 355, 405; <b>unique</b> · 390; <b>unique_copy</b>
· 390; <b>upper_bound</b> · 395; utilities · 417</p>

<p class=MsoIndex1>ANSI/ISO C++ Committee · 9</p>

<p class=MsoIndex1>applicator algorithms · 405</p>

<p class=MsoIndex1>applicator, iostreams manipulator · 200</p>

<p class=MsoIndex1>applying a function to a container · 255</p>

<p class=MsoIndex1><b>argument_type</b> · 342</p>

<p class=MsoIndex1>argument-dependent lookup · 274, 278; disabling · 275</p>

<p class=MsoIndex1><b>assert</b> macro · 66</p>

<p class=MsoIndex1>assertion · 66; side effects in an · 67</p>

<p class=MsoIndex1><b>Assignable</b> · 337</p>

<p class=MsoIndex1>associative container · 433, 513</p>

<p class=MsoIndex1><b>atof(&nbsp;)</b> · 181</p>

<p class=MsoIndex1><b>atoi(&nbsp;)</b> · 181</p>

<p class=MsoIndex1>atomic operation · 732</p>

<p class=MsoIndex1><b>auto_ptr</b> · 35; not for containers · 437</p>

<p class=MsoIndex1>automated testing · 71</p>

<p class=MsoIndex1>automatic type conversion, and exception handling · 23</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>B</p>

</div>

<p class=MsoIndex1><b>back_insert_iterator</b> · 448, 482</p>

<p class=MsoIndex1><b>back_inserter(&nbsp;)</b> · 328, 370, 372, 418, 448</p>

<p class=MsoIndex1><b>bad_cast</b> exception class · 40, 557</p>

<p class=MsoIndex1><b>bad_exception</b> class · 44</p>

<p class=MsoIndex1><b>bad_typeid</b> exception class · 40, 559</p>

<p class=MsoIndex1><b>badbit</b> · 165</p>

<p class=MsoIndex1><b>basic_istream</b> · 158, 216</p>

<p class=MsoIndex1><b>basic_ostream</b> · 158, 217</p>

<p class=MsoIndex1><b>basic_string</b> · 134, 217, 241</p>

<p class=MsoIndex1>Becker, Pete · 11</p>

<p class=MsoIndex1><b>before(&nbsp;), </b>RTTI function · 559</p>

<p class=MsoIndex1>behavioral design patterns · 616</p>

<p class=MsoIndex1>bidirectional iterator · 446</p>

<p class=MsoIndex1><b>BidirectionalIterator</b> · 364</p>

<p class=MsoIndex1>binary files · 172, 214</p>

<p class=MsoIndex1>binary function · 337</p>

<p class=MsoIndex1>binary predicate · 337</p>

<p class=MsoIndex1>binary search · 63</p>

<p class=MsoIndex1><b>binary_function</b> · 342, 353; <b>first_argument_type</b>
· 342; <b>result_type</b> · 342; <b>second_argument_type</b> · 342</p>

<p class=MsoIndex1><b>binary_negate </b>function object · 341</p>

<p class=MsoIndex1><b>binary_search</b> algorithm · 395</p>

<p class=MsoIndex1><b>bind1st</b> function object adaptor · 339</p>

<p class=MsoIndex1><b>bind2nd</b> function object adaptor · 338, 350, 371</p>

<p class=MsoIndex1><b>binder1st</b> function object · 339</p>

<p class=MsoIndex1><b>binder2nd</b> function object · 339</p>

<p class=MsoIndex1><b>bitset</b> · 229, 506, 540; <b>to_string(&nbsp;)</b> ·
241</p>

<p class=MsoIndex1>blocking, and threads · 734</p>

<p class=MsoIndex1>book errors, reporting · 10</p>

<p class=MsoIndex1>Bright, Walter · 8, 11</p>

<p class=MsoIndex1><b>broadcast(&nbsp;)</b>, threading · 734, 742, 757</p>

<p class=MsoIndex1>buffering, stream · 173</p>

<p class=MsoIndex1>Builder design pattern · 660</p>

<p class=MsoIndex1>busy wait, threading · 732, 743</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>C</p>

</div>

<p class=MsoIndex1><b>cancel(&nbsp;)</b>, ZThread library function · 717</p>

<p class=MsoIndex1><b>Cancelable</b>, ZThread library class · 717</p>

<p class=MsoIndex1>cast: downcast · 551; <b>dynamic_cast</b> · 555; runtime ·
551; runtime type identification, casting to intermediate levels · 560</p>

<p class=MsoIndex1><b>catch</b> · 20; catching any exception · 25</p>

<p class=MsoIndex1><b>cerr</b> · 158</p>

<p class=MsoIndex1><b>cfront</b> · 574</p>

<p class=MsoIndex1>Chain of Responsibility design pattern · 642</p>

<p class=MsoIndex1>chaining, in iostreams · 159</p>

<p class=MsoIndex1>change, vector of change · 614</p>

<p class=MsoIndex1><b>char_traits</b> · 217, 241, 287</p>

<p class=MsoIndex1>character traits · 217; <b>compare(&nbsp;)</b> · 217</p>

<p class=MsoIndex1><b>cin</b> · 158</p>

<p class=MsoIndex1>class: hierarchies and exception handling · 24; invariant ·
69; maintaining library source · 204; wrapping · 151</p>

<p class=MsoIndex1>class template: partial ordering · 263; partial
specialization · 263</p>

<p class=MsoIndex1>cleaning up the stack during exception handling · 28</p>

<p class=MsoIndex1><b>clear(&nbsp;)</b> · 166, 175</p>

<p class=MsoIndex1><b>close(&nbsp;)</b> · 168</p>

<p class=MsoIndex1>code bloat, of templates · 268</p>

<p class=MsoIndex1>code invariant · 63</p>

<p class=MsoIndex1>cohesion · 49</p>

<p class=MsoIndex1>Collecting Parameter design pattern (idiom) · 618</p>

<p class=MsoIndex1>command line, interface · 162</p>

<p class=MsoIndex1>Command pattern · 626; decoupling · 628</p>

<p class=MsoIndex1>Committee, ANSI/ISO C++ · 9</p>

<p class=MsoIndex1>compilation, of templates · 315</p>

<p class=MsoIndex1>compile time: assertions · 304; error checking · 155;
looping · 299; selection · 303</p>

<p class=MsoIndex1>complexity of algorithms · 333</p>

<p class=MsoIndex1><b>compose</b> non-standard function object adaptor · 360</p>

<p class=MsoIndex1>composition, and design patterns · 614, 615</p>

<p class=MsoIndex1>concurrency · 691; blocking · 734; Command pattern · 628;
when to use it · 771</p>

<p class=MsoIndex1><b>ConcurrentExecutor</b> (Concurrency) · 704</p>

<p class=MsoIndex1><b>Condition</b> class, threading · 742</p>

<p class=MsoIndex1>console I/O · 162</p>

<p class=MsoIndex1>constructor: default constructor synthesized by the compiler
· 620; design patterns · 616; exception handling · 29, 30, 57; failing · 57;
order of constructor and destructor calls · 562; private constructor · 620;
protected · 581; simulating virtual constructors · 654; virtual functions
inside constructors · 654</p>

<p class=MsoIndex1>container · 429; adaptor · 433, 487; associative · 433, 513;
<b>bitset</b> · 506, 540; cleaning up · 437, 534; combining STL containers ·
530; creating custom · 536; <b>deque</b> · 434, 465; duplicate keys · 523;
extended STL containers · 440; <b>list</b> · 434, 471; <b>map</b> · 513, 521; <b>multimap</b>
· 513, 523; multiple membership problem · 438; <b>multiset</b> · 513, 527; of
pointers · 436; <b>priority_queue</b> · 496; <b>queue</b> · 491; reversible ·
445; sequence · 433; sequence operations · 454; <b>set</b> · 479, 513; <b>stack</b>
· 487; <b>valarray</b> · 540; value-based · 434; <b>vector</b> · 434, 457; <b>vector&lt;bool&gt;</b>
· 506, 511</p>

<p class=MsoIndex1>contract, design by · 68</p>

<p class=MsoIndex1>conversion, automatic type conversions and exception
handling · 23</p>

<p class=MsoIndex1>cooperation between threads · 741</p>

<p class=MsoIndex1>Coplien, James · 296, 655</p>

<p class=MsoIndex1><b>copy </b>algorithm · 326, 365</p>

<p class=MsoIndex1><b>copy_backward</b> algorithm · 372</p>

<p class=MsoIndex1>copy-on-write · 634</p>

<p class=MsoIndex1><b>count</b> algorithm · 370</p>

<p class=MsoIndex1><b>count_if</b> algorithm · 334, 371</p>

<p class=MsoIndex1><b>CountedPtr</b>, reference-counting template in ZThread
library (Concurrency) · 714</p>

<p class=MsoIndex1>counting algorithms · 370</p>

<p class=MsoIndex1><b>cout</b> · 158</p>

<p class=MsoIndex1>covariance, of exception specifications · 47</p>

<p class=MsoIndex1>Crahen, Eric · 11, 694</p>

<p class=MsoIndex1>creational design patterns · 615</p>

<p class=MsoIndex1>critical section, in thread programming · 719</p>

<p class=MsoIndex1>curiously recurring template pattern · 294, 624</p>

<p class=MsoIndex1>Cygwin, and ZThreads · 696</p>

<p class=MsoIndex1>Czarnecki, Krysztof · 300</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>D</p>

</div>

<p class=MsoIndex1>datalogger · 211</p>

<p class=MsoIndex1>dead thread · 734</p>

<p class=MsoIndex1>deadlock · 720, 764; conditions for · 769</p>

<p class=MsoIndex1>debugging · 87</p>

<p class=MsoIndex1><b>dec</b> · 187</p>

<p class=MsoIndex1>declaration, forward · 163</p>

<p class=MsoIndex1>default constructor: synthesized by the compiler · 620</p>

<p class=MsoIndex1>dependent base class · 278</p>

<p class=MsoIndex1>dependent name · 274</p>

<p class=MsoIndex1><b>deque</b> · 434, 465</p>

<p class=MsoIndex1>design: abstraction in program design · 614; cohesion · 49;
decisions · 66; exception-neutral · 52; exception-safe · 48</p>

<p class=MsoIndex1>design by contract · 68</p>

<p class=MsoIndex1>design patterns · 613; Abstract Factory · 651; Adapter ·
636; aggregation · 616; behavioral · 616; Builder · 660; Chain of Responsibility
· 642; Collecting Parameter idiom · 618; Command · 626; constructors · 616;
creational · 615; destructors · 616; Double Dispatching · 679; Factory Method ·
581, 645; Messenger idiom · 617; Multiple Dispatching · 679; Observer · 667;
Proxy · 632; simulating virtual constructors · 654; Singleton · 460, 619; State
· 634; Strategy · 640; structural · 615; Template Method · 639; vector of
change · 614; Visitor · 683</p>

<p class=MsoIndex1>destructor · 659; design patterns · 616; exception handling
· 28, 57; explicit call · 453; order of constructor and destructor calls · 562;
virtual · 581</p>

<p class=MsoIndex1>diamond inheritance · 588</p>

<p class=MsoIndex1><b>difference_type</b> · 370</p>

<p class=MsoIndex1>dining philosophers, threading · 764</p>

<p class=MsoIndex1>dispatching: Double Dispatching design pattern · 679;
Multiple Dispatching design pattern · 679</p>

<p class=MsoIndex1><b>distance(&nbsp;)</b> · 417</p>

<p class=MsoIndex1><b>divides </b>function object · 341</p>

<p class=MsoIndex1>documentation, library · 101</p>

<p class=MsoIndex1>document-view architecture · 667</p>

<p class=MsoIndex1><b>domain_error</b> exception class · 40</p>

<p class=MsoIndex1>dominance · 601</p>

<p class=MsoIndex1>Double Dispatching design pattern · 653, 679</p>

<p class=MsoIndex1>downcast · 551</p>

<p class=MsoIndex1>dynamic type, of an object · 557</p>

<p class=MsoIndex1><b>dynamic_cast</b> · 555; casting to intermediate levels ·
560; difference between <b>dynamic_cast</b> and <b>typeid</b>, runtime type
identification · 561; for polymorphic types · 556</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>E</p>

</div>

<p class=MsoIndex1>effectors · 201</p>

<p class=MsoIndex1>efficiency: runtime type identification · 565; threads and ·
693</p>

<p class=MsoIndex1>Eisenecker, Ulrich · 300</p>

<p class=MsoIndex1>ellipses, with exception handling · 25</p>

<p class=MsoIndex1><b>endl</b> · 195</p>

<p class=MsoIndex1>envelope, and letter classes · 655</p>

<p class=MsoIndex1><b>eofbit</b> · 166</p>

<p class=MsoIndex1><b>epsilon(&nbsp;)</b> · 181</p>

<p class=MsoIndex1><b>equal</b> algorithm · 327, 385</p>

<p class=MsoIndex1><b>equal_range</b> algorithm · 396</p>

<p class=MsoIndex1><b>equal_to</b> function object · 339, 341</p>

<p class=MsoIndex1><b>EqualityComparable</b> · 337</p>

<p class=MsoIndex1><b>errno</b> · 16</p>

<p class=MsoIndex1>error: handling · 15; handling, in C · 16; recovery · 15;
reporting errors in book · 10</p>

<p class=MsoIndex1>event-driven programming, and the Command pattern · 628</p>

<p class=MsoIndex1><b>exception</b> class · 38; <b>what(&nbsp;)</b> · 38</p>

<p class=MsoIndex1>exception handling · 15; asynchronous events · 53; atomic
allocations for safety · 32; automatic type conversions · 23; <b>bad_cast</b>
exception class · 40, 557; <b>bad_exception</b> class · 44; <b>bad_typeid</b>
exception class · 40, 559; catching an exception · 20; catching any exception ·
25, 26; catching by reference · 23; catching via accessible base · 25; class
hierarchies · 24; cleaning up the stack during a throw · 28; constructors · 29,
30, 57; destructors · 28, 36, 57; <b>domain_error</b> exception class · 40;
ellipses · 25; <b>exception</b> class · 38; <b>exception</b> class, <b>what(&nbsp;)</b>
· 38; exception handler · 20; exception hierarchies · 56; exception matching ·
23; exception neutral · 52; exception safety · 48; exception specifications ·
40; <b>exception</b> type · 39; incomplete objects · 29; inheritance · 24; <b>invalid_argument</b>
exception class · 40; <b>length_error</b> exception class · 40; <b>logic_error</b>
class · 38; memory leaks · 29; multiple inheritance · 56; naked pointers · 30;
object slicing and · 23; <b>out_of_range</b> exception class · 40; overhead of
· 58; programming guidelines · 52; references · 34, 56; resource management ·
30; rethrowing an exception · 26, 52; <b>runtime_error</b> class · 38; <b>set_terminate(&nbsp;)</b>
· 27; <b>set_unexpected(&nbsp;)</b> · 41; specifications, and inheritance · 46;
specifications, covariance of · 47; specifications, when not to use · 47; stack
unwinding · 19; Standard C++ library exceptions · 38; <b>terminate(&nbsp;)</b>
· 44; termination vs. resumption · 22; testing · 79; throwing &amp; catching
pointers · 57; throwing an exception · 18, 19; typical uses of exceptions · 54;
uncaught exceptions · 26, 28; <b>unexpected(&nbsp;)</b> · 41; when to avoid ·
52; zero-cost model · 60; ZThreads (Concurrency) · 708</p>

<p class=MsoIndex1>exception specifications · 40; covariance of · 47;
inheritance · 46; when not to use · 47</p>

<p class=MsoIndex1>exclusion, mutual, in threads · 719</p>

<p class=MsoIndex1>Executors, ZThread (Concurrency) · 702</p>

<p class=MsoIndex1>explicit instantiation, of templates · 316</p>

<p class=MsoIndex1><b>export</b> keyword · 319</p>

<p class=MsoIndex1>exported templates · 319</p>

<p class=MsoIndex1>expression templates · 308</p>

<p class=MsoIndex1>extractor, stream · 158</p>

<p class=MsoIndex1>Extreme Programming (XP) · 71, 615</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>F</p>

</div>

<p class=MsoIndex1>facet: locale · 220</p>

<p class=MsoIndex1>Factory Method design pattern · 581, 645</p>

<p class=MsoIndex1><b>fail(&nbsp;)</b> · 175</p>

<p class=MsoIndex1><b>failbit</b> · 160, 166</p>

<p class=MsoIndex1>Fibonacci · 298, 636</p>

<p class=MsoIndex1>file streams, <b>close(&nbsp;)</b> · 168</p>

<p class=MsoIndex1>file, iostreams · 156, 162</p>

<p class=MsoIndex1><b>FILE</b>, stdio · 152</p>

<p class=MsoIndex1><b>fill</b> algorithm · 369</p>

<p class=MsoIndex1><b>fill_n</b> algorithm · 369</p>

<p class=MsoIndex1>filling and generating algorithms · 368</p>

<p class=MsoIndex1><b>find</b> algorithm · 334, 377</p>

<p class=MsoIndex1><b>find_end</b> algorithm · 379</p>

<p class=MsoIndex1><b>find_first_of</b> algorithm · 378</p>

<p class=MsoIndex1><b>find_if</b> algorithm · 378</p>

<p class=MsoIndex1><b>first_argument_type</b> · 342</p>

<p class=MsoIndex1><b>flock(&nbsp;)</b>, and SynchronousExecutor (Concurrency)
· 705</p>

<p class=MsoIndex1><b>flush</b>, iostreams · 195</p>

<p class=MsoIndex1><b>for_each</b> algorithm · 355, 405</p>

<p class=MsoIndex1>format fields · 188</p>

<p class=MsoIndex1>format flags: <b>dec</b> · 187; <b>hex</b> · 187; <b>ios</b>;
<b>showbase</b> · 187; <b>showpoint</b> · 187; <b>showpos</b> · 187; <b>skipws</b>
· 187; <b>unitbuf</b> · 187; <b>uppercase</b> · 187; <b>oct</b> · 187</p>

<p class=MsoIndex1>formatted I/O · 186</p>

<p class=MsoIndex1>formatting: in-core · 179; manipulators, iostreams · 194;
output stream · 186</p>

<p class=MsoIndex1>forward declaration · 163</p>

<p class=MsoIndex1>forward iterator · 446</p>

<p class=MsoIndex1><b>forward_iterator_tag</b> · 447</p>

<p class=MsoIndex1><b>ForwardIterator</b> · 363</p>

<p class=MsoIndex1>framework, unit test · 75</p>

<p class=MsoIndex1>friend template · 284</p>

<p class=MsoIndex1>friends, of templates · 279</p>

<p class=MsoIndex1><b>front_insert_iterator</b> · 448</p>

<p class=MsoIndex1><b>front_inserter(&nbsp;)</b> · 418, 448</p>

<p class=MsoIndex1><b>fseek(&nbsp;)</b> · 176</p>

<p class=MsoIndex1><b>fstream</b> · 168; simultaneous input and output · 172</p>

<p class=MsoIndex1>function: applying a function to a container · 255; binary ·
337; unary · 337</p>

<p class=MsoIndex1>function object · 335, 626; adaptable · 341; adaptor · 338; <b>binary_negate</b>
· 341; <b>bind1st</b> adaptor · 339; <b>bind2nd</b> adaptor · 338, 350; <b>binder1st</b>
· 339; <b>binder2nd</b> · 339; classification · 336; <b>divides</b> · 341; <b>equal_to</b>
· 339, 341; <b>greater</b> · 338, 341, 371; <b>greater_equal</b> · 341; <b>less</b>
· 341; <b>less_equal</b> · 341; <b>logical_and</b> · 341; <b>logical_not</b> ·
341; <b>logical_or</b> · 341; <b>minus</b> · 340; <b>modulus</b> · 341; <b>multiplies</b>
· 341; <b>negate</b> · 341; <b>not_equal_to</b> · 341; <b>not1</b> adaptor ·
339; <b>plus</b> · 340; <b>unary_negate</b> · 341</p>

<p class=MsoIndex1>function object adaptor · 338; <b>bind2nd</b> · 371; <b>not1</b>
· 352; <b>pointer_to_binary_function</b> · 353; <b>pointer_to_unary_function</b>
· 352</p>

<p class=MsoIndex1>function pointer adaptor · 351; <b>ptr_fun</b> · 351</p>

<p class=MsoIndex1>function template · 245; address of · 251; explicit
qualification · 246; overloading · 249; partial ordering of · 259;
specialization · 261; type deduction parameters in · 245</p>

<p class=MsoIndex1>function-call operator · 335</p>

<p class=MsoIndex1>function-level try blocks · 36</p>

<p class=MsoIndex1>functor · 626; see <i>function object</i> · 335</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>G</p>

</div>

<p class=MsoIndex1>Gang of Four (GoF) · 613</p>

<p class=MsoIndex1>general utility algorithms · 417</p>

<p class=MsoIndex1><b>generate</b> algorithm · 369</p>

<p class=MsoIndex1><b>generate_n</b> algorithm · 369</p>

<p class=MsoIndex1>generator · 337, 369</p>

<p class=MsoIndex1>generic algorithms · 325</p>

<p class=MsoIndex1>get pointer · 177</p>

<p class=MsoIndex1><b>get(&nbsp;)</b> · 170; overloaded versions · 165</p>

<p class=MsoIndex1><b>getline(&nbsp;)</b> · 164, 171</p>

<p class=MsoIndex1>getline(&nbsp;), for <b>string</b>s · 129</p>

<p class=MsoIndex1><b>getPriority(&nbsp;)</b> · 711</p>

<p class=MsoIndex1>GoF, Gang of Four · 613</p>

<p class=MsoIndex1><b>goodbit</b> · 166</p>

<p class=MsoIndex1><b>greater</b> function object · 338, 341, 371</p>

<p class=MsoIndex1><b>greater_equal </b>function object · 341</p>

<p class=MsoIndex1>Guard template, ZThread (concurrency) · 721</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>H</p>

</div>

<p class=MsoIndex1>handler, exception · 20</p>

<p class=MsoIndex1>handshaking, between concurrent tasks · 742</p>

<p class=MsoIndex1><b>hash_map</b> non-standard container · 539</p>

<p class=MsoIndex1><b>hash_multimap</b> non-standard container · 539</p>

<p class=MsoIndex1><b>hash_multiset</b> non-standard container · 539</p>

<p class=MsoIndex1><b>hash_set</b> non-standard container · 539</p>

<p class=MsoIndex1>heap operations · 403</p>

<p class=MsoIndex1><b>hex</b> · 187</p>

<p class=MsoIndex1>hierarchy, object-based · 573</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>I</p>

</div>

<p class=MsoIndex1>I/O: console · 162; interactive · 162; raw · 165; threads,
blocking · 737</p>

<p class=MsoIndex1>i18n, see <i>internationalization</i> · 216</p>

<p class=MsoIndex1><b>ifstream</b> · 156, 168, 174</p>

<p class=MsoIndex1><b>ignore(&nbsp;)</b> · 170</p>

<p class=MsoIndex1><b>imbue(&nbsp;)</b> · 220</p>

<p class=MsoIndex1>implementation inheritance · 579</p>

<p class=MsoIndex1><b>includes</b> algorithm · 400</p>

<p class=MsoIndex1>inclusion model, of template compilation · 315</p>

<p class=MsoIndex1>incomplete type · 163</p>

<p class=MsoIndex1>in-core formatting · 179</p>

<p class=MsoIndex1>inheritance: design patterns · 614; diamond · 588;
hierarchies · 573; implementation · 579; interface · 575</p>

<p class=MsoIndex1>inheritance, multiple · 573, 673; avoiding · 603; dominance
· 601; name lookup · 599; runtime type identification · 560, 563, 570</p>

<p class=MsoIndex1>initialization: controlling initialization order · 621; lazy
· 620; object · 596; Resource Acquisition Is Initialization (RAII) · 32, 36,
582; zero initialization · 522</p>

<p class=MsoIndex1>inner class idiom, adapted from Java · 671</p>

<p class=MsoIndex1><b>inner_product</b> algorithm · 414</p>

<p class=MsoIndex1><b>inplace_merge</b> algorithm · 399</p>

<p class=MsoIndex1>input iterator · 446</p>

<p class=MsoIndex1><b>input_iterator_tag</b> · 447</p>

<p class=MsoIndex1><b>InputIterator</b> · 363</p>

<p class=MsoIndex1><b>insert(&nbsp;)</b> · 448</p>

<p class=MsoIndex1><b>insert_iterator</b> · 372, 448, 482</p>

<p class=MsoIndex1><b>inserter(&nbsp;)</b> · 372, 418, 448</p>

<p class=MsoIndex1>inserter, stream · 158</p>

<p class=MsoIndex1>instantiation, template · 260</p>

<p class=MsoIndex1>interactive I/O · 162</p>

<p class=MsoIndex1>interface: class · 576; command-line · 162; extending an ·
603; inheritance · 575; repairing an interface with multiple inheritance · 603;
responsive user · 700</p>

<p class=MsoIndex1>internationalization · 216</p>

<p class=MsoIndex1><b>interrupt(&nbsp;)</b>, threading · 735</p>

<p class=MsoIndex1>interrupted status, threading · 739</p>

<p class=MsoIndex1><b>Interrupted_Exception</b>, threading · 739</p>

<p class=MsoIndex1><b>invalid_argument</b> exception class · 40</p>

<p class=MsoIndex1>invalidation, iterator · 463</p>

<p class=MsoIndex1>invariant: class · 69; code · 63; loop · 64</p>

<p class=MsoIndex1><b>ios</b>: <b>app</b> · 172; <b>ate</b> · 172; <b>basefield</b>
· 188; <b>beg</b> · 176; <b>binary</b> · 172, 214; <b>cur</b> · 176; <b>end</b>
· 176; <b>failbit</b> · 160; <b>fill(&nbsp;)</b> · 190; <b>in</b> · 171; <b>out</b>
· 172; <b>precision(&nbsp;)</b> · 190; <b>showbase</b> · 187; <b>showpoint</b> ·
187; <b>showpos</b> · 187; <b>skipws</b> · 187; <b>trunc</b> · 172; <b>unitbuf</b>
· 187; <b>uppercase</b> · 187; <b>width(&nbsp;)</b> · 190</p>

<p class=MsoIndex1><b>ios_base</b> · 157</p>

<p class=MsoIndex1><b>iostate</b> · 168</p>

<p class=MsoIndex1>iostreams · 156; applicator · 200; automatic · 189; <b>badbit</b>
· 165; binary mode · 172, 214; buffering · 173; <b>clear</b> function · 166, 175;
<b>dec</b> manipulator · 195; <b>endl</b> manipulator · 195; <b>eofbit</b> ·
166; errors · 165; exceptions · 167; <b>exceptions</b> function · 167;
extractor · 158; <b>fail</b> function · 175; <b>failbit</b> · 166; <b>failure</b>
exception type · 167; files · 162; <b>fill(&nbsp;)</b> · 190; <b>fixed</b> ·
196; <b>flags(&nbsp;)</b> · 186; <b>flush</b> · 195; <b>fmtflags</b> type ·
186; format fields · 188; format flags · 186; formatting · 186; <b>fseek(&nbsp;)</b>
· 176; <b>get(&nbsp;)</b> · 170; <b>getline(&nbsp;)</b> · 171; <b>goodbit</b> ·
166; <b>hex</b> manipulator · 195; <b>ignore(&nbsp;)</b> · 170; <b>imbue(&nbsp;)</b>
· 220; inserter · 158; <b>internal</b> · 196; <b>ios::basefield</b> · 188; <b>ios::dec</b>
· 189; <b>ios::fixed</b> · 189; <b>ios::hex</b> · 189; <b>ios::internal</b> ·
190; <b>ios::left</b> · 190; <b>ios::oct</b> · 189; <b>ios::right</b> · 190; <b>ios::scientific</b>
· 189; <b>iostate</b> type · 168; <b>left</b> · 196; locales · 216;
manipulators · 194; manipulators, creating · 199; narrow · 216; <b>narrow</b>
function · 218; <b>noshowbase</b> · 195; <b>noshowpoint</b> · 196; <b>noshowpos</b>
· 195; <b>noskipws</b> · 196; <b>nouppercase</b> · 195; <b>oct</b> manipulator
· 195; open modes · 171; <b>operator &lt;&lt;</b> · 158; <b>operator &gt;&gt;</b>
· 158; positioning · 175; <b>precision(&nbsp;)</b> · 190, 213; <b>resetiosflags</b>
manipulator · 196; <b>right</b> · 196; <b>scientific</b> · 196; seeking in ·
175; <b>setbase</b> manipulator · 197; <b>setf(&nbsp;)</b> · 187, 188, 213; <b>setfill</b>
manipulator · 197; <b>setiosflags</b> manipulator · 196; <b>setprecision</b>
manipulator · 197; <b>setstate</b> function · 166; <b>setw</b> manipulator ·
197, 213; <b>showbase</b> · 195; <b>showpoint</b> · 196; <b>showpos</b> · 195; <b>skipws</b>
· 196; <b>smanip</b> type · 201; string I/O with · 179; text mode · 172;
threads, colliding output · 727; <b>unsetf(&nbsp;)</b> · 188; <b>uppercase</b>
· 195; wide · 216; <b>widen</b> function · 218; <b>width(&nbsp;)</b> · 190; <b>write(&nbsp;)</b>
· 213; <b>ws</b> manipulator · 195</p>

<p class=MsoIndex1><b>istream</b> · 156; <b>get(&nbsp;)</b> · 164; <b>getline(&nbsp;)</b>
· 164; <b>read(&nbsp;)</b> · 165; <b>seekg(&nbsp;)</b> · 176; <b>tellg(&nbsp;)</b>
· 176</p>

<p class=MsoIndex1><b>istream_iterator</b> · 333, 446, 450</p>

<p class=MsoIndex1><b>istreambuf_iterator</b> · 446, 451, 481</p>

<p class=MsoIndex1><b>istringstream</b> · 156, 179</p>

<p class=MsoIndex1><b>iter_swap</b> algorithm · 419, 457</p>

<p class=MsoIndex1>iterator · 429, 615; adapting a class to produce · 637;
adaptor · 487; bidirectional · 446; categories · 446; forward · 446; input ·
446; invalidation · 463; istream · 333; ostream · 332; output · 446;
past-the-end · 443; random-access · 446; reverse · 445; stream · 331; stream
iterator · 450; tag · 447; traits · 366</p>

<p class=MsoIndex1><b>iterator_traits</b> · 366</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>J</p>

</div>

<p class=MsoIndex1>Josuttis, Nico · 101</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>K</p>

</div>

<p class=MsoIndex1>King, Jamie · 10</p>

<p class=MsoIndex1>Koenig, Andrew · 274</p>

<p class=MsoIndex1>Kreft, Klaus · 314, 780</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>L</p>

</div>

<p class=MsoIndex1>Lajoie, Josee · 60</p>

<p class=MsoIndex1>Langer, Angelika · 314, 780</p>

<p class=MsoIndex1>lazy initialization · 620, 634</p>

<p class=MsoIndex1><b>length_error</b> exception class · 40</p>

<p class=MsoIndex1><b>less </b>function object · 341</p>

<p class=MsoIndex1><b>less_equal </b>function object · 341</p>

<p class=MsoIndex1><b>LessThanComparable</b> · 337</p>

<p class=MsoIndex1>letter, envelope and letter classes · 655</p>

<p class=MsoIndex1><b>lexicographical_compare</b> algorithm · 385</p>

<p class=MsoIndex1>library: documentation · 101; maintaining class source · 204</p>

<p class=MsoIndex1>line input · 162</p>

<p class=MsoIndex1>linear search · 377</p>

<p class=MsoIndex1>Linux, and ZThreads · 696</p>

<p class=MsoIndex1><b>list</b> · 434, 471; <b>merge(&nbsp;)</b> · 474; <b>remove(&nbsp;)</b>
· 474; <b>reverse(&nbsp;)</b> · 472; <b>sort(&nbsp;)</b> · 472; <b>unique(&nbsp;)</b>
· 474; vs. <b>set</b> · 476</p>

<p class=MsoIndex1>locale · 216, 218; <b>collate</b> category · 219; <b>ctype</b>
category · 219; facet · 220; iostreams · 216; <b>messages</b> category · 219; <b>monetary</b>
category · 219; <b>money_get</b> facet · 220; <b>money_punct</b> facet · 220; <b>money_put</b>
facet · 220; <b>numeric</b> category · 219; <b>time</b> category · 219; <b>time_get</b>
facet · 220; <b>time_put</b> facet · 220</p>

<p class=MsoIndex1><b>localtime(&nbsp;)</b> · 213</p>

<p class=MsoIndex1><b>logic_error</b> class · 38</p>

<p class=MsoIndex1><b>logical_and </b>function object · 341</p>

<p class=MsoIndex1><b>logical_not </b>function object · 341</p>

<p class=MsoIndex1><b>logical_or </b>function object · 341</p>

<p class=MsoIndex1><b>longjmp(&nbsp;)</b> · 16</p>

<p class=MsoIndex1>loop: invariant · 64; unrolling · 301</p>

<p class=MsoIndex1><b>lower_bound</b> algorithm · 395</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>M</p>

</div>

<p class=MsoIndex1>machine epsilon · 181</p>

<p class=MsoIndex1>maintaining class library source · 204</p>

<p class=MsoIndex1><b>make_heap</b> algorithm · 404, 499</p>

<p class=MsoIndex1><b>make_pair(&nbsp;)</b> · 417</p>

<p class=MsoIndex1>manipulating sequences · 372</p>

<p class=MsoIndex1>manipulators · 160; creating · 199; iostreams formatting ·
194; with arguments · 196</p>

<p class=MsoIndex1><b>map</b> · 521; keys and values · 521</p>

<p class=MsoIndex1><b>max</b> algorithm · 419</p>

<p class=MsoIndex1><b>max_element</b> algorithm · 380</p>

<p class=MsoIndex1><b>mem_fun</b> member pointer adaptor · 355</p>

<p class=MsoIndex1><b>mem_fun_ref</b> member pointer adaptor · 355</p>

<p class=MsoIndex1>member templates · 242; vs. <b>virtual</b> · 245</p>

<p class=MsoIndex1>memory leaks · 90</p>

<p class=MsoIndex1>memory management, and threads · 711</p>

<p class=MsoIndex1><b>merge</b> algorithm · 399</p>

<p class=MsoIndex1>merging algorithms · 398</p>

<p class=MsoIndex1>Messenger design pattern (idiom) · 617</p>

<p class=MsoIndex1>metaprogramming · 297; compile-time assertions · 304;
compile-time looping · 299; compile-time selection · 303; loop unrolling · 301;
Turing completeness of · 298</p>

<p class=MsoIndex1>Meyer, Bertrand · 68</p>

<p class=MsoIndex1>Meyers, Scott · 60, 623</p>

<p class=MsoIndex1><b>min</b> algorithm · 418</p>

<p class=MsoIndex1><b>min_element</b> algorithm · 379</p>

<p class=MsoIndex1><b>minus </b>function object · 340</p>

<p class=MsoIndex1><b>mismatch</b> algorithm · 386</p>

<p class=MsoIndex1>mixin: class · 579; parameterized · 583</p>

<p class=MsoIndex1>model-view-controller (MVC) · 667</p>

<p class=MsoIndex1><b>modulus </b>function object · 341</p>

<p class=MsoIndex1><b>money_get</b> · 220</p>

<p class=MsoIndex1><b>money_punct</b> · 220</p>

<p class=MsoIndex1><b>money_put</b> · 220</p>

<p class=MsoIndex1><b>multimap</b> · 523</p>

<p class=MsoIndex1>Multiple Dispatching design pattern · 679</p>

<p class=MsoIndex1>multiple inheritance · 573, 673; avoiding · 603; dominance ·
601; duplicate subobjects · 585; exception handling · 56; name lookup · 599;
repairing an interface · 603; runtime type identification · 560, 563, 570</p>

<p class=MsoIndex1><b>multiplies </b>function object · 341</p>

<p class=MsoIndex1>multiprocessor machine, and threading · 692</p>

<p class=MsoIndex1><b>multiset</b> · 527; <b>equal_range(&nbsp;)</b> · 529</p>

<p class=MsoIndex1>multitasking · 691</p>

<p class=MsoIndex1>multithreading · 691; drawbacks · 771; ZThread library for
C++ · 694</p>

<p class=MsoIndex1>mutex: simplifying with the Guard template · 721; threading
· 742; ZThread <b>FastMutex</b> · 731</p>

<p class=MsoIndex1>mutual exclusion, in threads · 719</p>

<p class=MsoIndex1>Myers, Nathan · 11, 251, 285, 452, 481, 482</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>N</p>

</div>

<p class=MsoIndex1>naked pointers, and exception handling · 30</p>

<p class=MsoIndex1>name lookup, and multiple inheritance · 599</p>

<p class=MsoIndex1><b>name(&nbsp;)</b>,<b> </b>RTTI function · 559</p>

<p class=MsoIndex1>narrow streams · 216</p>

<p class=MsoIndex1><b>narrow(&nbsp;)</b> · 218</p>

<p class=MsoIndex1><b>negate </b>function object · 341</p>

<p class=MsoIndex1><b>new</b>, placement · 91</p>

<p class=MsoIndex1>newline, differences between DOS and Unix · 172</p>

<p class=MsoIndex1><b>next_permutation</b> algorithm · 373</p>

<p class=MsoIndex1><b>not_equal_to </b>function object · 341</p>

<p class=MsoIndex1><b>not1</b> function object adaptor · 339, 352</p>

<p class=MsoIndex1><b>nth_element</b> algorithm · 394</p>

<p class=MsoIndex1>numeric algorithms · 413</p>

<p class=MsoIndex1><b>numeric_limits</b> · 203, 285</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>O</p>

</div>

<p class=MsoIndex1>object: initialization · 596; object-based hierarchy · 573;
slicing, and exception handling · 23</p>

<p class=MsoIndex1><b>Observable</b> · 668</p>

<p class=MsoIndex1>Observer design pattern · 667</p>

<p class=MsoIndex1><b>oct</b> · 187</p>

<p class=MsoIndex1><b>ofstream</b> · 156, 168</p>

<p class=MsoIndex1>one-definition rule · 622</p>

<p class=MsoIndex1>open modes, iostreams · 171</p>

<p class=MsoIndex1><b>operator new(&nbsp;)</b> · 90</p>

<p class=MsoIndex1><b>operator void*(&nbsp;)</b>, for streams · 167</p>

<p class=MsoIndex1><b>operator(&nbsp;)</b> · 229, 335, 339</p>

<p class=MsoIndex1><b>operator++(&nbsp;)</b> · 234</p>

<p class=MsoIndex1>optimization, throughput, with threading · 692</p>

<p class=MsoIndex1>order: controlling initialization · 621; of constructor and
destructor calls · 562</p>

<p class=MsoIndex1>ordering: algorithms · 393; strict weak · 337</p>

<p class=MsoIndex1><b>ostream</b> · 156; <b>fill(&nbsp;)</b> · 160;
manipulators · 160; <b>seekp(&nbsp;)</b> · 176; <b>setfill(&nbsp;)</b> · 160; <b>setw(&nbsp;)</b>
· 160; <b>tellp</b> · 176; <b>write(&nbsp;)</b> · 165</p>

<p class=MsoIndex1><b>ostream_iterator</b> · 332, 365, 446, 451</p>

<p class=MsoIndex1><b>ostreambuf_iterator</b> · 446, 451</p>

<p class=MsoIndex1><b>ostringstream</b> · 156, 179; <b>str(&nbsp;)</b> · 182</p>

<p class=MsoIndex1><b>out_of_range</b> exception class · 40</p>

<p class=MsoIndex1>output: iterator · 446; stream formatting · 186</p>

<p class=MsoIndex1><b>output_iterator_tag</b> · 447</p>

<p class=MsoIndex1><b>OutputIterator</b> · 363</p>

<p class=MsoIndex1>overhead, exception handling · 58</p>

<p class=MsoIndex1>overloading, function template · 249</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>P</p>

</div>

<p class=MsoIndex1>parameter, template · 227</p>

<p class=MsoIndex1>parameterized mixin · 583</p>

<p class=MsoIndex1>Park, Nick · 257</p>

<p class=MsoIndex1>partial ordering: class templates · 263; function templates
· 259</p>

<p class=MsoIndex1>partial specialization, template · 263</p>

<p class=MsoIndex1><b>partial_sort</b> algorithm · 394</p>

<p class=MsoIndex1><b>partial_sort_copy</b> algorithm · 394</p>

<p class=MsoIndex1><b>partial_sum</b> algorithm · 414</p>

<p class=MsoIndex1><b>partition</b> algorithm · 374</p>

<p class=MsoIndex1>past-the-end iterator · 443</p>

<p class=MsoIndex1>patterns, design patterns · 613</p>

<p class=MsoIndex1><b>perror(&nbsp;)</b> · 16</p>

<p class=MsoIndex1>philosophers, dining, and threading · 764</p>

<p class=MsoIndex1>placement <b>new</b> · 91</p>

<p class=MsoIndex1>Plauger, P. J. · 101</p>

<p class=MsoIndex1><b>plus </b>function object · 340</p>

<p class=MsoIndex1>pointer to member adaptor: <b>mem_fun</b> · 355; <b>mem_fun_ref</b>
· 355</p>

<p class=MsoIndex1>pointer, smart · 437</p>

<p class=MsoIndex1><b>pointer_to_binary_function</b> function object adaptor ·
353</p>

<p class=MsoIndex1><b>pointer_to_unary_function</b> function object adaptor ·
352</p>

<p class=MsoIndex1>policies · 291</p>

<p class=MsoIndex1>policy class · 293</p>

<p class=MsoIndex1>polymorphism · 564</p>

<p class=MsoIndex1>PoolExecutor (Concurrency) · 703</p>

<p class=MsoIndex1><b>pop_heap</b> algorithm · 404, 499</p>

<p class=MsoIndex1>POSIX standard · 145</p>

<p class=MsoIndex1>postcondition · 68</p>

<p class=MsoIndex1><b>precision(&nbsp;)</b> · 213</p>

<p class=MsoIndex1>precondition · 68</p>

<p class=MsoIndex1>predicate · 329; binary · 337; unary · 337</p>

<p class=MsoIndex1><b>prev_permutation </b>algorithm · 373</p>

<p class=MsoIndex1><b>printf(&nbsp;)</b> · 154; error code · 15</p>

<p class=MsoIndex1>priority, thread · 709</p>

<p class=MsoIndex1><b>priority_queue</b> · 496; as a heap · 499; <b>pop(&nbsp;)</b>
· 500</p>

<p class=MsoIndex1>private constructor · 620</p>

<p class=MsoIndex1>process, threading and · 691</p>

<p class=MsoIndex1>producer-consumer, threading · 747</p>

<p class=MsoIndex1>programming paradigms · 573</p>

<p class=MsoIndex1>protected constructor · 581</p>

<p class=MsoIndex1>Proxy design pattern · 632</p>

<p class=MsoIndex1><b>ptr_fun</b> function pointer adaptor · 351</p>

<p class=MsoIndex1>pure virtual function · 576</p>

<p class=MsoIndex1><b>push_back(&nbsp;)</b> · 434, 448, 482</p>

<p class=MsoIndex1><b>push_front(&nbsp;)</b> · 434, 448</p>

<p class=MsoIndex1><b>push_heap</b> algorithm · 404, 499</p>

<p class=MsoIndex1>put pointer · 176</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>Q</p>

</div>

<p class=MsoIndex1>qualified name · 274, 278</p>

<p class=MsoIndex1><b>queue</b> · 491</p>

<p class=MsoIndex1>queues, thread, for problem-solving · 750</p>

<p class=MsoIndex1>quicksort · 366</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>R</p>

</div>

<p class=MsoIndex1>race condition · 717</p>

<p class=MsoIndex1>RAII · 32, 36, 582</p>

<p class=MsoIndex1><b>raise(&nbsp;)</b> · 16</p>

<p class=MsoIndex1><b>rand(&nbsp;)</b> · 215</p>

<p class=MsoIndex1><b>RAND_MAX</b> · 215</p>

<p class=MsoIndex1><b>random_shuffle</b> algorithm · 374</p>

<p class=MsoIndex1>random-access iterator · 446</p>

<p class=MsoIndex1><b>RandomAccessIterator</b> · 364</p>

<p class=MsoIndex1>range, of sequence · 326</p>

<p class=MsoIndex1>raw byte I/O · 165</p>

<p class=MsoIndex1><b>raw_storage_iterator</b> · 446, 452</p>

<p class=MsoIndex1><b>rbegin(&nbsp;)</b> · 445, 448</p>

<p class=MsoIndex1><b>rdbuf(&nbsp;)</b> · 174</p>

<p class=MsoIndex1><b>read(&nbsp;)</b> · 165</p>

<p class=MsoIndex1>refactoring · 70</p>

<p class=MsoIndex1>reference counting · 582, 634; ZThreads (Concurrency) · 712</p>

<p class=MsoIndex1>references: <b>bad_cast</b> · 557; exception handling · 34,
56</p>

<p class=MsoIndex1><b>remove</b> algorithm · 389</p>

<p class=MsoIndex1><b>remove_copy</b> algorithm · 389</p>

<p class=MsoIndex1><b>remove_copy_if</b> algorithm · 329, 339, 350, 390</p>

<p class=MsoIndex1><b>remove_if</b> algorithm · 389</p>

<p class=MsoIndex1>removing elements, algorithm · 389</p>

<p class=MsoIndex1><b>rend(&nbsp;)</b> · 445, 448</p>

<p class=MsoIndex1>reordering, stable and unstable · 366</p>

<p class=MsoIndex1><b>replace</b> algorithm · 380</p>

<p class=MsoIndex1><b>replace_copy</b> algorithm · 380</p>

<p class=MsoIndex1><b>replace_copy_if</b> algorithm · 330, 380</p>

<p class=MsoIndex1><b>replace_if</b> algorithm · 330, 380</p>

<p class=MsoIndex1>reporting errors in book · 10</p>

<p class=MsoIndex1>requirements · 70</p>

<p class=MsoIndex1><b>reserve(&nbsp;)</b> · 458</p>

<p class=MsoIndex1><b>resize(&nbsp;)</b> · 456</p>

<p class=MsoIndex1>Resource Acquisition Is Initialization (RAII) · 32, 36, 582</p>

<p class=MsoIndex1>responsive user interfaces · 700</p>

<p class=MsoIndex1><b>result_type</b> · 342</p>

<p class=MsoIndex1>resumption, vs. termination, exception handling · 22</p>

<p class=MsoIndex1>rethrow, exception · 26, 52</p>

<p class=MsoIndex1><b>reverse</b> algorithm · 372</p>

<p class=MsoIndex1><b>reverse_copy</b> algorithm · 372</p>

<p class=MsoIndex1><b>reverse_iterator</b> · 445, 448, 487</p>

<p class=MsoIndex1>reversible container · 445</p>

<p class=MsoIndex1><b>rope</b> non-standard string class · 539</p>

<p class=MsoIndex1><b>rotate</b> algorithm · 373</p>

<p class=MsoIndex1><b>rotate_copy</b> algorithm · 373</p>

<p class=MsoIndex1><b>Runnable</b> · 696</p>

<p class=MsoIndex1>runtime cast · 551</p>

<p class=MsoIndex1>runtime stack · 228</p>

<p class=MsoIndex1>runtime type identification · 551; casting to intermediate
levels · 560; <b>const</b> and <b>volatile</b> and · 558; difference between <b>dynamic_cast</b>
and <b>typeid</b> · 561; efficiency · 565; mechanism &amp; overhead · 570;
misuse · 564; multiple inheritance · 560, 563, 570; templates and · 562; <b>type_info</b>
· 570; <b>type_info</b> class · 557; <b>type_info::before(&nbsp;)</b> · 559; <b>type_info::name(&nbsp;)</b>
· 559; <b>typeid</b> operator · 557; void pointers · 561; VTABLE · 570; when to
use it · 564</p>

<p class=MsoIndex1><b>runtime_error</b> class · 38</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>S</p>

</div>

<p class=MsoIndex1>Saks, Dan · 282</p>

<p class=MsoIndex1>Schwarz, Jerry · 201</p>

<p class=MsoIndex1><b>search</b> algorithm · 379</p>

<p class=MsoIndex1><b>search_n</b> algorithm · 379</p>

<p class=MsoIndex1>searching and replacing algorithms · 377</p>

<p class=MsoIndex1><b>second_argument_type</b> · 342</p>

<p class=MsoIndex1><b>seekg(&nbsp;)</b> · 176</p>

<p class=MsoIndex1>seeking in iostreams · 175</p>

<p class=MsoIndex1><b>seekp(&nbsp;)</b> · 176</p>

<p class=MsoIndex1>separation model, of template compilation · 319</p>

<p class=MsoIndex1>sequence: <b>at(&nbsp;)</b> · 470; container · 433;
converting between sequences · 467; <b>deque</b> · 465; <b>erase(&nbsp;)</b> ·
457; expanding with <b>resize(&nbsp;)</b> · 456; <b>insert(&nbsp;)</b> · 457; <b>list</b>
· 471; operations · 454; <b>operator[&nbsp;]</b> · 471; random-access · 470; <b>swap(
)</b> · 457; swapping sequences · 477; <b>vector</b> · 457</p>

<p class=MsoIndex1>serialization: object · 215; thread · 750</p>

<p class=MsoIndex1><b>set</b> · 479, 513; <b>find(&nbsp;)</b> · 480; operations
· 400; ordering of · 480; STL set class example · 432; vs. <b>list</b> · 476</p>

<p class=MsoIndex1><b>set_difference</b> algorithm · 401</p>

<p class=MsoIndex1><b>set_intersection</b> algorithm · 401</p>

<p class=MsoIndex1><b>set_symmetric_difference</b> algorithm · 402</p>

<p class=MsoIndex1><b>set_terminate(&nbsp;)</b> · 27</p>

<p class=MsoIndex1><b>set_unexpected(&nbsp;)</b> · 41</p>

<p class=MsoIndex1><b>set_union</b> algorithm · 401</p>

<p class=MsoIndex1><b>setf(&nbsp;)</b> · 187, 213</p>

<p class=MsoIndex1><b>setjmp(&nbsp;)</b> · 16</p>

<p class=MsoIndex1><b>setPriority(&nbsp;)</b> · 711</p>

<p class=MsoIndex1><b>setw(&nbsp;)</b> · 213</p>

<p class=MsoIndex1>Sieve of Eratosthenes · 119</p>

<p class=MsoIndex1><b>signal(&nbsp;)</b> · 16, 53; threading · 734, 742</p>

<p class=MsoIndex1>Singleton · 460, 619; implemented with curiously recurring
template pattern · 624; Meyers’ Singleton · 623; ZThreads library (concurrency)
· 728</p>

<p class=MsoIndex1><b>sleep(&nbsp;),</b> threading · 707, 734</p>

<p class=MsoIndex1>slice, <b>valarray</b> · 542</p>

<p class=MsoIndex1>slicing, object slicing and exception handling · 23</p>

<p class=MsoIndex1><b>slist</b> non-standard container · 539</p>

<p class=MsoIndex1>Smalltalk · 573</p>

<p class=MsoIndex1><b>smanip</b> · 201</p>

<p class=MsoIndex1>smart pointer · 437</p>

<p class=MsoIndex1>software quality · 63</p>

<p class=MsoIndex1><b>sort</b> algorithm · 366, 393</p>

<p class=MsoIndex1><b>sort_heap</b> algorithm · 404</p>

<p class=MsoIndex1>sorting algorithms · 393</p>

<p class=MsoIndex1>specialization: function template · 261; template · 260</p>

<p class=MsoIndex1>specification, exception · 40</p>

<p class=MsoIndex1><b>srand(&nbsp;)</b> · 214</p>

<p class=MsoIndex1>stable reordering · 366</p>

<p class=MsoIndex1><b>stable_partition</b> algorithm · 374</p>

<p class=MsoIndex1><b>stable_sort</b> algorithm · 366, 393</p>

<p class=MsoIndex1><b>stack</b> · 487; exception safety of · 489; <b>pop(&nbsp;)</b>
· 489; <b>push(&nbsp;)</b> · 489; <b>top(&nbsp;)</b> · 489</p>

<p class=MsoIndex1>stack frame · 58</p>

<p class=MsoIndex1>stack unwinding · 19</p>

<p class=MsoIndex1>Standard C · 9</p>

<p class=MsoIndex1>Standard C++ · 9; concurrency · 694; exception types · 38</p>

<p class=MsoIndex1>State design pattern · 634</p>

<p class=MsoIndex1><b>stdio</b> · 151</p>

<p class=MsoIndex1>STL extensions · 538</p>

<p class=MsoIndex1>Strategy design pattern · 640</p>

<p class=MsoIndex1><b>strcmp(&nbsp;)</b> · 217</p>

<p class=MsoIndex1>stream · 156; errors · 165; iterator · 331, 450; output
formatting · 186; state · 165</p>

<p class=MsoIndex1><b>streambuf</b> · 173; <b>get(&nbsp;)</b> · 174; <b>rdbuf(&nbsp;)</b>
· 174</p>

<p class=MsoIndex1><b>streampos</b> · 176</p>

<p class=MsoIndex1>strict weak ordering · 337</p>

<p class=MsoIndex1><b>StrictWeakOrdering</b> · 374, 403</p>

<p class=MsoIndex1><b>string</b> · 103; <b>append(&nbsp;)</b> · 110; <b>at(&nbsp;)</b>
· 132; <b>c_str(&nbsp;)</b> · 131; <b>capacity(&nbsp;)</b> · 111;
case-insensitive search · 120; character traits · 134; <b>compare(&nbsp;)</b> ·
131; concatenation · 117; <b>empty(&nbsp;)</b> · 356; <b>erase(&nbsp;)</b> ·
126; <b>find(&nbsp;)</b> · 115; <b>find_first_not_of(&nbsp;)</b> · 118; <b>find_first_of(&nbsp;)</b>
· 118; <b>find_last_not_of(&nbsp;)</b> · 118; <b>find_last_of(&nbsp;)</b> ·
118; getline(&nbsp;) · 129; indexing operations · 133; <b>insert(&nbsp;)</b> ·
110; iterator · 108; <b>length(&nbsp;)</b> · 111; memory management · 110, 114;
<b>npos</b> member · 114; <b>operator!=</b> · 129; <b>operator[&nbsp;]</b> ·
132; <b>operator+</b> · 117; <b>operator+=</b> · 117; <b>operator&lt;</b> ·
129; <b>operator&lt;=</b> · 129; <b>operator==</b> · 129; <b>operator&gt;</b> ·
129; <b>operator&gt;=</b> · 129; reference-counted · 104; relational operators
· 129; <b>replace(&nbsp;)</b> · 112; <b>reserve(&nbsp;)</b> · 111; <b>resize(&nbsp;)</b>
· 111; <b>rfind(&nbsp;)</b> · 118; <b>size(&nbsp;)</b> · 111; stream I/O · 156;
<b>substr(&nbsp;)</b> · 107; <b>swap(&nbsp;)</b> · 132; transforming strings to
typed values · 181</p>

<p class=MsoIndex1>string streams · 179</p>

<p class=MsoIndex1><b>stringbuf</b> · 183</p>

<p class=MsoIndex1>stringizing, preprocessor operator · 193</p>

<p class=MsoIndex1>Stroustrup, Bjarne · 101</p>

<p class=MsoIndex1><b>struct tm</b> · 213</p>

<p class=MsoIndex1>structural design patterns · 615</p>

<p class=MsoIndex1>subobject, duplicate subobjects in multiple inheritance ·
585</p>

<p class=MsoIndex1>subtasks · 691</p>

<p class=MsoIndex1>suite, test · 79</p>

<p class=MsoIndex1>surrogate, in design patterns · 631</p>

<p class=MsoIndex1><b>swap </b> algorithm · 419</p>

<p class=MsoIndex1><b>swap_ranges</b> algorithm · 373</p>

<p class=MsoIndex1>synchronization: (concurrency) example of problem from lack
of synchronization · 732; blocking · 734; thread · 719</p>

<p class=MsoIndex1><b>Synchronization_Exception</b>, ZThread library · 698, 703</p>

<p class=MsoIndex1>synchronized, threading, wrapper for an entire class · 723</p>

<p class=MsoIndex1><b>SynchronousExecutor</b> (Concurrency) · 705</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>T</p>

</div>

<p class=MsoIndex1>tag, iterator tag classes · 447</p>

<p class=MsoIndex1>task, defining for threading · 696</p>

<p class=MsoIndex1><b>tellg(&nbsp;)</b> · 176</p>

<p class=MsoIndex1><b>tellp(&nbsp;)</b> · 176</p>

<p class=MsoIndex1>template: argument-dependent lookup in · 274; code bloat,
preventing · 268; compilation · 274; compilation models · 315; compilation,
two-phase · 274; curiously recurring template pattern · 294; default arguments
· 230; dependent names in · 274; explicit instantiation · 316; <b>export</b> ·
319; expression templates · 308; friend template · 284; friends · 279; function
· 245; idioms · 285; inclusion compilation model · 315; instantiation · 260;
keyword · 240; member · 242; member, and <b>virtual</b> keyword · 245;
metaprogramming · 297; name lookup issues · 273; names in · 273; non-type
parameters · 228; parameters · 227; partial ordering of class templates · 263;
partial ordering of function templates · 259; partial specialization · 263;
policy-based design · 291; qualified names in · 274, 278; runtime type identification
and · 562; separation compilation model · 319; specialization · 260; template
template parameters · 232; traits · 285</p>

<p class=MsoIndex1>Template Method design pattern · 639</p>

<p class=MsoIndex1><b>terminate(&nbsp;)</b> · 27, 44; uncaught exceptions · 26</p>

<p class=MsoIndex1>terminating threads · 735</p>

<p class=MsoIndex1>termination problem, concurrency · 727</p>

<p class=MsoIndex1>termination, vs. resumption, exception handling · 22</p>

<p class=MsoIndex1>test: automated unit testing · 71; Boolean expressions in
testing · 72; framework · 75; suite · 79; test-first programming · 71; unit ·
70</p>

<p class=MsoIndex1><b>Test</b> class · 76</p>

<p class=MsoIndex1><b>TestSuite</b> framework · 75</p>

<p class=MsoIndex1>text processing · 103</p>

<p class=MsoIndex1>thread · 691; atomic operation · 732; blocked · 734; <b>broadcast(&nbsp;)</b>
· 734, 742, 757; busy wait · 732, 743; <b>Cancelable</b>, ZThread library class
· 717; colliding over resources, improperly accessing shared resources · 715;
concurrency · 691; <b>Condition</b> class for <b>wait(&nbsp;)</b> and <b>signal(&nbsp;)</b>
· 742; cooperation · 741; dead state · 734; deadlock · 720, 764; deadlock, and
priorities · 709; dining philosophers · 764; drawbacks · 771; example of
problem from lack of synchronization · 732; <b>getPriority(&nbsp;)</b> · 711;
handshaking between tasks · 742; I/O and threads, blocking · 737; <b>interrupt(&nbsp;)</b>
· 735; interrupted status · 739; <b>Interrupted_Exception</b> · 739; iostreams
and colliding output · 727; memory management · 711; multiple, for
problem-solving · 741; mutex, for handshaking · 742; mutex, simplifying with
the <b>Guard</b> template · 721; new state · 734; order of task shutdown · 717;
order of thread execution · 708; priority · 709; producer-consumer · 747; queues
solve problems · 750; race condition · 717; reference counting · 712; reference
counting with <b>CountedPtr</b> · 714; runnable state · 734; serialization ·
750; <b>setPriority(&nbsp;)</b> · 711; sharing resources · 711; <b>signal(&nbsp;)</b>
· 734, 742; <b>sleep(&nbsp;)</b> · 707, 734; states · 734; synchronization ·
719; synchronization and blocking · 734; synchronized wrapper for an entire
class · 723; termination · 735; termination problem · 727; thread local storage
· 724; threads and efficiency · 693; TQueue, solving threading problems with ·
750; <b>wait(&nbsp;)</b> · 734, 742; when to use threads · 771; <b>yield(&nbsp;)</b>
· 706; ZThread <b>FastMutex</b> · 731</p>

<p class=MsoIndex1><b>ThreadedExecutor</b> (Concurrency) · 702</p>

<p class=MsoIndex1>throughput, optimize · 692</p>

<p class=MsoIndex1><b>throw</b> · 19</p>

<p class=MsoIndex1>throwing an exception · 18</p>

<p class=MsoIndex1><b>time(&nbsp;)</b> · 214</p>

<p class=MsoIndex1><b>time_get</b> · 220</p>

<p class=MsoIndex1><b>time_put</b> · 220</p>

<p class=MsoIndex1><b>tolower</b> · 252</p>

<p class=MsoIndex1><b>toupper</b> · 252</p>

<p class=MsoIndex1><b>TQueue</b>, solving threading problems with · 750</p>

<p class=MsoIndex1>trace: file · 88; macro · 87</p>

<p class=MsoIndex1>traits · 285; iterator · 366</p>

<p class=MsoIndex1><b>transform </b>algorithm · 252, 347, 349, 355, 405</p>

<p class=MsoIndex1>transforming character strings to typed values · 181</p>

<p class=MsoIndex1><b>try</b> · 20</p>

<p class=MsoIndex1>try block · 20; function-level · 36</p>

<p class=MsoIndex1>type: automatic type conversions and exception handling ·
23; deduction, of function template parameters · 245; incomplete · 163; runtime
type identification (RTTI) · 551</p>

<p class=MsoIndex1><b>type_info</b>: <b>name</b> function · 244; structure ·
570</p>

<p class=MsoIndex1><b>type_info</b> class · 557</p>

<p class=MsoIndex1><b>type_info::before(&nbsp;)</b> · 559</p>

<p class=MsoIndex1><b>type_info</b><b>::name(&nbsp;)</b> · 559</p>

<p class=MsoIndex1><b>typeid</b> operator · 244, 557; difference between <b>dynamic_cast</b>
and <b>typeid</b>, runtime type identification · 561</p>

<p class=MsoIndex1><b>typename</b>: keyword · 237; <b>typedef</b> · 240; versus
<b>class</b> · 240</p>

<p class=MsoIndex1>typing, weak · 579</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>U</p>

</div>

<p class=MsoIndex1>unary function · 337</p>

<p class=MsoIndex1>unary predicate · 337</p>

<p class=MsoIndex1><b>unary_composer</b> non-standard function object · 360</p>

<p class=MsoIndex1><b>unary_function</b> · 342, 352; <b>argument_type</b> ·
342; <b>result_type</b> · 342</p>

<p class=MsoIndex1><b>unary_negate </b>function object · 341</p>

<p class=MsoIndex1>uncaught exceptions · 26</p>

<p class=MsoIndex1><b>uncaught_exception( )</b> · 52</p>

<p class=MsoIndex1><b>unexpected(&nbsp;)</b> · 41</p>

<p class=MsoIndex1>Unicode · 216</p>

<p class=MsoIndex1><b>unique</b> algorithm · 390</p>

<p class=MsoIndex1><b>unique_copy</b> algorithm · 390</p>

<p class=MsoIndex1>unit buffering · 188</p>

<p class=MsoIndex1>unit test · 70</p>

<p class=MsoIndex1>unstable reordering · 366</p>

<p class=MsoIndex1>upcast · 603</p>

<p class=MsoIndex1><b>upper_bound</b> algorithm · 395</p>

<p class=MsoIndex1>Urlocker, Zack · 608</p>

<p class=MsoIndex1>user interface, responsive, with threading · 692, 700</p>

<p class=MsoIndex1>utility algorithms · 417</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>V</p>

</div>

<p class=MsoIndex1><b>valarray</b> · 540; slice · 542</p>

<p class=MsoIndex1><b>value_type</b> · 450</p>

<p class=MsoIndex1>van Rossum, Guido · 773</p>

<p class=MsoIndex1>Vandevoorde, Daveed · 308</p>

<p class=MsoIndex1><b>vector</b> · 457; <b>reserve(&nbsp;)</b> · 458</p>

<p class=MsoIndex1>vector of change · 614</p>

<p class=MsoIndex1><b>vector&lt;bool&gt;</b> · 263, 506, 511</p>

<p class=MsoIndex1>Veldhuizen, Todd · 308</p>

<p class=MsoIndex1>virtual: base class · 563, 589; base, initialization of ·
592; destructor · 581; function table · 654; pure virtual functions · 576;
simulating virtual constructors · 654; virtual functions inside constructors ·
654</p>

<p class=MsoIndex1>Visitor design pattern · 683</p>

<p class=MsoIndex1>void · 561</p>

<p class=MsoIndex1>VPTR · 654</p>

<p class=MsoIndex1>VTABLE · 654; runtime type identification · 570</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>W</p>

</div>

<p class=MsoIndex1><b>wait(&nbsp;)</b>, threading · 734, 742</p>

<p class=MsoIndex1><b>wchar_t</b> · 216</p>

<p class=MsoIndex1><b>wcscmp(&nbsp;)</b> · 217</p>

<p class=MsoIndex1>weak typing · 579</p>

<p class=MsoIndex1>web servers, multiprocessor · 692</p>

<p class=MsoIndex1>wide: character · 216; stream · 216; stream function, <b>wcscmp(&nbsp;)</b>
· 217</p>

<p class=MsoIndex1><b>widen(&nbsp;)</b> · 218</p>

<p class=MsoIndex1>Will-Harris, Daniel · 11</p>

<p class=MsoIndex1>wrapping, class · 151</p>

<p class=MsoIndex1><b>write(&nbsp;)</b> · 165, 213</p>

<p class=MsoIndex1><b>ws</b> · 195</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>X</p>

</div>

<p class=MsoIndex1>XP, Extreme Programming · 71, 615</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>Y</p>

</div>

<p class=MsoIndex1><b>yield(&nbsp;)</b>, threading · 706</p>

<div style='border:none;border-top:solid windowtext 1.5pt;padding:0in 0in 0in 0in;
margin-left:.25in;margin-right:0in'>

<p class=MsoIndexHeading style='margin-left:0in;page-break-after:avoid'>Z</p>

</div>

<p class=MsoIndex1>zero initialization · 522</p>

<p class=MsoIndex1>Zolman, Leor · 320</p>

<p class=MsoIndex1>ZThread: <b>Cancelable</b> class · 717; Executors · 702;
installing the library · 695; multithreading library for C++ · 694</p>

</div>

<sup><span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:auto'>
</span></sup>

<div class=Section26>

<p class=MsoNormal></p>

</div>

<sup><span style='font-size:10pt;font-family:Verdana'><br clear=all
style='page-break-before:always'>
</span></sup>

<div><br clear=all>

<hr align=left size=1 width="33%">

<div id=ftn1>

<p class=MsoFootnoteText><a href="#_ftnref1" name="_ftn1"><span
class=MsoFootnoteReference>[1]</span></a> You
might be surprised when you run the example—some C++ compilers have extended <b>longjmp(&nbsp;)</b>
to clean up objects on the stack. This behavior is not portable.</p>

</div>

<div id=ftn2>

<p class=MsoFootnoteText><a href="#_ftnref2" name="_ftn2"><span
class=MsoFootnoteReference>[2]</span></a> The
BASIC language has long supported a limited form of resumptive exception
handling with its ON ERROR facility.</p>

</div>

<div id=ftn3>

<p class=MsoFootnoteText><a href="#_ftnref3" name="_ftn3"><span
class=MsoFootnoteReference>[3]</span></a> You
might always want to specify exception objects by <b>const</b> reference in
exception handlers. (It’s rare to modify and rethrow an exception.) However, we
are not dogmatic about this practice.</p>

</div>

<div id=ftn4>

<p class=MsoFootnoteText><a href="#_ftnref4" name="_ftn4"><span
class=MsoFootnoteReference>[4]</span></a> Only
<i>unambiguous, accessible base classes</i> can catch derived exceptions. This
rule minimizes the runtime overhead needed to validate exceptions. Remember
that exceptions are checked at runtime, not at compile time, and therefore the
extensive information available at compile time is not available during
exception handling.</p>

</div>

<div id=ftn5>

<p class=MsoFootnoteText><a href="#_ftnref5" name="_ftn5"><span
class=MsoFootnoteReference>[5]</span></a> Note
that there’s an exception class called <b>std::out_of_range</b> in the C++
Standard Library, intended to be used in situations such as this.</p>

<p class=MsoFootnoteText>&nbsp;</p>

</div>

<div id=ftn6>

<p class=MsoFootnoteText><a href="#_ftnref6" name="_ftn6"><span
class=MsoFootnoteReference>[6]</span></a> For
more detail on <b>auto_ptr</b>, see Herb Sutter’s article entitled, “Using
auto_ptr Effectively” in the October 1999 issue of the <i>C/C++ Users Journal</i>,
pp. 63–67.</p>

</div>

<div id=ftn7>

<p class=MsoFootnoteText><a href="#_ftnref7" name="_ftn7"><span
class=MsoFootnoteReference>[7]</span></a> If
you’re interested in a more in–depth analysis of exception safety issues, the
definitive reference is Herb Sutter’s <i>Exceptional C++</i>, Addison–Wesley,
2000.</p>

</div>

<div id=ftn8>

<p class=MsoFootnoteText><a href="#_ftnref8" name="_ftn8"><span
class=MsoFootnoteReference>[8]</span></a> The
library function <b>uncaught_exception(&nbsp;)</b> returns <b>true</b> in the
middle of stack unwinding, so technically you can test <b>uncaught_exception(&nbsp;)</b>
for <b>false</b> and let an exception escape from a destructor. We’ve never
seen a situation in which this constituted good design, however, so we only
mention it in this footnote.</p>

</div>

<div id=ftn9>

<p class=MsoFootnoteText><a href="#_ftnref9" name="_ftn9"><span
class=MsoFootnoteReference>[9]</span></a> Some
compilers do throw exceptions in these cases, but they usually provide a
compiler option to disable this (unusual) behavior.</p>

</div>

<div id=ftn10>

<p class=MsoFootnoteText><a href="#_ftnref10" name="_ftn10"><span
class=MsoFootnoteReference>[10]</span></a> Check
out the Boost smart pointer types at http://www.boost.org/libs/smart_ptr/index.htm.
Some of these are being considered for inclusion in the next revision of
Standard C++.</p>

</div>

<div id=ftn11>

<p class=MsoFootnoteText><a href="#_ftnref11" name="_ftn11"><span
class=MsoFootnoteReference>[11]</span></a> This
depends on how much return code checking you would have to insert if you
weren’t using exceptions.</p>

</div>

<div id=ftn12>

<p class=MsoFootnoteText><a href="#_ftnref12" name="_ftn12"><span
class=MsoFootnoteReference>[12]</span></a> Borland
enables exceptions by default; to disable exceptions use the<br>
<b>–x</b>– compiler option. Microsoft disables support by default; to turn it
on, use the <b>–GX</b> option. With both compilers use the <b>–c</b> option to
compile only.</p>

</div>

<div id=ftn13>

<p class=MsoFootnoteText><a href="#_ftnref13" name="_ftn13"><span
class=MsoFootnoteReference>[13]</span></a> The
GNU C++ compiler uses the zero–cost model by default. Metrowerks Code Warrior
for C++ also has an option to use the zero–cost model.</p>

</div>

<div id=ftn14>

<p class=MsoFootnoteText><a href="#_ftnref14" name="_ftn14"><span
class=MsoFootnoteReference>[14]</span></a> Thanks
to Scott Meyers and Josee Lajoie for their insights on the zero–cost model. You
can find more information on how exceptions work in Josee’s excellent article,
“Exception Handling: Behind the Scenes,” <i>C++ Gems</i>, SIGS, 1996.</p>

</div>

<div id=ftn15>

<p class=MsoFootnoteText><a href="#_ftnref15" name="_ftn15"><span
class=MsoFootnoteReference>[15]</span></a> He
invented Quicksort, among other things.</p>

</div>

<div id=ftn16>

<p class=MsoFootnoteText><a href="#_ftnref16" name="_ftn16"><span
class=MsoFootnoteReference>[16]</span></a> As
quoted in <i>Programming Language Pragmatics</i>, by Michael L. Scott,
Morgan–Kaufmann, 2000.</p>

</div>

<div id=ftn17>

<p class=MsoFootnoteText><a href="#_ftnref17" name="_ftn17"><span
class=MsoFootnoteReference>[17]</span></a> See
his book, <i>Object–Oriented Software Construction</i>, Prentice–Hall, 1994.</p>

</div>

<div id=ftn18>

<p class=MsoFootnoteText><a href="#_ftnref18" name="_ftn18"><span
class=MsoFootnoteReference>[18]</span></a> This
is still an assertion <i>conceptually</i>, but since we don’t want to halt
execution, the <b>assert(&nbsp;)</b> macro is not appropriate. Java 1.4, for
example, throws an exception when an assertion fails.</p>

</div>

<div id=ftn19>

<p class=MsoFootnoteText><a href="#_ftnref19" name="_ftn19"><span
class=MsoFootnoteReference>[19]</span></a> There
is a nice phrase to help remember this phenomenon: “Require no more; promise no
less,” first coined in <i>C++ FAQs</i>, by Marshall Cline and Greg Lomow
(Addison–Wesley, 1994). Since pre–conditions can weaken in derived classes, we
say that they are <i>contravariant</i>, and, conversely, post–conditions are <i>covariant</i>
(which explains why we mentioned the covariance of exception specifications in
Chapter 1).</p>

</div>

<div id=ftn20>

<p class=MsoFootnoteText><a href="#_ftnref20" name="_ftn20"><span
class=MsoFootnoteReference>[20]</span></a> This
section is based on Chuck’s article, “The Simplest Automated Unit Test
Framework That Could Possibly Work,” <i>C/C++ Users Journal</i>, Sept. 2000.</p>

</div>

<div id=ftn21>

<p class=MsoFootnoteText><a href="#_ftnref21" name="_ftn21"><span
class=MsoFootnoteReference>[21]</span></a> A
good book on this subject is Martin Fowler’s <i>Refactoring: Improving the
Design of Existing Code</i> (Addison–Wesley, 2000). See also http://www.refactoring.com.
Refactoring is a crucial practice of Extreme Programming (XP).</p>

</div>

<div id=ftn22>

<p class=MsoFootnoteText><a href="#_ftnref22" name="_ftn22"><span
class=MsoFootnoteReference>[22]</span></a> See
<i>Extreme Programming Explained: Embrace Change</i> by Kent Beck, Addison
Wesley 1999. Lightweight methodologies such as XP have “joined forces” in the
Agile Alliance (see http://www.agilealliance.org/home).</p>

</div>

<div id=ftn23>

<p class=MsoFootnoteText><a href="#_ftnref23" name="_ftn23"><span
class=MsoFootnoteReference>[23]</span></a> Our
Date class is also “internationalized,” in that it supports wide character
sets. This is introduced at the end of the next chapter.</p>

</div>

<div id=ftn24>

<p class=MsoFootnoteText><a href="#_ftnref24" name="_ftn24"><span
class=MsoFootnoteReference>[24]</span></a> See
http://sourceforge.net/projects/cppunit for more information.</p>

</div>

<div id=ftn25>

<p class=MsoFootnoteText><a href="#_ftnref25" name="_ftn25"><span
class=MsoFootnoteReference>[25]</span></a> This
is a key principle of Extreme Programming.</p>

</div>

<div id=ftn26>

<p class=MsoFootnoteText><a href="#_ftnref26" name="_ftn26"><span
class=MsoFootnoteReference>[26]</span></a> “Runtime
Type Identification,” discussed in chapter 9. Specifically, we use the <b>name(&nbsp;)</b>
member function of the <b>typeinfo</b> class. If you’re using Microsoft Visual
C++, you need to specify the compile option <b>/GR</b>. If you don’t, you’ll
get an access violation at runtime.</p>

</div>

<div id=ftn27>

<p class=MsoFootnoteText><a href="#_ftnref27" name="_ftn27"><span
class=MsoFootnoteReference>[27]</span></a> In
particular, we use <i>stringizing</i> (via the <b>#</b> preprocessing operator)
and the predefined macros <b>__FILE</b>__ and <b>__LINE__</b>. See the code
later in the chapter.</p>

</div>

<div id=ftn28>

<p class=MsoFootnoteText><a href="#_ftnref28" name="_ftn28"><span
class=MsoFootnoteReference>[28]</span></a> Batch
files and shell scripts work well for this. The <b>Suite</b> class is a
C++–based way of organizing related tests.</p>

</div>

<div id=ftn29>

<p class=MsoFootnoteText><a href="#_ftnref29" name="_ftn29"><span
class=MsoFootnoteReference>[29]</span></a> Our
key technical reviewer, Pete Becker of Dinkumware. Ltd., brought to our attention
that it is illegal to use macros to replace C++ keywords. His take on this
technique was as follows: “This is a dirty trick. Dirty tricks are sometimes
necessary to figure out why code isn’t working, so you may want to keep this in
your toolbox, but don’t ship any code with it.” Caveat programmer.</p>

</div>

<div id=ftn30>

<p class=MsoFootnoteText><a href="#_ftnref30" name="_ftn30"><span
class=MsoFootnoteReference>[30]</span></a> Thanks
to Reg Charney of the C++ Standards Committee for suggesting this trick.</p>

</div>

<div id=ftn31>

<p class=MsoFootnoteText><a href="#_ftnref31" name="_ftn31"><span
class=MsoFootnoteReference>[31]</span></a> Some
of the material in this chapter was originally created by Nancy Nicolaisen.</p>

</div>

<div id=ftn32>

<p class=MsoFootnoteText><a href="#_ftnref32" name="_ftn32"><span
class=MsoFootnoteReference>[32]</span></a> It’s
difficult to make reference–counting implementations thread safe. (See Herb
Sutter, <i>More Exceptional C++</i>, pp. 104–14). See Chapter 10 for more on
programming with multiple threads.</p>

</div>

<div id=ftn33>

<p class=MsoFootnoteText><a href="#_ftnref33" name="_ftn33"><span
class=MsoFootnoteReference>[33]</span></a> It
is an abbreviation for “no position,” and is the largest value that can be
represented by the string allocator’s <b>size_type</b> (<b>std::size_t</b> by
default).</p>

</div>

<div id=ftn34>

<p class=MsoFootnoteText><a href="#_ftnref34" name="_ftn34"><span
class=MsoFootnoteReference>[34]</span></a> Discussed
in depth in Chapter 6.</p>

</div>

<div id=ftn35>

<p class=MsoFootnoteText><a href="#_ftnref35" name="_ftn35"><span
class=MsoFootnoteReference>[35]</span></a> To
keep the exposition simple, this version does not handle nested tags, such as
comments.</p>

</div>

<div id=ftn36>

<p class=MsoFootnoteText><a href="#_ftnref36" name="_ftn36"><span
class=MsoFootnoteReference>[36]</span></a> It
is tempting to use mathematics here to factor out some of these calls to <b>erase(&nbsp;)</b>,
but since in some cases one of the operands is <b>string::npos</b> (the largest
unsigned integer available), integer overflow occurs and wrecks the algorithm.</p>

</div>

<div id=ftn37>

<p class=MsoFootnoteText><a href="#_ftnref37" name="_ftn37"><span
class=MsoFootnoteReference>[37]</span></a> For
the safety reasons mentioned, the C++ Standards Committee is considering a
proposal to redefine <b>string::operator[]</b> to behave identically to <b>string::at(&nbsp;)</b>
for C++0x.</p>

</div>

<div id=ftn38>

<p class=MsoFootnoteText><a href="#_ftnref38" name="_ftn38"><span
class=MsoFootnoteReference>[38]</span></a> Your
implementation can define all three template arguments here. Because the last
two template parameters have default arguments, such a declaration is
equivalent to what we show here.</p>

</div>

<div id=ftn39>

<p class=MsoFootnoteText><a href="#_ftnref39" name="_ftn39"><span
class=MsoFootnoteReference>[39]</span></a> Beware
that some versions of Microsoft Word erroneously replace single quote
characters with an extended ASCII character when you save a document as text,
which causes a compile error. We have no idea why this happens. Just replace
the character manually with an apostrophe.</p>

</div>

<div id=ftn40>

<p class=MsoFootnoteText><a href="#_ftnref40" name="_ftn40"><span
class=MsoFootnoteReference>[40]</span></a> POSIX,
an IEEE standard, stands for “Portable Operating System Interface” and is a
generalization of many of the low–level system calls found in UNIX systems.</p>

</div>

<div id=ftn41>

<p class=MsoFootnoteText><a href="#_ftnref41" name="_ftn41"><span
class=MsoFootnoteReference>[41]</span></a> Explained
in depth in Chapter 5.</p>

</div>

<div id=ftn42>

<p class=MsoFootnoteText><a href="#_ftnref42" name="_ftn42"><span
class=MsoFootnoteReference>[42]</span></a> For
this reason, you can write <b>ios::failbit</b> instead of <b>ios_base::failbit</b>
to save typing.</p>

</div>

<div id=ftn43>

<p class=MsoFootnoteText><a href="#_ftnref43" name="_ftn43"><span
class=MsoFootnoteReference>[43]</span></a> It
is customary to use <b>operator void*(&nbsp;)</b> in preference to <b>operator
bool(&nbsp;)</b> because the implicit conversions from <b>bool</b> to <b>int</b>
may cause surprises, should you incorrectly place a stream in a context where
an integer conversion can be applied. The <b>operator void*(&nbsp;)</b>
function will only be called implicitly in the body of a Boolean expression.</p>

</div>

<div id=ftn44>

<p class=MsoFootnoteText><a href="#_ftnref44" name="_ftn44"><span
class=MsoFootnoteReference>[44]</span></a> An
integral type used to hold single–bit flags.</p>

</div>

<div id=ftn45>

<p class=MsoFootnoteText><a href="#_ftnref45" name="_ftn45"><span
class=MsoFootnoteReference>[45]</span></a> A
more in–depth treatment of stream buffers and streams in general can be found
in Langer &amp; Kreft’s, <i>Standard C++ iostreams and Locales</i>,
Addison–Wesley, 1999.</p>

</div>

<div id=ftn46>

<p class=MsoFootnoteText><a href="#_ftnref46" name="_ftn46"><span
class=MsoFootnoteReference>[46]</span></a> For
more information on machine epsilon and floating–point computation in general,
see Chuck’s article, “The Standard C Library, Part 3,” <i>C/C++ Users Journal</i>,
March 1995, available at www.freshsources.com/1995006a.htm.</p>

</div>

<div id=ftn47>

<p class=MsoFootnoteText><a href="#_ftnref47" name="_ftn47"><span
class=MsoFootnoteReference>[47]</span></a> Before
putting <b>nl</b> into a header file, make it an <b>inline</b> function.</p>

</div>

<div id=ftn48>

<p class=MsoFootnoteText><a href="#_ftnref48" name="_ftn48"><span
class=MsoFootnoteReference>[48]</span></a> Jerry
Schwarz is the designer of iostreams.</p>

</div>

<div id=ftn49>

<p class=MsoFootnoteText><a href="#_ftnref49" name="_ftn49"><span
class=MsoFootnoteReference>[49]</span></a> See
the Langer &amp; Kreft book mentioned earlier for more detailed information.</p>

</div>

<div id=ftn50>

<p class=MsoFootnoteText><a href="#_ftnref50" name="_ftn50"><span
class=MsoFootnoteReference>[50]</span></a> See,
for example, Dinkumware’s Abridged library at http://www.dinkumware.com. This
library omits locale support. and exception support is optional.</p>

</div>

<div id=ftn51>

<p class=MsoFootnoteText><a href="#_ftnref51" name="_ftn51"><span
class=MsoFootnoteReference>[51]</span></a> Vandevoorde
and Josuttis, <i>C++ Templates: The Complete Guide</i>, Addison Wesley, 2003.
Note that “Daveed” sometimes appears as “David.”</p>

</div>

<div id=ftn52>

<p class=MsoFootnoteText><a href="#_ftnref52" name="_ftn52"><span
class=MsoFootnoteReference>[52]</span></a> The
C++ Standards Committee is considering relaxing the only–within–a–template rule
for these disambiguation hints, and some compilers allow them in non–template
code already.</p>

</div>

<div id=ftn53>

<p class=MsoFootnoteText><a href="#_ftnref53" name="_ftn53"><span
class=MsoFootnoteReference>[53]</span></a> See
Stroustrup, <i>The C++ Programming Language</i>, 3<sup>rd</sup> Edition,
Addison Wesley, pp. 335–336.</p>

</div>

<div id=ftn54>

<p class=MsoFootnoteText><a href="#_ftnref54" name="_ftn54"><span
class=MsoFootnoteReference>[54]</span></a> Technically,
comparing two pointers that are not inside the same array is undefined
behavior, but today’s compilers don’t complain about this. All the more reason
to do it right.</p>

</div>

<div id=ftn55>

<p class=MsoFootnoteText><a href="#_ftnref55" name="_ftn55"><span
class=MsoFootnoteReference>[55]</span></a> We
are indebted to Nathan Myers for this example.</p>

</div>

<div id=ftn56>

<p class=MsoFootnoteText><a href="#_ftnref56" name="_ftn56"><span
class=MsoFootnoteReference>[56]</span></a> Such
as type information encoded in a decorated name.</p>

</div>

<div id=ftn57>

<p class=MsoFootnoteText><a href="#_ftnref57" name="_ftn57"><span
class=MsoFootnoteReference>[57]</span></a> C++
compilers can introduce names anywhere they want, however. Fortunately, most
don’t declare names they don’t need.</p>

</div>

<div id=ftn58>

<p class=MsoFootnoteText><a href="#_ftnref58" name="_ftn58"><span
class=MsoFootnoteReference>[58]</span></a> If
you’re interested in seeing the proposal, it’s Core Issue 352.</p>

</div>

<div id=ftn59>

<p class=MsoFootnoteText><a href="#_ftnref59" name="_ftn59"><span
class=MsoFootnoteReference>[59]</span></a> A
reference to the British animated short films by Nick Park featuring Wallace
and Gromit.</p>

</div>

<div id=ftn60>

<p class=MsoFootnoteText><a href="#_ftnref60" name="_ftn60"><span
class=MsoFootnoteReference>[60]</span></a> We
discuss <b>vector&lt;bool&gt;</b> in depth in Chapter 7.</p>

</div>

<div id=ftn61>

<p class=MsoFootnoteText><a href="#_ftnref61" name="_ftn61"><span
class=MsoFootnoteReference>[61]</span></a> Instead
of <b>this–&gt;</b> you could use any valid qualification, such as <b>Sortable::at(&nbsp;)</b>
or <b>vector&lt;T&gt;::at(&nbsp;)</b>. The point is that it must be qualified.</p>

</div>

<div id=ftn62>

<p class=MsoFootnoteText><a href="#_ftnref62" name="_ftn62"><span
class=MsoFootnoteReference>[62]</span></a> See
also the explanation accompanying <b>PriorityQueue6.cpp</b> in Chapter 7.</p>

</div>

<div id=ftn63>

<p class=MsoFootnoteText><a href="#_ftnref63" name="_ftn63"><span
class=MsoFootnoteReference>[63]</span></a> Since
the forwarding functions are inline, no code for Stack&lt;void*&gt; is
generated at all!</p>

</div>

<div id=ftn64>

<p class=MsoFootnoteText><a href="#_ftnref64" name="_ftn64"><span
class=MsoFootnoteReference>[64]</span></a> Also
called <i>Koenig lookup</i>, after Andrew Koenig, who first proposed the
technique to the C++ Standards Committee. ADL applies universally, whether
templates are involved or not.</p>

</div>

<div id=ftn65>

<p class=MsoFootnoteText><a href="#_ftnref65" name="_ftn65"><span
class=MsoFootnoteReference>[65]</span></a> From
a presentation by Herb Sutter.</p>

</div>

<div id=ftn66>

<p class=MsoFootnoteText><a href="#_ftnref66" name="_ftn66"><span
class=MsoFootnoteReference>[66]</span></a> A
number of compilers use this front end, including Comeau C++.</p>

</div>

<div id=ftn67>

<p class=MsoFootnoteText><a href="#_ftnref67" name="_ftn67"><span
class=MsoFootnoteReference>[67]</span></a> Also
based on an example by Herb Sutter.</p>

</div>

<div id=ftn68>

<p class=MsoFootnoteText><a href="#_ftnref68" name="_ftn68"><span
class=MsoFootnoteReference>[68]</span></a> In
a talk given at <i>The C++ Seminar</i>, Portland, OR, September, 2001.</p>

</div>

<div id=ftn69>

<p class=MsoFootnoteText><a href="#_ftnref69" name="_ftn69"><span
class=MsoFootnoteReference>[69]</span></a> Another
template idiom, mixin inheritance, is covered in Chapter 9.</p>

</div>

<div id=ftn70>

<p class=MsoFootnoteText><a href="#_ftnref70" name="_ftn70"><span
class=MsoFootnoteReference>[70]</span></a> The
fact that <b>char_traits&lt;&gt;::compare(&nbsp;)</b> may call <b>strcmp(&nbsp;)</b>
in one instance vs. <b>wcscmp(&nbsp;)</b> in another, for example, is
immaterial to the point we make here: the “function” performed by <b>compare(&nbsp;)</b>
is the same.</p>

</div>

<div id=ftn71>

<p class=MsoFootnoteText><a href="#_ftnref71" name="_ftn71"><span
class=MsoFootnoteReference>[71]</span></a> <i>Modern
C++ Design: Generic Programming and Design Patterns Applied</i>, Addison
Wesley, 2001.</p>

</div>

<div id=ftn72>

<p class=MsoFootnoteText><a href="#_ftnref72" name="_ftn72"><span
class=MsoFootnoteReference>[72]</span></a> <i>C++
Gems</i>, edited by Stan Lippman, SIGS, 1996.</p>

</div>

<div id=ftn73>

<p class=MsoFootnoteText><a href="#_ftnref73" name="_ftn73"><span
class=MsoFootnoteReference>[73]</span></a> These
are technically compile–time constants, so you could argue that the identifiers
should be all uppercase letters to follow the usual form. We left them
lowercased because they are simulations of variables.</p>

</div>

<div id=ftn74>

<p class=MsoFootnoteText><a href="#_ftnref74" name="_ftn74"><span
class=MsoFootnoteReference>[74]</span></a> In
1966 Böhm and Jacopini proved that any language supporting selection and
repetition, along with the ability to use an arbitrary number of variables, is
equivalent to a Turing machine, which is believed capable of expressing any
algorithm.</p>

</div>

<div id=ftn75>

<p class=MsoFootnoteText><a href="#_ftnref75" name="_ftn75"><span
class=MsoFootnoteReference>[75]</span></a> Czarnecki
and Eisenecker, <i>Generative Programming: Methods, Tools, and Applications</i>,
Addison Wesley, 2000, p. 417.</p>

</div>

<div id=ftn76>

<p class=MsoFootnoteText><a href="#_ftnref76" name="_ftn76"><span
class=MsoFootnoteReference>[76]</span></a> There
is a much better way to compute powers of integers: the Russian Peasant
Algorithm.</p>

</div>

<div id=ftn77>

<p class=MsoFootnoteText><a href="#_ftnref77" name="_ftn77"><span
class=MsoFootnoteReference>[77]</span></a> <i>Modern
C++ Design</i>, pp. 23–26.</p>

</div>

<div id=ftn78>

<p class=MsoFootnoteText><a href="#_ftnref78" name="_ftn78"><span
class=MsoFootnoteReference>[78]</span></a> You
are not allowed to pass object types (other than built–ins) to an ellipsis
parameter specification, but since we are only asking for its size (a
compile–time operation), the expression is never actually evaluated at runtime.</p>

</div>

<div id=ftn79>

<p class=MsoFootnoteText><a href="#_ftnref79" name="_ftn79"><span
class=MsoFootnoteReference>[79]</span></a> A
reprint of Todd’s original article can be found in Lippman, <i>C++ Gems</i>,
SIGS, 1996. It should also be noted that besides retaining mathematical
notation and optimized code, expression templates also allow for C++ libraries
to incorporate paradigms and mechanisms found in other programming languages,
such as lambda expressions. Another example is the fantastic class library
Spirit, which is a parser that makes heavy use of expression templates,
allowing for (an approximate) EBNF notation directly in C++, resulting in
extremely efficient parsers. Visit http://spirit.sourceforge.net/.</p>

</div>

<div id=ftn80>

<p class=MsoFootnoteText><a href="#_ftnref80" name="_ftn80"><span
class=MsoFootnoteReference>[80]</span></a> See
his and Nico’s book, <i>C++ Templates</i>, book cited earlier.</p>

</div>

<div id=ftn81>

<p class=MsoFootnoteText><a href="#_ftnref81" name="_ftn81"><span
class=MsoFootnoteReference>[81]</span></a> Namely,
Blitz++ (http://www.oonumerics.org/blitz/), the Matrix Template Library (http://www.osl.iu.edu/research/mtl/),
and POOMA (http://www.acl.lanl.gov/pooma/).</p>

</div>

<div id=ftn82>

<p class=MsoFootnoteText><a href="#_ftnref82" name="_ftn82"><span
class=MsoFootnoteReference>[82]</span></a> We
mean “vector” in the mathematical sense, as a fixed–length, one–dimensional,
numerical array.</p>

</div>

<div id=ftn83>

<p class=MsoFootnoteText><a href="#_ftnref83" name="_ftn83"><span
class=MsoFootnoteReference>[83]</span></a> Langer
and Kreft, “C++ Expression Templates,” <i>C/C++ Users Journal</i>, March 2003.
See also the article on expression templates by Thomas Becker in the June 2003
issue of the same journal (that article was the inspiration for the material in
this section).</p>

</div>

<div id=ftn84>

<p class=MsoFootnoteText><a href="#_ftnref84" name="_ftn84"><span
class=MsoFootnoteReference>[84]</span></a> As
explained earlier, you must explicitly instantiate a template only once per
program.</p>

</div>

<div id=ftn85>

<p class=MsoFootnoteText><a href="#_ftnref85" name="_ftn85"><span
class=MsoFootnoteReference>[85]</span></a> Visit
http://www.bdsoft.com/tools/stlfilt.html.</p>

</div>

<div id=ftn86>

<p class=MsoFootnoteText><a href="#_ftnref86" name="_ftn86"><span
class=MsoFootnoteReference>[86]</span></a> Or
something that is callable as a function, as you’ll see shortly.</p>

</div>

<div id=ftn87>

<p class=MsoFootnoteText><a href="#_ftnref87" name="_ftn87"><span
class=MsoFootnoteReference>[87]</span></a> This
is simply an English rendition of <b>O(n log n)</b>, which is the mathematical
way of saying that for large <b>n</b>, the number of comparisons grows in
direct proportion to the function <b>f(n) = n log n</b>.</p>

</div>

<div id=ftn88>

<p class=MsoFootnoteText><a href="#_ftnref88" name="_ftn88"><span
class=MsoFootnoteReference>[88]</span></a> Unless
you do something ungainly using global variables.</p>

</div>

<div id=ftn89>

<p class=MsoFootnoteText><a href="#_ftnref89" name="_ftn89"><span
class=MsoFootnoteReference>[89]</span></a> Function
objects are also called <i>functors</i>, after a mathematical concept with
similar behavior.</p>

</div>

<div id=ftn90>

<p class=MsoFootnoteText><a href="#_ftnref90" name="_ftn90"><span
class=MsoFootnoteReference>[90]</span></a> The
spelling here is <i>adaptor</i>, following the use in the C++ Standard.
Elsewhere you will see it spelled <i>adapter</i> when used in the context of
design patterns, following the common spelling there. Both spellings are
considered acceptable by dictionaries.</p>

</div>

<div id=ftn91>

<p class=MsoFootnoteText><a href="#_ftnref91" name="_ftn91"><span
class=MsoFootnoteReference>[91]</span></a> There’s
a complication with different library implementations. If <b>pow(&nbsp;)</b>
has C linkage, meaning its name is not “mangled” like C++ functions, then this
example won’t compile. <b>ptr_fun</b> requires a pointer to a normal,
overloadable C++ function.</p>

</div>

<div id=ftn92>

<p class=MsoFootnoteText><a href="#_ftnref92" name="_ftn92"><span
class=MsoFootnoteReference>[92]</span></a> If
a compiler were to define <b>string::empty</b> with default arguments (which is
allowed), then the expression <b>&amp;string::empty</b> would define a pointer
to a member function taking the total number of arguments. Since there is no
way for the compiler to provide the extra defaults, there would be a “missing
argument” error when an algorithm applied <b>string::empty</b> via <b>mem_fun_ref</b>.</p>

</div>

<div id=ftn93>

<p class=MsoFootnoteText><a href="#_ftnref93" name="_ftn93"><span
class=MsoFootnoteReference>[93]</span></a> STLPort,
for instance, which comes with version 6 of Borland C++ Builder and the Digital
Mars compiler, and is based on SGI STL.</p>

</div>

<div id=ftn94>

<p class=MsoFootnoteText><a href="#_ftnref94" name="_ftn94"><span
class=MsoFootnoteReference>[94]</span></a> The
<b>stable_sort(&nbsp;)</b> algorithm uses <i>mergesort</i>, which is indeed
stable, but tends to run slower than <i>quicksort</i> on average.</p>

</div>

<div id=ftn95>

<p class=MsoFootnoteText><a href="#_ftnref95" name="_ftn95"><span
class=MsoFootnoteReference>[95]</span></a> Iterators
are discussed in more depth in the next chapter.</p>

</div>

<div id=ftn96>

<p class=MsoFootnoteText><a href="#_ftnref96" name="_ftn96"><span
class=MsoFootnoteReference>[96]</span></a> Algorithms
can determine the type of an iterator by reading its <b>tag</b>, discussed in
the next chapter.</p>

</div>

<div id=ftn97>

<p class=MsoFootnoteText><a href="#_ftnref97" name="_ftn97"><span
class=MsoFootnoteReference>[97]</span></a> We’re
ignoring the copy constructor and assignment operator in this example, since
they don’t apply.</p>

</div>

<div id=ftn98>

<p class=MsoFootnoteText><a href="#_ftnref98" name="_ftn98"><span
class=MsoFootnoteReference>[98]</span></a> Without
violating any copyright laws, of course.</p>

</div>

<div id=ftn99>

<p class=MsoFootnoteText><a href="#_ftnref99" name="_ftn99"><span
class=MsoFootnoteReference>[99]</span></a> This
would be an example of the State pattern, described in Chapter 10.</p>

</div>

<div id=ftn100>

<p class=MsoFootnoteText><a href="#_ftnref100" name="_ftn100"><span
class=MsoFootnoteReference>[100]</span></a> Visit
http://www.dinkumware.com, http://www.sgi.com/tech/stl, or
http://www.stlport.org.</p>

</div>

<div id=ftn101>

<p class=MsoFootnoteText><a href="#_ftnref101" name="_ftn101"><span
class=MsoFootnoteReference>[101]</span></a> This
is about to change, as more smart pointer types are about to be added to the
next version of the Standard. For a preliminary look at them, see the smart
pointers available at www.boost.org.</p>

</div>

<div id=ftn102>

<p class=MsoFootnoteText><a href="#_ftnref102" name="_ftn102"><span
class=MsoFootnoteReference>[102]</span></a> The
container adaptors, stack, queue, and priority_queue do not support iterators,
since they do not behave as sequences from the user’s point of view.</p>

</div>

<div id=ftn103>

<p class=MsoFootnoteText><a href="#_ftnref103" name="_ftn103"><span
class=MsoFootnoteReference>[103]</span></a> It
will only work for implementations of <b>vector</b> that use a <i>pointer</i>
(a <b>T*</b>) as the iterator type, like STLPort does.</p>

</div>

<div id=ftn104>

<p class=MsoFootnoteText><a href="#_ftnref104" name="_ftn104"><span
class=MsoFootnoteReference>[104]</span></a> These
were actually created to abstract the locale facets away from iostreams so that
locale facets could operate on any sequence of characters, not just iostreams.
Locales allow iostreams to easily handle culturally–different formatting (such
as the representation of money).</p>

</div>

<div id=ftn105>

<p class=MsoFootnoteText><a href="#_ftnref105" name="_ftn105"><span
class=MsoFootnoteReference>[105]</span></a> You
will need to provide a <b>char_traits</b> specialization for any other argument
type.</p>

</div>

<div id=ftn106>

<p class=MsoFootnoteText><a href="#_ftnref106" name="_ftn106"><span
class=MsoFootnoteReference>[106]</span></a> We
are indebted to Nathan Myers for explaining this.</p>

</div>

<div id=ftn107>

<p class=MsoFootnoteText><a href="#_ftnref107" name="_ftn107"><span
class=MsoFootnoteReference>[107]</span></a> Singleton
is a well–known design pattern and is discussed in depth in Chapter 10.</p>

</div>

<div id=ftn108>

<p class=MsoFootnoteText><a href="#_ftnref108" name="_ftn108"><span
class=MsoFootnoteReference>[108]</span></a> This
is another example coached by Nathan Myers.</p>

</div>

<div id=ftn109>

<p class=MsoFootnoteText><a href="#_ftnref109" name="_ftn109"><span
class=MsoFootnoteReference>[109]</span></a> We
revisit multithreading issues in Chapter 11.</p>

</div>

<div id=ftn110>

<p class=MsoFootnoteText><a href="#_ftnref110" name="_ftn110"><span
class=MsoFootnoteReference>[110]</span></a> This
means they depend in some way on a template parameter. See Chapter 5 in the
section entitled “Name Lookup Issues.”</p>

</div>

<div id=ftn111>

<p class=MsoFootnoteText><a href="#_ftnref111" name="_ftn111"><span
class=MsoFootnoteReference>[111]</span></a> As
we explained in Chapter 5, any valid qualification, such as <b>PQV::</b>, will
do.</p>

</div>

<div id=ftn112>

<p class=MsoFootnoteText><a href="#_ftnref112" name="_ftn112"><span
class=MsoFootnoteReference>[112]</span></a> Chuck
designed and provided the original reference implementations for <b>bitset</b>
and also <b>bitstring</b>, the precursor to <b>vector&lt;bool&gt;</b>, while an
active member of the C++ Standards Committee in the early 1990s.</p>

</div>

<div id=ftn113>

<p class=MsoFootnoteText><a href="#_ftnref113" name="_ftn113"><span
class=MsoFootnoteReference>[113]</span></a> Technically,
it is not legal for users to add to the standard namespace, but it is the
easiest way to avoid this obscure name lookup problem, and is supported by all
the compilers we use.</p>

</div>

<div id=ftn114>

<p class=MsoFootnoteText><a href="#_ftnref114" name="_ftn114"><span
class=MsoFootnoteReference>[114]</span></a> They
will likely appear in the next revision of Standard C++.</p>

</div>

<div id=ftn115>

<p class=MsoFootnoteText><a href="#_ftnref115" name="_ftn115"><span
class=MsoFootnoteReference>[115]</span></a> Available
at http://www.sgi.com/tech/stl.</p>

</div>

<div id=ftn116>

<p class=MsoFootnoteText><a href="#_ftnref116" name="_ftn116"><span
class=MsoFootnoteReference>[116]</span></a> As
we explained earlier, the <b>vector&lt;bool&gt;</b> specialization is also a
non–STL container to some degree.</p>

</div>

<div id=ftn117>

<p class=MsoFootnoteText><a href="#_ftnref117" name="_ftn117"><span
class=MsoFootnoteReference>[117]</span></a> With
Microsoft’s compilers you will have to enable RTTI; it’s disabled by default.
The command–line option to enable it is <b>/GR</b>.</p>

</div>

<div id=ftn118>

<p class=MsoFootnoteText><a href="#_ftnref118" name="_ftn118"><span
class=MsoFootnoteReference>[118]</span></a> Compilers
typically insert a pointer to a class’s RTTI table inside its virtual function
table.</p>

</div>

<div id=ftn119>

<p class=MsoFootnoteText><a href="#_ftnref119" name="_ftn119"><span
class=MsoFootnoteReference>[119]</span></a> A
<b>dynamic_cast&lt;void*&gt;</b> always gives the address of the full
object—not a subobject. This will be explained more fully in the next chapter.</p>

</div>

<div id=ftn120>

<p class=MsoFootnoteText><a href="#_ftnref120" name="_ftn120"><span
class=MsoFootnoteReference>[120]</span></a> This
is also true of Java, and other object–oriented languages.</p>

</div>

<div id=ftn121>

<p class=MsoFootnoteText><a href="#_ftnref121" name="_ftn121"><span
class=MsoFootnoteReference>[121]</span></a> These
version numbers are internal AT&amp;T numberings.</p>

</div>

<div id=ftn122>

<p class=MsoFootnoteText><a href="#_ftnref122" name="_ftn122"><span
class=MsoFootnoteReference>[122]</span></a> Even
more importantly, we don’t want undefined behavior. It is an error for a base
class not to have a virtual destructor.</p>

</div>

<div id=ftn123>

<p class=MsoFootnoteText><a href="#_ftnref123" name="_ftn123"><span
class=MsoFootnoteReference>[123]</span></a> The
actual layout is implementation specific.</p>

</div>

<div id=ftn124>

<p class=MsoFootnoteText><a href="#_ftnref124" name="_ftn124"><span
class=MsoFootnoteReference>[124]</span></a> But
not detected as an error.  <b>dynamic_cast</b>, however, can solve this
problem. See the previous chapter for details.</p>

</div>

<div id=ftn125>

<p class=MsoFootnoteText><a href="#_ftnref125" name="_ftn125"><span
class=MsoFootnoteReference>[125]</span></a> That
is, <b>5*sizeof(int)</b>. Compilers can add arbitrary padding, so the size of
an object must be at least as large as the sum of its parts, but can be larger.</p>

</div>

<div id=ftn126>

<p class=MsoFootnoteText><a href="#_ftnref126" name="_ftn126"><span
class=MsoFootnoteReference>[126]</span></a> We
use the term <i>hierarchy</i> because everyone else does, but the graph
representing multiple inheritance relationships is in general a <i>directed
acyclic graph</i> (DAG), also called a <i>lattice</i>, for obvious reasons.</p>

</div>

<div id=ftn127>

<p class=MsoFootnoteText><a href="#_ftnref127" name="_ftn127"><span
class=MsoFootnoteReference>[127]</span></a> The
presence of these pointers explains why the size of <b>b</b> is much larger
than the size of four integers.  This is (part of) the cost of virtual base
classes. There is also VPTR overhead due to the virtual destructor.</p>

</div>

<div id=ftn128>

<p class=MsoFootnoteText><a href="#_ftnref128" name="_ftn128"><span
class=MsoFootnoteReference>[128]</span></a> Once
again, base classes must have virtual destructors, but most compilers will let
this experiment compile.</p>

</div>

<div id=ftn129>

<p class=MsoFootnoteText><a href="#_ftnref129" name="_ftn129"><span
class=MsoFootnoteReference>[129]</span></a> Note
that virtual inheritance is crucial to this example. If <b>Top</b> were not a
virtual base class, there would be multiple <b>Top</b> subobjects, and the
ambiguity would remain. Dominance with multiple inheritance only comes into
play with virtual base classes.</p>

</div>

<div id=ftn130>

<p class=MsoFootnoteText><a href="#_ftnref130" name="_ftn130"><span
class=MsoFootnoteReference>[130]</span></a> Jerry
Schwarz, the author of iostreams, has remarked to both of us on separate
occasions that if he had it to do over again, he would probably remove MI from
the design of iostreams and use multiple stream buffers and conversion
operators instead.</p>

</div>

<div id=ftn131>

<p class=MsoFootnoteText><a href="#_ftnref131" name="_ftn131"><span
class=MsoFootnoteReference>[131]</span></a> We’ve
seen this in commercial C++ libraries, at least in some of the early ones.</p>

</div>

<div id=ftn132>

<p class=MsoFootnoteText><a href="#_ftnref132" name="_ftn132"><span
class=MsoFootnoteReference>[132]</span></a> A
phrase coined by Zack Urlocker.</p>

</div>

<div id=ftn133>

<p class=MsoFootnoteText><a href="#_ftnref133" name="_ftn133"><span
class=MsoFootnoteReference>[133]</span></a> Conveniently,
the examples are in C++; unfortunately, the dialect is pre–Standard C++ which
suffers from the lack of more modern language features like STL containers.</p>

</div>

<div id=ftn134>

<p class=MsoFootnoteText><a href="#_ftnref134" name="_ftn134"><span
class=MsoFootnoteReference>[134]</span></a> Much
of this material was derived from <i>Thinking in Patterns: Problem–Solving
Techniques using Java</i>, available at www.MindView.net.</p>

</div>

<div id=ftn135>

<p class=MsoFootnoteText><a href="#_ftnref135" name="_ftn135"><span
class=MsoFootnoteReference>[135]</span></a> For
up–to–date information, visit http://hillside.net/patterns.</p>

</div>

<div id=ftn136>

<p class=MsoFootnoteText><a href="#_ftnref136" name="_ftn136"><span
class=MsoFootnoteReference>[136]</span></a> Bill
Venners’ name for it; you may see it named differently elsewhere.</p>

</div>

<div id=ftn137>

<p class=MsoFootnoteText><a href="#_ftnref137" name="_ftn137"><span
class=MsoFootnoteReference>[137]</span></a> The
C++ Standard states: “No translation unit shall contain more than one
definition of any variable, function, class type, enumeration type or template…
Every program shall contain exactly one definition of every non–inline function
or object that is used in that program.”</p>

</div>

<div id=ftn138>

<p class=MsoFootnoteText><a href="#_ftnref138" name="_ftn138"><span
class=MsoFootnoteReference>[138]</span></a> This
is known as Meyers’ Singleton, after its creator, Scott Meyers.</p>

</div>

<div id=ftn139>

<p class=MsoFootnoteText><a href="#_ftnref139" name="_ftn139"><span
class=MsoFootnoteReference>[139]</span></a> Andrei
Alexandrescu develops a superior, policy–based solution to implementing the
Singleton pattern in <i>Modern C++ Design</i>.</p>

</div>

<div id=ftn140>

<p class=MsoFootnoteText><a href="#_ftnref140" name="_ftn140"><span
class=MsoFootnoteReference>[140]</span></a> For
more information, see the article “Once is Not Enough” by Hyslop and Sutter in
the March 2003 issue of <i>CUJ</i>.</p>

</div>

<div id=ftn141>

<p class=MsoFootnoteText><a href="#_ftnref141" name="_ftn141"><span
class=MsoFootnoteReference>[141]</span></a> <span
style='display:none'>#[BT_F4]#</span>Page 235.</p>

</div>

<div id=ftn142>

<p class=MsoFootnoteText><a href="#_ftnref142" name="_ftn142"><span
class=MsoFootnoteReference>[142]</span></a> See
<i>Thinking in C++, Volume 1</i> for more details about reference counting.</p>

</div>

<div id=ftn143>

<p class=MsoFootnoteText><a href="#_ftnref143" name="_ftn143"><span
class=MsoFootnoteReference>[143]</span></a>James
O. Coplien, <i>Advanced C++ Programming Styles and Idioms</i>, Addison Wesley,
1992.</p>

</div>

<div id=ftn144>

<p class=MsoFootnoteText><a href="#_ftnref144" name="_ftn144"><span
class=MsoFootnoteReference>[144]</span></a> It
differs from Java in that <b>java.util.Observable.notifyObservers(&nbsp;)</b>
doesn’t call <b>clearChanged(&nbsp;)</b> until after notifying all the
observers</p>

</div>

<div id=ftn145>

<p class=MsoFootnoteText><a href="#_ftnref145" name="_ftn145"><span
class=MsoFootnoteReference>[145]</span></a> There
is some similarity between inner classes and <i>subroutine closures</i>, which
save the reference environment of a function call so it can be reproduced
later.</p>

</div>

<div id=ftn146>

<p class=MsoFootnoteText><a href="#_ftnref146" name="_ftn146"><span
class=MsoFootnoteReference>[146]</span></a> This
example existed for a number of years in both C++ and Java on www.MindView.net
before it appeared, without attribution, in a recent book by other authors.</p>

</div>

<div id=ftn147>

<p class=MsoFootnoteText><a href="#_ftnref147" name="_ftn147"><span
class=MsoFootnoteReference>[147]</span></a> The
motivation for including Visitor in GoF was probably excessive cleverness. At a
workshop, one of the GoF authors told one of us that “Visitor was his favorite
pattern.”</p>

</div>

<div id=ftn148>

<p class=MsoFootnoteText><a href="#_ftnref148" name="_ftn148"><span
class=MsoFootnoteReference>[148]</span></a> This
is true when the system uses time slicing (Windows, for example). Solaris uses
a FIFO concurrency model: unless a higher priority thread is awakened the
current thread runs until it blocks or terminates. That means that other
threads with the same priority don’t run until the current one gives up the
processor.</p>

</div>

<div id=ftn149>

<p class=MsoFootnoteText><a href="#_ftnref149" name="_ftn149"><span
class=MsoFootnoteReference>[149]</span></a> Assuming
you’ve designed it for multiple CPUs. Otherwise, code that seems to work fine
on a time–sliced single processor system can fail when moved to multiple–CPU
system, since the additional CPUs can reveal problems that a one–CPU system
does not.</p>

</div>

<div id=ftn150>

<p class=MsoFootnoteText><a href="#_ftnref150" name="_ftn150"><span
class=MsoFootnoteReference>[150]</span></a> 
Much of this chapter began as a translation from the <i>Concurrency </i>chapter
in <i>Thinking in Java, 3<sup>rd</sup> edition</i>, Prentice Hall 2003,
although it has changed very significantly in the process.</p>

</div>

<div id=ftn151>

<p class=MsoFootnoteText><a href="#_ftnref151" name="_ftn151"><span
class=MsoFootnoteReference>[151]</span></a> This
can be significant. Usually only a small part of a function needs to be
guarded. Putting the guard at the function entry point can often make the
critical section longer than it needs to be.</p>

</div>

<div id=ftn152>

<p class=MsoFootnoteText><a href="#_ftnref152" name="_ftn152"><span
class=MsoFootnoteReference>[152]</span></a> This
is an oversimplification. Sometimes even when it seems like an atomic operation
should be safe, it may not be, so you must be very careful when deciding that
you can get away without synchronization. Removing synchronization is often a
sign of premature optimization—things that can cause you a lot of trouble
without gaining much. Or anything.</p>

</div>

<div id=ftn153>

<p class=MsoFootnoteText><a href="#_ftnref153" name="_ftn153"><span
class=MsoFootnoteReference>[153]</span></a> Atomicity
isn’t the only issue. On multiprocessor systems visibility is much more of an
issue than on single processor systems. Changes made by one thread, even if
they’re atomic in the sense of not being interruptible, might not be visible to
other threads (the changes might be temporarily stored in a local processor
cache, for example), so different threads will have a different view of the
application’s state. The synchronization mechanism forces changes by one thread
on a multiprocessor system to be visible across the application, whereas
without synchronization it’s indeterminate when changes become visible.</p>

</div>

<div id=ftn154>

<p class=MsoFootnoteText><a href="#_ftnref154" name="_ftn154"><span
class=MsoFootnoteReference>[154]</span></a> However,
exceptions are never delivered asynchronously in ZThreads. Thus, there is no
danger of something aborting mid–instruction/function call. And as long as you
use the <b>Guard</b> template to acquire mutexes, the mutexes will be
automatically released if an exception is thrown.</p>

</div>

<div id=ftn155>

<p class=MsoFootnoteText><a href="#_ftnref155" name="_ftn155"><span
class=MsoFootnoteReference>[155]</span></a> Actually,
<b>sleep(&nbsp;)</b> only provides a minimum delay, not a guaranteed delay, so
it’s possible (although improbable) that the <b>sleep(1100)</b> will wake up
before the <b>sleep(1000)</b>.</p>

</div>

<div id=ftn156>

<p class=MsoFootnoteText><a href="#_ftnref156" name="_ftn156"><span
class=MsoFootnoteReference>[156]</span></a> There
is nothing in the C++ Standard that says that interruptions can’t occur during
IO operations. However, most implementations don’t support it.</p>

</div>

<div id=ftn157>

<p class=MsoFootnoteText><a href="#_ftnref157" name="_ftn157"><span
class=MsoFootnoteReference>[157]</span></a> Note
that, although it’s unlikely, the call to <b>t.interrupt(&nbsp;)</b> could
actually happen before the call to <b>blocked.f(&nbsp;)</b>.</p>

</div>

<div id=ftn158>

<p class=MsoFootnoteText><a href="#_ftnref158" name="_ftn158"><span
class=MsoFootnoteReference>[158]</span></a> This
is in contrast to Java, where you must hold the lock in order to call <b>notify(&nbsp;)</b>
(Java’s version of <b>signal(&nbsp;)</b>). Although Posix threads, on which the
ZThread library is loosely based, do not require that you hold the lock in
order to call <b>signal(&nbsp;)</b> or <b>broadcast(&nbsp;)</b>, it is often
recommended.</p>

</div>

<div id=ftn159>

<p class=MsoFootnoteText><a href="#_ftnref159" name="_ftn159"><span
class=MsoFootnoteReference>[159]</span></a> On
some platforms there’s a third way to come out of a <b>wait(&nbsp;)</b>, the
so–called <i>spurious wakeup</i>. A spurious wakeup essentially means that a
thread may prematurely stop blocking (while waiting on a condition variable or
semaphore) without being prompted by a <b>signal(&nbsp;)</b> or <b>broadcast(&nbsp;)</b>.
The thread just wakes up, seemingly by itself. Spurious wakeups exist because
implementing POSIX threads, or the equivalent, isn’t always as straightforward
as it should be on some platforms. By allowing spurious wakeups the job of
building a library like pthreads is easier for those platforms. Spurious
wakeups do not occur in ZThreads, because the library compensates for and hides
these issues from the user.</p>

</div>

<div id=ftn160>

<p class=MsoFootnoteText><a href="#_ftnref160" name="_ftn160"><span
class=MsoFootnoteReference>[160]</span></a> Note
that if the readers stop for some reason, the writers will keep on writing
until the system runs out of memory. If this is an issue with your program you
can add a maximum allowable element count, and writers should then block if the
queue is full.</p>

</div>

<div id=ftn161>

<p class=MsoFootnoteText><a href="#_ftnref161" name="_ftn161"><span
class=MsoFootnoteReference>[161]</span></a> In
particular, refer to the earlier footnote in this chapter on multiprocessors
and visibility.</p>

</div>

<div id=ftn162>

<p class=MsoFootnoteText><a href="#_ftnref162" name="_ftn162"><span
class=MsoFootnoteReference>[162]</span></a> At
the time of this writing, Cygwin (www.cygwin.com) was undergoing changes and
improvements to its threading support, but we were still unable to observe
deadlocking behavior with this program under the available version of Cygwin.
The program deadlocked quickly under, for example, Linux.</p>

</div>

</div>

<center><img src="TicV2_files/image004.jpg">
<img src="TicV2_files/image005.jpg"></center>

</body>

</html>
